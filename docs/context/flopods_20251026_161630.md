# Flopods: AI Workflow Canvas - Complete Codebase

**Project:** AI Workflow Canvas - Multi-LLM Node-Based Platform
**Author:** Zahid Khan
**Generated:** 2025-10-26 16:16:30 IST
**Version:** 0.0.1

---

## Backend Source Code (NestJS)

### `apps\backend\src\app.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { ScheduleModule } from '@nestjs/schedule';

import { AccessTokenGuard } from './common/guards/auth';
import { PrismaModule } from './prisma/prisma.module';
import { WebSocketModule } from './common/websocket/websocket.module';
import { V1AppModule } from './v1/app.module';
import { QueueModule } from './common/queue/queue.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: ['.env'],
    }),
    QueueModule,
    PrismaModule,
    ScheduleModule.forRoot(),
    WebSocketModule,
    V1AppModule,
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: AccessTokenGuard,
    },
  ],
})
export class AppModule {}

```

### `apps\backend\src\common\aws\aws.module.ts`

```typescript
import { Module, Global } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AwsSesEmailService } from './ses/ses-email.service';
import { S3Service } from './s3/s3.service';
import { DynamoDbService } from './dynamodb/dynamodb.service';
import { SnsService } from './sns/sns.service';

@Global()
@Module({
  imports: [ConfigModule],
  providers: [AwsSesEmailService, S3Service, SnsService, DynamoDbService],
  exports: [AwsSesEmailService, S3Service, SnsService, DynamoDbService],
})
export class AwsModule {}

```

### `apps\backend\src\common\aws\dynamodb\dynamodb.service.ts`

```typescript
import { Injectable, Logger, InternalServerErrorException, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  DynamoDBClient,
  PutItemCommand,
  GetItemCommand,
  UpdateItemCommand,
  DeleteItemCommand,
  QueryCommand,
  ScanCommand,
  BatchWriteItemCommand,
  BatchGetItemCommand,
  CreateTableCommand,
  DescribeTableCommand,
  UpdateTimeToLiveCommand,
  ResourceNotFoundException,
} from '@aws-sdk/client-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';

export interface QueryOptions {
  tableName: string;
  keyConditionExpression: string;
  expressionAttributeValues: Record<string, any>;
  expressionAttributeNames?: Record<string, string>;
  indexName?: string;
  limit?: number;
  exclusiveStartKey?: Record<string, any>;
  scanIndexForward?: boolean;
}

export interface ScanOptions {
  tableName: string;
  filterExpression?: string;
  expressionAttributeValues?: Record<string, any>;
  expressionAttributeNames?: Record<string, string>;
  limit?: number;
  exclusiveStartKey?: Record<string, any>;
}

@Injectable()
export class DynamoDbService implements OnModuleInit {
  private readonly logger = new Logger(DynamoDbService.name);
  private readonly dynamoClient: DynamoDBClient | null = null;
  private readonly isEnabled: boolean;
  private readonly region: string;
  private readonly isProduction: boolean;

  // Table names
  private readonly podTableName: string;
  private readonly executionTableName: string;
  private readonly contextTableName: string;

  constructor(private readonly configService: ConfigService) {
    this.region =
      this.configService.get<string>('AWS_DYNAMODB_REGION') ||
      this.configService.get<string>('AWS_REGION') ||
      'ap-south-1';

    const accessKeyId = this.configService.get<string>('AWS_DYNAMODB_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_DYNAMODB_SECRET_ACCESS_KEY');
    const endpoint = this.configService.get<string>('AWS_DYNAMODB_ENDPOINT');

    this.isProduction = this.configService.get('NODE_ENV') === 'production';

    // Get table names from environment
    this.podTableName = this.configService.get<string>(
      'AWS_DYNAMODB_POD_TABLE',
      'flopods-pods-dev',
    );
    this.executionTableName = this.configService.get<string>(
      'AWS_DYNAMODB_EXECUTION_TABLE',
      'flopods-executions-dev',
    );
    this.contextTableName = this.configService.get<string>(
      'AWS_DYNAMODB_CONTEXT_TABLE',
      'flopods-context-dev',
    );

    this.isEnabled = !!(accessKeyId && secretAccessKey);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      const clientConfig: any = {
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      };

      if (endpoint) {
        clientConfig.endpoint = endpoint;
        this.logger.log(`ðŸ”§ DynamoDB Local endpoint: ${endpoint}`);
      }

      this.dynamoClient = new DynamoDBClient(clientConfig);
      this.logger.log('âœ… AWS DynamoDB initialized successfully');
      this.logger.log(`ðŸ“‹ Pod Table: ${this.podTableName}`);
      this.logger.log(`ðŸ“‹ Execution Table: ${this.executionTableName}`);
      this.logger.log(`ðŸ“‹ Context Table: ${this.contextTableName}`);
    } else {
      this.logger.warn('âš ï¸  AWS DynamoDB not configured');
    }
  }

  async onModuleInit() {
    if (this.isEnabled && this.dynamoClient) {
      // Only auto-create tables in development
      if (!this.isProduction) {
        this.logger.log('ðŸ”§ Development mode: Ensuring tables exist...');
        await Promise.all([
          this.ensureTableExists(this.podTableName, this.createPodTableSchema()),
          this.ensureTableExists(this.executionTableName, this.createExecutionTableSchema()),
          this.ensureTableExists(this.contextTableName, this.createContextTableSchema()),
        ]);
        // this.logger.log('ðŸ”§ Development mode: Active');
      } else {
        this.logger.log('ðŸ­ Production mode: Skipping auto table creation');
      }
    }
  }

  /**
   * Ensure table exists (development only)
   */
  private async ensureTableExists(tableName: string, schema: CreateTableCommand['input']) {
    try {
      await this.dynamoClient!.send(new DescribeTableCommand({ TableName: tableName }));
      this.logger.log(`âœ… DynamoDB table "${tableName}" exists`);
    } catch (error: any) {
      if (error instanceof ResourceNotFoundException) {
        await this.createTable(schema);
        // Enable TTL after table creation
        await this.enableTTL(tableName);
      } else {
        this.logger.error(`âŒ Error checking table ${tableName}: ${error.message}`);
      }
    }
  }

  /**
   * Create table with schema
   */
  private async createTable(schema: CreateTableCommand['input']) {
    try {
      await this.dynamoClient!.send(new CreateTableCommand(schema));
      this.logger.log(`âœ… Created DynamoDB table "${schema.TableName}"`);

      // Wait for table to be active
      await this.waitForTableActive(schema.TableName!);
    } catch (error: any) {
      this.logger.error(`âŒ Error creating table ${schema.TableName}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Wait for table to become active
   */
  private async waitForTableActive(tableName: string, maxAttempts = 30) {
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const { Table } = await this.dynamoClient!.send(
          new DescribeTableCommand({ TableName: tableName }),
        );

        if (Table?.TableStatus === 'ACTIVE') {
          this.logger.log(`âœ… Table "${tableName}" is active`);
          return;
        }

        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch {
        this.logger.warn(`â³ Waiting for table "${tableName}" to be active...`);
      }
    }

    throw new Error(`Table "${tableName}" did not become active in time`);
  }

  /**
   * Enable TTL on a table
   */
  private async enableTTL(tableName: string) {
    try {
      await this.dynamoClient!.send(
        new UpdateTimeToLiveCommand({
          TableName: tableName,
          TimeToLiveSpecification: {
            Enabled: true,
            AttributeName: 'ttl',
          },
        }),
      );
      this.logger.log(`âœ… Enabled TTL for table "${tableName}"`);
    } catch (error: any) {
      this.logger.warn(`âš ï¸ Could not enable TTL for "${tableName}": ${error.message}`);
    }
  }

  /**
   * Pod Table Schema
   * Stores: Pod content, configuration, visual properties, connections, context
   */
  private createPodTableSchema(): CreateTableCommand['input'] {
    return {
      TableName: this.podTableName,
      KeySchema: [
        { AttributeName: 'pk', KeyType: 'HASH' }, // WORKSPACE#<id>
        { AttributeName: 'sk', KeyType: 'RANGE' }, // FLOW#<flowId>#POD#<podId>
      ],
      AttributeDefinitions: [
        { AttributeName: 'pk', AttributeType: 'S' },
        { AttributeName: 'sk', AttributeType: 'S' },
        { AttributeName: 'gsi1pk', AttributeType: 'S' }, // FLOW#<flowId>
        { AttributeName: 'gsi1sk', AttributeType: 'S' }, // POD#<podId>
        { AttributeName: 'gsi2pk', AttributeType: 'S' }, // POD#<podId>
        { AttributeName: 'gsi2sk', AttributeType: 'S' }, // VERSION#<timestamp>
      ],
      GlobalSecondaryIndexes: [
        {
          IndexName: 'GSI1-FlowPods',
          KeySchema: [
            { AttributeName: 'gsi1pk', KeyType: 'HASH' },
            { AttributeName: 'gsi1sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
        {
          IndexName: 'GSI2-PodVersions',
          KeySchema: [
            { AttributeName: 'gsi2pk', KeyType: 'HASH' },
            { AttributeName: 'gsi2sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
      ],
      BillingMode: 'PAY_PER_REQUEST',
    };
  }

  /**
   * Execution Table Schema
   * Stores: Execution results, inputs, outputs, context used, caching
   */
  private createExecutionTableSchema(): CreateTableCommand['input'] {
    return {
      TableName: this.executionTableName,
      KeySchema: [
        { AttributeName: 'pk', KeyType: 'HASH' }, // POD#<podId>
        { AttributeName: 'sk', KeyType: 'RANGE' }, // EXECUTION#<timestamp>
      ],
      AttributeDefinitions: [
        { AttributeName: 'pk', AttributeType: 'S' },
        { AttributeName: 'sk', AttributeType: 'S' },
        { AttributeName: 'gsi1pk', AttributeType: 'S' }, // FLOW#<flowId>
        { AttributeName: 'gsi1sk', AttributeType: 'S' }, // EXECUTION#<timestamp>
        { AttributeName: 'gsi2pk', AttributeType: 'S' }, // WORKSPACE#<id>#STATUS#<status>
        { AttributeName: 'gsi2sk', AttributeType: 'S' }, // TIMESTAMP#<timestamp>
      ],
      GlobalSecondaryIndexes: [
        {
          IndexName: 'GSI1-FlowExecutions',
          KeySchema: [
            { AttributeName: 'gsi1pk', KeyType: 'HASH' },
            { AttributeName: 'gsi1sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
        {
          IndexName: 'GSI2-WorkspaceExecutions',
          KeySchema: [
            { AttributeName: 'gsi2pk', KeyType: 'HASH' },
            { AttributeName: 'gsi2sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
      ],
      BillingMode: 'PAY_PER_REQUEST',
    };
  }

  /**
   * Context Table Schema
   * Stores: Context chains, pod relationships, execution context snapshots
   */
  private createContextTableSchema(): CreateTableCommand['input'] {
    return {
      TableName: this.contextTableName,
      KeySchema: [
        { AttributeName: 'pk', KeyType: 'HASH' }, // EXECUTION#<execId> or FLOW#<flowId>
        { AttributeName: 'sk', KeyType: 'RANGE' }, // CONTEXT#<timestamp> or POD#<podId>
      ],
      AttributeDefinitions: [
        { AttributeName: 'pk', AttributeType: 'S' },
        { AttributeName: 'sk', AttributeType: 'S' },
        { AttributeName: 'gsi1pk', AttributeType: 'S' }, // POD#<podId>
        { AttributeName: 'gsi1sk', AttributeType: 'S' }, // USED_IN#<flowId>#<timestamp>
      ],
      GlobalSecondaryIndexes: [
        {
          IndexName: 'GSI1-PodContextUsage',
          KeySchema: [
            { AttributeName: 'gsi1pk', KeyType: 'HASH' },
            { AttributeName: 'gsi1sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
      ],
      BillingMode: 'PAY_PER_REQUEST',
    };
  }

  /**
   * Put item into table
   */
  async putItem(tableName: string, item: Record<string, any>): Promise<void> {
    if (!this.isEnabled || !this.dynamoClient) {
      this.logger.debug(`[DynamoDB LOG] Put item in ${tableName}`);
      return;
    }

    try {
      const command = new PutItemCommand({
        TableName: tableName,
        Item: marshall(item, { removeUndefinedValues: true }),
      });

      await this.dynamoClient.send(command);
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB put item error:', error);
      throw new InternalServerErrorException(`Failed to put item in DynamoDB: ${error.message}`);
    }
  }

  /**
   * Get item from table
   */
  async getItem(tableName: string, key: Record<string, any>): Promise<Record<string, any> | null> {
    if (!this.isEnabled || !this.dynamoClient) {
      return null;
    }

    try {
      const command = new GetItemCommand({
        TableName: tableName,
        Key: marshall(key),
      });

      const response = await this.dynamoClient.send(command);
      return response.Item ? unmarshall(response.Item) : null;
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB get item error:', error);
      throw new InternalServerErrorException(`Failed to get item from DynamoDB: ${error.message}`);
    }
  }

  /**
   * Update item in table
   */
  async updateItem(
    tableName: string,
    key: Record<string, any>,
    updates: Record<string, any>,
  ): Promise<Record<string, any>> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const updateExpression =
        'SET ' +
        Object.keys(updates)
          .map((k, i) => `#attr${i} = :val${i}`)
          .join(', ');
      const expressionAttributeNames = Object.keys(updates).reduce(
        (acc, k, i) => {
          acc[`#attr${i}`] = k;
          return acc;
        },
        {} as Record<string, string>,
      );
      const expressionAttributeValues = marshall(
        Object.values(updates).reduce(
          (acc, v, i) => {
            acc[`:val${i}`] = v;
            return acc;
          },
          {} as Record<string, any>,
        ),
      );

      const command = new UpdateItemCommand({
        TableName: tableName,
        Key: marshall(key),
        UpdateExpression: updateExpression,
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ReturnValues: 'ALL_NEW',
      });

      const response = await this.dynamoClient.send(command);
      return response.Attributes ? unmarshall(response.Attributes) : {};
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB update item error:', error);
      throw new InternalServerErrorException(`Failed to update item: ${error.message}`);
    }
  }

  /**
   * Delete item from table
   */
  async deleteItem(tableName: string, key: Record<string, any>): Promise<void> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new DeleteItemCommand({
        TableName: tableName,
        Key: marshall(key),
      });

      await this.dynamoClient.send(command);
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB delete item error:', error);
      throw new InternalServerErrorException(`Failed to delete item: ${error.message}`);
    }
  }

  /**
   * Query items from table (supports GSI)
   */
  async query(options: QueryOptions): Promise<{
    items: Record<string, any>[];
    lastEvaluatedKey?: Record<string, any>;
  }> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new QueryCommand({
        TableName: options.tableName,
        IndexName: options.indexName,
        KeyConditionExpression: options.keyConditionExpression,
        ExpressionAttributeValues: marshall(options.expressionAttributeValues),
        ExpressionAttributeNames: options.expressionAttributeNames,
        Limit: options.limit,
        ScanIndexForward: options.scanIndexForward !== false,
        ExclusiveStartKey: options.exclusiveStartKey
          ? marshall(options.exclusiveStartKey)
          : undefined,
      });

      const response = await this.dynamoClient.send(command);

      return {
        items: (response.Items || []).map((item) => unmarshall(item)),
        lastEvaluatedKey: response.LastEvaluatedKey
          ? unmarshall(response.LastEvaluatedKey)
          : undefined,
      };
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB query error:', error);
      throw new InternalServerErrorException(`Failed to query items: ${error.message}`);
    }
  }

  /**
   * Scan table
   */
  async scan(options: ScanOptions): Promise<{
    items: Record<string, any>[];
    lastEvaluatedKey?: Record<string, any>;
  }> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new ScanCommand({
        TableName: options.tableName,
        FilterExpression: options.filterExpression,
        ExpressionAttributeValues: options.expressionAttributeValues
          ? marshall(options.expressionAttributeValues)
          : undefined,
        ExpressionAttributeNames: options.expressionAttributeNames,
        Limit: options.limit,
        ExclusiveStartKey: options.exclusiveStartKey
          ? marshall(options.exclusiveStartKey)
          : undefined,
      });

      const response = await this.dynamoClient.send(command);

      return {
        items: (response.Items || []).map((item) => unmarshall(item)),
        lastEvaluatedKey: response.LastEvaluatedKey
          ? unmarshall(response.LastEvaluatedKey)
          : undefined,
      };
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB scan error:', error);
      throw new InternalServerErrorException(`Failed to scan table: ${error.message}`);
    }
  }

  /**
   * Batch write items
   */
  async batchWrite(tableName: string, items: Record<string, any>[]): Promise<void> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    const batches = [];
    for (let i = 0; i < items.length; i += 25) {
      batches.push(items.slice(i, i + 25));
    }

    try {
      for (const batch of batches) {
        const command = new BatchWriteItemCommand({
          RequestItems: {
            [tableName]: batch.map((item) => ({
              PutRequest: { Item: marshall(item, { removeUndefinedValues: true }) },
            })),
          },
        });

        await this.dynamoClient.send(command);
      }

      this.logger.log(`âœ… ${items.length} items batch written to table`);
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB batch write error:', error);
      throw new InternalServerErrorException(`Failed to batch write items: ${error.message}`);
    }
  }

  /**
   * Batch get items
   */
  async batchGet(tableName: string, keys: Record<string, any>[]): Promise<Record<string, any>[]> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new BatchGetItemCommand({
        RequestItems: {
          [tableName]: {
            Keys: keys.map((key) => marshall(key)),
          },
        },
      });

      const response = await this.dynamoClient.send(command);
      const items = response.Responses?.[tableName] || [];

      return items.map((item) => unmarshall(item));
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB batch get error:', error);
      throw new InternalServerErrorException(`Failed to batch get items: ${error.message}`);
    }
  }

  /**
   * Helper: Get all pods in a flow with their context
   */
  async queryPodsByFlow(flowId: string): Promise<Record<string, any>[]> {
    const { items } = await this.query({
      tableName: this.podTableName,
      indexName: 'GSI1-FlowPods',
      keyConditionExpression: 'gsi1pk = :flowId',
      expressionAttributeValues: {
        ':flowId': `FLOW#${flowId}`,
      },
      scanIndexForward: true,
    });

    return items;
  }

  /**
   * Helper: Get pod content with all context
   */
  async getPodWithContext(workspaceId: string, flowId: string, podId: string) {
    return this.getItem(this.podTableName, {
      pk: `WORKSPACE#${workspaceId}`,
      sk: `FLOW#${flowId}#POD#${podId}`,
    });
  }

  /**
   * Check if DynamoDB is configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get DynamoDB configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
      isProduction: this.isProduction,
      podTableName: this.podTableName,
      executionTableName: this.executionTableName,
      contextTableName: this.contextTableName,
      endpoint: this.configService.get<string>('AWS_DYNAMODB_ENDPOINT'),
    };
  }

  /**
   * Get table names
   */
  getTableNames() {
    return {
      pods: this.podTableName,
      executions: this.executionTableName,
      context: this.contextTableName,
    };
  }
}

```

### `apps\backend\src\common\aws\s3\s3.service.ts`

```typescript
import {
  Injectable,
  Logger,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  DeleteObjectsCommand,
  HeadObjectCommand,
  ListObjectsV2Command,
  CopyObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export interface UploadOptions {
  key: string;
  body: Buffer;
  contentType?: string;
  metadata?: Record<string, string>;
  acl?: 'private' | 'public-read' | 'public-read-write';
}

export interface ListObjectsOptions {
  prefix?: string;
  maxKeys?: number;
  continuationToken?: string;
}

@Injectable()
export class S3Service {
  private readonly logger = new Logger(S3Service.name);
  private readonly s3Client: S3Client | null = null;
  private readonly bucketName: string;
  private readonly isEnabled: boolean;
  private readonly region: string;

  constructor(private readonly configService: ConfigService) {
    this.region = this.configService.get<string>('AWS_REGION') || 'us-east-1';
    const accessKeyId = this.configService.get<string>('AWS_S3_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_S3_SECRET_ACCESS_KEY');
    this.bucketName = this.configService.get<string>('AWS_S3_BUCKET_NAME') || '';

    this.isEnabled = !!(this.region && accessKeyId && secretAccessKey && this.bucketName);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      this.s3Client = new S3Client({
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      });
      this.logger.log('âœ… AWS S3 initialized successfully');
    } else {
      this.logger.warn('âš ï¸  AWS S3 not configured');
    }
  }

  /**
   * Upload file to S3
   */
  async uploadFile(options: UploadOptions): Promise<string> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    const { key, body, contentType, metadata, acl } = options;

    try {
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: key,
        Body: body,
        ContentType: contentType,
        Metadata: metadata,
        ACL: acl || 'private',
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ“ File uploaded to S3: ${key}`);

      return acl === 'public-read'
        ? `https://${this.bucketName}.s3.${this.region}.amazonaws.com/${key}`
        : key;
    } catch (error: any) {
      this.logger.error('âŒ S3 upload error:', error);
      throw new InternalServerErrorException(`Failed to upload file: ${error.message}`);
    }
  }

  /**
   * Get signed URL for secure file access
   */
  async getSignedUrl(key: string, expiresIn: number = 3600): Promise<string> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new GetObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      // Type assertion to fix AWS SDK version mismatch
      const url = await getSignedUrl(this.s3Client as any, command as any, { expiresIn });
      this.logger.log(`ðŸ”— Generated signed URL for: ${key} (expires in ${expiresIn}s)`);
      return url;
    } catch (error: any) {
      this.logger.error('âŒ S3 get signed URL error:', error);
      throw new InternalServerErrorException(`Failed to generate signed URL: ${error.message}`);
    }
  }

  /**
   * Get signed URL for file upload (client-side upload)
   */

  async getUploadSignedUrl(
    key: string,
    contentType: string,
    expiresIn: number = 3600,
  ): Promise<string> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: key,
        ContentType: contentType,
      });

      // Type assertion to fix AWS SDK version mismatch
      const url = await getSignedUrl(this.s3Client as any, command as any, { expiresIn });
      this.logger.log(`ðŸ”— Generated upload signed URL for: ${key}`);
      return url;
    } catch (error: any) {
      this.logger.error('âŒ S3 get upload signed URL error:', error);
      throw new InternalServerErrorException(`Failed to generate upload URL: ${error.message}`);
    }
  }

  /**
   * Delete single file
   */
  async deleteFile(key: string): Promise<void> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new DeleteObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ—‘ï¸  File deleted from S3: ${key}`);
    } catch (error: any) {
      this.logger.error('âŒ S3 delete error:', error);
      throw new InternalServerErrorException(`Failed to delete file: ${error.message}`);
    }
  }

  /**
   * Delete multiple files
   */
  async deleteFiles(keys: string[]): Promise<void> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    if (keys.length === 0) return;

    try {
      const command = new DeleteObjectsCommand({
        Bucket: this.bucketName,
        Delete: {
          Objects: keys.map((key) => ({ Key: key })),
        },
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ—‘ï¸  ${keys.length} files deleted from S3`);
    } catch (error: any) {
      this.logger.error('âŒ S3 batch delete error:', error);
      throw new InternalServerErrorException(`Failed to delete files: ${error.message}`);
    }
  }

  /**
   * Check if file exists
   */
  async fileExists(key: string): Promise<boolean> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new HeadObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      await this.s3Client.send(command);
      return true;
    } catch (error: any) {
      if (error.name === 'NotFound') {
        return false;
      }
      throw error;
    }
  }

  /**
   * Get file metadata
   */
  async getFileMetadata(key: string): Promise<Record<string, any>> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new HeadObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      const response = await this.s3Client.send(command);
      return {
        contentType: response.ContentType,
        contentLength: response.ContentLength,
        lastModified: response.LastModified,
        metadata: response.Metadata,
      };
    } catch (error: any) {
      this.logger.error('âŒ S3 get metadata error:', error);
      throw new NotFoundException(`File not found: ${key}`);
    }
  }

  /**
   * List objects in bucket
   */
  async listObjects(options: ListObjectsOptions = {}): Promise<{
    files: Array<{ key: string; size: number; lastModified: Date }>;
    nextToken?: string;
  }> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new ListObjectsV2Command({
        Bucket: this.bucketName,
        Prefix: options.prefix,
        MaxKeys: options.maxKeys || 1000,
        ContinuationToken: options.continuationToken,
      });

      const response = await this.s3Client.send(command);

      return {
        files: (response.Contents || []).map((item) => ({
          key: item.Key || '',
          size: item.Size || 0,
          lastModified: item.LastModified || new Date(),
        })),
        nextToken: response.NextContinuationToken,
      };
    } catch (error: any) {
      this.logger.error('âŒ S3 list objects error:', error);
      throw new InternalServerErrorException(`Failed to list objects: ${error.message}`);
    }
  }

  /**
   * Copy file within S3
   */
  async copyFile(sourceKey: string, destinationKey: string): Promise<void> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new CopyObjectCommand({
        Bucket: this.bucketName,
        CopySource: `${this.bucketName}/${sourceKey}`,
        Key: destinationKey,
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ“‹ File copied: ${sourceKey} â†’ ${destinationKey}`);
    } catch (error: any) {
      this.logger.error('âŒ S3 copy error:', error);
      throw new InternalServerErrorException(`Failed to copy file: ${error.message}`);
    }
  }

  /**
   * Check if S3 is configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get S3 configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
      bucket: this.bucketName,
    };
  }
}

```

### `apps\backend\src\common\aws\ses\ses-email.service.ts`

```typescript
import { Injectable, InternalServerErrorException, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  SESClient,
  SendEmailCommand,
  SendEmailCommandInput,
  VerifyEmailIdentityCommand,
  GetSendQuotaCommand,
  ListVerifiedEmailAddressesCommand,
} from '@aws-sdk/client-ses';

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  bodyHtml: string;
  bodyText?: string;
  from?: string;
  replyTo?: string[];
  cc?: string[];
  bcc?: string[];
}

@Injectable()
export class AwsSesEmailService {
  private readonly logger = new Logger(AwsSesEmailService.name);
  private readonly sesClient: SESClient | null = null;
  private readonly defaultFromEmail: string;
  private readonly isEnabled: boolean;
  private readonly region: string;

  constructor(private readonly configService: ConfigService) {
    this.region = this.configService.get<string>('AWS_REGION') || 'us-east-1';
    const accessKeyId = this.configService.get<string>('AWS_SES_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_SES_SECRET_ACCESS_KEY');
    this.defaultFromEmail = this.configService.get<string>('AWS_SES_NO_REPLY_EMAIL') || '';

    this.isEnabled = !!(this.region && accessKeyId && secretAccessKey);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      this.sesClient = new SESClient({
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      });
      this.logger.log('âœ… AWS SES initialized successfully');
    } else {
      this.logger.warn('âš ï¸  AWS SES not configured - emails will be logged only');
    }
  }

  /**
   * Send a single email
   */
  async sendEmail(options: SendEmailOptions): Promise<{ messageId: string }> {
    const { to, subject, bodyHtml, bodyText, from, replyTo, cc, bcc } = options;

    if (!this.defaultFromEmail && !from) {
      throw new InternalServerErrorException('SES "from" email is not configured.');
    }

    const source = from || `Actopod <${this.defaultFromEmail}>`;
    const toAddresses = Array.isArray(to) ? to : [to];

    // Development mode - log only
    if (!this.isEnabled || !this.sesClient) {
      this.logger.log('=== EMAIL LOG (Development Mode) ===');
      this.logger.log(`From: ${source}`);
      this.logger.log(`To: ${toAddresses.join(', ')}`);
      this.logger.log(`Subject: ${subject}`);
      this.logger.log(`Body: ${bodyText || 'HTML content'}`);
      if (cc) this.logger.log(`CC: ${cc.join(', ')}`);
      if (bcc) this.logger.log(`BCC: ${bcc.join(', ')}`);
      this.logger.log('===================================');
      return { messageId: `dev-mode-${Date.now()}` };
    }

    const params: SendEmailCommandInput = {
      Source: source,
      Destination: {
        ToAddresses: toAddresses,
        ...(cc && cc.length > 0 && { CcAddresses: cc }),
        ...(bcc && bcc.length > 0 && { BccAddresses: bcc }),
      },
      ...(replyTo && replyTo.length > 0 && { ReplyToAddresses: replyTo }),
      Message: {
        Subject: { Data: subject, Charset: 'UTF-8' },
        Body: {
          Html: { Data: bodyHtml, Charset: 'UTF-8' },
          ...(bodyText && { Text: { Data: bodyText, Charset: 'UTF-8' } }),
        },
      },
    };

    try {
      this.logger.log(`ðŸ“§ Sending email to: ${toAddresses.join(', ')}`);
      const command = new SendEmailCommand(params);
      const response = await this.sesClient.send(command);
      this.logger.log(`âœ… Email sent successfully. Message ID: ${response.MessageId}`);
      return { messageId: response.MessageId || '' };
    } catch (error: any) {
      this.logger.error('âŒ SES send email error:', error);
      throw new InternalServerErrorException(`Failed to send email: ${error.message}`);
    }
  }

  /**
   * Send bulk emails by sending individual emails (simple approach)
   * For production with high volume, use SES SendBulkTemplatedEmail with pre-created templates
   */
  async sendBulkEmails(
    recipients: string[],
    subject: string,
    bodyHtml: string,
    bodyText?: string,
  ): Promise<{ successCount: number; failureCount: number; errors: string[] }> {
    if (!this.isEnabled || !this.sesClient) {
      this.logger.warn('Bulk email skipped - SES not configured');
      return { successCount: 0, failureCount: recipients.length, errors: [] };
    }

    let successCount = 0;
    let failureCount = 0;
    const errors: string[] = [];

    // Send emails in batches to avoid rate limiting
    const batchSize = 10;
    for (let i = 0; i < recipients.length; i += batchSize) {
      const batch = recipients.slice(i, i + batchSize);

      const promises = batch.map(async (recipient) => {
        try {
          await this.sendEmail({
            to: recipient,
            subject,
            bodyHtml,
            bodyText,
          });
          successCount++;
        } catch (error: any) {
          failureCount++;
          errors.push(`${recipient}: ${error.message}`);
        }
      });

      await Promise.all(promises);

      // Rate limiting - wait between batches
      if (i + batchSize < recipients.length) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }

    this.logger.log(`ðŸ“§ Bulk email completed: ${successCount} success, ${failureCount} failures`);
    return { successCount, failureCount, errors };
  }

  /**
   * Verify email identity (required before sending from that address)
   */
  async verifyEmailIdentity(email: string): Promise<void> {
    if (!this.isEnabled || !this.sesClient) {
      this.logger.warn(`Email verification skipped - SES not configured: ${email}`);
      return;
    }

    try {
      const command = new VerifyEmailIdentityCommand({ EmailAddress: email });
      await this.sesClient.send(command);
      this.logger.log(`âœ… Verification email sent to: ${email}`);
    } catch (error: any) {
      this.logger.error('âŒ SES verify email error:', error);
      throw new InternalServerErrorException(`Failed to verify email: ${error.message}`);
    }
  }

  /**
   * Get SES send quota (how many emails can be sent)
   */
  async getSendQuota(): Promise<{
    max24HourSend: number;
    maxSendRate: number;
    sentLast24Hours: number;
  }> {
    if (!this.isEnabled || !this.sesClient) {
      throw new InternalServerErrorException('SES not configured');
    }

    try {
      const command = new GetSendQuotaCommand({});
      const response = await this.sesClient.send(command);

      return {
        max24HourSend: response.Max24HourSend || 0,
        maxSendRate: response.MaxSendRate || 0,
        sentLast24Hours: response.SentLast24Hours || 0,
      };
    } catch (error: any) {
      this.logger.error('âŒ SES get send quota error:', error);
      throw new InternalServerErrorException(`Failed to get send quota: ${error.message}`);
    }
  }

  /**
   * List verified email addresses
   */
  async listVerifiedEmails(): Promise<string[]> {
    if (!this.isEnabled || !this.sesClient) {
      throw new InternalServerErrorException('SES not configured');
    }

    try {
      const command = new ListVerifiedEmailAddressesCommand({});
      const response = await this.sesClient.send(command);
      return response.VerifiedEmailAddresses || [];
    } catch (error: any) {
      this.logger.error('âŒ SES list verified emails error:', error);
      throw new InternalServerErrorException(`Failed to list verified emails: ${error.message}`);
    }
  }

  /**
   * Send email with retry logic
   */
  async sendEmailWithRetry(
    options: SendEmailOptions,
    maxRetries: number = 3,
  ): Promise<{ messageId: string }> {
    let lastError: any;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.sendEmail(options);
      } catch (error: any) {
        lastError = error;
        this.logger.warn(`Email send attempt ${attempt}/${maxRetries} failed: ${error.message}`);

        if (attempt < maxRetries) {
          // Exponential backoff
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  /**
   * Validate email format
   */
  validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Sanitize email list (remove invalid emails)
   */
  sanitizeEmailList(emails: string[]): string[] {
    return emails.filter((email) => this.validateEmail(email));
  }

  /**
   * Check if SES is properly configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get SES configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
      defaultFrom: this.defaultFromEmail,
    };
  }
}

```

### `apps\backend\src\common\aws\ses\templates\auth\magic-link.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const magicLinkTemplate = (
  name: string,
  magicUrl: string,
  expiresIn: string,
  ipAddress: string,
  deviceName: string,
): string => {
  const content = `
    <h2>ðŸ” Sign in to Actopod</h2>
    <p>Hi ${name || 'there'},</p>
    <p>Click the button below to securely sign in to your Actopod account:</p>
    <p style="text-align: center;">
      <a href="${magicUrl}" class="button">Sign In to Actopod</a>
    </p>
    <p>Or copy and paste this link into your browser:</p>
    <p style="word-break: break-all; color: #6b7280; background-color: #f3f4f6; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px;">
      ${magicUrl}
    </p>

    <div style="margin-top: 30px; padding: 20px; background-color: #EEF2FF; border-left: 4px solid #4F46E5; border-radius: 6px;">
      <p style="margin: 0 0 10px 0; font-weight: 600; color: #4338CA;">ðŸ”’ Security Information</p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ This link expires in <strong>${expiresIn}</strong></p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ Device: ${deviceName}</p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ IP Address: ${ipAddress}</p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ Can only be used once</p>
    </div>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF2F2; border-left: 4px solid #EF4444; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #991B1B;">
        <strong>âš ï¸ Security Warning:</strong><br>
        If you didn't request this sign-in link, please ignore this email or contact our support team immediately at <a href="mailto:${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}">${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}</a>
      </p>
    </div>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\auth\reset-password.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const resetPasswordTemplate = (name: string, resetUrl: string): string => {
  const content = `
    <h2>Reset Your Password</h2>
    <p>Hi ${name},</p>
    <p>We received a request to reset your password for your Actopod account.</p>

    <p style="text-align: center;">
      <a href="${resetUrl}" class="button">Reset Password</a>
    </p>

    <p>Or copy and paste this link into your browser:</p>
    <p style="word-break: break-all; color: #6b7280; background-color: #f3f4f6; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px;">
      ${resetUrl}
    </p>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF3C7; border-left: 4px solid #F59E0B; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #92400E;">
        â° This password reset link will expire in <strong>1 hour</strong>.
      </p>
    </div>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF2F2; border-left: 4px solid #EF4444; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #991B1B;">
        <strong>âš ï¸ Security Warning:</strong><br>
        If you didn't request a password reset, please ignore this email. Your password will remain unchanged.
      </p>
    </div>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\auth\verify-email.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const verifyEmailTemplate = (name: string, verificationUrl: string): string => {
  const content = `
    <h2>Welcome to Actopod, ${name}!</h2>
    <p>Thank you for signing up. Please verify your email address to get started with our AI Workflow Canvas.</p>

    <p style="text-align: center;">
      <a href="${verificationUrl}" class="button">Verify Email Address</a>
    </p>

    <p>Or copy and paste this link into your browser:</p>
    <p style="word-break: break-all; color: #6b7280; background-color: #f3f4f6; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px;">
      ${verificationUrl}
    </p>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF3C7; border-left: 4px solid #F59E0B; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #92400E;">
        â° This verification link will expire in <strong>24 hours</strong>.
      </p>
    </div>

    <p style="margin-top: 20px; color: #6b7280; font-size: 14px;">
      If you didn't create an account with Actopod, you can safely ignore this email.
    </p>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\auth\welcome.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const welcomeEmailTemplate = (name: string): string => {
  const content = `
    <h2>Welcome to Actopod, ${name}! ðŸŽ‰</h2>
    <p>Your account has been successfully verified.</p>
    <p>You're all set to start building powerful AI workflows with our Multi-LLM Node-Based Platform.</p>

    <div style="margin: 30px 0; padding: 20px; background-color: #F0FDF4; border-radius: 8px;">
      <h3 style="margin-top: 0; color: #065F46;">ðŸš€ Quick Start Guide</h3>
      <ul style="padding-left: 20px;">
        <li style="margin: 10px 0;">Create your first canvas</li>
        <li style="margin: 10px 0;">Add AI nodes (OpenAI, Anthropic, Google Gemini, and more)</li>
        <li style="margin: 10px 0;">Connect nodes to build powerful workflows</li>
        <li style="margin: 10px 0;">Run and iterate on your AI canvas</li>
      </ul>
    </div>

    <p style="text-align: center;">
      <a href="${process.env.FRONTEND_URL}/dashboard" class="button">Get Started â†’</a>
    </p>

    <div style="margin-top: 30px; padding: 20px; background-color: #F9FAFB; border-radius: 8px;">
      <h3 style="margin-top: 0; color: #374151;">ðŸ“š Helpful Resources</h3>
      <ul style="list-style: none; padding: 0;">
        <li style="margin: 10px 0;">
          ðŸ“– <a href="${process.env.FRONTEND_URL}/docs">Documentation</a> - Learn the basics
        </li>
        <li style="margin: 10px 0;">
          ðŸŽ“ <a href="${process.env.FRONTEND_URL}/tutorials">Tutorials</a> - Step-by-step guides
        </li>
        <li style="margin: 10px 0;">
          ðŸ’¬ <a href="${process.env.FRONTEND_URL}/community">Community</a> - Connect with others
        </li>
        <li style="margin: 10px 0;">
          ðŸ†˜ <a href="${process.env.FRONTEND_URL}/support">Support</a> - Get help anytime
        </li>
      </ul>
    </div>

    <p style="margin-top: 30px;">
      Need help getting started? Our support team is here to help at
      <a href="mailto:${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}">${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}</a>
    </p>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\base.template.ts`

```typescript
export const baseEmailTemplate = (content: string): string => `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Actopod</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9fafb;
    }
    .container {
      background-color: #ffffff;
      border-radius: 8px;
      padding: 40px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .header {
      text-align: center;
      padding-bottom: 30px;
      border-bottom: 2px solid #4F46E5;
      margin-bottom: 30px;
    }
    .logo {
      font-size: 32px;
      font-weight: bold;
      color: #4F46E5;
      text-decoration: none;
    }
    .content {
      color: #374151;
      font-size: 16px;
    }
    .content h2 {
      color: #111827;
      font-size: 24px;
      margin-top: 0;
    }
    .button {
      display: inline-block;
      padding: 14px 28px;
      background-color: #4F46E5;
      color: #ffffff !important;
      text-decoration: none;
      border-radius: 8px;
      margin: 20px 0;
      font-weight: 600;
      transition: background-color 0.3s;
    }
    .button:hover {
      background-color: #4338CA;
    }
    .footer {
      text-align: center;
      padding-top: 30px;
      margin-top: 30px;
      border-top: 1px solid #e5e7eb;
      color: #6b7280;
      font-size: 14px;
    }
    .footer a {
      color: #4F46E5;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">ðŸš€ Actopod</div>
    </div>
    <div class="content">
      ${content}
    </div>
    <div class="footer">
      <p>Â© ${new Date().getFullYear()} Actopod. All rights reserved.</p>
      <p>AI Workflow Canvas - Multi-LLM Node-Based Platform</p>
      <p>
        <a href="${process.env.FRONTEND_URL}/help">Help Center</a> â€¢
        <a href="${process.env.FRONTEND_URL}/privacy">Privacy Policy</a> â€¢
        <a href="${process.env.FRONTEND_URL}/terms">Terms of Service</a>
      </p>
    </div>
  </div>
</body>
</html>
`;

```

### `apps\backend\src\common\aws\ses\templates\workspace\invitation.template.ts`

```typescript
import { WorkspaceRole } from '@actopod/schema';

export const workspaceInvitationTemplate = (
  workspaceName: string,
  inviteLink: string,
  role: WorkspaceRole,
): string => {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Workspace Invitation</title>
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f5f5f5;">
  <div style="max-width: 600px; margin: 40px auto; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; text-align: center; border-radius: 8px 8px 0 0;">
      <h1 style="color: #ffffff; margin: 0; font-size: 28px; font-weight: 600;">Workspace Invitation</h1>
    </div>

    <div style="padding: 40px;">
      <p style="font-size: 16px; color: #333; line-height: 1.6; margin: 0 0 20px;">
        You've been invited to join <strong>${workspaceName}</strong> as a <strong>${role}</strong> on Actopod.
      </p>

      <p style="font-size: 16px; color: #333; line-height: 1.6; margin: 0 0 30px;">
        Click the button below to accept the invitation and start collaborating:
      </p>

      <div style="text-align: center; margin: 30px 0;">
        <a href="${inviteLink}" style="display: inline-block; padding: 14px 32px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #ffffff; text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 16px;">
          Accept Invitation
        </a>
      </div>

      <p style="font-size: 14px; color: #666; line-height: 1.6; margin: 30px 0 0; padding-top: 20px; border-top: 1px solid #eee;">
        This invitation will expire in <strong>7 days</strong>.
      </p>

      <p style="font-size: 14px; color: #666; line-height: 1.6; margin: 10px 0 0;">
        If you didn't expect this invitation, you can safely ignore this email.
      </p>
    </div>

    <div style="background-color: #f9f9f9; padding: 20px; text-align: center; border-radius: 0 0 8px 8px; border-top: 1px solid #eee;">
      <p style="margin: 0; font-size: 12px; color: #999;">
        Â© ${new Date().getFullYear()} Actopod. All rights reserved.
      </p>
    </div>
  </div>
</body>
</html>
  `;
};

```

### `apps\backend\src\common\aws\sns\sns.service.ts`

```typescript
import { Injectable, Logger, InternalServerErrorException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  SNSClient,
  PublishCommand,
  CreateTopicCommand,
  SubscribeCommand,
  UnsubscribeCommand,
  ListTopicsCommand,
  SetTopicAttributesCommand,
} from '@aws-sdk/client-sns';

export interface PublishOptions {
  topicArn: string;
  message: string;
  subject?: string;
  messageAttributes?: Record<string, any>;
}

export interface SubscriptionOptions {
  topicArn: string;
  protocol: 'email' | 'sms' | 'http' | 'https' | 'sqs' | 'lambda';
  endpoint: string;
}

@Injectable()
export class SnsService {
  private readonly logger = new Logger(SnsService.name);
  private readonly snsClient: SNSClient | null = null;
  private readonly isEnabled: boolean;
  private readonly region: string;

  constructor(private readonly configService: ConfigService) {
    this.region = this.configService.get<string>('AWS_REGION') || 'us-east-1';
    const accessKeyId = this.configService.get<string>('AWS_SNS_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_SNS_SECRET_ACCESS_KEY');

    this.isEnabled = !!(this.region && accessKeyId && secretAccessKey);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      this.snsClient = new SNSClient({
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      });
      this.logger.log('âœ… AWS SNS initialized successfully');
    } else {
      this.logger.warn('âš ï¸  AWS SNS not configured');
    }
  }

  /**
   * Publish message to SNS topic
   */
  async publishMessage(options: PublishOptions): Promise<string> {
    if (!this.isEnabled || !this.snsClient) {
      this.logger.log(`[SNS LOG] Topic: ${options.topicArn}, Message: ${options.message}`);
      return `dev-mode-${Date.now()}`;
    }

    try {
      const command = new PublishCommand({
        TopicArn: options.topicArn,
        Message: options.message,
        Subject: options.subject,
        MessageAttributes: options.messageAttributes,
      });

      const response = await this.snsClient.send(command);
      this.logger.log(`ðŸ“¢ SNS message published: ${response.MessageId}`);
      return response.MessageId || '';
    } catch (error: any) {
      this.logger.error('âŒ SNS publish error:', error);
      throw new InternalServerErrorException(`Failed to publish SNS message: ${error.message}`);
    }
  }

  /**
   * Create SNS topic
   */
  async createTopic(name: string): Promise<string> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new CreateTopicCommand({ Name: name });
      const response = await this.snsClient.send(command);
      this.logger.log(`âœ… SNS topic created: ${name}`);
      return response.TopicArn || '';
    } catch (error: any) {
      this.logger.error('âŒ SNS create topic error:', error);
      throw new InternalServerErrorException(`Failed to create SNS topic: ${error.message}`);
    }
  }

  /**
   * Subscribe to SNS topic
   */
  async subscribe(options: SubscriptionOptions): Promise<string> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new SubscribeCommand({
        TopicArn: options.topicArn,
        Protocol: options.protocol,
        Endpoint: options.endpoint,
      });

      const response = await this.snsClient.send(command);
      this.logger.log(`âœ… Subscribed to SNS topic: ${options.topicArn}`);
      return response.SubscriptionArn || '';
    } catch (error: any) {
      this.logger.error('âŒ SNS subscribe error:', error);
      throw new InternalServerErrorException(`Failed to subscribe to SNS topic: ${error.message}`);
    }
  }

  /**
   * Unsubscribe from SNS topic
   */
  async unsubscribe(subscriptionArn: string): Promise<void> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new UnsubscribeCommand({ SubscriptionArn: subscriptionArn });
      await this.snsClient.send(command);
      this.logger.log(`âœ… Unsubscribed from SNS topic`);
    } catch (error: any) {
      this.logger.error('âŒ SNS unsubscribe error:', error);
      throw new InternalServerErrorException(`Failed to unsubscribe: ${error.message}`);
    }
  }

  /**
   * List all SNS topics
   */
  async listTopics(): Promise<string[]> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new ListTopicsCommand({});
      const response = await this.snsClient.send(command);
      return (response.Topics || []).map((t) => t.TopicArn || '');
    } catch (error: any) {
      this.logger.error('âŒ SNS list topics error:', error);
      throw new InternalServerErrorException(`Failed to list SNS topics: ${error.message}`);
    }
  }

  /**
   * Set topic attribute
   */
  async setTopicAttribute(
    topicArn: string,
    attributeName: string,
    attributeValue: string,
  ): Promise<void> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new SetTopicAttributesCommand({
        TopicArn: topicArn,
        AttributeName: attributeName,
        AttributeValue: attributeValue,
      });

      await this.snsClient.send(command);
      this.logger.log(`âœ… SNS topic attribute set: ${attributeName}`);
    } catch (error: any) {
      this.logger.error('âŒ SNS set attribute error:', error);
      throw new InternalServerErrorException(`Failed to set topic attribute: ${error.message}`);
    }
  }

  /**
   * Check if SNS is configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get SNS configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
    };
  }
}

```

### `apps\backend\src\common\decorators\common\index.ts`

```typescript
export * from './public.decorator';
export * from './paginate.decorator';
export * from './is-not-empty-object.decorator';

```

### `apps\backend\src\common\decorators\common\is-not-empty-object.decorator.ts`

```typescript
// src/common/decorators/common/is-not-empty-object.decorator.ts

import type { ValidationOptions, ValidationArguments } from 'class-validator';
import { registerDecorator } from 'class-validator';

export function IsNotEmptyObject(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'isNotEmptyObject',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          // Exclude the 'data' property itself from the check
          const keys = Object.keys(args.object).filter(
            (key) => key !== propertyName,
          );
          return keys.length > 0;
        },
        defaultMessage() {
          return 'At least one field must be provided';
        },
      },
    });
  };
}

```

### `apps\backend\src\common\decorators\common\paginate.decorator.ts`

```typescript
import {
  SetMetadata,
  createParamDecorator,
  ExecutionContext,
} from '@nestjs/common';

export const PAGINATE_METADATA_KEY = 'paginate';

export interface PaginateOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  order?: 'asc' | 'desc';
  search?: string;
  filters?: { [key: string]: any };
}

/**
 * This decorator is still available if you want to set some default metadata.
 */
export const Paginate = (
  options: PaginateOptions = {
    page: 1,
    limit: 20,
    sortBy: 'createdAt',
    order: 'desc',
  },
) => SetMetadata(PAGINATE_METADATA_KEY, options);

/**
 * Extract pagination options from the request query.
 */
export const PaginationParams = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): PaginateOptions => {
    const request = ctx.switchToHttp().getRequest();
    const page = parseInt(request.query.page, 10) || 1;
    const limit = parseInt(request.query.limit, 10) || 20;
    const sortBy = request.query.sortBy || 'createdAt';
    const order = request.query.order || 'desc';
    const search = request.query.search || '';
    const filters = request.query.filters
      ? JSON.parse(request.query.filters)
      : {};
    return { page, limit, sortBy, order, search, filters };
  },
);

```

### `apps\backend\src\common\decorators\common\public.decorator.ts`

```typescript
// src/common/decorators/common.decorator.ts

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

```

### `apps\backend\src\common\decorators\user\get-current-user.decorator.ts`

```typescript
// src/common/decorators/user.decorator.ts

import type { ExecutionContext } from '@nestjs/common';
import { createParamDecorator } from '@nestjs/common';

export const GetCurrentUser = createParamDecorator(
  (data: string | undefined, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest();
    if (data) {
      return request.user[data];
    }
    return request.user;
  },
);

```

### `apps\backend\src\common\decorators\user\get-current-user-id.decorator.ts`

```typescript
// src/common/decorators/user.decorator.ts

import type { ExecutionContext } from '@nestjs/common';
import { createParamDecorator, UnauthorizedException } from '@nestjs/common';

export const GetCurrentUserId = createParamDecorator(
  (data: unknown, context: ExecutionContext): string => {
    const request = context.switchToHttp().getRequest();
    return request.user?.userId;
  },
);

```

### `apps\backend\src\common\decorators\user\index.ts`

```typescript
export * from './get-current-user.decorator';
export * from './get-current-user-id.decorator';

```

### `apps\backend\src\common\dto\pagination.dto.ts`

```typescript
// src/common/dto/pagination-query.dto.ts

import { IsOptional, IsPositive, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationQueryDto {
  @IsOptional()
  @IsPositive()
  @Type(() => Number)
  page?: number = 1;

  @IsOptional()
  @IsPositive()
  @Type(() => Number)
  limit?: number = 10;

  @IsOptional()
  @IsString()
  sortBy?: string;

  @IsOptional()
  @IsString()
  order?: 'asc' | 'desc' = 'asc';

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  filters?: { [key: string]: any }; // You can enhance this to be more specific
}

```

### `apps\backend\src\common\filters\exception.filters.ts`

```typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // CRITICAL: Don't try to send response if headers already sent
    if (response.headersSent) {
      this.logger.error('Headers already sent. Cannot send error response.');
      this.logger.error('Exception details:', exception);
      return;
    }

    let status: number;
    let message: string;
    let errors: any[] = [];

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'object') {
        message = (exceptionResponse as any).message || exception.message;
        errors = (exceptionResponse as any).errors || [];
      } else {
        message = exceptionResponse;
      }
    } else {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Internal server error';
      this.logger.error('Unhandled exception:', exception);
    }

    try {
      response.status(status).json({
        statusCode: status,
        message,
        errors,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
    } catch (error) {
      // If we still can't send response, log it
      this.logger.error('Failed to send error response:', error);
    }
  }
}

```

### `apps\backend\src\common\filters\ws-exception.filter.ts`

```typescript
// common/filters/ws-exception.filter.ts
import { Catch, ArgumentsHost } from '@nestjs/common';
import { BaseWsExceptionFilter, WsException } from '@nestjs/websockets';
import { Socket } from 'socket.io';

@Catch()
export class WsExceptionFilter extends BaseWsExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const client = host.switchToWs().getClient<Socket>();

    const error =
      exception instanceof WsException
        ? exception.getError()
        : exception instanceof Error
          ? exception.message
          : 'Unknown error';

    client.emit('error', {
      message: typeof error === 'string' ? error : 'Internal server error',
      code: 'WS_ERROR',
      timestamp: new Date().toISOString(),
    });
  }
}

```

### `apps\backend\src\common\guards\auth\access-token.guard.ts`

```typescript
import { Injectable, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { IS_PUBLIC_KEY } from '../../decorators/common';

@Injectable()
export class AccessTokenGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }
}

```

### `apps\backend\src\common\guards\auth\github-oauth.guard.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GitHubOAuthGuard extends AuthGuard('github') {}

```

### `apps\backend\src\common\guards\auth\google-oauth.guard.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GoogleOAuthGuard extends AuthGuard('google') {}

```

### `apps\backend\src\common\guards\auth\index.ts`

```typescript
export * from './access-token.guard';
export * from './refresh-token.guard';
export * from './google-oauth.guard';
export * from './github-oauth.guard';

```

### `apps\backend\src\common\guards\auth\refresh-token.guard.ts`

```typescript
// src/auth/guards/refresh-token.guard.ts

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class RefreshTokenGuard extends AuthGuard('jwt-refresh') {}

```

### `apps\backend\src\common\interceptors\response.interceptor.ts`

```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  HttpStatus,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Reflector } from '@nestjs/core';
import { PAGINATE_METADATA_KEY, PaginateOptions } from '../decorators/common';
import { Response } from 'express';

interface ApiResponse<T> {
  statusCode: number;
  message: string;
  data: T | null;
  errors?: string[];
  timestamp: string;
  pagination?: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
  };
}

interface PaginationResult {
  data: any;
  pagination?: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
  };
}

@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, ApiResponse<T>> {
  constructor(private readonly reflector: Reflector) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<ApiResponse<T> | any> {
    const ctx = context.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest();

    // CRITICAL: Skip if headers already sent (OAuth redirects)
    if (response.headersSent) {
      return next.handle();
    }

    const paginateOptions = this.reflector.get<PaginateOptions>(
      PAGINATE_METADATA_KEY,
      context.getHandler(),
    );

    return next.handle().pipe(
      map((data: any) => {
        // Double-check after handler execution
        if (response.headersSent) {
          return data;
        }

        // Don't wrap null/undefined or redirects
        if (!data || response.statusCode === 302 || response.statusCode === 301) {
          return data;
        }

        const statusCode = data.statusCode || response.statusCode || HttpStatus.OK;
        const message = data.message || response.locals.customMessage || 'Success';
        const errors = data.errors || response.locals.errors || [];
        const timestamp = data.timestamp || new Date().toISOString();

        // If data already contains pagination metadata, return as-is
        if (data && typeof data === 'object' && data.pagination) {
          return this.sanitizeResponse({
            statusCode,
            message,
            data: data.data,
            errors,
            timestamp,
            pagination: data.pagination,
          });
        }

        // Apply pagination if needed
        const responseData = data.data !== undefined ? data.data : data;
        const paginationData: PaginationResult = {
          data: responseData,
        };

        if (Array.isArray(responseData) && paginateOptions) {
          const paginated = this.applyPagination(responseData, paginateOptions, request);
          paginationData.data = paginated.data;
          paginationData.pagination = paginated.pagination;
        }

        return this.sanitizeResponse({
          statusCode,
          message,
          data: paginationData.data as T,
          errors,
          timestamp,
          ...(paginationData.pagination ? { pagination: paginationData.pagination } : {}),
        });
      }),
    );
  }

  private applyPagination(data: any[], options: PaginateOptions, request: any): PaginationResult {
    let { page, limit, sortBy, order, search, filters } = options;
    page = parseInt(request.query.page, 10) || page || 1;
    limit = parseInt(request.query.limit, 10) || limit || 20;
    sortBy = request.query.sortBy || sortBy || 'createdAt';
    order = request.query.order || order || 'desc';
    search = request.query.search || search || '';
    filters = request.query.filters ? JSON.parse(request.query.filters) : filters || {};

    let filteredData = data;

    if (search) {
      filteredData = filteredData.filter((item) =>
        Object.values(item).some((val) => String(val).toLowerCase().includes(search.toLowerCase())),
      );
    }

    if (filters) {
      for (const [key, value] of Object.entries(filters)) {
        filteredData = filteredData.filter((item: { [key: string]: any }) => item[key] === value);
      }
    }

    if (sortBy) {
      filteredData = filteredData.sort((a, b) => {
        if (a[sortBy] < b[sortBy]) {
          return order === 'asc' ? -1 : 1;
        }
        if (a[sortBy] > b[sortBy]) {
          return order === 'asc' ? 1 : -1;
        }
        return 0;
      });
    }

    const totalItems = filteredData.length;
    const totalPages = Math.ceil(totalItems / limit);
    const startIndex = (page - 1) * limit;
    const endIndex = Math.min(startIndex + limit, totalItems);
    const paginatedData = filteredData.slice(startIndex, endIndex);

    return {
      data: paginatedData,
      pagination: {
        totalItems,
        totalPages,
        currentPage: page,
        pageSize: paginatedData.length,
      },
    };
  }

  private sanitizeData(data: any): any {
    if (Array.isArray(data)) {
      return data.map((item) => this.sanitizeData(item));
    } else if (data !== null && typeof data === 'object') {
      if (typeof data.toISOString === 'function') {
        return data.toISOString();
      }
      const sanitized: any = {};
      for (const [key, value] of Object.entries(data)) {
        if (key === 'hash' || key === 'password') {
          continue;
        }
        sanitized[key] = this.sanitizeData(value);
      }
      return sanitized;
    }
    return data;
  }

  private sanitizeResponse(response: ApiResponse<T>): ApiResponse<T> {
    return this.sanitizeData(response);
  }
}

```

### `apps\backend\src\common\queue\queue.factory.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { QueueAdapter } from './queue-adapter.interface';
import { RedisQueueAdapter } from './redis-queue.adapter';
import { SqsQueueAdapter } from './sqs-queue.adapter';

@Injectable()
export class QueueFactory {
  private readonly logger = new Logger(QueueFactory.name);

  constructor(private readonly config: ConfigService) {}

  createQueue(queueName: string, concurrency: number = 10): QueueAdapter {
    const backend = this.config.get('QUEUE_BACKEND', 'redis');

    this.logger.log(`ðŸ”§ Creating queue "${queueName}" with backend: ${backend}`);

    if (backend === 'sqs') {
      return new SqsQueueAdapter(this.config);
    }

    return new RedisQueueAdapter(this.config, queueName, concurrency);
  }
}

```

### `apps\backend\src\common\queue\queue.module.ts`

```typescript
import { Module, Global } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { QueueFactory } from './queue.factory';

@Global()
@Module({
  imports: [ConfigModule],
  providers: [QueueFactory],
  exports: [QueueFactory],
})
export class QueueModule {}

```

### `apps\backend\src\common\queue\queue-adapter.interface.ts`

```typescript
import { JobState } from 'bullmq';

export interface QueueJobData<T = any> {
  id?: string;
  data: T;
  attemptsMade?: number;
}

export interface QueueMetrics {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
}

export interface QueueJobStatus {
  id?: string;
  state?: JobState | 'unknown';
  progress?: any;
  attemptsMade?: number;
  processedOn?: number;
  finishedOn?: number;
}

export interface QueueAdapter<T = any> {
  add(jobName: string, data: T, options?: any): Promise<string>;
  process(handler: (job: any) => Promise<any>): void;
  getMetrics(): Promise<QueueMetrics>;
  cancel(jobId: string): Promise<boolean>;
  getJobStatus(jobId: string): Promise<QueueJobStatus | null>;
  close(): Promise<void>;
}

```

### `apps\backend\src\common\queue\redis-queue.adapter.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Queue, Worker, Job } from 'bullmq';
import { QueueAdapter, QueueJobStatus } from './queue-adapter.interface';

@Injectable()
export class RedisQueueAdapter implements QueueAdapter {
  private readonly logger = new Logger(RedisQueueAdapter.name);
  private queue: Queue;
  private worker!: Worker;

  constructor(
    private readonly config: ConfigService,
    queueName: string,
    private readonly concurrency: number = 10,
  ) {
    const redisConfig = {
      host: this.config.get('REDIS_HOST', 'localhost'),
      port: this.config.get('REDIS_PORT', 6379),
      password: this.config.get('REDIS_PASSWORD'),
      tls: this.config.get('REDIS_TLS_ENABLED') === 'true' ? {} : undefined,
    };

    this.queue = new Queue(queueName, {
      connection: redisConfig,
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
        removeOnComplete: {
          age: 3600,
          count: 1000,
        },
        removeOnFail: {
          age: 86400,
        },
      },
    });

    this.logger.log(`âœ… Redis queue initialized: ${queueName}`);
  }

  async add(jobName: string, data: any, options?: any): Promise<string> {
    const job = await this.queue.add(jobName, data, options);
    return job.id || `${Date.now()}`;
  }

  process(handler: (job: any) => Promise<any>): void {
    this.worker = new Worker(this.queue.name, async (job: Job) => handler(job), {
      connection: this.queue.opts.connection as any,
      concurrency: this.concurrency,
    });

    this.setupEventHandlers();
  }

  async getMetrics() {
    const [waiting, active, completed, failed] = await Promise.all([
      this.queue.getWaitingCount(),
      this.queue.getActiveCount(),
      this.queue.getCompletedCount(),
      this.queue.getFailedCount(),
    ]);

    return { waiting, active, completed, failed };
  }

  async cancel(jobId: string): Promise<boolean> {
    const job = await this.queue.getJob(jobId);
    if (job) {
      await job.remove();
      return true;
    }
    return false;
  }

  async getJobStatus(jobId: string): Promise<QueueJobStatus | null> {
    const job = await this.queue.getJob(jobId);
    if (!job) return null;

    return {
      id: job.id,
      state: await job.getState(),
      progress: job.progress,
      attemptsMade: job.attemptsMade,
      processedOn: job.processedOn,
      finishedOn: job.finishedOn,
    };
  }

  private setupEventHandlers() {
    this.worker.on('completed', (job: Job) => {
      this.logger.log(`âœ… Job ${job.id} completed`);
    });

    this.worker.on('failed', (job: Job | undefined, err: Error) => {
      this.logger.error(`âŒ Job ${job?.id} failed:`, err.message);
    });

    this.worker.on('stalled', (jobId: string) => {
      this.logger.warn(`âš ï¸ Job ${jobId} stalled`);
    });
  }

  async close(): Promise<void> {
    await this.queue.close();
    if (this.worker) await this.worker.close();
  }
}

```

### `apps\backend\src\common\queue\sqs-queue.adapter.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  SQSClient,
  SendMessageCommand,
  ReceiveMessageCommand,
  DeleteMessageCommand,
  GetQueueAttributesCommand,
  Message,
} from '@aws-sdk/client-sqs';
import { QueueAdapter, QueueJobStatus } from './queue-adapter.interface';

@Injectable()
export class SqsQueueAdapter implements QueueAdapter {
  private readonly logger = new Logger(SqsQueueAdapter.name);
  private sqs: SQSClient;
  private queueUrl: string;
  private isProcessing = false;
  private processingHandler: ((job: any) => Promise<any>) | null = null;

  constructor(private readonly config: ConfigService) {
    const region = this.config.get('AWS_SQS_REGION') || this.config.get('AWS_REGION');

    this.sqs = new SQSClient({
      region,
      credentials: {
        accessKeyId: this.config.get('AWS_SQS_ACCESS_KEY_ID')!,
        secretAccessKey: this.config.get('AWS_SQS_SECRET_ACCESS_KEY')!,
      },
    });

    this.queueUrl = this.config.get('AWS_SQS_QUEUE_URL')!;
    this.logger.log(`âœ… SQS queue initialized: ${this.queueUrl}`);
  }

  async add(jobName: string, data: any, options?: any): Promise<string> {
    const jobId = options?.jobId || Date.now().toString();

    const command = new SendMessageCommand({
      QueueUrl: this.queueUrl,
      MessageBody: JSON.stringify({ jobName, data, options }),
      MessageAttributes: {
        jobName: { DataType: 'String', StringValue: jobName },
        jobId: { DataType: 'String', StringValue: jobId },
      },
    });

    const result = await this.sqs.send(command);
    return result.MessageId || jobId;
  }

  process(handler: (job: any) => Promise<any>): void {
    this.processingHandler = handler;
    this.startPolling();
  }

  private async startPolling() {
    this.isProcessing = true;

    while (this.isProcessing) {
      try {
        const command = new ReceiveMessageCommand({
          QueueUrl: this.queueUrl,
          MaxNumberOfMessages: 10,
          WaitTimeSeconds: 20,
          MessageAttributeNames: ['All'],
        });

        const result = await this.sqs.send(command);

        if (result.Messages && result.Messages.length > 0) {
          await Promise.all(
            result.Messages.map(async (message: Message) => {
              try {
                const body = JSON.parse(message.Body!);
                const job = {
                  id: message.MessageAttributes?.jobId?.StringValue || message.MessageId,
                  data: body.data,
                  attemptsMade: 0,
                };

                await this.processingHandler!(job);

                const deleteCommand = new DeleteMessageCommand({
                  QueueUrl: this.queueUrl,
                  ReceiptHandle: message.ReceiptHandle!,
                });
                await this.sqs.send(deleteCommand);

                this.logger.log(`âœ… Job ${job.id} completed`);
              } catch (error) {
                this.logger.error(
                  `âŒ Job processing failed:`,
                  error instanceof Error ? error.message : 'Unknown error',
                );
              }
            }),
          );
        }
      } catch (error) {
        this.logger.error('SQS polling error:', error);
        await new Promise((resolve) => setTimeout(resolve, 5000));
      }
    }
  }

  async getMetrics() {
    const command = new GetQueueAttributesCommand({
      QueueUrl: this.queueUrl,
      AttributeNames: [
        'ApproximateNumberOfMessages',
        'ApproximateNumberOfMessagesNotVisible',
        'ApproximateNumberOfMessagesDelayed',
      ],
    });

    const result = await this.sqs.send(command);

    return {
      waiting: parseInt(result.Attributes?.ApproximateNumberOfMessages || '0'),
      active: parseInt(result.Attributes?.ApproximateNumberOfMessagesNotVisible || '0'),
      completed: 0,
      failed: 0,
    };
  }

  async cancel(_jobId: string): Promise<boolean> {
    this.logger.warn('SQS does not support job cancellation by ID');
    return false;
  }

  async getJobStatus(_jobId: string): Promise<QueueJobStatus | null> {
    return null;
  }

  async close(): Promise<void> {
    this.isProcessing = false;
  }
}

```

### `apps\backend\src\common\websocket\websocket.module.ts`

```typescript
import { Global, Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Global()
@Module({
  imports: [
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_ACCESS_TOKEN_SECRET') || 'fallback-secret',
      }),
      inject: [ConfigService],
    }),
  ],
  exports: [JwtModule],
})
export class WebSocketModule {}

```

### `apps\backend\src\main.ts`

```typescript
import 'tsconfig-paths/register';
import { NestFactory, Reflector } from '@nestjs/core';
import {
  ClassSerializerInterceptor,
  HttpException,
  HttpStatus,
  ValidationPipe,
  VersioningType,
  Logger,
} from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { ValidationError } from 'class-validator';

import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/exception.filters';
import { ResponseInterceptor } from './common/interceptors/response.interceptor';
import { PrismaService } from './prisma/prisma.service';
import { config } from 'dotenv';
import { join } from 'path';

config({ path: join(__dirname, '../../..', '.env') });

function flattenValidationErrors(
  errors: ValidationError[],
  parentPath = '',
): { property: string; constraints: Record<string, string> }[] {
  const result: { property: string; constraints: Record<string, string> }[] = [];

  for (const error of errors) {
    const propertyPath = parentPath
      ? Array.isArray(error)
        ? `${parentPath}[${error.property}]`
        : `${parentPath}.${error.property}`
      : error.property;

    if (error.constraints) {
      result.push({
        property: propertyPath,
        constraints: error.constraints,
      });
    }

    if (error.children && error.children.length > 0) {
      const childPathPrefix = Array.isArray(error) ? `${propertyPath}` : `${propertyPath}`;
      result.push(...flattenValidationErrors(error.children, childPathPrefix));
    }
  }

  return result;
}

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule, {
    rawBody: true,
  });

  // Global API prefix
  app.setGlobalPrefix('api');

  // CORS configuration (applies to both HTTP and WebSocket)
  app.enableCors({
    origin: [
      process.env.FRONTEND_URL || 'http://localhost:5173',
      /^http:\/\/localhost:\d+$/, // Allow all localhost ports
      /^https?:\/\/.*\.actopod\.dev/, // Production subdomains
    ],
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    credentials: true,
  });

  // API Versioning
  app.enableVersioning({
    type: VersioningType.URI,
    defaultVersion: '1',
  });

  // Connect to Prisma database
  const prisma = app.get(PrismaService);
  try {
    await prisma.$connect();
    logger.log('âœ… Database connected successfully');
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('âŒ Database connection failed', errorMessage);
    throw new HttpException(
      { message: 'Unable to connect to database', error: errorMessage },
      HttpStatus.INTERNAL_SERVER_ERROR,
    );
  }

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
      forbidNonWhitelisted: true,
      exceptionFactory: (validationErrors: ValidationError[] = []) => {
        const flattened = flattenValidationErrors(validationErrors);
        return new HttpException(
          {
            message: 'Validation failed',
            errors: flattened,
          },
          HttpStatus.BAD_REQUEST,
        );
      },
    }),
  );

  // Global interceptors and filters
  const reflector = app.get(Reflector);
  app.useGlobalInterceptors(new ResponseInterceptor(reflector));
  app.useGlobalInterceptors(new ClassSerializerInterceptor(reflector));
  app.useGlobalFilters(new AllExceptionsFilter());

  // Swagger documentation
  const swaggerConfig = new DocumentBuilder()
    .setTitle('Actopod API v1')
    .setDescription('AI Workflow Canvas - Multi-LLM Node-Based Platform')
    .setVersion('1.0')
    .addBearerAuth({
      type: 'http',
      scheme: 'bearer',
      bearerFormat: 'JWT',
      name: 'Authorization',
      description: 'Enter JWT token',
      in: 'header',
    })
    .build();

  const document = SwaggerModule.createDocument(app, swaggerConfig);
  SwaggerModule.setup('api/v1/docs', app, document, {
    customSiteTitle: 'Actopod API v1 Docs',
    swaggerOptions: {
      persistAuthorization: true,
    },
  });

  // Start server
  const port = parseInt(process.env.BACKEND_PORT || '3000', 10);
  await app.listen(port, '0.0.0.0');

  logger.log(`ðŸš€ Actopod Backend running on: http://localhost:${port}`);
  logger.log(`ðŸ“š API v1 Documentation: http://localhost:${port}/api/v1/docs`);
  logger.log(`ðŸ” Health Check: http://localhost:${port}/api/v1/health`);
  logger.log(`ðŸ”Œ WebSocket: ws://localhost:${port}/notifications`);
}

bootstrap().catch((error: unknown) => {
  const logger = new Logger('Bootstrap');
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  logger.error('âŒ Failed to start application', errorMessage);
  process.exit(1);
});

```

### `apps\backend\src\prisma\prisma.module.ts`

```typescript
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

```

### `apps\backend\src\prisma\prisma.service.ts`

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@actopod/schema';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

```

### `apps\backend\src\v1\app.module.ts`

```typescript
// v1/app.module.ts
import { Module } from '@nestjs/common';
import { V1ServerModule } from './server/server.module';
import { V1AuthModule } from './auth/auth.module';
import { V1WorkspaceModule } from './workspace/workspace.module';
import { V1UserModule } from './user/user.module';
import { V1NotificationModule } from './notification/notification.module';
import { V1FlowModule } from './flow/flow.module';
import { V1ExecutionModule } from './execution/execution.module';
import { V1PodModule } from './pods/pod.module';
import { V1ModelsModule } from './models/models.module';

@Module({
  imports: [
    // ALL your V1 modules
    V1ServerModule,
    V1AuthModule,
    V1WorkspaceModule,
    V1UserModule,
    V1NotificationModule,
    V1FlowModule,
    V1ExecutionModule,
    V1PodModule,
    V1ModelsModule,
  ],
  providers: [
    // {
    //   provide: APP_GUARD,
    //   useClass: AccessTokenGuard,
    // },
  ],
  exports: [
    // export if needed by the root or other modules
    V1ServerModule,
    V1AuthModule,
    V1WorkspaceModule,
    V1UserModule,
    V1NotificationModule,
    V1FlowModule,
    V1ExecutionModule,
    V1PodModule,
    V1ModelsModule,
  ],
})
export class V1AppModule {}

```

### `apps\backend\src\v1\auth\auth.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  UseGuards,
  Req,
  Res,
  HttpCode,
  HttpStatus,
  Body,
  Ip,
  UseInterceptors,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth, ApiResponse } from '@nestjs/swagger';
import { Request, Response } from 'express';
import { V1AuthService } from './auth.service';
import { SendMagicLinkDto, VerifyMagicLinkDto } from './dto/magic-link.dto';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { ForgotPasswordDto } from './dto/forgot-password.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { UAParser } from 'ua-parser-js';
import { Public } from '../../common/decorators/common';
import { GitHubOAuthGuard, GoogleOAuthGuard, RefreshTokenGuard } from '../../common/guards/auth';
import { GetCurrentUserId } from '../../common/decorators/user';

@ApiTags('Authentication')
@Controller({ path: 'auth', version: '1' })
export class V1AuthController {
  constructor(private readonly authService: V1AuthService) {}

  // ============================================
  // EMAIL/PASSWORD AUTHENTICATION
  // ============================================

  @Public()
  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'Register new user with email and password' })
  @ApiResponse({
    status: 201,
    description: 'User registered successfully. Verification email sent.',
  })
  @ApiResponse({ status: 409, description: 'Email already exists' })
  @ApiResponse({ status: 400, description: 'Invalid input data' })
  async register(@Body() dto: RegisterDto) {
    return this.authService.register(dto.email, dto.name, dto.password);
  }

  @Public()
  @Post('verify-email')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify email address' })
  @ApiResponse({ status: 200, description: 'Email verified successfully' })
  @ApiResponse({ status: 400, description: 'Invalid or expired verification token' })
  async verifyEmail(@Body() dto: { token: string }) {
    return this.authService.verifyEmail(dto.token);
  }

  @Public()
  @Post('login')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Login with email and password' })
  @ApiResponse({ status: 200, description: 'Login successful. Returns access and refresh tokens.' })
  @ApiResponse({ status: 401, description: 'Invalid credentials or email not verified' })
  async login(@Body() dto: LoginDto, @Req() req: Request) {
    const uaString = req.headers['user-agent'] || '';
    const parser = new UAParser(uaString);
    const os = parser.getOS().name || 'Unknown OS';
    const browser = parser.getBrowser().name || 'Unknown Browser';
    const deviceName = `${os} â€“ ${browser}`;

    return this.authService.login(dto.email, dto.password, deviceName);
  }

  @Public()
  @Post('forgot-password')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Request password reset link' })
  @ApiResponse({ status: 200, description: 'If email exists, password reset link sent' })
  async forgotPassword(@Body() dto: ForgotPasswordDto) {
    return this.authService.forgotPassword(dto.email);
  }

  @Public()
  @Post('reset-password')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Reset password with token from email' })
  @ApiResponse({ status: 200, description: 'Password reset successfully' })
  @ApiResponse({ status: 400, description: 'Invalid or expired reset token' })
  async resetPassword(@Body() dto: ResetPasswordDto) {
    return this.authService.resetPassword(dto.token, dto.newPassword);
  }

  // ============================================
  // MAGIC LINK AUTHENTICATION
  // ============================================

  @Public()
  @Post('magic-link/send')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Send passwordless magic link to email' })
  @ApiResponse({ status: 200, description: 'If email exists, magic link sent' })
  @ApiResponse({ status: 429, description: 'Too many attempts. Try again later.' })
  async sendMagicLink(@Body() dto: SendMagicLinkDto, @Req() req: Request, @Ip() ipAddress: string) {
    const uaString = req.headers['user-agent'] || '';
    const parser = new UAParser(uaString);
    const os = parser.getOS().name || 'Unknown OS';
    const browser = parser.getBrowser().name || 'Unknown Browser';
    const deviceName = `${os} â€“ ${browser}`;

    return this.authService.sendMagicLink(dto.email, deviceName, ipAddress || 'unknown');
  }

  @Public()
  @Post('magic-link/verify')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify magic link token and get JWT tokens' })
  @ApiResponse({
    status: 200,
    description: 'Magic link verified. Returns access and refresh tokens.',
  })
  @ApiResponse({ status: 401, description: 'Invalid or expired magic link' })
  async verifyMagicLink(
    @Body() dto: VerifyMagicLinkDto & { email: string },
    @Req() req: Request,
    @Ip() ipAddress: string,
  ) {
    const uaString = req.headers['user-agent'] || '';
    const parser = new UAParser(uaString);
    const os = parser.getOS().name || 'Unknown OS';
    const browser = parser.getBrowser().name || 'Unknown Browser';
    const deviceName = `${os} â€“ ${browser}`;

    return this.authService.verifyMagicLink(
      dto.token,
      dto.email,
      deviceName,
      ipAddress || 'unknown',
    );
  }

  // ============================================
  // OAUTH AUTHENTICATION
  // ============================================

  @Public()
  @Get('google')
  @UseGuards(GoogleOAuthGuard)
  @ApiOperation({ summary: 'Initiate Google OAuth login flow' })
  @ApiResponse({ status: 302, description: 'Redirects to Google OAuth consent screen' })
  async googleAuth() {}

  @Public()
  @Get('google/callback')
  @UseGuards(GoogleOAuthGuard)
  @UseInterceptors()
  @ApiOperation({ summary: 'Google OAuth callback endpoint' })
  @ApiResponse({ status: 302, description: 'Redirects to frontend with tokens' })
  async googleAuthCallback(@Req() req: Request, @Res() res: Response) {
    const user = req.user as any;

    if (!user) {
      const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
      return res.redirect(`${frontendUrl}/auth/error?message=Authentication failed`);
    }

    const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
    const params = new URLSearchParams({
      accessToken: user.accessToken,
      refreshToken: user.refreshToken,
      userId: user.userId,
      deviceId: user.deviceId,
    });

    res.redirect(`${frontendUrl}/auth/callback?${params.toString()}`);
  }

  @Public()
  @Get('github')
  @UseGuards(GitHubOAuthGuard)
  @ApiOperation({ summary: 'Initiate GitHub OAuth login flow' })
  @ApiResponse({ status: 302, description: 'Redirects to GitHub OAuth consent screen' })
  async githubAuth() {}

  @Public()
  @Get('github/callback')
  @UseGuards(GitHubOAuthGuard)
  @UseInterceptors() // â† Clear all interceptors for this route
  @ApiOperation({ summary: 'GitHub OAuth callback endpoint' })
  @ApiResponse({ status: 302, description: 'Redirects to frontend with tokens' })
  async githubAuthCallback(@Req() req: Request, @Res() res: Response) {
    const user = req.user as any;

    if (!user) {
      const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
      return res.redirect(`${frontendUrl}/auth/error?message=Authentication failed`);
    }

    const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
    const params = new URLSearchParams({
      accessToken: user.accessToken,
      refreshToken: user.refreshToken,
      userId: user.userId,
      deviceId: user.deviceId,
    });

    res.redirect(`${frontendUrl}/auth/callback?${params.toString()}`);
  }

  // ============================================
  // TOKEN MANAGEMENT
  // ============================================

  @Public()
  @Post('refresh')
  @UseGuards(RefreshTokenGuard)
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Refresh access token using refresh token' })
  @ApiResponse({ status: 200, description: 'New access and refresh tokens generated' })
  @ApiResponse({ status: 401, description: 'Invalid or expired refresh token' })
  async refreshTokens(@Req() req: any, @Body() body: { deviceId: string }) {
    return this.authService.refreshTokens(req.user.refreshToken, body.deviceId);
  }

  @Post('logout')
  @HttpCode(HttpStatus.OK)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Logout from current device' })
  @ApiResponse({ status: 200, description: 'Logged out successfully' })
  async logout(@GetCurrentUserId() userId: string, @Req() req: Request) {
    const deviceId = req.headers['x-device-id'] as string;
    return this.authService.logout(userId, deviceId);
  }

  @Post('logout-all')
  @HttpCode(HttpStatus.OK)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Logout from all devices' })
  @ApiResponse({ status: 200, description: 'Logged out from all devices' })
  async logoutAll(@GetCurrentUserId() userId: string) {
    return this.authService.logoutAllDevices(userId);
  }

  @Get('me')
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get current authenticated user info' })
  @ApiResponse({ status: 200, description: 'Returns current user ID' })
  @ApiResponse({ status: 401, description: 'Not authenticated' })
  async getCurrentUser(@GetCurrentUserId() userId: string) {
    return { userId };
  }

  @Public()
  @Post('resend-verification')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Resend email verification link' })
  @ApiResponse({ status: 200, description: 'Verification email sent if user exists' })
  @ApiResponse({ status: 429, description: 'Too many attempts' })
  async resendVerification(@Body() dto: { email: string }) {
    return this.authService.resendVerificationEmail(dto.email);
  }

  @Get('email-verified-status')
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Check if current user email is verified' })
  @ApiResponse({ status: 200, description: 'Returns verification status' })
  async checkEmailVerified(@GetCurrentUserId() userId: string) {
    return this.authService.checkEmailVerifiedStatus(userId);
  }
}

```

### `apps\backend\src\v1\auth\auth.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { V1AuthController } from './auth.controller';
import { V1AuthService } from './auth.service';
import { AccessTokenStrategy } from './strategies/access-token.strategy';
import { RefreshTokenStrategy } from './strategies/refresh-token.strategy';
import { GoogleStrategy } from './strategies/google.strategy';
import { GitHubStrategy } from './strategies/github.strategy';
import { AwsModule } from '../../common/aws/aws.module';

@Module({
  imports: [PassportModule, JwtModule.register({}), AwsModule],
  controllers: [V1AuthController],
  providers: [
    V1AuthService,
    AccessTokenStrategy,
    RefreshTokenStrategy,
    GoogleStrategy,
    GitHubStrategy,
  ],
  exports: [V1AuthService],
})
export class V1AuthModule {}

```

### `apps\backend\src\v1\auth\auth.service.ts`

```typescript
import {
  Injectable,
  UnauthorizedException,
  Logger,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../prisma/prisma.service';
import { AwsSesEmailService } from '../../common/aws/ses/ses-email.service';
import { AuthUserType, GoogleUserData, GitHubUserData, JwtPayload } from './types';
import { AuthProvider } from '@actopod/schema';
import { randomBytes, createHash } from 'crypto';
import * as bcrypt from 'bcrypt';
import { magicLinkTemplate } from '../../common/aws/ses/templates/auth/magic-link.template';
import { resetPasswordTemplate } from '../../common/aws/ses/templates/auth/reset-password.template';
import { verifyEmailTemplate } from '../../common/aws/ses/templates/auth/verify-email.template';
import { welcomeEmailTemplate } from '../../common/aws/ses/templates/auth/welcome.template';

@Injectable()
export class V1AuthService {
  private readonly logger = new Logger(V1AuthService.name);
  private readonly MAGIC_LINK_EXPIRY = 15 * 60 * 1000;
  private readonly RESET_PASSWORD_EXPIRY = 60 * 60 * 1000;
  private readonly MAX_ATTEMPTS = 3;
  private readonly ATTEMPT_WINDOW = 60 * 60 * 1000;

  constructor(
    private readonly prisma: PrismaService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly emailService: AwsSesEmailService,
  ) {}

  // ============================================
  // PASSWORD AUTHENTICATION
  // ============================================

  async register(
    email: string,
    name: string,
    password: string,
  ): Promise<{ message: string; userId: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const existingUser = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (existingUser) {
      throw new ConflictException('Email already registered');
    }

    const hash = await bcrypt.hash(password, 10);
    const verificationToken = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(verificationToken).digest('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

    const user = await this.prisma.$transaction(async (tx) => {
      const newUser = await tx.user.create({
        data: { email: normalizedEmail, name, hash },
      });

      await tx.account.create({
        data: {
          userId: newUser.id,
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
          accessToken: tokenHash,
          expiresAt,
        },
      });

      await tx.workspace.create({
        data: {
          name: `${name}'s Workspace`,
          type: 'PERSONAL',
          members: {
            create: {
              userId: newUser.id,
              role: 'OWNER',
              canCreateCanvas: true,
              canDeleteCanvas: true,
              canManageBilling: true,
              canInviteMembers: true,
              canManageMembers: true,
              canManageApiKeys: true,
            },
          },
        },
      });

      return newUser;
    });

    const verificationUrl = `${this.configService.get('FRONTEND_URL')}/auth/verify-email?token=${verificationToken}`;
    await this.emailService.sendEmail({
      to: user.email,
      subject: 'Verify your Actopod account',
      bodyHtml: verifyEmailTemplate(user.name || 'there', verificationUrl),
    });

    this.logger.log(`User registered: ${user.email}`);

    return {
      message: 'Registration successful. Please check your email to verify your account.',
      userId: user.id,
    };
  }

  async verifyEmail(token: string): Promise<{ message: string }> {
    const tokenHash = createHash('sha256').update(token).digest('hex');

    const account = await this.prisma.account.findFirst({
      where: {
        accessToken: tokenHash,
        provider: AuthProvider.EMAIL,
        expiresAt: { gte: new Date() },
      },
      include: { user: true },
    });

    if (!account) {
      throw new BadRequestException('Invalid or expired verification token');
    }

    await this.prisma.account.update({
      where: { id: account.id },
      data: { accessToken: null, expiresAt: null },
    });

    await this.emailService.sendEmail({
      to: account.user.email,
      subject: 'Welcome to Actopod!',
      bodyHtml: welcomeEmailTemplate(account.user.name || 'there'),
    });

    this.logger.log(`Email verified: ${account.user.email}`);
    return { message: 'Email verified successfully. You can now log in.' };
  }

  async resendVerificationEmail(email: string): Promise<{ message: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
      include: { accounts: { where: { provider: AuthProvider.EMAIL } } },
    });

    if (!user) {
      this.logger.warn(`Verification resend requested for non-existent user: ${normalizedEmail}`);
      return {
        message: 'If the email exists and is not verified, a verification link has been sent',
      };
    }

    const emailAccount = user.accounts[0];
    if (emailAccount && !emailAccount.accessToken) {
      return { message: 'Email is already verified' };
    }

    if (emailAccount?.expiresAt && emailAccount.expiresAt > new Date()) {
      const timeSinceLastSent = Date.now() - emailAccount.createdAt.getTime();
      if (timeSinceLastSent < 60 * 1000) {
        throw new BadRequestException('Please wait before requesting another verification email');
      }
    }

    const verificationToken = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(verificationToken).digest('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        accessToken: tokenHash,
        expiresAt,
      },
      update: { accessToken: tokenHash, expiresAt },
    });

    const verificationUrl = `${this.configService.get('FRONTEND_URL')}/auth/verify-email?token=${verificationToken}`;
    await this.emailService.sendEmail({
      to: user.email,
      subject: 'Verify your Actopod account',
      bodyHtml: verifyEmailTemplate(user.name || 'there', verificationUrl),
    });

    this.logger.log(`Verification email resent to: ${user.email}`);
    return {
      message: 'If the email exists and is not verified, a verification link has been sent',
    };
  }

  async checkEmailVerifiedStatus(userId: string): Promise<{ isVerified: boolean; email: string }> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: { accounts: { where: { provider: AuthProvider.EMAIL } } },
    });

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    const emailAccount = user.accounts[0];
    const isVerified = !emailAccount || !emailAccount.accessToken;

    return { isVerified, email: user.email };
  }

  async login(email: string, password: string, deviceName: string): Promise<AuthUserType> {
    const normalizedEmail = email.toLowerCase().trim();

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user || !user.hash) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, user.hash);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Check if user already has a token for this device
    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: user.id, deviceName: deviceName },
    });

    this.logger.log(`User logged in: ${user.email}`);

    return this.generateTokens(user.id, user.email, deviceName, existingToken?.id);
  }

  async forgotPassword(email: string): Promise<{ message: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user || !user.hash) {
      return { message: 'If the email exists, a password reset link has been sent' };
    }

    const resetToken = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(resetToken).digest('hex');
    const expiresAt = new Date(Date.now() + this.RESET_PASSWORD_EXPIRY);

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        refreshToken: tokenHash,
        expiresAt,
      },
      update: { refreshToken: tokenHash, expiresAt },
    });

    const resetUrl = `${this.configService.get('FRONTEND_URL')}/auth/reset-password?token=${resetToken}`;
    await this.emailService.sendEmail({
      to: user.email,
      subject: 'Reset your Actopod password',
      bodyHtml: resetPasswordTemplate(user.name || 'there', resetUrl),
    });

    this.logger.log(`Password reset requested: ${user.email}`);
    return { message: 'If the email exists, a password reset link has been sent' };
  }

  async resetPassword(token: string, newPassword: string): Promise<{ message: string }> {
    const tokenHash = createHash('sha256').update(token).digest('hex');

    const account = await this.prisma.account.findFirst({
      where: {
        refreshToken: tokenHash,
        provider: AuthProvider.EMAIL,
        expiresAt: { gte: new Date() },
      },
      include: { user: true },
    });

    if (!account) {
      throw new BadRequestException('Invalid or expired reset token');
    }

    const hash = await bcrypt.hash(newPassword, 10);

    await this.prisma.$transaction([
      this.prisma.user.update({
        where: { id: account.userId },
        data: { hash },
      }),
      this.prisma.account.update({
        where: { id: account.id },
        data: { refreshToken: null, expiresAt: null },
      }),
      this.prisma.refreshToken.deleteMany({
        where: { userId: account.userId },
      }),
    ]);

    this.logger.log(`Password reset: ${account.user.email}`);
    return { message: 'Password reset successfully. You can now log in with your new password.' };
  }

  // ============================================
  // MAGIC LINK AUTHENTICATION
  // ============================================

  async sendMagicLink(
    email: string,
    deviceName: string,
    ipAddress: string,
  ): Promise<{ message: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const recentAttempts = await this.prisma.account.count({
      where: {
        user: { email: normalizedEmail },
        provider: AuthProvider.EMAIL,
        createdAt: { gte: new Date(Date.now() - this.ATTEMPT_WINDOW) },
      },
    });

    if (recentAttempts >= this.MAX_ATTEMPTS) {
      throw new BadRequestException('Too many login attempts. Please try again in 1 hour.');
    }

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      this.logger.warn(`Magic link requested for non-existent user: ${normalizedEmail}`);
      return { message: 'If the email exists, a magic link has been sent' };
    }

    const token = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(token).digest('hex');
    const expiresAt = new Date(Date.now() + this.MAGIC_LINK_EXPIRY);

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        accessToken: tokenHash,
        refreshToken: JSON.stringify({ deviceName, ipAddress }),
        expiresAt,
      },
      update: {
        accessToken: tokenHash,
        refreshToken: JSON.stringify({ deviceName, ipAddress }),
        expiresAt,
      },
    });

    const magicUrl = `${this.configService.get('FRONTEND_URL')}/auth/verify-magic-link?token=${token}&email=${encodeURIComponent(normalizedEmail)}`;

    await this.emailService.sendEmail({
      to: user.email,
      subject: 'ðŸ” Sign in to Actopod',
      bodyHtml: magicLinkTemplate(
        user.name || 'there',
        magicUrl,
        '15 minutes',
        ipAddress,
        deviceName,
      ),
    });

    this.logger.log(`Magic link sent to: ${normalizedEmail}`);
    return { message: 'If the email exists, a magic link has been sent' };
  }

  async verifyMagicLink(
    token: string,
    email: string,
    deviceName: string,
    _ipAddress: string,
  ): Promise<AuthUserType> {
    const normalizedEmail = email.toLowerCase().trim();
    const tokenHash = createHash('sha256').update(token).digest('hex');

    const account = await this.prisma.account.findFirst({
      where: {
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        accessToken: tokenHash,
        expiresAt: { gte: new Date() },
      },
      include: { user: true },
    });

    if (!account) {
      this.logger.warn(`Invalid or expired magic link: ${normalizedEmail}`);
      throw new UnauthorizedException('Invalid or expired magic link');
    }

    try {
      const metadata = JSON.parse(account.refreshToken || '{}');
      if (metadata.ipAddress !== _ipAddress) {
        this.logger.warn(`IP mismatch for magic link: ${normalizedEmail}`);
      }
    } catch {
      /* empty */
    }

    await this.prisma.account.update({
      where: { id: account.id },
      data: { accessToken: null, refreshToken: null, expiresAt: null },
    });

    this.logger.log(`Magic link verified: ${normalizedEmail}`);

    // Check for existing device
    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: account.user.id, deviceName: deviceName },
    });

    return this.generateTokens(account.user.id, account.user.email, deviceName, existingToken?.id);
  }

  // ============================================
  // OAUTH AUTHENTICATION
  // ============================================

  async validateGoogleUser(data: GoogleUserData): Promise<AuthUserType> {
    const { email, firstName, lastName, googleId, picture, deviceName } = data;

    let user = await this.prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (!user) {
      user = await this.prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            email: email.toLowerCase(),
            name: `${firstName} ${lastName}`.trim(),
            image: picture,
            hash: null,
          },
        });

        await tx.workspace.create({
          data: {
            name: `${newUser.name}'s Workspace`,
            type: 'PERSONAL',
            members: {
              create: {
                userId: newUser.id,
                role: 'OWNER',
                canCreateCanvas: true,
                canDeleteCanvas: true,
                canManageBilling: true,
                canInviteMembers: true,
                canManageMembers: true,
                canManageApiKeys: true,
              },
            },
          },
        });

        this.logger.log(`New user created via Google: ${newUser.email}`);
        return newUser;
      });
    }

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.GOOGLE,
          providerAccountId: googleId,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.GOOGLE,
        providerAccountId: googleId,
      },
      update: {},
    });

    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: user.id, deviceName: deviceName },
    });

    return this.generateTokens(user.id, user.email, deviceName, existingToken?.id);
  }

  async validateGitHubUser(data: GitHubUserData): Promise<AuthUserType> {
    const { email, name, githubId, avatarUrl, deviceName } = data;

    let user = await this.prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (!user) {
      user = await this.prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            email: email.toLowerCase(),
            name,
            image: avatarUrl,
            hash: null,
          },
        });

        await tx.workspace.create({
          data: {
            name: `${newUser.name}'s Workspace`,
            type: 'PERSONAL',
            members: {
              create: {
                userId: newUser.id,
                role: 'OWNER',
                canCreateCanvas: true,
                canDeleteCanvas: true,
                canManageBilling: true,
                canInviteMembers: true,
                canManageMembers: true,
                canManageApiKeys: true,
              },
            },
          },
        });

        this.logger.log(`New user created via GitHub: ${newUser.email}`);
        return newUser;
      });
    }

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.GITHUB,
          providerAccountId: githubId,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.GITHUB,
        providerAccountId: githubId,
      },
      update: {},
    });

    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: user.id, deviceName: deviceName },
    });

    return this.generateTokens(user.id, user.email, deviceName, existingToken?.id);
  }

  // ============================================
  // TOKEN MANAGEMENT
  // ============================================

  async refreshTokens(refreshToken: string, deviceId: string): Promise<AuthUserType> {
    const storedToken = await this.prisma.refreshToken.findUnique({
      where: { token: refreshToken },
      include: { user: true },
    });

    if (!storedToken || storedToken.expiresAt < new Date() || storedToken.id !== deviceId) {
      throw new UnauthorizedException('Invalid or expired refresh token');
    }

    const deviceName = storedToken.deviceName;

    return this.generateTokens(storedToken.user.id, storedToken.user.email, deviceName, deviceId);
  }

  async logout(userId: string, deviceId: string): Promise<{ message: string }> {
    await this.prisma.refreshToken.deleteMany({
      where: { userId, id: deviceId },
    });

    this.logger.log(`User logged out: ${userId} from device: ${deviceId}`);
    return { message: 'Logged out successfully' };
  }

  async logoutAllDevices(userId: string): Promise<{ message: string }> {
    await this.prisma.refreshToken.deleteMany({
      where: { userId },
    });

    this.logger.log(`User logged out from all devices: ${userId}`);
    return { message: 'Logged out from all devices' };
  }

  // ============================================
  // PRIVATE HELPERS
  // ============================================

  private async generateTokens(
    userId: string,
    email: string,
    deviceName: string,
    existingTokenId?: string,
  ): Promise<AuthUserType> {
    const payload: JwtPayload = { userId, email };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(payload, {
        secret: this.configService.get('JWT_ACCESS_TOKEN_SECRET'),
        expiresIn: this.configService.get('JWT_ACCESS_TOKEN_EXPIRATION'),
      }),
      this.jwtService.signAsync(payload, {
        secret: this.configService.get('JWT_REFRESH_TOKEN_SECRET'),
        expiresIn: this.configService.get('JWT_REFRESH_TOKEN_EXPIRATION'),
      }),
    ]);

    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    let tokenRecord;

    if (existingTokenId) {
      // UPDATE existing record (keeps same ID)
      tokenRecord = await this.prisma.refreshToken.update({
        where: { id: existingTokenId },
        data: {
          token: refreshToken,
          expiresAt,
          deviceName: deviceName,
        },
      });
    } else {
      // CREATE new record
      tokenRecord = await this.prisma.refreshToken.create({
        data: {
          userId,
          deviceName: deviceName, // Store deviceName in deviceId column
          token: refreshToken,
          expiresAt,
        },
      });
    }

    return {
      userId,
      email,
      accessToken,
      refreshToken,
      deviceId: tokenRecord.id, // Database CUID
      deviceName: deviceName, // Human-readable name
    };
  }
}

```

### `apps\backend\src\v1\auth\dto\forgot-password.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty } from 'class-validator';

export class ForgotPasswordDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'Email address to send password reset link',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;
}

```

### `apps\backend\src\v1\auth\dto\login.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'User email address',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;

  @ApiProperty({
    example: 'Password123!',
    description: 'User password',
    required: true,
  })
  @IsString({ message: 'Password must be a string' })
  @IsNotEmpty({ message: 'Password is required' })
  password!: string;
}

```

### `apps\backend\src\v1\auth\dto\magic-link.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class SendMagicLinkDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'Email address to send magic link',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;
}

export class VerifyMagicLinkDto {
  @ApiProperty({
    description: 'Magic link token from email',
    required: true,
  })
  @IsString({ message: 'Token must be a string' })
  @IsNotEmpty({ message: 'Token is required' })
  token!: string;

  @ApiProperty({
    example: 'john@example.com',
    description: 'Email address associated with the magic link',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;
}

```

### `apps\backend\src\v1\auth\dto\refresh-token.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty, IsOptional } from 'class-validator';

export class RefreshTokenDto {
  @ApiProperty({
    description: 'Refresh token to get new access token',
    required: true,
  })
  @IsString({ message: 'Refresh token must be a string' })
  @IsNotEmpty({ message: 'Refresh token is required' })
  refreshToken!: string;

  @ApiProperty({
    description: 'Device ID for session management',
    required: false,
  })
  @IsString({ message: 'Device ID must be a string' })
  @IsOptional()
  deviceId?: string;
}

```

### `apps\backend\src\v1\auth\dto\register.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString, MinLength, Matches } from 'class-validator';

export class RegisterDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'User email address',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;

  @ApiProperty({
    example: 'John Doe',
    description: 'Full name',
    required: true,
  })
  @IsString({ message: 'Name must be a string' })
  @IsNotEmpty({ message: 'Name is required' })
  name!: string;

  @ApiProperty({
    example: 'Password123!',
    description:
      'Password must contain at least 8 characters, one uppercase, one lowercase, one number and one special character',
    required: true,
    minLength: 8,
  })
  @IsString({ message: 'Password must be a string' })
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message:
      'Password must contain at least one uppercase letter, one lowercase letter, one number and one special character',
  })
  @IsNotEmpty({ message: 'Password is required' })
  password!: string;
}

```

### `apps\backend\src\v1\auth\dto\reset-password.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty, MinLength, Matches } from 'class-validator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'Password reset token from email',
    required: true,
  })
  @IsString({ message: 'Token must be a string' })
  @IsNotEmpty({ message: 'Token is required' })
  token!: string;

  @ApiProperty({
    example: 'NewPassword123!',
    description:
      'New password (min 8 chars, must include uppercase, lowercase, number, special char)',
    required: true,
    minLength: 8,
  })
  @IsString({ message: 'Password must be a string' })
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message:
      'Password must contain at least one uppercase letter, one lowercase letter, one number and one special character',
  })
  @IsNotEmpty({ message: 'Password is required' })
  newPassword!: string;
}

```

### `apps\backend\src\v1\auth\dto\verify-email.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty } from 'class-validator';

export class VerifyEmailDto {
  @ApiProperty({
    description: 'Email verification token from email',
    required: true,
  })
  @IsString({ message: 'Token must be a string' })
  @IsNotEmpty({ message: 'Token is required' })
  token!: string;
}

```

### `apps\backend\src\v1\auth\strategies\access-token.strategy.ts`

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../../prisma/prisma.service';
import { JwtPayload } from '../types';

@Injectable()
export class AccessTokenStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_ACCESS_TOKEN_SECRET') || '',
    });
  }

  async validate(payload: JwtPayload) {
    const user = await this.prisma.user.findUnique({
      where: { id: payload.userId },
    });

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    return { userId: user.id, email: user.email };
  }
}

```

### `apps\backend\src\v1\auth\strategies\github.strategy.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, Profile, StrategyOptionsWithRequest } from 'passport-github2';
import { ConfigService } from '@nestjs/config';
import { V1AuthService } from '../auth.service';
import { Request } from 'express';
import { UAParser } from 'ua-parser-js';

@Injectable()
export class GitHubStrategy extends PassportStrategy(Strategy, 'github') {
  private readonly logger = new Logger(GitHubStrategy.name);

  constructor(
    private readonly configService: ConfigService,
    private readonly authService: V1AuthService,
  ) {
    const options: StrategyOptionsWithRequest = {
      clientID: configService.get<string>('GITHUB_CLIENT_ID') || '',
      clientSecret: configService.get<string>('GITHUB_CLIENT_SECRET') || '',
      callbackURL: configService.get<string>('GITHUB_CALLBACK_URL') || '',
      scope: ['user:email'],
      passReqToCallback: true,
    };
    super(options);
  }

  async validate(
    req: Request,
    accessToken: string,
    refreshToken: string,
    profile: Profile,
    done: (error: any, user?: any) => void,
  ): Promise<void> {
    try {
      const uaString = req.headers['user-agent'] || '';
      const parser = new UAParser(uaString);
      const os = parser.getOS().name || 'Unknown OS';
      const browser = parser.getBrowser().name || 'Unknown Browser';
      const deviceName = `${os} â€“ ${browser}`;

      const email = profile.emails?.[0]?.value || '';
      const name = profile.displayName || profile.username || '';
      const avatarUrl = profile.photos?.[0]?.value || '';
      const githubId = profile.id;

      this.logger.log(`GitHub OAuth: ${email}`);

      const user = await this.authService.validateGitHubUser({
        email,
        name,
        githubId,
        avatarUrl,
        deviceName,
      });

      done(null, user);
    } catch (error: any) {
      this.logger.error('Error in GitHubStrategy.validate()', error?.stack || error);
      done(error, false); // Use false instead of null
    }
  }
}

```

### `apps\backend\src\v1\auth\strategies\google.strategy.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import {
  Strategy,
  Profile,
  VerifyCallback,
  StrategyOptionsWithRequest,
} from 'passport-google-oauth20';
import { ConfigService } from '@nestjs/config';
import { V1AuthService } from '../auth.service';
import { Request } from 'express';
import { UAParser } from 'ua-parser-js';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  private readonly logger = new Logger(GoogleStrategy.name);

  constructor(
    private readonly configService: ConfigService,
    private readonly authService: V1AuthService,
  ) {
    const options: StrategyOptionsWithRequest = {
      clientID: configService.get<string>('GOOGLE_CLIENT_ID') || '',
      clientSecret: configService.get<string>('GOOGLE_CLIENT_SECRET') || '',
      callbackURL: configService.get<string>('GOOGLE_CALLBACK_URL') || '',
      scope: ['email', 'profile'],
      passReqToCallback: true,
    };
    super(options);
  }

  async validate(
    req: Request,
    accessToken: string,
    refreshToken: string,
    profile: Profile,
    done: VerifyCallback,
  ): Promise<void> {
    try {
      const uaString = req.headers['user-agent'] || '';
      const parser = new UAParser(uaString);
      const os = parser.getOS().name || 'Unknown OS';
      const browser = parser.getBrowser().name || 'Unknown Browser';
      const deviceName = `${os} â€“ ${browser}`;

      const email = profile.emails?.[0]?.value || '';
      const firstName = profile.name?.givenName || '';
      const lastName = profile.name?.familyName || '';
      const picture = profile.photos?.[0]?.value || '';
      const googleId = profile.id;

      this.logger.log(`Google OAuth: ${email}`);

      const user = await this.authService.validateGoogleUser({
        email,
        firstName,
        lastName,
        googleId,
        picture,
        deviceName,
      });

      done(null, user);
    } catch (error: any) {
      this.logger.error('Error in GoogleStrategy.validate()', error?.stack || error);
      done(error, false); // Use false instead of null
    }
  }
}

```

### `apps\backend\src\v1\auth\strategies\refresh-token.strategy.ts`

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy, StrategyOptionsWithRequest } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { JwtPayload } from '../types';
import { Request } from 'express';

@Injectable()
export class RefreshTokenStrategy extends PassportStrategy(Strategy, 'jwt-refresh') {
  constructor(configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_REFRESH_TOKEN_SECRET') || '',
      passReqToCallback: true,
    } as StrategyOptionsWithRequest);
  }

  async validate(req: Request, payload: JwtPayload) {
    const authHeader = req.headers['authorization'];
    if (!authHeader) {
      throw new UnauthorizedException('No authorization header');
    }

    const [scheme, token] = authHeader.split(' ');
    if (scheme !== 'Bearer' || !token) {
      throw new UnauthorizedException('Malformed authorization header');
    }

    const deviceId = req.body.deviceId ?? req.query.deviceId ?? req.headers['x-device-id'];
    if (!deviceId) {
      throw new UnauthorizedException('Device ID is missing');
    }

    return {
      userId: payload.userId,
      email: payload.email,
      refreshToken: token,
      deviceId: deviceId as string,
    };
  }
}

```

### `apps\backend\src\v1\auth\types\index.ts`

```typescript
export interface JwtPayload {
  userId: string;
  email: string;
}

export interface JwtPayloadWithRt extends JwtPayload {
  refreshToken: string;
  deviceId: string;
}

export interface AuthUserType {
  userId: string;
  email: string;
  accessToken: string;
  refreshToken: string;
  deviceId: string;
  deviceName: string;
}

export interface GoogleUserData {
  email: string;
  firstName: string;
  lastName: string;
  googleId: string;
  picture?: string;
  deviceName: string;
}

export interface GitHubUserData {
  email: string;
  name: string;
  githubId: string;
  avatarUrl?: string;
  deviceName: string;
}

export interface MagicLinkData {
  email: string;
  token: string;
  expiresAt: Date;
  deviceName: string;
  ipAddress: string;
}

```

### `apps\backend\src\v1\execution\context-resolution.service.ts`

```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PodType } from '@actopod/schema';
import { PrismaService } from '../../prisma/prisma.service';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';

export interface ResolvedContext {
  podId: string;
  output: string;
  executionId?: string;
  timestamp: Date;
}

export interface ContextChain {
  pod: {
    id: string;
    type: PodType;
  };
  context: ResolvedContext[];
  variables: Record<string, string>;
}

@Injectable()
export class V1ContextResolutionService {
  private readonly logger = new Logger(V1ContextResolutionService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
  ) {}

  /**
   * Resolve all context for a pod execution
   */
  async resolveContext(podId: string, flowId: string): Promise<ContextChain> {
    const pod = await this.prisma.pod.findUnique({
      where: { id: podId },
      select: {
        id: true,
        type: true,
      },
    });

    if (!pod) {
      throw new NotFoundException(`Pod ${podId} not found`);
    }

    const upstreamEdges = await this.prisma.edge.findMany({
      where: {
        flowId,
        targetPodId: podId,
      },
      select: {
        sourcePodId: true,
      },
    });

    if (upstreamEdges.length === 0) {
      this.logger.debug(`Pod ${podId} has no upstream dependencies`);
      return {
        pod,
        context: [],
        variables: {},
      };
    }

    const upstreamPodIds = upstreamEdges.map((e: { sourcePodId: string }) => e.sourcePodId);

    const contextPromises = upstreamPodIds.map((upstreamPodId: string) => {
      return this.getLatestPodOutput(upstreamPodId);
    });

    const resolvedContexts = await Promise.all(contextPromises);
    const validContexts = resolvedContexts.filter(
      (c: ResolvedContext | null): c is ResolvedContext => c !== null,
    );

    const variables: Record<string, string> = {};
    for (const ctx of validContexts) {
      variables[ctx.podId] = ctx.output;
    }

    this.logger.debug(`Resolved ${validContexts.length} context items for pod ${podId}`);

    return {
      pod,
      context: validContexts,
      variables,
    };
  }

  /**
   * Resolve context with support for pinned executions
   */
  async resolveContextWithPins(
    podId: string,
    flowId: string,
    contextMappings?: Array<{ sourcePodId: string; pinnedExecutionId: string | null }>,
  ): Promise<ContextChain> {
    const pod = await this.prisma.pod.findUnique({
      where: { id: podId },
      select: {
        id: true,
        type: true,
      },
    });

    if (!pod) {
      throw new NotFoundException(`Pod ${podId} not found`);
    }

    const upstreamEdges = await this.prisma.edge.findMany({
      where: {
        flowId,
        targetPodId: podId,
      },
      select: {
        sourcePodId: true,
      },
    });

    if (upstreamEdges.length === 0) {
      this.logger.debug(`Pod ${podId} has no upstream dependencies`);
      return {
        pod,
        context: [],
        variables: {},
      };
    }

    const upstreamPodIds = upstreamEdges.map((e: { sourcePodId: string }) => e.sourcePodId);

    // Build mapping of pod â†’ execution ID
    const executionMap = new Map<string, string | null>();
    if (contextMappings) {
      for (const mapping of contextMappings) {
        executionMap.set(mapping.sourcePodId, mapping.pinnedExecutionId);
      }
    }

    const contextPromises = upstreamPodIds.map((upstreamPodId: string) => {
      const pinnedExecutionId = executionMap.get(upstreamPodId);

      if (pinnedExecutionId) {
        // Use specific pinned execution
        return this.getPinnedPodOutput(upstreamPodId, pinnedExecutionId);
      } else {
        // Use latest execution (default behavior)
        return this.getLatestPodOutput(upstreamPodId);
      }
    });

    const resolvedContexts = await Promise.all(contextPromises);
    const validContexts = resolvedContexts.filter(
      (c: ResolvedContext | null): c is ResolvedContext => c !== null,
    );

    const variables: Record<string, string> = {};
    for (const ctx of validContexts) {
      variables[ctx.podId] = ctx.output;
    }

    this.logger.debug(
      `Resolved ${validContexts.length} context items for pod ${podId} (${contextMappings?.length || 0} pinned)`,
    );

    return {
      pod,
      context: validContexts,
      variables,
    };
  }

  /**
   * Get specific pinned execution output
   */
  private async getPinnedPodOutput(
    podId: string,
    executionId: string,
  ): Promise<ResolvedContext | null> {
    const execution = await this.prisma.podExecution.findFirst({
      where: {
        id: executionId,
        podId,
        status: 'COMPLETED',
      },
      select: {
        id: true,
        responseMetadata: true,
        finishedAt: true,
      },
    });

    if (!execution || !execution.responseMetadata) {
      this.logger.warn(`Pinned execution ${executionId} not found or incomplete for pod ${podId}`);
      return null;
    }

    const output = this.extractOutputFromResponse(execution.responseMetadata);

    if (!output) {
      this.logger.warn(`Could not extract output from pinned execution ${executionId}`);
      return null;
    }

    return {
      podId,
      output,
      executionId: execution.id,
      timestamp: execution.finishedAt!,
    };
  }

  /**
   * Get latest execution output for a pod
   */
  private async getLatestPodOutput(podId: string): Promise<ResolvedContext | null> {
    const latestExecution = await this.prisma.podExecution.findFirst({
      where: {
        podId,
        status: 'COMPLETED',
      },
      orderBy: {
        finishedAt: 'desc',
      },
      select: {
        id: true,
        responseMetadata: true,
        finishedAt: true,
      },
      take: 1,
    });

    if (!latestExecution || !latestExecution.responseMetadata) {
      this.logger.warn(`No completed execution found for pod ${podId}`);
      return null;
    }

    const output = this.extractOutputFromResponse(latestExecution.responseMetadata);

    if (!output) {
      this.logger.warn(`Could not extract output from execution ${latestExecution.id}`);
      return null;
    }

    return {
      podId,
      output,
      executionId: latestExecution.id,
      timestamp: latestExecution.finishedAt!,
    };
  }

  /**
   * Extract text output from LLM response metadata
   */
  private extractOutputFromResponse(responseMetadata: any): string | null {
    try {
      // OpenAI format
      if (responseMetadata.choices && responseMetadata.choices[0]) {
        return responseMetadata.choices[0].message.content;
      }

      // Anthropic format
      if (responseMetadata.content && Array.isArray(responseMetadata.content)) {
        const textBlocks = responseMetadata.content.filter((block: any) => block.type === 'text');
        return textBlocks.map((block: any) => block.text).join('\n');
      }

      // Gemini format
      if (responseMetadata.candidates && responseMetadata.candidates[0]) {
        const parts = responseMetadata.candidates[0].content.parts;
        return parts.map((p: any) => p.text).join('\n');
      }

      return null;
    } catch (error) {
      this.logger.error('Failed to extract output from response', error);
      return null;
    }
  }

  /**
   * Interpolate variables in a string
   */
  interpolateVariables(text: string, variables: Record<string, string>): string {
    let result = text;

    const variableRegex = /\{\{([a-zA-Z0-9_-]+)(?:\.output)?\}\}/g;

    result = result.replace(variableRegex, (match, podId) => {
      const value = variables[podId];
      if (value === undefined) {
        this.logger.warn(`Variable ${podId} not found in context`);
        return match;
      }
      return value;
    });

    return result;
  }

  /**
   * Get execution order for all pods in a flow (topological sort)
   */
  async getExecutionOrder(flowId: string): Promise<string[]> {
    const pods = await this.prisma.pod.findMany({
      where: { flowId },
      select: { id: true },
    });

    const edges = await this.prisma.edge.findMany({
      where: { flowId },
      select: {
        sourcePodId: true,
        targetPodId: true,
      },
    });

    const graph = new Map<string, string[]>();
    const inDegree = new Map<string, number>();

    for (const pod of pods) {
      graph.set(pod.id, []);
      inDegree.set(pod.id, 0);
    }

    for (const edge of edges) {
      graph.get(edge.sourcePodId)!.push(edge.targetPodId);
      inDegree.set(edge.targetPodId, (inDegree.get(edge.targetPodId) || 0) + 1);
    }

    const queue: string[] = [];
    const result: string[] = [];

    for (const [podId, degree] of inDegree.entries()) {
      if (degree === 0) {
        queue.push(podId);
      }
    }

    while (queue.length > 0) {
      const current = queue.shift()!;
      result.push(current);

      for (const neighbor of graph.get(current) || []) {
        inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
        if (inDegree.get(neighbor) === 0) {
          queue.push(neighbor);
        }
      }
    }

    if (result.length !== pods.length) {
      throw new Error(`Circular dependency detected in flow ${flowId}`);
    }

    return result;
  }
}

```

### `apps\backend\src\v1\execution\dto\execute-pod.dto.ts`

```typescript
// dto/execute-pod.dto.ts

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsString,
  IsEnum,
  IsArray,
  IsOptional,
  IsNumber,
  ValidateNested,
  IsIn,
  Min,
  Max,
} from 'class-validator';
import { Type } from 'class-transformer';
import { LLMProvider } from '@actopod/schema';

export class LLMMessageDto {
  @ApiProperty({
    description: 'Role of the message sender',
    enum: ['system', 'user', 'assistant'],
    example: 'user',
  })
  @IsIn(['system', 'user', 'assistant'])
  role!: 'system' | 'user' | 'assistant';

  @ApiProperty({
    description: 'Content of the message',
    example: 'Explain quantum computing in simple terms',
  })
  @IsString()
  content!: string;
}

export class ExecutePodDto {
  @ApiProperty({
    description: 'ID of the pod to execute',
    example: 'pod_1234567890_abc123',
  })
  @IsString()
  podId!: string;

  @ApiProperty({
    description: 'Messages to send to the LLM',
    type: [LLMMessageDto],
    example: [{ role: 'user', content: 'Hello!' }],
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => LLMMessageDto)
  messages!: LLMMessageDto[];

  // Runtime overrides (all optional)
  @ApiPropertyOptional({
    description: 'Override pod provider',
    enum: LLMProvider,
    example: LLMProvider.OPENAI,
  })
  @IsOptional()
  @IsEnum(LLMProvider)
  provider?: LLMProvider;

  @ApiPropertyOptional({
    description: 'Override pod model',
    example: 'gpt-4o',
  })
  @IsOptional()
  @IsString()
  model?: string;

  @ApiPropertyOptional({
    description: 'Override system prompt (overrides pod configuration)',
    example: 'You are an expert in quantum physics',
  })
  @IsOptional()
  @IsString()
  systemPrompt?: string;

  @ApiPropertyOptional({
    description: 'Override sampling temperature (0-2)',
    minimum: 0,
    maximum: 2,
    example: 0.7,
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(2)
  temperature?: number;

  @ApiPropertyOptional({
    description: 'Override maximum tokens to generate',
    minimum: 1,
    maximum: 128000000,
    example: 2048,
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(128000000)
  maxTokens?: number;

  @ApiPropertyOptional({
    description: 'Override top-p nucleus sampling (0-1)',
    minimum: 0,
    maximum: 1,
    example: 0.9,
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(1)
  topP?: number;

  @ApiPropertyOptional({
    description: 'Override presence penalty (-2 to 2)',
    minimum: -2,
    maximum: 2,
    example: 0,
  })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  presencePenalty?: number;

  @ApiPropertyOptional({
    description: 'Override frequency penalty (-2 to 2)',
    minimum: -2,
    maximum: 2,
    example: 0,
  })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  frequencyPenalty?: number;

  @ApiPropertyOptional({
    description: 'Override thinking budget for reasoning models',
    minimum: 1000,
    maximum: 128000000,
    example: 10000,
  })
  @IsOptional()
  @IsNumber()
  @Min(1000)
  @Max(128000000)
  thinkingBudget?: number;

  @ApiPropertyOptional({
    description: 'Override response format',
    enum: ['text', 'json_object', 'json'],
    example: 'text',
  })
  @IsOptional()
  @IsIn(['text', 'json_object', 'json'])
  responseFormat?: 'text' | 'json_object' | 'json';
}

```

### `apps\backend\src\v1\execution\dto\execution-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { Expose } from 'class-transformer';
import { PodExecutionStatus, LLMProvider } from '@actopod/schema';

export class ExecutionUsageDto {
  @ApiProperty({ description: 'Prompt (input) tokens used', example: 150 })
  @Expose()
  promptTokens!: number;

  @ApiProperty({ description: 'Completion (output) tokens generated', example: 450 })
  @Expose()
  completionTokens!: number;

  @ApiProperty({ description: 'Total tokens used', example: 600 })
  @Expose()
  totalTokens!: number;

  @ApiProperty({
    description: 'Reasoning tokens (for o-series models)',
    required: false,
    example: 200,
  })
  @Expose()
  reasoningTokens?: number;

  @ApiProperty({ description: 'Cached input tokens (cost savings)', required: false, example: 100 })
  @Expose()
  cachedTokens?: number;
}

export class ExecutionCostDto {
  @ApiProperty({ description: 'Input cost in USD', example: 0.000375 })
  @Expose()
  inputCost!: number;

  @ApiProperty({ description: 'Output cost in USD', example: 0.0045 })
  @Expose()
  outputCost!: number;

  @ApiProperty({ description: 'Reasoning cost in USD', example: 0.0012 })
  @Expose()
  reasoningCost!: number;

  @ApiProperty({ description: 'Total cost in USD', example: 0.005975 })
  @Expose()
  totalCost!: number;
}

export class ExecutionResultDto {
  @ApiProperty({ description: 'Unique execution ID', example: 'exec_cm2abc123' })
  @Expose()
  executionId!: string;

  @ApiProperty({ description: 'Generated content from LLM', example: 'Quantum computing uses...' })
  @Expose()
  content!: string;

  @ApiProperty({ description: 'Token usage breakdown', type: ExecutionUsageDto })
  @Expose()
  usage!: ExecutionUsageDto;

  @ApiProperty({ description: 'Cost breakdown in USD', type: ExecutionCostDto })
  @Expose()
  cost!: ExecutionCostDto;
}

export class ExecutionHistoryItemDto {
  @ApiProperty({ description: 'Execution ID', example: 'exec_cm2abc123' })
  @Expose()
  id!: string;

  @ApiProperty({ description: 'Pod ID', example: 'pod_1234567890_abc123' })
  @Expose()
  podId!: string;

  @ApiProperty({ description: 'Execution status', enum: PodExecutionStatus, example: 'COMPLETED' })
  @Expose()
  status!: PodExecutionStatus;

  @ApiProperty({ description: 'LLM provider used', enum: LLMProvider, example: 'OPENAI' })
  @Expose()
  provider!: LLMProvider;

  @ApiProperty({ description: 'Model ID', example: 'gpt-4o' })
  @Expose()
  modelId!: string;

  @ApiProperty({ description: 'Model name returned by provider', example: 'gpt-4o-2024-05-13' })
  @Expose()
  modelName!: string | null;

  @ApiProperty({ description: 'Input tokens used', example: 150 })
  @Expose()
  inputTokens!: number;

  @ApiProperty({ description: 'Output tokens generated', example: 450 })
  @Expose()
  outputTokens!: number;

  @ApiProperty({ description: 'Reasoning tokens (o-series)', example: 0 })
  @Expose()
  reasoningTokens!: number;

  @ApiProperty({ description: 'Total cost in USD', example: '0.005975', required: false })
  @Expose()
  costInUsd!: string | null;

  @ApiProperty({ description: 'Execution start timestamp', example: '2025-10-24T18:00:00.000Z' })
  @Expose()
  startedAt!: Date;

  @ApiProperty({ description: 'Execution finish timestamp', example: '2025-10-24T18:00:05.000Z' })
  @Expose()
  finishedAt!: Date | null;

  @ApiProperty({ description: 'Runtime in milliseconds', example: 5432 })
  @Expose()
  runtimeInMs!: number | null;

  @ApiProperty({ description: 'Error message if failed', required: false })
  @Expose()
  errorMessage!: string | null;

  @ApiProperty({ description: 'Error code if failed', required: false })
  @Expose()
  errorCode!: string | null;
}

export class ExecutionDetailDto {
  @ApiProperty({ description: 'Execution ID', example: 'exec_cm2abc123' })
  @Expose()
  id!: string;

  @ApiProperty({ description: 'Pod details' })
  @Expose()
  pod!: {
    id: string;
    type: string;
    flowId: string;
  };

  @ApiProperty({ description: 'Execution status', enum: PodExecutionStatus })
  @Expose()
  status!: PodExecutionStatus;

  @ApiProperty({ description: 'LLM provider', enum: LLMProvider })
  @Expose()
  provider!: LLMProvider;

  @ApiProperty({ description: 'Model used' })
  @Expose()
  modelId!: string;

  @ApiProperty({ description: 'Token counts' })
  @Expose()
  inputTokens!: number;

  @Expose()
  outputTokens!: number;

  @Expose()
  reasoningTokens!: number;

  @ApiProperty({ description: 'Cost in USD' })
  @Expose()
  costInUsd!: string | null;

  @ApiProperty({ description: 'Timestamps' })
  @Expose()
  startedAt!: Date;

  @Expose()
  finishedAt!: Date | null;

  @Expose()
  runtimeInMs!: number | null;

  @ApiProperty({ description: 'Raw response from LLM provider' })
  @Expose()
  responseMetadata!: any;

  @ApiProperty({ description: 'Error info if failed' })
  @Expose()
  errorMessage!: string | null;

  @Expose()
  errorCode!: string | null;
}

```

### `apps\backend\src\v1\execution\execution.controller.ts`

```typescript
// execution.controller.ts - Pure streaming, no queue

import {
  Controller,
  Post,
  Get,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
  Res,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { Response } from 'express';
import { V1ExecutionService } from './execution.service';
import { ExecutePodDto } from './dto/execute-pod.dto';
import { ExecutionHistoryItemDto, ExecutionDetailDto } from './dto/execution-response.dto';
import { GetCurrentUserId } from '../../common/decorators/user';

@ApiTags('Executions')
@Controller('workspaces/:workspaceId')
@ApiBearerAuth()
export class V1ExecutionController {
  constructor(private readonly executionService: V1ExecutionService) {}

  @Post('executions')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Execute a pod with instant streaming (BYOK optimized)',
    description:
      'Execute a pod with real-time streaming response. No queuing - instant token streaming for perfect UX with BYOK.',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', example: 'cm2abc123' })
  @ApiResponse({
    status: 200,
    description: 'Streaming execution (SSE format)',
  })
  @ApiResponse({ status: 400, description: 'Invalid request or missing API key' })
  @ApiResponse({ status: 404, description: 'Pod not found' })
  async executePod(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId('id') userId: string,
    @Body() dto: ExecutePodDto,
    @Res() res: Response,
  ): Promise<void> {
    // Validate input
    if (!dto.podId || !dto.messages || dto.messages.length === 0) {
      res.status(400).json({
        error: 'Invalid request',
        message: 'podId and messages are required',
      });
      return;
    }

    // Set up SSE headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering
    res.flushHeaders();

    try {
      // INSTANT STREAMING - No queue!
      const stream = this.executionService.executePod({
        podId: dto.podId,
        workspaceId,
        userId,
        messages: dto.messages,
        provider: dto.provider,
        model: dto.model,
        systemPrompt: dto.systemPrompt,
        temperature: dto.temperature,
        maxTokens: dto.maxTokens,
        topP: dto.topP,
        presencePenalty: dto.presencePenalty,
        frequencyPenalty: dto.frequencyPenalty,
        thinkingBudget: dto.thinkingBudget,
        responseFormat: dto.responseFormat,
      });

      // Stream chunks to client in real-time
      for await (const chunk of stream) {
        res.write(`data: ${JSON.stringify(chunk)}\n\n`);
      }

      // Send completion signal
      res.write('data: [DONE]\n\n');
      res.end();
    } catch (error) {
      // Send error through SSE
      res.write(
        `data: ${JSON.stringify({
          type: 'error',
          error: error instanceof Error ? error.message : 'Unknown error',
          timestamp: new Date().toISOString(),
        })}\n\n`,
      );
      res.end();
    }
  }

  @Get('flows/:flowId/executions/pods/:podId')
  @ApiOperation({ summary: 'Get execution history for a specific pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'podId', description: 'Pod ID', example: 'pod_1234567890_abc123' })
  @ApiQuery({ name: 'limit', required: false, example: 10, description: 'Max 100' })
  @ApiResponse({ status: 200, type: [ExecutionHistoryItemDto] })
  async getPodExecutionsByPodId(
    @Param('podId') podId: string,
    @Query('limit') limit?: string,
  ): Promise<ExecutionHistoryItemDto[]> {
    const parsedLimit = limit ? Math.min(parseInt(limit, 10), 100) : 10;
    return this.executionService.getPodExecutions(podId, parsedLimit);
  }

  @Get('executions/:executionId')
  @ApiOperation({ summary: 'Get execution details' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'executionId', description: 'Execution ID', example: 'exec_cm2abc123' })
  @ApiResponse({ status: 200, type: ExecutionDetailDto })
  @ApiResponse({ status: 404, description: 'Execution not found' })
  async getExecution(@Param('executionId') executionId: string): Promise<ExecutionDetailDto> {
    return this.executionService.getExecution(executionId);
  }
}

```

### `apps\backend\src\v1\execution\execution.module.ts`

```typescript
// execution.module.ts

import { Module } from '@nestjs/common';
import { V1ExecutionService } from './execution.service';
import { V1ExecutionController } from './execution.controller';
import { PrismaModule } from '../../prisma/prisma.module';
import { ProviderModule } from './providers/provider.module';
import { V1FlowModule } from '../flow/flow.module';
import { AwsModule } from '../../common/aws/aws.module';
import { V1ContextResolutionService } from './context-resolution.service';

@Module({
  imports: [PrismaModule, AwsModule, ProviderModule, V1FlowModule],
  controllers: [V1ExecutionController],
  providers: [V1ExecutionService, V1ContextResolutionService],
  exports: [V1ExecutionService],
})
export class V1ExecutionModule {}

```

### `apps\backend\src\v1\execution\execution.service.ts`

```typescript
// execution.service.ts - Direct streaming, no queue, instant response

import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';
import { ProviderFactory } from './providers/provider.factory';
import { V1ContextResolutionService } from './context-resolution.service';
import { LLMProvider, PodExecutionStatus } from '@actopod/schema';
import { ExecutionHistoryItemDto, ExecutionDetailDto } from './dto/execution-response.dto';
import { LLMPromptPodContent, PodContextMapping } from '../pods/types/pod-content.types';
import { LLMStreamChunk } from './types/llm-provider.types';
import { nanoid } from 'nanoid';

type LLMMessage = {
  role: 'system' | 'user' | 'assistant';
  content: string;
};

@Injectable()
export class V1ExecutionService {
  private readonly logger = new Logger(V1ExecutionService.name);

  private readonly DEFAULT_SYSTEM_PROMPTS = {
    general: 'You are a helpful AI assistant. Provide clear, accurate, and concise responses.',
    analyst: 'You are a data analyst. Analyze information objectively and provide insights.',
    coder: 'You are a coding assistant. Write clean, efficient, and well-documented code.',
    creative: 'You are a creative writing assistant. Be imaginative and engaging.',
  };

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
    private readonly providerFactory: ProviderFactory,
    private readonly contextResolution: V1ContextResolutionService,
  ) {}

  /**
   * INSTANT STREAMING - No queue, perfect for BYOK
   * Users see tokens immediately as they're generated
   */
  async *executePod(params: {
    podId: string;
    workspaceId: string;
    userId: string;
    messages: LLMMessage[];
    provider?: LLMProvider;
    model?: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
    thinkingBudget?: number;
    responseFormat?: 'text' | 'json_object' | 'json';
    contextMappings?: PodContextMapping[];
  }): AsyncGenerator<LLMStreamChunk, void, unknown> {
    const { podId, workspaceId, messages, contextMappings } = params;
    const executionId = `exec_${nanoid(16)}`;
    const startTime = Date.now();

    try {
      // Get pod info
      const pod = await this.prisma.pod.findFirst({
        where: { id: podId, flow: { workspaceId } },
        select: {
          flowId: true,
          id: true,
          type: true,
          dynamoPartitionKey: true,
          dynamoSortKey: true,
        },
      });

      if (!pod) {
        yield { type: 'error', error: `Pod ${podId} not found` };
        return;
      }

      if (pod.type !== 'LLM_PROMPT') {
        yield { type: 'error', error: 'Only LLM_PROMPT pods can be executed' };
        return;
      }

      const podConfig = await this.getPodConfig(pod.dynamoPartitionKey, pod.dynamoSortKey);
      if (!podConfig) {
        yield { type: 'error', error: 'Pod configuration not found' };
        return;
      }

      const llmConfig = podConfig.config;

      // Resolve all parameters (request â†’ pod config â†’ undefined)
      const finalProvider = params.provider ?? llmConfig.provider;
      const finalModel = params.model ?? llmConfig.model;
      const finalSystemPrompt = params.systemPrompt ?? llmConfig.systemPrompt;
      const finalTemperature = params.temperature ?? llmConfig.temperature;
      const finalMaxTokens = params.maxTokens ?? llmConfig.maxTokens;
      const finalTopP = params.topP ?? llmConfig.topP;
      const finalPresencePenalty = params.presencePenalty ?? llmConfig.presencePenalty;
      const finalFrequencyPenalty = params.frequencyPenalty ?? llmConfig.frequencyPenalty;
      const finalThinkingBudget = params.thinkingBudget ?? llmConfig.thinkingBudget;
      const finalResponseFormat = params.responseFormat ?? llmConfig.responseFormat;

      // Create execution record
      await this.prisma.podExecution.create({
        data: {
          id: executionId,
          podId,
          flowId: pod.flowId,
          workspaceId,
          status: PodExecutionStatus.RUNNING,
          provider: finalProvider,
          modelId: finalModel,
          startedAt: new Date(),
        },
      });

      // Resolve context
      const contextChain = contextMappings
        ? await this.contextResolution.resolveContextWithPins(podId, pod.flowId, contextMappings)
        : await this.contextResolution.resolveContext(podId, pod.flowId);

      // Build system prompt with variable interpolation
      let systemPrompt = finalSystemPrompt ?? this.DEFAULT_SYSTEM_PROMPTS.general;
      systemPrompt = this.contextResolution.interpolateVariables(
        systemPrompt,
        contextChain.variables,
      );

      // Interpolate messages
      const interpolatedMessages = messages.map((msg) => {
        if (msg.role === 'user' && typeof msg.content === 'string') {
          return {
            ...msg,
            content: this.contextResolution.interpolateVariables(
              msg.content,
              contextChain.variables,
            ),
          };
        }
        return msg;
      });

      const finalMessages = this.buildMessagesWithSystemPrompt(
        interpolatedMessages,
        systemPrompt,
        params.systemPrompt !== undefined,
      );

      // Get API key
      const workspaceKey = await this.providerFactory.getWorkspaceApiKey(
        workspaceId,
        finalProvider,
      );
      if (!workspaceKey) {
        yield {
          type: 'error',
          error: `No ${finalProvider} API key configured for this workspace`,
        };
        return;
      }

      const { apiKey, keyId, customEndpoint } = workspaceKey;

      // Get provider
      const llmProvider = this.providerFactory.getProvider(finalProvider);

      if (!llmProvider.executeStream) {
        yield {
          type: 'error',
          error: `Provider ${finalProvider} does not support streaming yet`,
        };
        return;
      }

      // Build request - only include defined parameters
      const llmRequest: any = {
        provider: finalProvider,
        model: finalModel,
        messages: finalMessages,
        apiKey,
        customEndpoint,
        apiKeyId: keyId,
        stream: true,
      };

      if (finalTemperature !== undefined) llmRequest.temperature = finalTemperature;
      if (finalMaxTokens !== undefined) llmRequest.maxTokens = finalMaxTokens;
      if (finalTopP !== undefined) llmRequest.topP = finalTopP;
      if (finalPresencePenalty !== undefined) llmRequest.presencePenalty = finalPresencePenalty;
      if (finalFrequencyPenalty !== undefined) llmRequest.frequencyPenalty = finalFrequencyPenalty;
      if (finalThinkingBudget !== undefined) llmRequest.thinkingBudget = finalThinkingBudget;
      if (finalResponseFormat !== undefined) llmRequest.responseFormat = finalResponseFormat;

      this.logger.debug(`ðŸŒŠ Streaming execution ${executionId}: ${finalProvider}/${finalModel}`);

      // Send start event
      yield { type: 'start', content: 'Processing started...' };

      // Stream response directly - NO QUEUE!
      let fullContent = '';
      let finalUsage: any = null;
      let finishReason = 'stop';

      for await (const chunk of llmProvider.executeStream(llmRequest)) {
        yield chunk; // Stream directly to user - INSTANT!

        if (chunk.type === 'token' && chunk.content) {
          fullContent += chunk.content;
        }

        if (chunk.type === 'done') {
          finalUsage = chunk.usage;
          finishReason = chunk.finishReason || 'stop';
        }
      }

      // Save execution results
      if (finalUsage) {
        const pricing = await this.prisma.modelPricingTier.findFirst({
          where: { provider: finalProvider, modelId: finalModel, isActive: true },
          orderBy: { effectiveFrom: 'desc' },
        });

        if (pricing) {
          const inputCost = (finalUsage.promptTokens / 1_000_000) * Number(pricing.inputTokenCost);
          const outputCost =
            (finalUsage.completionTokens / 1_000_000) * Number(pricing.outputTokenCost);
          const reasoningCost =
            ((finalUsage.reasoningTokens || 0) / 1_000_000) * Number(pricing.reasoningTokenCost);
          const totalCost = inputCost + outputCost + reasoningCost;

          await this.prisma.podExecution.update({
            where: { id: executionId },
            data: {
              status: PodExecutionStatus.COMPLETED,
              finishedAt: new Date(),
              runtimeInMs: Date.now() - startTime,
              apiKeyId: keyId,
              inputTokens: finalUsage.promptTokens,
              outputTokens: finalUsage.completionTokens,
              reasoningTokens: finalUsage.reasoningTokens || 0,
              costInUsd: totalCost,
              modelName: finalModel,
              responseMetadata: { content: fullContent, finishReason },
            },
          });

          await this.providerFactory.trackApiKeyUsage(
            keyId,
            {
              input: finalUsage.promptTokens,
              output: finalUsage.completionTokens,
              reasoning: finalUsage.reasoningTokens,
            },
            totalCost,
            true,
          );

          this.logger.log(
            `âœ… Execution ${executionId} completed - ${finalUsage.totalTokens} tokens, $${totalCost.toFixed(6)} in ${Date.now() - startTime}ms`,
          );
        }
      }

      await this.prisma.pod.update({
        where: { id: podId },
        data: {
          executionStatus: PodExecutionStatus.COMPLETED,
          lastExecutionId: executionId,
        },
      });
    } catch (error) {
      await this.prisma.podExecution.update({
        where: { id: executionId },
        data: {
          status: PodExecutionStatus.ERROR,
          finishedAt: new Date(),
          runtimeInMs: Date.now() - startTime,
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
        },
      });

      this.logger.error(`âŒ Execution ${executionId} failed:`, error);

      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  private async getPodConfig(pk: string, sk: string): Promise<LLMPromptPodContent | null> {
    try {
      const tableName = this.dynamoDb.getTableNames().pods;
      const item = (await this.dynamoDb.getItem(tableName, { pk, sk })) as any | null;
      return item?.content?.type === 'LLM_PROMPT' ? (item.content as LLMPromptPodContent) : null;
    } catch (error) {
      this.logger.error('Failed to fetch pod config from DynamoDB', error);
      return null;
    }
  }

  private buildMessagesWithSystemPrompt(
    messages: LLMMessage[],
    systemPrompt: string,
    userProvidedSystemPrompt: boolean = false,
  ): LLMMessage[] {
    const hasSystemMessage = messages.some((m) => m.role === 'system');

    if (hasSystemMessage) {
      this.logger.debug('Using system message from messages array');
      return messages;
    }

    this.logger.debug(
      `Using ${userProvidedSystemPrompt ? 'user-provided' : 'configured'} system prompt: "${systemPrompt.substring(0, 50)}..."`,
    );

    return [{ role: 'system', content: systemPrompt }, ...messages];
  }

  async getPodExecutions(podId: string, limit: number = 10): Promise<ExecutionHistoryItemDto[]> {
    const executions = await this.prisma.podExecution.findMany({
      where: { podId },
      orderBy: { startedAt: 'desc' },
      take: Math.min(limit, 100), // Max 100
      select: {
        id: true,
        podId: true,
        status: true,
        provider: true,
        modelId: true,
        modelName: true,
        inputTokens: true,
        outputTokens: true,
        reasoningTokens: true,
        costInUsd: true,
        startedAt: true,
        finishedAt: true,
        runtimeInMs: true,
        errorMessage: true,
        errorCode: true,
      },
    });

    return executions.map((exec) => ({
      id: exec.id,
      podId: exec.podId,
      status: exec.status,
      provider: exec.provider,
      modelId: exec.modelId,
      modelName: exec.modelName,
      inputTokens: exec.inputTokens,
      outputTokens: exec.outputTokens,
      reasoningTokens: exec.reasoningTokens,
      costInUsd: exec.costInUsd ? exec.costInUsd.toString() : null,
      startedAt: exec.startedAt,
      finishedAt: exec.finishedAt,
      runtimeInMs: exec.runtimeInMs,
      errorMessage: exec.errorMessage,
      errorCode: exec.errorCode,
    }));
  }

  async getExecution(executionId: string): Promise<ExecutionDetailDto> {
    const execution = await this.prisma.podExecution.findUnique({
      where: { id: executionId },
      include: {
        pod: {
          select: {
            id: true,
            type: true,
            flowId: true,
          },
        },
      },
    });

    if (!execution) {
      throw new NotFoundException(`Execution ${executionId} not found`);
    }

    return {
      ...execution,
      costInUsd: execution.costInUsd ? execution.costInUsd.toString() : null,
    } as ExecutionDetailDto;
  }
}

```

### `apps\backend\src\v1\execution\execution-queue.service.ts`

```typescript
// execution-queue.service.ts

import { Injectable, Logger, OnModuleDestroy } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { V1ExecutionService } from './execution.service';
import { V1FlowGateway } from '../flow/flow.gateway';
import { PrismaService } from '../../prisma/prisma.service';
import { LLMProvider, PodExecutionStatus } from '@actopod/schema';
import { QueueFactory } from '../../common/queue/queue.factory';
import { QueueAdapter } from '../../common/queue/queue-adapter.interface';

export type ExecutionJobData = {
  executionId: string;
  podId: string;
  workspaceId: string;
  userId: string;
  flowId: string;
  messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }>;
  provider?: LLMProvider;
  model?: string;
  systemPrompt?: string; // ADD THIS
  temperature?: number;
  maxTokens?: number;
  topP?: number; // ADD THIS
  presencePenalty?: number; // ADD THIS
  frequencyPenalty?: number; // ADD THIS
  thinkingBudget?: number;
  responseFormat?: 'text' | 'json_object' | 'json'; // ADD THIS
};

@Injectable()
export class V1ExecutionQueueService implements OnModuleDestroy {
  private readonly logger = new Logger(V1ExecutionQueueService.name);
  private executionQueue: QueueAdapter;

  constructor(
    private readonly config: ConfigService,
    private readonly queueFactory: QueueFactory,
    private readonly executionService: V1ExecutionService,
    private readonly flowGateway: V1FlowGateway,
    private readonly prisma: PrismaService,
  ) {
    this.executionQueue = this.queueFactory.createQueue('pod-executions', 10);

    this.executionQueue.process(async (job: any) => {
      return this.processExecution(job);
    });

    this.logger.log('âœ… Execution queue service initialized with streaming support');
  }

  async queueExecution(data: ExecutionJobData): Promise<string> {
    try {
      const jobId = await this.executionQueue.add('execute-pod', data, {
        jobId: data.executionId,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
      });

      this.logger.log(
        `ðŸ“‹ Queued execution ${data.executionId} for pod ${data.podId} (provider: ${data.provider || 'default'})`,
      );

      this.flowGateway.broadcastToFlow(data.flowId, 'execution:queued', {
        executionId: data.executionId,
        podId: data.podId,
        status: PodExecutionStatus.QUEUED,
        timestamp: new Date(),
      });

      return jobId;
    } catch (error) {
      this.logger.error(
        `Failed to queue execution ${data.executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
      throw error;
    }
  }

  private async processExecution(job: any) {
    const { executionId, podId, workspaceId, userId, flowId, ...params } = job.data;

    this.logger.log(
      `ðŸš€ Processing execution ${executionId} (attempt ${job.attemptsMade || 1}/${job.opts?.attempts || 3})`,
    );

    try {
      await this.updateExecutionStatus(executionId, PodExecutionStatus.RUNNING);

      this.flowGateway.broadcastToFlow(flowId, 'execution:running', {
        executionId,
        podId,
        status: PodExecutionStatus.RUNNING,
        timestamp: new Date(),
      });

      // Execute with ALL parameters passed through
      const result = await this.executionService.executePod({
        podId,
        workspaceId,
        userId,
        messages: params.messages,
        provider: params.provider,
        model: params.model,
        systemPrompt: params.systemPrompt, // PASS THIS
        temperature: params.temperature,
        maxTokens: params.maxTokens,
        topP: params.topP, // PASS THIS
        presencePenalty: params.presencePenalty, // PASS THIS
        frequencyPenalty: params.frequencyPenalty, // PASS THIS
        thinkingBudget: params.thinkingBudget,
        responseFormat: params.responseFormat, // PASS THIS
      });

      this.logger.log(`âœ… Execution ${executionId} completed successfully`);

      this.flowGateway.broadcastToFlow(flowId, 'execution:completed', {
        executionId,
        podId,
        status: PodExecutionStatus.COMPLETED,
        result,
        timestamp: new Date(),
      });

      return result;
    } catch (error) {
      this.logger.error(
        `âŒ Execution ${executionId} failed (attempt ${job.attemptsMade || 1}):`,
        error instanceof Error ? error.message : 'Unknown error',
      );

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const errorCode = error instanceof Error ? error.name : 'UNKNOWN_ERROR';

      await this.updateExecutionStatus(executionId, PodExecutionStatus.ERROR, errorMessage);

      this.flowGateway.broadcastToFlow(flowId, 'execution:error', {
        executionId,
        podId,
        status: PodExecutionStatus.ERROR,
        error: errorMessage,
        errorCode,
        timestamp: new Date(),
      });

      throw error;
    }
  }

  private async updateExecutionStatus(
    executionId: string,
    status: PodExecutionStatus,
    errorMessage?: string,
  ): Promise<void> {
    try {
      await this.prisma.podExecution.update({
        where: { id: executionId },
        data: {
          status,
          ...(status === PodExecutionStatus.RUNNING && { startedAt: new Date() }),
          ...(errorMessage && {
            errorMessage,
            errorCode: 'EXECUTION_ERROR',
            finishedAt: new Date(),
          }),
        },
      });
    } catch (error) {
      this.logger.error(
        `Failed to update execution status for ${executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
    }
  }

  async getQueueMetrics() {
    try {
      const metrics = await this.executionQueue.getMetrics();

      this.logger.debug(
        `Queue metrics: waiting=${metrics.waiting}, active=${metrics.active}, completed=${metrics.completed}, failed=${metrics.failed}`,
      );

      return metrics;
    } catch (error) {
      this.logger.error('Failed to get queue metrics:', error);
      return {
        waiting: 0,
        active: 0,
        completed: 0,
        failed: 0,
      };
    }
  }

  async cancelExecution(executionId: string): Promise<boolean> {
    try {
      const cancelled = await this.executionQueue.cancel(executionId);

      if (cancelled) {
        await this.updateExecutionStatus(executionId, PodExecutionStatus.CANCELLED);
        this.logger.log(`ðŸ›‘ Cancelled execution ${executionId}`);
        return true;
      }

      this.logger.warn(`Failed to cancel execution ${executionId} - job not found in queue`);
      return false;
    } catch (error) {
      this.logger.error(
        `Error cancelling execution ${executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
      return false;
    }
  }

  async getExecutionQueueStatus(executionId: string) {
    try {
      return await this.executionQueue.getJobStatus(executionId);
    } catch (error) {
      this.logger.error(
        `Failed to get queue status for ${executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
      return null;
    }
  }

  async onModuleDestroy() {
    try {
      this.logger.log('ðŸ›‘ Shutting down execution queue...');
      await this.executionQueue.close();
      this.logger.log('âœ… Execution queue closed successfully');
    } catch (error) {
      this.logger.error('Error closing execution queue:', error);
    }
  }
}

```

### `apps\backend\src\v1\execution\providers\anthropic.provider.ts`

```typescript
import { Injectable } from '@nestjs/common';
import axios from 'axios';
import { BaseLLMProvider } from './base-llm.provider';
import { LLMProvider } from '@actopod/schema';
import { LLMRequest, LLMResponse, LLMStreamChunk } from '../types/llm-provider.types';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class AnthropicProvider extends BaseLLMProvider {
  private readonly defaultBaseUrl = 'https://api.anthropic.com/v1';
  private readonly apiVersion = '2023-06-01';

  constructor(prisma: PrismaService) {
    super('AnthropicProvider', prisma);
  }

  async execute(request: LLMRequest): Promise<LLMResponse> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const systemMessage = request.messages.find((m) => m.role === 'system');
      const userMessages = request.messages.filter((m) => m.role !== 'system');

      const modelPricing = await this.getModelPricing(LLMProvider.ANTHROPIC, request.model);
      const supportsExtendedThinking = modelPricing?.modelId?.includes('4-5') || false;

      const requestBody: any = {
        model: request.model,
        messages: userMessages.map((m) => ({
          role: m.role,
          content: typeof m.content === 'string' ? m.content : JSON.stringify(m.content),
        })),
        max_tokens: request.maxTokens ?? this.getDefaultMaxTokens(request.model),
      };

      if (systemMessage) {
        requestBody.system =
          typeof systemMessage.content === 'string'
            ? systemMessage.content
            : JSON.stringify(systemMessage.content);
      }

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (request.topP !== undefined) {
        requestBody.top_p = request.topP;
      }

      if (supportsExtendedThinking && request.thinkingBudget) {
        requestBody.thinking = {
          type: 'enabled',
          budget_tokens: request.thinkingBudget,
        };
      }

      this.logger.debug(
        `Executing Anthropic request: model=${request.model}, max_tokens=${requestBody.max_tokens}`,
      );

      const response = await this.retryWithBackoff(() =>
        axios.post(`${baseUrl}/messages`, requestBody, {
          headers: this.getRequestHeaders(request.apiKey, request.model),
          timeout: 180000,
        }),
      );

      const data = response.data;

      let content = '';
      if (Array.isArray(data.content)) {
        const textBlocks = data.content.filter((block: any) => block.type === 'text');
        content = textBlocks.map((block: any) => block.text).join('\n');
      } else {
        content = data.content[0]?.text || '';
      }

      const result: LLMResponse = {
        id: data.id,
        model: data.model,
        provider: LLMProvider.ANTHROPIC,
        content,
        finishReason: data.stop_reason,
        usage: {
          promptTokens: data.usage.input_tokens,
          completionTokens: data.usage.output_tokens,
          totalTokens: data.usage.input_tokens + data.usage.output_tokens,
          cachedTokens: data.usage.cache_read_input_tokens,
        },
        rawResponse: data,
        timestamp: new Date(),
      };

      this.logger.log(`âœ… Anthropic execution completed: ${result.usage.totalTokens} tokens`);

      return result;
    } catch (error) {
      this.logger.error(
        `âŒ Anthropic execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      this.handleError(error, 'Anthropic');
    }
  }

  async *executeStream(request: LLMRequest): AsyncGenerator<LLMStreamChunk> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const systemMessage = request.messages.find((m) => m.role === 'system');
      const userMessages = request.messages.filter((m) => m.role !== 'system');

      const modelPricing = await this.getModelPricing(LLMProvider.ANTHROPIC, request.model);
      const supportsExtendedThinking = modelPricing?.modelId?.includes('4-5') || false;

      const requestBody: any = {
        model: request.model,
        messages: userMessages.map((m) => ({
          role: m.role,
          content: typeof m.content === 'string' ? m.content : JSON.stringify(m.content),
        })),
        max_tokens: request.maxTokens ?? this.getDefaultMaxTokens(request.model),
        stream: true,
      };

      if (systemMessage) {
        requestBody.system =
          typeof systemMessage.content === 'string'
            ? systemMessage.content
            : JSON.stringify(systemMessage.content);
      }

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (request.topP !== undefined) {
        requestBody.top_p = request.topP;
      }

      if (supportsExtendedThinking && request.thinkingBudget) {
        requestBody.thinking = {
          type: 'enabled',
          budget_tokens: request.thinkingBudget,
        };
      }

      this.logger.debug(
        `Streaming Anthropic request: model=${request.model}, max_tokens=${requestBody.max_tokens}`,
      );

      const response = await axios.post(`${baseUrl}/messages`, requestBody, {
        headers: this.getRequestHeaders(request.apiKey, request.model),
        responseType: 'stream',
        timeout: 180000,
      });

      yield { type: 'start' };

      let buffer = '';
      let finalUsage: any = null;

      for await (const chunk of response.data) {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '' || !line.startsWith('data: ')) continue;

          try {
            const data = JSON.parse(line.substring(6));

            if (data.type === 'content_block_delta') {
              if (data.delta?.type === 'text_delta' && data.delta?.text) {
                yield { type: 'token', content: data.delta.text };
              }
            }

            if (data.type === 'message_delta') {
              if (data.usage) {
                finalUsage = data.usage;
              }
            }

            if (data.type === 'message_stop') {
              if (finalUsage) {
                yield {
                  type: 'done',
                  finishReason: data.delta?.stop_reason || 'end_turn',
                  usage: {
                    promptTokens: finalUsage.input_tokens || 0,
                    completionTokens: finalUsage.output_tokens || 0,
                    totalTokens: (finalUsage.input_tokens || 0) + (finalUsage.output_tokens || 0),
                  },
                };
              } else {
                yield { type: 'done', finishReason: 'end_turn' };
              }
            }
          } catch {
            this.logger.warn(`Failed to parse SSE line: ${line}`);
          }
        }
      }

      this.logger.log(`âœ… Anthropic stream completed`);
    } catch (error) {
      this.logger.error(
        `âŒ Anthropic stream failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  private getDefaultMaxTokens(model: string): number {
    // Claude 3.7 Sonnet - 128K output
    if (model.includes('claude-3-7')) {
      return 128000;
    }

    // Claude Sonnet 4 - 64K output
    if (model.includes('claude-sonnet-4') || model.includes('sonnet-4-5')) {
      return 64000;
    }

    // Claude Opus 4 - 32K output
    if (model.includes('claude-opus-4') || model.includes('opus-4-1')) {
      return 32000;
    }

    // Claude 3.5 Sonnet - 8K output (with special header)
    if (model.includes('claude-3-5-sonnet') || model.includes('3-5-sonnet')) {
      return 8192;
    }

    // Claude Haiku - 10K output
    if (model.includes('haiku')) {
      return 10000;
    }

    // Default for older models
    return 4096;
  }

  private getRequestHeaders(apiKey: string, model: string): any {
    const headers: any = {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': this.apiVersion,
    };

    // Enable extended output for Claude 3.5 Sonnet
    if (model.includes('claude-3-5-sonnet')) {
      headers['anthropic-beta'] = 'max-tokens-3-5-sonnet-2024-07-15';
    }

    return headers;
  }

  async testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean> {
    try {
      const baseUrl = customEndpoint || this.defaultBaseUrl;
      await axios.post(
        `${baseUrl}/messages`,
        {
          model: 'claude-3-5-haiku-20241022',
          max_tokens: 10,
          messages: [{ role: 'user', content: 'test' }],
        },
        {
          headers: {
            'x-api-key': apiKey,
            'anthropic-version': this.apiVersion,
          },
          timeout: 10000,
        },
      );
      this.logger.log('âœ… Anthropic API key validation successful');
      return true;
    } catch {
      this.logger.warn('Anthropic API key validation failed');
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    const dbModels = await this.getModelsFromDb(LLMProvider.ANTHROPIC);
    if (dbModels.length > 0) {
      this.logger.debug(`Loaded ${dbModels.length} Anthropic models from database`);
      return dbModels;
    }

    const fallbackModels = [
      'claude-sonnet-4-5-20250929',
      'claude-haiku-4-5-20250929',
      'claude-opus-4-1-20250808',
      'claude-3-5-sonnet-20241022',
      'claude-3-5-haiku-20241022',
    ];

    this.logger.debug(`Using ${fallbackModels.length} fallback Anthropic models`);
    return fallbackModels;
  }
}

```

### `apps\backend\src\v1\execution\providers\base-llm.provider.ts`

```typescript
import { Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { ILLMProvider, LLMRequest, LLMResponse } from '../types/llm-provider.types';
import { LLMProvider, ModelPricingTier } from '@actopod/schema';

export abstract class BaseLLMProvider implements ILLMProvider {
  protected readonly logger: Logger;

  constructor(
    providerName: string,
    protected readonly prisma: PrismaService,
  ) {
    this.logger = new Logger(providerName);
  }

  abstract execute(request: LLMRequest): Promise<LLMResponse>;
  abstract testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean>;
  abstract getAvailableModels(): Promise<string[]>;

  /**
   * Get active models from database for this provider
   */
  protected async getModelsFromDb(provider: LLMProvider): Promise<string[]> {
    try {
      const models = await this.prisma.modelPricingTier.findMany({
        where: {
          provider,
          isActive: true,
        },
        select: {
          modelId: true,
          displayName: true,
        },
        orderBy: {
          displayName: 'asc',
        },
      });

      return models.map((m) => m.modelId);
    } catch (error) {
      this.logger.warn(
        `Failed to fetch models from DB: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      return [];
    }
  }

  /**
   * Get model pricing info from database
   */
  protected async getModelPricing(
    provider: LLMProvider,
    modelId: string,
  ): Promise<ModelPricingTier | null> {
    try {
      return await this.prisma.modelPricingTier.findFirst({
        where: {
          provider,
          modelId,
          isActive: true,
        },
        orderBy: {
          effectiveFrom: 'desc',
        },
      });
    } catch (error) {
      this.logger.warn(`Failed to fetch pricing for ${modelId}:`, error);
      return null;
    }
  }

  /**
   * Handle common errors with better messaging
   */
  protected handleError(error: any, provider: string): never {
    this.logger.error(`${provider} execution failed:`, error);

    const status = error.response?.status;
    const errorData = error.response?.data;

    // Handle specific HTTP status codes
    if (status === 401 || status === 403) {
      throw new Error(`Invalid or expired API key for ${provider}`);
    }
    if (status === 429) {
      const retryAfter = error.response?.headers?.['retry-after'];
      throw new Error(
        `Rate limit exceeded for ${provider}${retryAfter ? `. Retry after ${retryAfter} seconds` : ''}`,
      );
    }
    if (status === 400) {
      const message = errorData?.error?.message || errorData?.message || 'Bad request';
      throw new Error(`${provider} bad request: ${message}`);
    }
    if (status === 404) {
      throw new Error(`${provider} endpoint not found. Check your configuration.`);
    }
    if (status === 500 || status === 503) {
      throw new Error(`${provider} service unavailable. Please try again later.`);
    }
    if (status === 502 || status === 504) {
      throw new Error(`${provider} gateway timeout. Please try again.`);
    }

    // Handle timeout errors
    if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
      throw new Error(`${provider} request timeout. Please try again.`);
    }

    // Handle network errors
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      throw new Error(`${provider} network error. Check your internet connection.`);
    }

    // Generic error
    const message = error.message || 'Unknown error';
    throw new Error(`${provider} execution failed: ${message}`);
  }

  /**
   * Retry with exponential backoff and jitter
   */
  protected async retryWithBackoff<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    baseDelay: number = 1000,
  ): Promise<T> {
    let lastError: any;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error: any) {
        lastError = error;

        // Don't retry on client errors (4xx except 429)
        const status = error.response?.status;
        if (status && status >= 400 && status < 500 && status !== 429) {
          this.logger.warn(`Non-retryable error (${status}), failing immediately`);
          throw error;
        }

        // Don't retry if this is the last attempt
        if (attempt === maxRetries - 1) {
          this.logger.error(`Max retries (${maxRetries}) exceeded`);
          throw error;
        }

        // Calculate delay with exponential backoff + jitter
        const exponentialDelay = baseDelay * Math.pow(2, attempt);
        const jitter = Math.random() * 1000; // Random 0-1000ms jitter
        const delay = Math.min(exponentialDelay + jitter, 30000); // Cap at 30 seconds

        this.logger.warn(
          `Retry ${attempt + 1}/${maxRetries} after ${Math.round(delay)}ms (status: ${status || 'unknown'})`,
        );

        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }
}

```

### `apps\backend\src\v1\execution\providers\gemini.provider.ts`

```typescript
import { Injectable } from '@nestjs/common';
import axios, { AxiosError } from 'axios';
import { BaseLLMProvider } from './base-llm.provider';
import { LLMProvider } from '@actopod/schema';
import { LLMRequest, LLMResponse, LLMStreamChunk } from '../types/llm-provider.types';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class GeminiProvider extends BaseLLMProvider {
  private readonly defaultBaseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private readonly REQUEST_TIMEOUT = 180000;
  private readonly API_KEY_TEST_TIMEOUT = 10000;

  constructor(prisma: PrismaService) {
    super('GeminiProvider', prisma);
  }

  async execute(request: LLMRequest): Promise<LLMResponse> {
    const startTime = Date.now();

    try {
      this.validateRequest(request);

      const baseUrl = this.sanitizeUrl(request.customEndpoint || this.defaultBaseUrl);
      const contents = this.convertMessagesToGeminiFormat(request.messages);

      if (contents.length === 0) {
        throw new Error('No valid messages to send after filtering system messages');
      }

      const requestBody = this.buildRequestBody(request, contents);

      this.logger.debug(`Executing Gemini request: model=${request.model}`);

      const response = await this.retryWithBackoff(() =>
        axios.post(
          `${baseUrl}/models/${request.model}:generateContent?key=${request.apiKey}`,
          requestBody,
          {
            headers: { 'Content-Type': 'application/json' },
            timeout: this.REQUEST_TIMEOUT,
            validateStatus: (status) => status < 500,
          },
        ),
      );

      if (response.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.');
      }

      if (response.status === 401 || response.status === 403) {
        throw new Error('Invalid or unauthorized API key');
      }

      if (response.status >= 400) {
        const errorMessage = response.data?.error?.message || 'Unknown API error';
        throw new Error(`Gemini API error (${response.status}): ${errorMessage}`);
      }

      const data = this.validateResponse(response.data);
      const llmResponse = this.parseResponse(data, request.model);

      const executionTime = Date.now() - startTime;
      this.logger.log(
        `âœ… Gemini execution completed: ${llmResponse.usage.totalTokens} tokens in ${executionTime}ms`,
      );

      return llmResponse;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(
        `âŒ Gemini execution failed after ${executionTime}ms: ${this.getErrorMessage(error)}`,
      );
      this.handleError(error, 'Google Gemini');
    }
  }

  async *executeStream(request: LLMRequest): AsyncGenerator<LLMStreamChunk> {
    try {
      this.validateRequest(request);

      const baseUrl = this.sanitizeUrl(request.customEndpoint || this.defaultBaseUrl);
      const contents = this.convertMessagesToGeminiFormat(request.messages);

      if (contents.length === 0) {
        throw new Error('No valid messages to send');
      }

      const requestBody = this.buildRequestBody(request, contents);

      this.logger.debug(`Streaming Gemini request: model=${request.model}`);

      const response = await axios.post(
        `${baseUrl}/models/${request.model}:streamGenerateContent?key=${request.apiKey}&alt=sse`,
        requestBody,
        {
          headers: { 'Content-Type': 'application/json' },
          responseType: 'stream',
          timeout: this.REQUEST_TIMEOUT,
        },
      );

      yield { type: 'start' };

      let buffer = '';
      let totalUsage = {
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0,
      };

      for await (const chunk of response.data) {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '' || !line.startsWith('data: ')) continue;

          try {
            const data = JSON.parse(line.substring(6));

            if (data.candidates && data.candidates[0]?.content?.parts) {
              for (const part of data.candidates[0].content.parts) {
                if (part.text) {
                  yield { type: 'token', content: part.text };
                }
              }
            }

            if (data.usageMetadata) {
              totalUsage = {
                promptTokens: data.usageMetadata.promptTokenCount || 0,
                completionTokens: data.usageMetadata.candidatesTokenCount || 0,
                totalTokens: data.usageMetadata.totalTokenCount || 0,
              };
            }

            if (data.candidates && data.candidates[0]?.finishReason) {
              yield {
                type: 'done',
                finishReason: data.candidates[0].finishReason,
                usage: totalUsage,
              };
            }
          } catch {
            this.logger.warn(`Failed to parse SSE line: ${line}`);
          }
        }
      }

      this.logger.log(`âœ… Gemini stream completed`);
    } catch (error) {
      this.logger.error(`âŒ Gemini stream failed: ${this.getErrorMessage(error)}`);
      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  private validateRequest(request: LLMRequest): void {
    if (
      !request.apiKey ||
      typeof request.apiKey !== 'string' ||
      request.apiKey.trim().length === 0
    ) {
      throw new Error('Invalid API key');
    }

    if (!request.model || typeof request.model !== 'string') {
      throw new Error('Invalid model');
    }

    if (!Array.isArray(request.messages) || request.messages.length === 0) {
      throw new Error('Invalid messages');
    }

    if (request.temperature !== undefined && (request.temperature < 0 || request.temperature > 2)) {
      throw new Error('Temperature must be between 0 and 2');
    }

    if (request.maxTokens !== undefined && (request.maxTokens < 1 || request.maxTokens > 65536)) {
      throw new Error('maxTokens must be between 1 and 65536');
    }

    if (request.topP !== undefined && (request.topP < 0 || request.topP > 1)) {
      throw new Error('topP must be between 0 and 1');
    }
  }

  private sanitizeUrl(url: string): string {
    try {
      const urlObj = new URL(url);
      if (!['http:', 'https:'].includes(urlObj.protocol)) {
        throw new Error('Invalid protocol');
      }
      return url.replace(/\/$/, '');
    } catch {
      throw new Error(`Invalid URL format: ${url}`);
    }
  }

  private convertMessagesToGeminiFormat(messages: LLMRequest['messages']): Array<{
    role: string;
    parts: Array<{ text: string }>;
  }> {
    return messages
      .filter((m) => m.role !== 'system')
      .map((m) => {
        if (!m.role || !m.content) {
          this.logger.warn(`Skipping invalid message: ${JSON.stringify(m)}`);
          return null;
        }

        const text =
          typeof m.content === 'string'
            ? m.content
            : typeof m.content === 'object'
              ? JSON.stringify(m.content)
              : String(m.content);

        if (text.length === 0) {
          this.logger.warn(`Skipping empty message from role: ${m.role}`);
          return null;
        }

        return {
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text }],
        };
      })
      .filter((m): m is NonNullable<typeof m> => m !== null);
  }

  private buildRequestBody(request: LLMRequest, contents: any[]): any {
    const requestBody: any = { contents };
    const generationConfig: any = {};

    if (request.temperature !== undefined) {
      generationConfig.temperature = request.temperature;
    }

    // Set maximum output tokens per official docs
    if (request.maxTokens !== undefined) {
      generationConfig.maxOutputTokens = request.maxTokens;
    } else {
      // Use model-specific maximum defaults
      if (request.model.includes('gemini-2.5')) {
        generationConfig.maxOutputTokens = 65535; // Gemini 2.5 maximum
      } else if (request.model.includes('gemini-2.0')) {
        generationConfig.maxOutputTokens = 8192; // Gemini 2.0 maximum
      }
      // Don't set for gemini-1.5 - let Google use its default
    }

    if (request.topP !== undefined) {
      generationConfig.topP = request.topP;
    }

    if (request.responseFormat === 'json_object') {
      generationConfig.response_mime_type = 'application/json';
    }

    if (request.thinkingBudget && request.model.includes('2.5')) {
      generationConfig.thinking_config = {
        budget_tokens: request.thinkingBudget,
      };
    }

    if (Object.keys(generationConfig).length > 0) {
      requestBody.generationConfig = generationConfig;
    }

    const systemMessage = request.messages.find((m) => m.role === 'system');
    if (systemMessage && systemMessage.content) {
      const systemText =
        typeof systemMessage.content === 'string'
          ? systemMessage.content
          : JSON.stringify(systemMessage.content);

      if (systemText.length > 0) {
        requestBody.systemInstruction = { parts: [{ text: systemText }] };
      }
    }

    requestBody.safetySettings = [
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_ONLY_HIGH' },
    ];

    return requestBody;
  }

  private validateResponse(data: any): any {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid response');
    }

    if (data.promptFeedback?.blockReason) {
      throw new Error(`Content blocked: ${data.promptFeedback.blockReason}`);
    }

    if (!data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
      throw new Error('No candidates returned');
    }

    const candidate = data.candidates[0];

    if (candidate.finishReason === 'SAFETY') {
      throw new Error('Content blocked due to safety concerns');
    }

    if (!candidate.content || !Array.isArray(candidate.content.parts)) {
      throw new Error('Invalid candidate structure');
    }

    return data;
  }

  private parseResponse(data: any, model: string): LLMResponse {
    const candidate = data.candidates[0];

    const content = candidate.content.parts
      .map((p: any) => p.text || '')
      .filter((text: string) => text.length > 0)
      .join('\n');

    return {
      id: data.modelVersion || model,
      model,
      provider: LLMProvider.GOOGLE_GEMINI,
      content,
      finishReason: candidate.finishReason || 'unknown',
      usage: {
        promptTokens: data.usageMetadata?.promptTokenCount || 0,
        completionTokens: data.usageMetadata?.candidatesTokenCount || 0,
        totalTokens: data.usageMetadata?.totalTokenCount || 0,
        cachedTokens: data.usageMetadata?.cachedContentTokenCount || 0,
      },
      rawResponse: data,
      timestamp: new Date(),
    };
  }

  private getErrorMessage(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (axios.isAxiosError(error)) {
      const axiosError = error as AxiosError;
      if (axiosError.response?.data) {
        const data = axiosError.response.data as any;
        return data.error?.message || data.message || axiosError.message;
      }
      return axiosError.message;
    }
    return String(error);
  }

  async testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean> {
    try {
      if (!apiKey || apiKey.trim().length === 0) {
        return false;
      }

      const baseUrl = this.sanitizeUrl(customEndpoint || this.defaultBaseUrl);
      const response = await axios.get(`${baseUrl}/models?key=${apiKey}`, {
        timeout: this.API_KEY_TEST_TIMEOUT,
        validateStatus: (status) => status < 500,
      });

      if (response.status === 200) {
        this.logger.log('âœ… Gemini API key validation successful');
        return true;
      }

      return false;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    try {
      const dbModels = await this.getModelsFromDb(LLMProvider.GOOGLE_GEMINI);
      if (dbModels.length > 0) {
        return dbModels;
      }

      return [
        'gemini-2.5-pro',
        'gemini-2.5-flash',
        'gemini-2.5-flash-lite',
        'gemini-2.0-flash',
        'gemini-1.5-pro',
      ];
    } catch {
      return ['gemini-2.5-flash', 'gemini-1.5-pro'];
    }
  }
}

```

### `apps\backend\src\v1\execution\providers\openai.provider.ts`

```typescript
import { Injectable } from '@nestjs/common';
import axios from 'axios';
import { LLMProvider } from '@actopod/schema';
import { LLMRequest, LLMResponse, LLMStreamChunk } from '../types/llm-provider.types';
import { PrismaService } from '../../../prisma/prisma.service';
import { BaseLLMProvider } from './base-llm.provider';

@Injectable()
export class OpenAIProvider extends BaseLLMProvider {
  private readonly defaultBaseUrl = 'https://api.openai.com/v1';

  constructor(prisma: PrismaService) {
    super('OpenAIProvider', prisma);
  }

  async execute(request: LLMRequest): Promise<LLMResponse> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const modelPricing = await this.getModelPricing(LLMProvider.OPENAI, request.model);
      const isReasoningModel = (modelPricing?.creditsPerMillionReasoningTokens ?? 0) > 0;

      const requestBody: any = {
        model: request.model,
        messages: request.messages,
        stream: false,
      };

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (!isReasoningModel) {
        if (request.maxTokens !== undefined) {
          requestBody.max_tokens = request.maxTokens;
        }
        if (request.topP !== undefined) {
          requestBody.top_p = request.topP;
        }
        if (request.presencePenalty !== undefined) {
          requestBody.presence_penalty = request.presencePenalty;
        }
        if (request.frequencyPenalty !== undefined) {
          requestBody.frequency_penalty = request.frequencyPenalty;
        }
        if (request.responseFormat) {
          requestBody.response_format = { type: request.responseFormat };
        }
      } else {
        if (request.maxTokens !== undefined) {
          requestBody.max_completion_tokens = request.maxTokens;
        }
      }

      this.logger.debug(
        `Executing OpenAI request: model=${request.model}, isReasoning=${isReasoningModel}, temperature=${request.temperature ?? 'default'}, maxTokens=${request.maxTokens ?? 'default'}`,
      );

      const response = await this.retryWithBackoff(() =>
        axios.post(`${baseUrl}/chat/completions`, requestBody, {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${request.apiKey}`,
          },
          timeout: 180000,
        }),
      );

      const data = response.data;
      const choice = data.choices[0];

      const result: LLMResponse = {
        id: data.id,
        model: data.model,
        provider: LLMProvider.OPENAI,
        content: choice.message.content || '',
        finishReason: choice.finish_reason,
        usage: {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens,
          reasoningTokens: data.usage.completion_tokens_details?.reasoning_tokens,
          cachedTokens: data.usage.prompt_tokens_details?.cached_tokens,
        },
        rawResponse: data,
        timestamp: new Date(),
      };

      this.logger.log(
        `âœ… OpenAI execution completed: ${result.usage.totalTokens} tokens (${result.usage.promptTokens} input + ${result.usage.completionTokens} output${result.usage.reasoningTokens ? ` + ${result.usage.reasoningTokens} reasoning` : ''})`,
      );

      return result;
    } catch (error) {
      this.logger.error(
        `âŒ OpenAI execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      this.handleError(error, 'OpenAI');
    }
  }

  async *executeStream(request: LLMRequest): AsyncGenerator<LLMStreamChunk> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const modelPricing = await this.getModelPricing(LLMProvider.OPENAI, request.model);
      const isReasoningModel = (modelPricing?.creditsPerMillionReasoningTokens ?? 0) > 0;

      const requestBody: any = {
        model: request.model,
        messages: request.messages,
        stream: true,
        stream_options: { include_usage: true },
      };

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (!isReasoningModel) {
        if (request.maxTokens !== undefined) {
          requestBody.max_tokens = request.maxTokens;
        }
        if (request.topP !== undefined) {
          requestBody.top_p = request.topP;
        }
        if (request.presencePenalty !== undefined) {
          requestBody.presence_penalty = request.presencePenalty;
        }
        if (request.frequencyPenalty !== undefined) {
          requestBody.frequency_penalty = request.frequencyPenalty;
        }
        if (request.responseFormat) {
          requestBody.response_format = { type: request.responseFormat };
        }
      } else {
        if (request.maxTokens !== undefined) {
          requestBody.max_completion_tokens = request.maxTokens;
        }
      }

      this.logger.debug(`Streaming OpenAI request: model=${request.model}`);

      const response = await axios.post(`${baseUrl}/chat/completions`, requestBody, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${request.apiKey}`,
        },
        responseType: 'stream',
        timeout: 180000,
      });

      yield { type: 'start' };

      let buffer = '';

      for await (const chunk of response.data) {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;
          if (!line.startsWith('data: ')) continue;

          try {
            const data = JSON.parse(line.substring(6));
            const delta = data.choices?.[0]?.delta;

            if (delta?.content) {
              yield { type: 'token', content: delta.content };
            }

            if (data.choices?.[0]?.finish_reason) {
              const usage = data.usage;
              if (usage) {
                yield {
                  type: 'done',
                  finishReason: data.choices[0].finish_reason,
                  usage: {
                    promptTokens: usage.prompt_tokens,
                    completionTokens: usage.completion_tokens,
                    totalTokens: usage.total_tokens,
                    reasoningTokens: usage.completion_tokens_details?.reasoning_tokens,
                    cachedTokens: usage.prompt_tokens_details?.cached_tokens,
                  },
                };
              } else {
                yield {
                  type: 'done',
                  finishReason: data.choices[0].finish_reason,
                };
              }
            }
          } catch {
            this.logger.warn(`Failed to parse SSE line: ${line}`);
          }
        }
      }

      this.logger.log(`âœ… OpenAI stream completed`);
    } catch (error) {
      this.logger.error(
        `âŒ OpenAI stream failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  async testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean> {
    try {
      const baseUrl = customEndpoint || this.defaultBaseUrl;
      await axios.get(`${baseUrl}/models`, {
        headers: { Authorization: `Bearer ${apiKey}` },
        timeout: 10000,
      });
      this.logger.log('âœ… OpenAI API key validation successful');
      return true;
    } catch {
      this.logger.warn('OpenAI API key validation failed');
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    const dbModels = await this.getModelsFromDb(LLMProvider.OPENAI);
    if (dbModels.length > 0) {
      this.logger.debug(`Loaded ${dbModels.length} OpenAI models from database`);
      return dbModels;
    }

    const fallbackModels = [
      'gpt-5',
      'gpt-5-mini',
      'gpt-5-nano',
      'gpt-5-pro',
      'gpt-4.1',
      'gpt-4.1-mini',
      'gpt-4.1-nano',
      'o3',
      'o3-pro',
      'o4-mini',
      'gpt-4o',
      'gpt-4o-mini',
    ];

    this.logger.debug(`Using ${fallbackModels.length} fallback OpenAI models`);
    return fallbackModels;
  }
}

```

### `apps\backend\src\v1\execution\providers\provider.factory.ts`

```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../../prisma/prisma.service';
import { LLMProvider, ProviderAPIKey } from '@actopod/schema';
import { OpenAIProvider } from './openai.provider';
import { AnthropicProvider } from './anthropic.provider';
import { GeminiProvider } from './gemini.provider';
import * as crypto from 'crypto';
import { ILLMProvider } from '../types/llm-provider.types';

/**
 * PRODUCTION-GRADE Provider Factory with:
 * - AES-256-GCM encryption for API keys
 * - Backward compatibility for old 16-byte IV format
 * - New 12-byte IV format (GCM standard)
 * - BYOK (Bring Your Own Key) support
 * - Usage tracking with fallback
 * - Circuit breaker pattern
 * - Comprehensive error handling
 */
@Injectable()
export class ProviderFactory implements OnModuleInit {
  private readonly logger = new Logger(ProviderFactory.name);
  private readonly encryptionKey: Buffer;
  private readonly encryptionAlgorithm = 'aes-256-gcm';
  private readonly NEW_IV_LENGTH = 12; // 96-bit IV for GCM (recommended)
  private readonly OLD_IV_LENGTH = 16; // 128-bit IV (legacy)
  private readonly AUTH_TAG_LENGTH = 16; // 128-bit auth tag

  // Circuit breaker state
  private readonly circuitBreaker = new Map<string, { failures: number; lastFailure: number }>();
  private readonly CIRCUIT_BREAKER_THRESHOLD = 5; // Failures before opening circuit
  private readonly CIRCUIT_BREAKER_TIMEOUT = 60000; // 1 minute cooldown

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
  ) {
    this.encryptionKey = this.initializeEncryption();
  }

  async onModuleInit() {
    await this.runHealthCheck();
  }

  /**
   * Initialize encryption with comprehensive validation
   */
  private initializeEncryption(): Buffer {
    try {
      const key = this.configService.get<string>('API_KEY_ENCRYPTION_SECRET');

      if (!key) {
        const errorMsg =
          'CRITICAL: API_KEY_ENCRYPTION_SECRET environment variable is not set. ' +
          "Generate one using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"";
        this.logger.error(errorMsg);
        throw new Error(errorMsg);
      }

      // Validate key format
      if (!/^[0-9a-fA-F]{64}$/.test(key)) {
        throw new Error(
          'API_KEY_ENCRYPTION_SECRET must be a 64-character hexadecimal string (32 bytes). ' +
            "Generate using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"",
        );
      }

      const keyBuffer = Buffer.from(key, 'hex');

      if (keyBuffer.length !== 32) {
        throw new Error(
          `API_KEY_ENCRYPTION_SECRET must be exactly 32 bytes (64 hex characters). Current: ${keyBuffer.length} bytes`,
        );
      }

      this.logger.log('âœ… Encryption key validated successfully');
      return keyBuffer;
    } catch (error) {
      this.logger.error('Failed to initialize encryption:', error);
      throw error;
    }
  }

  /**
   * Get provider instance with validation and caching
   */
  getProvider(provider: LLMProvider): ILLMProvider {
    try {
      if (!provider || typeof provider !== 'string') {
        throw new Error('Invalid provider: Provider must be a non-empty string');
      }

      switch (provider) {
        case LLMProvider.OPENAI:
          return new OpenAIProvider(this.prisma);
        case LLMProvider.ANTHROPIC:
          return new AnthropicProvider(this.prisma);
        case LLMProvider.GOOGLE_GEMINI:
          return new GeminiProvider(this.prisma);
        default:
          throw new Error(
            `Unsupported provider: ${provider}. Supported providers: ${Object.values(LLMProvider).join(', ')}`,
          );
      }
    } catch (error) {
      this.logger.error(`Failed to get provider instance for ${provider}:`, error);
      throw error;
    }
  }

  /**
   * Get and decrypt workspace API key with circuit breaker
   */
  async getWorkspaceApiKey(
    workspaceId: string,
    provider: LLMProvider,
  ): Promise<{ apiKey: string; keyId: string; customEndpoint?: string } | null> {
    try {
      // Input validation
      if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.trim().length === 0) {
        throw new Error('Invalid workspaceId: Must be a non-empty string');
      }

      if (!provider || typeof provider !== 'string') {
        throw new Error('Invalid provider: Must be a valid LLMProvider enum value');
      }

      // Check circuit breaker
      const circuitKey = `${workspaceId}:${provider}`;
      if (this.isCircuitOpen(circuitKey)) {
        throw new Error(
          `Circuit breaker open for ${provider}. Too many recent failures. Please try again later.`,
        );
      }

      const apiKeyRecord = await this.prisma.providerAPIKey.findFirst({
        where: {
          workspaceId,
          provider,
          isActive: true,
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      if (!apiKeyRecord) {
        this.logger.debug(
          `No active API key found for workspace ${workspaceId} and provider ${provider}`,
        );
        return null;
      }

      // Validate key record
      if (!apiKeyRecord.keyHash || typeof apiKeyRecord.keyHash !== 'string') {
        this.logger.error(
          `Invalid keyHash for API key ${apiKeyRecord.id}: keyHash is missing or invalid`,
        );
        throw new Error('Stored API key data is corrupted');
      }

      // Decrypt API key with backward compatibility
      const decryptedKey = this.decryptApiKey(apiKeyRecord.keyHash);

      if (!decryptedKey || decryptedKey.length === 0) {
        throw new Error('Decryption produced empty API key');
      }

      // Reset circuit breaker on success
      this.resetCircuitBreaker(circuitKey);

      this.logger.debug(
        `Successfully retrieved and decrypted API key ${apiKeyRecord.id} for workspace ${workspaceId}`,
      );

      return {
        apiKey: decryptedKey,
        keyId: apiKeyRecord.id,
        customEndpoint: (apiKeyRecord as any).customEndpoint || undefined,
      };
    } catch (error) {
      // Record failure in circuit breaker
      const circuitKey = `${workspaceId}:${provider}`;
      this.recordFailure(circuitKey);

      this.logger.error(
        `Failed to get workspace API key for ${workspaceId}/${provider}:`,
        error instanceof Error ? error.message : error,
      );
      throw new Error(
        `Failed to retrieve API key: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Circuit breaker: Check if circuit is open
   */
  private isCircuitOpen(key: string): boolean {
    const state = this.circuitBreaker.get(key);
    if (!state) return false;

    const now = Date.now();
    const timeSinceLastFailure = now - state.lastFailure;

    // Reset if cooldown period has passed
    if (timeSinceLastFailure > this.CIRCUIT_BREAKER_TIMEOUT) {
      this.circuitBreaker.delete(key);
      return false;
    }

    return state.failures >= this.CIRCUIT_BREAKER_THRESHOLD;
  }

  /**
   * Circuit breaker: Record failure
   */
  private recordFailure(key: string): void {
    const state = this.circuitBreaker.get(key) || { failures: 0, lastFailure: 0 };
    state.failures += 1;
    state.lastFailure = Date.now();
    this.circuitBreaker.set(key, state);

    if (state.failures >= this.CIRCUIT_BREAKER_THRESHOLD) {
      this.logger.warn(`Circuit breaker opened for ${key} after ${state.failures} failures`);
    }
  }

  /**
   * Circuit breaker: Reset on success
   */
  private resetCircuitBreaker(key: string): void {
    this.circuitBreaker.delete(key);
  }

  /**
   * Encrypt API key using AES-256-GCM with NEW 12-byte IV format
   */
  encryptApiKey(plaintext: string): string {
    try {
      // Input validation
      if (!plaintext || typeof plaintext !== 'string') {
        throw new Error('Invalid plaintext: Must be a non-empty string');
      }

      if (plaintext.trim().length === 0) {
        throw new Error('Cannot encrypt empty API key');
      }

      // Generate cryptographically secure 12-byte IV (GCM standard)
      const iv = crypto.randomBytes(this.NEW_IV_LENGTH);

      // Create cipher
      const cipher = crypto.createCipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);

      // Encrypt
      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      // Get authentication tag
      const authTag = cipher.getAuthTag();

      // Validate auth tag length
      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(
          `Invalid auth tag length: expected ${this.AUTH_TAG_LENGTH}, got ${authTag.length}`,
        );
      }

      // Format: iv:authTag:encrypted
      const result = `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;

      this.logger.debug('API key encrypted successfully with 12-byte IV');
      return result;
    } catch (error) {
      this.logger.error('Failed to encrypt API key:', error);
      throw new Error(
        `Encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Decrypt API key with BACKWARD COMPATIBILITY for both 12-byte and 16-byte IV formats
   */
  private decryptApiKey(encryptedData: string): string {
    try {
      // Input validation
      if (!encryptedData || typeof encryptedData !== 'string') {
        throw new Error('Invalid encrypted data: Must be a non-empty string');
      }

      // Parse encrypted data
      const parts = encryptedData.split(':');

      if (parts.length !== 3) {
        throw new Error(
          `Invalid encrypted data format: Expected 3 parts (iv:authTag:encrypted), got ${parts.length}`,
        );
      }

      const [ivHex, authTagHex, encrypted] = parts;

      // Validate parts
      if (!ivHex || !authTagHex || !encrypted) {
        throw new Error('One or more encrypted data components are empty');
      }

      // Validate hex format
      if (
        !/^[0-9a-fA-F]+$/.test(ivHex) ||
        !/^[0-9a-fA-F]+$/.test(authTagHex) ||
        !/^[0-9a-fA-F]+$/.test(encrypted)
      ) {
        throw new Error('Encrypted data contains invalid hexadecimal characters');
      }

      // Convert from hex
      const iv = Buffer.from(ivHex, 'hex');
      const authTag = Buffer.from(authTagHex, 'hex');

      // Determine IV format (backward compatibility)
      const ivLength = iv.length;

      if (ivLength !== this.NEW_IV_LENGTH && ivLength !== this.OLD_IV_LENGTH) {
        throw new Error(
          `Invalid IV length: expected ${this.NEW_IV_LENGTH} bytes (new format) or ${this.OLD_IV_LENGTH} bytes (legacy format), got ${ivLength} bytes`,
        );
      }

      // Log if using legacy format
      if (ivLength === this.OLD_IV_LENGTH) {
        this.logger.warn(
          `Decrypting API key with legacy 16-byte IV format. Consider re-encrypting with the new 12-byte format.`,
        );
      }

      // Validate auth tag length
      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(
          `Invalid auth tag length: expected ${this.AUTH_TAG_LENGTH} bytes, got ${authTag.length}`,
        );
      }

      // Create decipher
      const decipher = crypto.createDecipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);

      decipher.setAuthTag(authTag);

      // Decrypt
      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      if (!decrypted || decrypted.length === 0) {
        throw new Error('Decryption produced empty result');
      }

      this.logger.debug(`API key decrypted successfully (IV length: ${ivLength} bytes)`);
      return decrypted;
    } catch (error) {
      this.logger.error(
        'Failed to decrypt API key:',
        error instanceof Error ? error.message : error,
      );

      // Provide helpful error messages
      if (error instanceof Error) {
        if (error.message.includes('Unsupported state') || error.message.includes('auth')) {
          throw new Error('Authentication failed: API key may be corrupted or tampered with');
        }
        if (error.message.includes('bad decrypt')) {
          throw new Error('Decryption failed: Incorrect encryption key or corrupted data');
        }
      }

      throw new Error(
        `Decryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Track API key usage with comprehensive error handling and fallbacks
   */
  async trackApiKeyUsage(
    keyId: string,
    tokens: { input: number; output: number; reasoning?: number },
    cost: number,
    success: boolean,
  ): Promise<void> {
    try {
      // Input validation
      if (!keyId || typeof keyId !== 'string' || keyId.trim().length === 0) {
        throw new Error('Invalid keyId: Must be a non-empty string');
      }

      // Validate tokens
      if (typeof tokens.input !== 'number' || tokens.input < 0) {
        throw new Error(`Invalid input tokens: ${tokens.input}`);
      }
      if (typeof tokens.output !== 'number' || tokens.output < 0) {
        throw new Error(`Invalid output tokens: ${tokens.output}`);
      }
      if (
        tokens.reasoning !== undefined &&
        (typeof tokens.reasoning !== 'number' || tokens.reasoning < 0)
      ) {
        throw new Error(`Invalid reasoning tokens: ${tokens.reasoning}`);
      }

      // Validate cost
      if (typeof cost !== 'number' || cost < 0) {
        throw new Error(`Invalid cost: ${cost}`);
      }

      const totalTokens = tokens.input + tokens.output + (tokens.reasoning || 0);

      // Update API key stats with transaction
      await this.prisma.$transaction(
        async (tx) => {
          // Update API key
          await tx.providerAPIKey.update({
            where: { id: keyId },
            data: {
              lastUsedAt: new Date(),
              usageCount: { increment: 1 },
              totalTokens: { increment: BigInt(totalTokens) },
              totalCost: { increment: cost },
              ...(success ? {} : { lastErrorAt: new Date() }),
            },
          });

          // Get workspace ID
          const apiKey = await tx.providerAPIKey.findUnique({
            where: { id: keyId },
            select: { workspaceId: true },
          });

          if (!apiKey) {
            throw new Error(`API key ${keyId} not found`);
          }

          // Update daily metrics
          const today = new Date();
          today.setHours(0, 0, 0, 0);

          await tx.usageMetric.upsert({
            where: {
              keyId_date: {
                keyId,
                date: today,
              },
            },
            create: {
              keyId,
              workspaceId: apiKey.workspaceId,
              date: today,
              requestCount: 1,
              successCount: success ? 1 : 0,
              errorCount: success ? 0 : 1,
              promptTokens: BigInt(tokens.input),
              completionTokens: BigInt(tokens.output + (tokens.reasoning || 0)),
              totalTokens: BigInt(totalTokens),
              estimatedCost: cost,
            },
            update: {
              requestCount: { increment: 1 },
              successCount: success ? { increment: 1 } : undefined,
              errorCount: success ? undefined : { increment: 1 },
              promptTokens: { increment: BigInt(tokens.input) },
              completionTokens: { increment: BigInt(tokens.output + (tokens.reasoning || 0)) },
              totalTokens: { increment: BigInt(totalTokens) },
              estimatedCost: { increment: cost },
            },
          });
        },
        {
          timeout: 10000, // 10 second timeout
        },
      );

      this.logger.debug(
        `âœ… Usage tracked for key ${keyId}: ${totalTokens} tokens, $${cost.toFixed(6)}, success=${success}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to track usage for key ${keyId}:`,
        error instanceof Error ? error.message : error,
      );

      // Don't throw - tracking failure shouldn't break execution
      this.logger.warn('Usage tracking failure will not affect execution flow');
    }
  }

  /**
   * Get all active API keys for workspace with error handling
   */
  async getWorkspaceApiKeys(workspaceId: string): Promise<ProviderAPIKey[]> {
    try {
      // Input validation
      if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.trim().length === 0) {
        throw new Error('Invalid workspaceId: Must be a non-empty string');
      }

      const keys = await this.prisma.providerAPIKey.findMany({
        where: {
          workspaceId,
          isActive: true,
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      this.logger.debug(`Retrieved ${keys.length} active API keys for workspace ${workspaceId}`);
      return keys;
    } catch (error) {
      this.logger.error(
        `Failed to get workspace API keys for ${workspaceId}:`,
        error instanceof Error ? error.message : error,
      );
      throw new Error(
        `Failed to retrieve API keys: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Health check for encryption system (run on startup)
   */
  private async runHealthCheck(): Promise<void> {
    try {
      // Test encryption/decryption
      const testData = 'test-api-key-' + Date.now();
      const encrypted = this.encryptApiKey(testData);
      const decrypted = this.decryptApiKey(encrypted);

      if (decrypted !== testData) {
        throw new Error('Encryption round-trip test failed');
      }

      // Test database connection
      await this.prisma.$queryRaw`SELECT 1`;

      this.logger.log('âœ… Provider factory health check passed');
    } catch (error) {
      this.logger.error('âŒ Provider factory health check failed:', error);
      throw error;
    }
  }

  /**
   * Health check endpoint for monitoring
   */
  async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; details: string }> {
    try {
      await this.runHealthCheck();
      return {
        status: 'healthy',
        details: 'Encryption and database connectivity verified',
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}

```

### `apps\backend\src\v1\execution\providers\provider.module.ts`

```typescript
// execution/providers/provider.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { ProviderFactory } from './provider.factory';
import { OpenAIProvider } from './openai.provider';
import { AnthropicProvider } from './anthropic.provider';
import { GeminiProvider } from './gemini.provider';
import { PrismaModule } from '../../../prisma/prisma.module';

@Module({
  imports: [PrismaModule, ConfigModule],
  providers: [ProviderFactory, OpenAIProvider, AnthropicProvider, GeminiProvider],
  exports: [ProviderFactory],
})
export class ProviderModule {}

```

### `apps\backend\src\v1\execution\types\llm-provider.types.ts`

```typescript
// types/llm-provider.types.ts

import { LLMProvider } from '@actopod/schema';

export interface LLMRequest {
  provider: LLMProvider;
  model: string;
  messages: Array<{ role: string; content: string | any }>;
  apiKey: string;
  customEndpoint?: string;
  apiKeyId?: string;
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;
  thinkingBudget?: number;
  responseFormat?: 'text' | 'json_object' | 'json';
  stream?: boolean; // NEW: Enable streaming
}

export interface LLMResponse {
  id: string;
  model: string;
  provider: LLMProvider;
  content: string;
  finishReason: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    reasoningTokens?: number;
    cachedTokens?: number;
  };
  rawResponse: any;
  timestamp: Date;
}

// NEW: Streaming chunk interface
export interface LLMStreamChunk {
  type: 'start' | 'token' | 'done' | 'error';
  content?: string;
  usage?: LLMResponse['usage'];
  finishReason?: string;
  error?: string;
}

export interface ILLMProvider {
  execute(request: LLMRequest): Promise<LLMResponse>;
  executeStream?(request: LLMRequest): AsyncGenerator<LLMStreamChunk>; // NEW: Stream method
  testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean>;
  getAvailableModels(): Promise<string[]>;
}

```

### `apps\backend\src\v1\flow\dto\add-collaborator.dto.ts`

```typescript
import { IsString, IsEmail, IsEnum, IsOptional } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { FlowAccessLevel } from '@actopod/schema';

export class AddCollaboratorDto {
  @ApiProperty({ example: 'user@example.com' })
  @IsEmail()
  email!: string;

  @ApiPropertyOptional({ enum: FlowAccessLevel, default: FlowAccessLevel.EDITOR })
  @IsOptional()
  @IsEnum(FlowAccessLevel)
  accessLevel?: FlowAccessLevel;

  @ApiPropertyOptional({ example: 'Can view and edit this workflow' })
  @IsOptional()
  @IsString()
  message?: string;
}

```

### `apps\backend\src\v1\flow\dto\create-flow.dto.ts`

```typescript
import { IsString, IsOptional, IsEnum, MaxLength, MinLength } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility } from '@actopod/schema';

export class CreateFlowDto {
  @ApiProperty({ example: 'My AI Workflow' })
  @IsString()
  @MinLength(1)
  @MaxLength(255)
  name!: string;

  @ApiPropertyOptional({ example: 'A multi-LLM workflow for content generation' })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  description?: string;

  @ApiPropertyOptional({ description: 'Space ID where this flow belongs' })
  @IsOptional()
  @IsString()
  spaceId?: string;

  @ApiPropertyOptional({ enum: FlowVisibility, default: 'PRIVATE' })
  @IsOptional()
  @IsEnum(FlowVisibility)
  visibility?: FlowVisibility = FlowVisibility.PRIVATE;
}

```

### `apps\backend\src\v1\flow\dto\flow-query.dto.ts`

```typescript
import { IsOptional, IsEnum, IsString, IsInt, Min, Max } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility } from '@actopod/schema';

export class FlowQueryDto {
  @ApiPropertyOptional({ example: 1, minimum: 1, default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page: number = 1;

  @ApiPropertyOptional({ example: 20, minimum: 1, maximum: 100, default: 20 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit: number = 20;

  @ApiPropertyOptional({ example: 'My Flow' })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ enum: FlowVisibility })
  @IsOptional()
  @IsEnum(FlowVisibility)
  visibility?: FlowVisibility;

  @ApiPropertyOptional({ description: 'Space ID to filter by' })
  @IsOptional()
  @IsString()
  spaceId?: string;

  get skip(): number {
    return (this.page - 1) * this.limit;
  }
}

```

### `apps\backend\src\v1\flow\dto\flow-response.dto.ts`

```typescript
import { Expose, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility, FlowAccessLevel, FlowActivityAction } from '@actopod/schema';

/**
 * Flow Response DTO
 * Represents a complete flow with metadata
 */
export class FlowResponseDto {
  @ApiProperty({
    description: 'Unique flow identifier',
    example: 'flow_clx123abc456',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'Workspace ID this flow belongs to',
    example: 'ws_clx789def012',
  })
  @Expose()
  workspaceId!: string;

  @ApiPropertyOptional({
    description: 'Space ID (folder) this flow is organized under',
    example: 'space_clx345ghi678',
    nullable: true,
  })
  @Expose()
  spaceId!: string | null;

  @ApiProperty({
    description: 'Flow name',
    example: 'Customer Support Automation',
    maxLength: 255,
  })
  @Expose()
  name!: string;

  @ApiPropertyOptional({
    description: 'Flow description',
    example: 'Automates customer support responses using GPT-4',
    maxLength: 500,
    nullable: true,
  })
  @Expose()
  description!: string | null;

  @ApiProperty({
    description: 'Flow visibility level',
    enum: FlowVisibility,
    example: FlowVisibility.PRIVATE,
    default: FlowVisibility.PRIVATE,
  })
  @Expose()
  visibility!: FlowVisibility;

  @ApiProperty({
    description: 'User ID of the flow creator',
    example: 'user_clx901jkl234',
  })
  @Expose()
  createdBy!: string;

  @ApiProperty({
    description: 'Flow creation timestamp',
    example: '2025-10-25T00:00:00.000Z',
    type: Date,
  })
  @Expose()
  createdAt!: Date;

  @ApiProperty({
    description: 'Last update timestamp',
    example: '2025-10-25T00:30:00.000Z',
    type: Date,
  })
  @Expose()
  updatedAt!: Date;

  @ApiProperty({
    description: 'Number of pods (nodes) in this flow',
    example: 15,
    minimum: 0,
  })
  @Expose()
  podCount!: number;

  @ApiProperty({
    description: 'Number of collaborators with access to this flow',
    example: 3,
    minimum: 0,
  })
  @Expose()
  collaboratorCount!: number;

  @ApiPropertyOptional({
    description: 'S3 key for flow thumbnail image',
    example: 'thumbnails/flow_clx123abc456.png',
    nullable: true,
  })
  @Expose()
  thumbnailS3Key!: string | null;

  @ApiPropertyOptional({
    description: 'Timestamp when thumbnail was last generated',
    example: '2025-10-25T00:15:00.000Z',
    type: Date,
    nullable: true,
  })
  @Expose()
  thumbnailGeneratedAt!: Date | null;
}

/**
 * Pagination Metadata DTO
 */
export class FlowPaginationDto {
  @ApiProperty({
    description: 'Total number of items across all pages',
    example: 47,
    minimum: 0,
  })
  @Expose()
  totalItems!: number;

  @ApiProperty({
    description: 'Total number of pages',
    example: 3,
    minimum: 0,
  })
  @Expose()
  totalPages!: number;

  @ApiProperty({
    description: 'Current page number (1-indexed)',
    example: 1,
    minimum: 1,
  })
  @Expose()
  currentPage!: number;

  @ApiProperty({
    description: 'Number of items on current page',
    example: 20,
    minimum: 0,
  })
  @Expose()
  pageSize!: number;
}

/**
 * Paginated Flow Response DTO
 */
export class FlowPaginatedResponseDto {
  @ApiProperty({
    description: 'Array of flow objects',
    type: [FlowResponseDto],
    isArray: true,
  })
  @Expose()
  @Type(() => FlowResponseDto)
  data!: FlowResponseDto[];

  @ApiProperty({
    description: 'Pagination metadata',
    type: FlowPaginationDto,
  })
  @Expose()
  @Type(() => FlowPaginationDto)
  pagination!: FlowPaginationDto;
}

/**
 * User Info DTO (Embedded in Collaborator Response)
 */
export class UserInfoDto {
  @ApiProperty({
    description: 'User ID',
    example: 'user_clx901jkl234',
  })
  id!: string;

  @ApiPropertyOptional({
    description: 'User display name',
    example: 'John Doe',
    nullable: true,
  })
  name!: string | null;

  @ApiProperty({
    description: 'User email address',
    example: 'john.doe@example.com',
  })
  email!: string;

  @ApiPropertyOptional({
    description: 'User profile image URL',
    example: 'https://example.com/avatar.jpg',
    nullable: true,
  })
  image!: string | null;
}

/**
 * Flow Collaborator Response DTO
 */
export class CollaboratorResponseDto {
  @ApiProperty({
    description: 'Collaborator record ID',
    example: 'collab_clx567mno890',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'User ID of the collaborator',
    example: 'user_clx901jkl234',
  })
  @Expose()
  userId!: string;

  @ApiProperty({
    description: 'Flow ID this collaboration is for',
    example: 'flow_clx123abc456',
  })
  @Expose()
  flowId!: string;

  @ApiProperty({
    description: 'Access level assigned to collaborator',
    enum: FlowAccessLevel,
    example: FlowAccessLevel.EDITOR,
  })
  @Expose()
  accessLevel!: FlowAccessLevel;

  @ApiProperty({
    description: 'Can edit flow content (pods, edges)',
    example: true,
    default: true,
  })
  @Expose()
  canEdit!: boolean;

  @ApiProperty({
    description: 'Can execute pods (run LLM queries)',
    example: true,
    default: true,
  })
  @Expose()
  canExecute!: boolean;

  @ApiProperty({
    description: 'Can delete pods and edges',
    example: false,
    default: false,
  })
  @Expose()
  canDelete!: boolean;

  @ApiProperty({
    description: 'Can share flow with others',
    example: false,
    default: false,
  })
  @Expose()
  canShare!: boolean;

  @ApiProperty({
    description: 'Can invite new collaborators',
    example: false,
    default: false,
  })
  @Expose()
  canInvite!: boolean;

  @ApiProperty({
    description: 'Timestamp when collaborator was invited',
    example: '2025-10-24T12:00:00.000Z',
    type: Date,
  })
  @Expose()
  invitedAt!: Date;

  @ApiPropertyOptional({
    description: 'Timestamp of last view/access',
    example: '2025-10-24T18:30:00.000Z',
    type: Date,
    nullable: true,
  })
  @Expose()
  lastViewedAt!: Date | null;

  @ApiProperty({
    description: 'Collaborator user information',
    type: UserInfoDto,
  })
  @Expose()
  @Type(() => UserInfoDto)
  user!: UserInfoDto;
}

/**
 * User Info DTO (for Activity Log)
 */
export class ActivityUserInfoDto {
  @ApiProperty({
    description: 'User ID',
    example: 'user_clx901jkl234',
  })
  id!: string;

  @ApiPropertyOptional({
    description: 'User display name',
    example: 'John Doe',
    nullable: true,
  })
  name!: string | null;

  @ApiProperty({
    description: 'User email address',
    example: 'john.doe@example.com',
  })
  email!: string;
}

/**
 * Flow Activity Log Response DTO
 */
export class ActivityLogResponseDto {
  @ApiProperty({
    description: 'Activity log entry ID',
    example: 'activity_clx789pqr012',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'Flow ID this activity belongs to',
    example: 'flow_clx123abc456',
  })
  @Expose()
  flowId!: string;

  @ApiPropertyOptional({
    description: 'User ID who performed the action',
    example: 'user_clx901jkl234',
    nullable: true,
  })
  @Expose()
  userId!: string | null;

  @ApiProperty({
    description: 'Type of action performed',
    enum: FlowActivityAction,
    example: FlowActivityAction.FLOW_UPDATED,
  })
  @Expose()
  action!: FlowActivityAction;

  @ApiPropertyOptional({
    description: 'Type of entity affected (pod, edge, collaborator, etc.)',
    example: 'pod',
    nullable: true,
  })
  @Expose()
  entityType!: string | null;

  @ApiPropertyOptional({
    description: 'ID of the affected entity',
    example: 'pod_clx456stu789',
    nullable: true,
  })
  @Expose()
  entityId!: string | null;

  @ApiPropertyOptional({
    description: 'JSON object containing change details',
    example: { name: 'Updated Flow Name', visibility: 'WORKSPACE' },
    nullable: true,
  })
  @Expose()
  changeData!: any;

  @ApiProperty({
    description: 'Timestamp when action was performed',
    example: '2025-10-24T15:45:00.000Z',
    type: Date,
  })
  @Expose()
  createdAt!: Date;

  @ApiPropertyOptional({
    description: 'User who performed the action (null for system actions)',
    type: ActivityUserInfoDto,
    nullable: true,
  })
  @Expose()
  @Type(() => ActivityUserInfoDto)
  user!: ActivityUserInfoDto | null;
}

```

### `apps\backend\src\v1\flow\dto\update-collaborator.dto.ts`

```typescript
import { IsEnum, IsBoolean, IsOptional } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { FlowAccessLevel } from '@actopod/schema';

export class UpdateCollaboratorDto {
  @ApiPropertyOptional({ enum: FlowAccessLevel })
  @IsOptional()
  @IsEnum(FlowAccessLevel)
  accessLevel?: FlowAccessLevel;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canEdit?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canExecute?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canDelete?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canShare?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canInvite?: boolean;
}

```

### `apps\backend\src\v1\flow\dto\update-flow.dto.ts`

```typescript
import { IsString, IsOptional, IsEnum, MaxLength, MinLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility } from '@actopod/schema';

export class UpdateFlowDto {
  @ApiPropertyOptional({ example: 'My Updated Workflow' })
  @IsOptional()
  @IsString()
  @MinLength(1)
  @MaxLength(255)
  name?: string;

  @ApiPropertyOptional({ example: 'Updated description' })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  description?: string;

  @ApiPropertyOptional({ description: 'Space ID' })
  @IsOptional()
  @IsString()
  spaceId?: string;

  @ApiPropertyOptional({ enum: FlowVisibility })
  @IsOptional()
  @IsEnum(FlowVisibility)
  visibility?: FlowVisibility;
}

```

### `apps\backend\src\v1\flow\flow.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
  ValidationPipe,
  ParseIntPipe,
  DefaultValuePipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
  ApiNotFoundResponse,
  ApiForbiddenResponse,
} from '@nestjs/swagger';
import { V1FlowService } from './flow.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { CreateFlowDto } from './dto/create-flow.dto';
import { UpdateFlowDto } from './dto/update-flow.dto';
import { FlowQueryDto } from './dto/flow-query.dto';
import { AddCollaboratorDto } from './dto/add-collaborator.dto';
import { UpdateCollaboratorDto } from './dto/update-collaborator.dto';
import {
  FlowResponseDto,
  FlowPaginatedResponseDto,
  CollaboratorResponseDto,
  ActivityLogResponseDto,
} from './dto/flow-response.dto';

@ApiTags('Flows')
@ApiBearerAuth('JWT')
@Controller({
  path: 'workspaces/:workspaceId/flows',
  version: '1',
})
@ApiUnauthorizedResponse({ description: 'Unauthorized' })
export class V1FlowController {
  constructor(private readonly flowService: V1FlowService) {}

  // ==================== FLOW CRUD ====================

  @Get()
  @ApiOperation({
    summary: 'Get all flows in workspace',
    description:
      'Returns paginated list of flows user has access to (owned, shared, or workspace-visible)',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Flows fetched successfully',
    type: FlowPaginatedResponseDto,
  })
  async getFlows(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Query(ValidationPipe) query: FlowQueryDto,
  ): Promise<FlowPaginatedResponseDto> {
    return this.flowService.getWorkspaceFlows(workspaceId, userId, query);
  }

  @Get(':id')
  @ApiOperation({
    summary: 'Get flow by ID',
    description: 'Returns detailed flow information including pod count and collaborators',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Flow fetched successfully',
    type: FlowResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Flow not found' })
  @ApiForbiddenResponse({ description: 'Access denied' })
  async getFlow(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<FlowResponseDto> {
    return this.flowService.getFlowById(flowId, workspaceId, userId);
  }

  @Post()
  @ApiOperation({
    summary: 'Create a new flow',
    description: 'Creates a new workflow canvas in the workspace',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiResponse({
    status: 201,
    description: 'Flow created successfully',
    type: FlowResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Invalid input or space not found' })
  async createFlow(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: CreateFlowDto,
  ): Promise<FlowResponseDto> {
    return this.flowService.createFlow(workspaceId, userId, dto);
  }

  @Patch(':id')
  @ApiOperation({
    summary: 'Update a flow',
    description: 'Updates flow metadata (name, description, space, visibility)',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Flow updated successfully',
    type: FlowResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Flow not found' })
  @ApiForbiddenResponse({ description: 'Edit permission required' })
  async updateFlow(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: UpdateFlowDto,
  ): Promise<FlowResponseDto> {
    return this.flowService.updateFlow(flowId, workspaceId, userId, dto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete a flow',
    description: 'Permanently deletes a flow and all associated data (pods, edges, activity logs)',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({ status: 204, description: 'Flow deleted successfully' })
  @ApiNotFoundResponse({ description: 'Flow not found' })
  @ApiForbiddenResponse({ description: 'Only owner can delete flow' })
  async deleteFlow(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.flowService.deleteFlow(flowId, workspaceId, userId);
  }

  // ==================== COLLABORATORS ====================

  @Get(':id/collaborators')
  @ApiOperation({
    summary: 'Get flow collaborators',
    description: 'Returns list of all users with access to this flow',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Collaborators fetched successfully',
    type: [CollaboratorResponseDto],
  })
  @ApiForbiddenResponse({ description: 'View permission required' })
  async getCollaborators(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<CollaboratorResponseDto[]> {
    return this.flowService.getFlowCollaborators(flowId, workspaceId, userId);
  }

  @Post(':id/collaborators')
  @ApiOperation({
    summary: 'Add collaborator to flow',
    description: 'Invites a user to collaborate on this flow',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 201,
    description: 'Collaborator added successfully',
    type: CollaboratorResponseDto,
  })
  @ApiBadRequestResponse({ description: 'User not found or already collaborator' })
  @ApiForbiddenResponse({ description: 'Invite permission required' })
  async addCollaborator(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: AddCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    return this.flowService.addCollaborator(flowId, workspaceId, userId, dto);
  }

  @Patch(':id/collaborators/:collaboratorId')
  @ApiOperation({
    summary: 'Update collaborator permissions',
    description: 'Changes access level and granular permissions for a collaborator',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiParam({ name: 'collaboratorId', description: 'Collaborator record ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Collaborator permissions updated',
    type: CollaboratorResponseDto,
  })
  @ApiForbiddenResponse({ description: 'Manage permission required' })
  async updateCollaborator(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @Param('collaboratorId') collaboratorId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: UpdateCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    return this.flowService.updateCollaborator(flowId, collaboratorId, workspaceId, userId, dto);
  }

  @Delete(':id/collaborators/:collaboratorId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Remove collaborator from flow',
    description: 'Revokes access for a collaborator',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiParam({ name: 'collaboratorId', description: 'Collaborator record ID', type: String })
  @ApiResponse({ status: 204, description: 'Collaborator removed successfully' })
  @ApiForbiddenResponse({ description: 'Manage permission required' })
  async removeCollaborator(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @Param('collaboratorId') collaboratorId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.flowService.removeCollaborator(flowId, collaboratorId, workspaceId, userId);
  }

  // ==================== ACTIVITY LOG ====================

  @Get(':id/activity')
  @ApiOperation({
    summary: 'Get flow activity log',
    description: 'Returns chronological list of all actions performed on this flow',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Activity log fetched successfully',
    type: [ActivityLogResponseDto],
  })
  async getActivity(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
    @Query('limit', new DefaultValuePipe(50), ParseIntPipe) limit: number,
  ): Promise<ActivityLogResponseDto[]> {
    return this.flowService.getFlowActivity(flowId, workspaceId, userId, limit);
  }
}

```

### `apps\backend\src\v1\flow\flow.gateway.ts`

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, UseFilters } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { WsExceptionFilter } from '../../common/filters/ws-exception.filter';

interface FlowSession {
  userId: string;
  socketId: string;
  flowId: string;
  userName?: string;
  userColor?: string;
  joinedAt: Date;
}

/**
 * PRODUCTION-GRADE WebSocket Gateway for Flow Canvas
 * Features:
 * - Real-time collaboration
 * - Pod execution streaming
 * - Presence tracking
 * - Error handling
 * - Rate limiting
 * - Heartbeat monitoring
 */
@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true,
  },
  namespace: 'flows',
  transports: ['websocket', 'polling'],
  pingInterval: 25000, // 25 seconds
  pingTimeout: 60000, // 1 minute
  maxHttpBufferSize: 1e6, // 1MB
  perMessageDeflate: true,
})
@UseFilters(new WsExceptionFilter())
export class V1FlowGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server!: Server;

  private readonly logger = new Logger(V1FlowGateway.name);
  private flowSessions = new Map<string, Map<string, FlowSession>>();

  // Rate limiting: max events per second per client
  private readonly rateLimitMap = new Map<string, { count: number; resetTime: number }>();
  private readonly RATE_LIMIT = 100; // 100 events per second
  private readonly RATE_LIMIT_WINDOW = 1000; // 1 second

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  afterInit(): void {
    this.logger.log('ðŸ”Œ Flow WebSocket Gateway initialized');

    // Cleanup stale sessions every 5 minutes
    setInterval(() => this.cleanupStaleSessions(), 5 * 60 * 1000);
  }

  // ==================== CONNECTION MANAGEMENT ====================

  async handleConnection(client: Socket): Promise<void> {
    try {
      const token =
        client.handshake.auth?.token ||
        client.handshake.headers?.authorization?.replace('Bearer ', '') ||
        client.handshake.query?.token;

      if (!token) {
        this.logger.warn(`âŒ Client ${client.id}: No token provided`);
        client.emit('error', { message: 'Authentication required', code: 'NO_TOKEN' });
        client.disconnect(true);
        return;
      }

      const secret = this.configService.get<string>('JWT_ACCESS_TOKEN_SECRET');

      if (!secret) {
        this.logger.error('JWT_ACCESS_TOKEN_SECRET not configured');
        client.disconnect(true);
        return;
      }

      const payload = await this.jwtService.verifyAsync(token, { secret });
      const userId = payload.userId || payload.sub;

      if (!userId) {
        this.logger.warn(`âŒ Client ${client.id}: Invalid token payload`);
        client.emit('error', { message: 'Invalid token', code: 'INVALID_TOKEN' });
        client.disconnect(true);
        return;
      }

      // Store user data on socket
      client.data.userId = userId;
      client.data.connectedAt = new Date();

      // Send connection confirmation
      client.emit('connected', {
        message: 'Connected to flows',
        userId,
        serverTime: new Date().toISOString(),
      });

      this.logger.log(`âœ… User ${userId} connected (socket: ${client.id})`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Authentication failed';
      this.logger.error(`âŒ Connection failed for ${client.id}: ${errorMessage}`);
      client.emit('error', { message: 'Authentication failed', code: 'AUTH_ERROR' });
      client.disconnect(true);
    }
  }

  handleDisconnect(client: Socket): void {
    const userId = client.data.userId;
    const flowId = client.data.flowId;

    if (flowId && userId) {
      const sessions = this.flowSessions.get(flowId);
      if (sessions) {
        const session = sessions.get(client.id);
        sessions.delete(client.id);

        if (sessions.size === 0) {
          this.flowSessions.delete(flowId);
          this.logger.log(`ðŸ“Š Flow ${flowId} now empty, sessions cleared`);
        }

        // Notify others user left
        this.server.to(`flow:${flowId}`).emit('user:left', {
          userId,
          socketId: client.id,
          userName: session?.userName,
        });

        this.logger.log(`ðŸ”Œ User ${userId} left flow ${flowId}`);
      }
    }

    // Cleanup rate limiting
    this.rateLimitMap.delete(client.id);
  }

  // ==================== FLOW ROOM MANAGEMENT ====================

  @SubscribeMessage('flow:join')
  async handleJoinFlow(
    @MessageBody() data: { flowId: string; userName?: string; userColor?: string },
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    try {
      if (!data.flowId || typeof data.flowId !== 'string') {
        client.emit('error', { message: 'Invalid flowId', code: 'INVALID_FLOW_ID' });
        return;
      }

      const { flowId, userName, userColor } = data;
      const userId = client.data.userId;

      // Leave previous flow if any
      if (client.data.flowId && client.data.flowId !== flowId) {
        await client.leave(`flow:${client.data.flowId}`);
      }

      // Join new flow room
      await client.join(`flow:${flowId}`);
      client.data.flowId = flowId;

      // Initialize flow sessions map
      if (!this.flowSessions.has(flowId)) {
        this.flowSessions.set(flowId, new Map());
      }

      const session: FlowSession = {
        userId,
        socketId: client.id,
        flowId,
        userName,
        userColor,
        joinedAt: new Date(),
      };

      this.flowSessions.get(flowId)!.set(client.id, session);

      // Notify others user joined
      client.to(`flow:${flowId}`).emit('user:joined', session);

      // Send current users to the new joiner
      const currentUsers = Array.from(this.flowSessions.get(flowId)!.values());
      client.emit('flow:users', currentUsers);

      this.logger.log(
        `ðŸ“Š User ${userId} joined flow ${flowId} (${currentUsers.length} total users)`,
      );
    } catch (error) {
      this.logger.error(`Failed to join flow:`, error);
      client.emit('error', { message: 'Failed to join flow', code: 'JOIN_ERROR' });
    }
  }

  @SubscribeMessage('flow:leave')
  handleLeaveFlow(@ConnectedSocket() client: Socket): void {
    const flowId = client.data.flowId;
    const userId = client.data.userId;

    if (flowId) {
      client.leave(`flow:${flowId}`);

      const sessions = this.flowSessions.get(flowId);
      if (sessions) {
        const session = sessions.get(client.id);
        sessions.delete(client.id);

        if (sessions.size === 0) {
          this.flowSessions.delete(flowId);
        }

        // Use session data when notifying others
        client.to(`flow:${flowId}`).emit('user:left', {
          userId,
          socketId: client.id,
          userName: session?.userName, // Include user name
        });
      } else {
        // Sessions not found, still notify
        client.to(`flow:${flowId}`).emit('user:left', {
          userId,
          socketId: client.id,
        });
      }

      client.data.flowId = null;
      this.logger.log(`ðŸ”Œ User ${userId} explicitly left flow ${flowId}`);
    }
  }

  // ==================== POD OPERATIONS ====================

  @SubscribeMessage('pod:create')
  handlePodCreate(@MessageBody() data: { pod: any }, @ConnectedSocket() client: Socket): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) {
      client.emit('error', { message: 'Not in a flow', code: 'NOT_IN_FLOW' });
      return;
    }

    // Broadcast to all OTHER users in the flow
    client.to(`flow:${flowId}`).emit('pod:created', {
      pod: data.pod,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ“¦ Pod created in flow ${flowId} by user ${client.data.userId}`);
  }

  @SubscribeMessage('pod:update')
  handlePodUpdate(
    @MessageBody() data: { podId: string; updates: any },
    @ConnectedSocket() client: Socket,
  ): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:updated', {
      podId: data.podId,
      updates: data.updates,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ“¦ Pod ${data.podId} updated in flow ${flowId}`);
  }

  @SubscribeMessage('pod:delete')
  handlePodDelete(@MessageBody() data: { podId: string }, @ConnectedSocket() client: Socket): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:deleted', {
      podId: data.podId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ“¦ Pod ${data.podId} deleted in flow ${flowId}`);
  }

  @SubscribeMessage('pod:move')
  handlePodMove(
    @MessageBody() data: { podId: string; position: { x: number; y: number } },
    @ConnectedSocket() client: Socket,
  ): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    // High-frequency event, only broadcast position
    client.to(`flow:${flowId}`).emit('pod:moved', {
      podId: data.podId,
      position: data.position,
      userId: client.data.userId,
    });
  }

  @SubscribeMessage('pod:lock')
  handlePodLock(@MessageBody() data: { podId: string }, @ConnectedSocket() client: Socket): void {
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:locked', {
      podId: data.podId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });
  }

  @SubscribeMessage('pod:unlock')
  handlePodUnlock(@MessageBody() data: { podId: string }, @ConnectedSocket() client: Socket): void {
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:unlocked', {
      podId: data.podId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });
  }

  // ==================== EDGE OPERATIONS ====================

  @SubscribeMessage('edge:create')
  handleEdgeCreate(@MessageBody() data: { edge: any }, @ConnectedSocket() client: Socket): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('edge:created', {
      edge: data.edge,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ”— Edge created in flow ${flowId}`);
  }

  @SubscribeMessage('edge:delete')
  handleEdgeDelete(
    @MessageBody() data: { edgeId: string },
    @ConnectedSocket() client: Socket,
  ): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('edge:deleted', {
      edgeId: data.edgeId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ”— Edge ${data.edgeId} deleted in flow ${flowId}`);
  }

  // ==================== CURSOR & SELECTION ====================

  @SubscribeMessage('cursor:move')
  handleCursorMove(
    @MessageBody() data: { position: { x: number; y: number } },
    @ConnectedSocket() client: Socket,
  ): void {
    // Very high-frequency event, skip rate limit check for cursors
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('cursor:updated', {
      userId: client.data.userId,
      position: data.position,
      socketId: client.id,
    });
  }

  @SubscribeMessage('selection:change')
  handleSelectionChange(
    @MessageBody() data: { selectedPodIds: string[] },
    @ConnectedSocket() client: Socket,
  ): void {
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('selection:changed', {
      userId: client.data.userId,
      selectedPodIds: data.selectedPodIds,
      socketId: client.id,
    });
  }

  // ==================== EXECUTION STREAMING (NEW) ====================

  /**
   * Broadcast execution start to flow
   */
  broadcastExecutionStart(flowId: string, executionId: string, podId: string): void {
    this.server.to(`flow:${flowId}`).emit('execution:started', {
      executionId,
      podId,
      status: 'RUNNING',
      timestamp: new Date().toISOString(),
    });
  }

  /**
   * Broadcast execution token stream to flow
   */
  broadcastExecutionToken(flowId: string, executionId: string, podId: string, token: string): void {
    this.server.to(`flow:${flowId}`).emit('execution:token', {
      executionId,
      podId,
      token,
    });
  }

  /**
   * Broadcast execution completion to flow
   */
  broadcastExecutionComplete(
    flowId: string,
    executionId: string,
    podId: string,
    result: any,
  ): void {
    this.server.to(`flow:${flowId}`).emit('execution:completed', {
      executionId,
      podId,
      status: 'COMPLETED',
      result,
      timestamp: new Date().toISOString(),
    });
  }

  /**
   * Broadcast execution error to flow
   */
  broadcastExecutionError(flowId: string, executionId: string, podId: string, error: string): void {
    this.server.to(`flow:${flowId}`).emit('execution:error', {
      executionId,
      podId,
      status: 'ERROR',
      error,
      timestamp: new Date().toISOString(),
    });
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Broadcast message to all users in a flow
   */
  broadcastToFlow(flowId: string, event: string, data: any): void {
    this.server.to(`flow:${flowId}`).emit(event, data);
  }

  /**
   * Get number of active users in a flow
   */
  getFlowUserCount(flowId: string): number {
    return this.flowSessions.get(flowId)?.size || 0;
  }

  /**
   * Get number of active flows
   */
  getActiveFlowsCount(): number {
    return this.flowSessions.size;
  }

  /**
   * Get all users in a flow
   */
  getFlowUsers(flowId: string): FlowSession[] {
    const sessions = this.flowSessions.get(flowId);
    return sessions ? Array.from(sessions.values()) : [];
  }

  /**
   * Rate limiting check
   */
  private checkRateLimit(client: Socket): boolean {
    const now = Date.now();
    const limit = this.rateLimitMap.get(client.id);

    if (!limit || now > limit.resetTime) {
      this.rateLimitMap.set(client.id, {
        count: 1,
        resetTime: now + this.RATE_LIMIT_WINDOW,
      });
      return true;
    }

    if (limit.count >= this.RATE_LIMIT) {
      client.emit('error', {
        message: 'Rate limit exceeded',
        code: 'RATE_LIMIT',
      });
      this.logger.warn(`Rate limit exceeded for client ${client.id}`);
      return false;
    }

    limit.count++;
    return true;
  }

  /**
   * Cleanup sessions older than 24 hours with no activity
   */
  private cleanupStaleSessions(): void {
    const now = Date.now();
    const staleThreshold = 24 * 60 * 60 * 1000; // 24 hours

    let cleaned = 0;

    for (const [flowId, sessions] of this.flowSessions.entries()) {
      for (const [socketId, session] of sessions.entries()) {
        if (now - session.joinedAt.getTime() > staleThreshold) {
          sessions.delete(socketId);
          cleaned++;
        }
      }

      if (sessions.size === 0) {
        this.flowSessions.delete(flowId);
      }
    }

    if (cleaned > 0) {
      this.logger.log(`ðŸ§¹ Cleaned up ${cleaned} stale sessions`);
    }
  }

  /**
   * Get statistics for monitoring
   */
  getStats(): {
    activeFlows: number;
    totalSessions: number;
    averageUsersPerFlow: number;
  } {
    const activeFlows = this.flowSessions.size;
    let totalSessions = 0;

    for (const sessions of this.flowSessions.values()) {
      totalSessions += sessions.size;
    }

    return {
      activeFlows,
      totalSessions,
      averageUsersPerFlow: activeFlows > 0 ? totalSessions / activeFlows : 0,
    };
  }
}

```

### `apps\backend\src\v1\flow\flow.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1FlowController } from './flow.controller';
import { V1FlowService } from './flow.service';
import { PrismaModule } from '../../prisma/prisma.module';
import { V1FlowGateway } from './flow.gateway';
import { JwtModule } from '@nestjs/jwt';

@Module({
  imports: [PrismaModule, JwtModule],
  controllers: [V1FlowController],
  providers: [V1FlowService, V1FlowGateway],
  exports: [V1FlowService, V1FlowGateway],
})
export class V1FlowModule {}

```

### `apps\backend\src\v1\flow\flow.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Prisma, FlowVisibility, FlowAccessLevel, FlowActivityAction } from '@actopod/schema';
import { plainToInstance } from 'class-transformer';
import { CreateFlowDto } from './dto/create-flow.dto';
import { UpdateFlowDto } from './dto/update-flow.dto';
import { FlowQueryDto } from './dto/flow-query.dto';
import { AddCollaboratorDto } from './dto/add-collaborator.dto';
import { UpdateCollaboratorDto } from './dto/update-collaborator.dto';
import {
  FlowResponseDto,
  FlowPaginatedResponseDto,
  FlowPaginationDto,
  CollaboratorResponseDto,
  ActivityLogResponseDto,
} from './dto/flow-response.dto';

@Injectable()
export class V1FlowService {
  private readonly logger = new Logger(V1FlowService.name);

  constructor(private readonly prisma: PrismaService) {}

  // ==================== FLOW CRUD ====================

  async getWorkspaceFlows(
    workspaceId: string,
    userId: string,
    query: FlowQueryDto,
  ): Promise<FlowPaginatedResponseDto> {
    try {
      // User can see: their own flows, flows shared with them, or workspace-visible flows
      const where: Prisma.FlowWhereInput = {
        workspaceId,
        OR: [
          { createdBy: userId },
          { collaborators: { some: { userId } } },
          { visibility: FlowVisibility.WORKSPACE },
        ],
        ...(query.search && {
          AND: [
            {
              OR: [
                { name: { contains: query.search, mode: 'insensitive' } },
                { description: { contains: query.search, mode: 'insensitive' } },
              ],
            },
          ],
        }),
        ...(query.visibility && { visibility: query.visibility }),
        ...(query.spaceId && { spaceId: query.spaceId }),
      };

      const [flows, totalItems] = await Promise.all([
        this.prisma.flow.findMany({
          where,
          include: {
            _count: {
              select: {
                pods: true,
                collaborators: true,
              },
            },
          },
          orderBy: { updatedAt: 'desc' },
          skip: query.skip,
          take: query.limit,
        }),
        this.prisma.flow.count({ where }),
      ]);

      const totalPages = Math.ceil(totalItems / query.limit);

      const pagination: FlowPaginationDto = {
        totalItems,
        totalPages,
        currentPage: query.page,
        pageSize: flows.length,
      };

      const data = flows.map((flow) =>
        plainToInstance(
          FlowResponseDto,
          {
            ...flow,
            podCount: flow._count.pods,
            collaboratorCount: flow._count.collaborators,
          },
          { excludeExtraneousValues: true },
        ),
      );

      return { data, pagination };
    } catch (error) {
      this.logger.error(`Failed to fetch flows for workspace ${workspaceId}`, error);
      throw new InternalServerErrorException('Failed to fetch flows');
    }
  }

  async getFlowById(flowId: string, workspaceId: string, userId: string): Promise<FlowResponseDto> {
    try {
      const flow = await this.prisma.flow.findFirst({
        where: {
          id: flowId,
          workspaceId,
        },
        include: {
          _count: {
            select: {
              pods: true,
              collaborators: true,
            },
          },
        },
      });

      if (!flow) {
        throw new NotFoundException('Flow not found');
      }

      // Verify user has access
      await this.verifyFlowAccess(flowId, userId, 'VIEW');

      return plainToInstance(
        FlowResponseDto,
        {
          ...flow,
          podCount: flow._count.pods,
          collaboratorCount: flow._count.collaborators,
        },
        { excludeExtraneousValues: true },
      );
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to fetch flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch flow');
    }
  }

  async createFlow(
    workspaceId: string,
    userId: string,
    dto: CreateFlowDto,
  ): Promise<FlowResponseDto> {
    try {
      if (dto.spaceId) {
        const space = await this.prisma.space.findFirst({
          where: { id: dto.spaceId, workspaceId },
        });

        if (!space) {
          throw new BadRequestException('Space not found in this workspace');
        }
      }

      const flow = await this.prisma.flow.create({
        data: {
          workspaceId,
          spaceId: dto.spaceId,
          name: dto.name,
          description: dto.description,
          visibility: dto.visibility || FlowVisibility.PRIVATE,
          createdBy: userId,
        },
        include: {
          _count: {
            select: {
              pods: true,
              collaborators: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flow.id, userId, FlowActivityAction.FLOW_CREATED, {
        name: flow.name,
        visibility: flow.visibility,
      });

      this.logger.log(`âœ… Flow created: ${flow.id} by user ${userId}`);

      return plainToInstance(
        FlowResponseDto,
        {
          ...flow,
          podCount: flow._count.pods,
          collaboratorCount: flow._count.collaborators,
        },
        { excludeExtraneousValues: true },
      );
    } catch (error) {
      if (error instanceof BadRequestException) throw error;
      this.logger.error('Failed to create flow', error);
      throw new InternalServerErrorException('Failed to create flow');
    }
  }

  async updateFlow(
    flowId: string,
    workspaceId: string,
    userId: string,
    dto: UpdateFlowDto,
  ): Promise<FlowResponseDto> {
    try {
      const existingFlow = await this.prisma.flow.findFirst({
        where: {
          id: flowId,
          workspaceId,
        },
      });

      if (!existingFlow) {
        throw new NotFoundException('Flow not found');
      }

      // Verify edit permission
      await this.verifyFlowAccess(flowId, userId, 'EDIT');

      if (dto.spaceId) {
        const space = await this.prisma.space.findFirst({
          where: { id: dto.spaceId, workspaceId },
        });

        if (!space) {
          throw new BadRequestException('Space not found in this workspace');
        }
      }

      const flow = await this.prisma.flow.update({
        where: { id: flowId },
        data: {
          ...(dto.name && { name: dto.name }),
          ...(dto.description !== undefined && { description: dto.description }),
          ...(dto.spaceId !== undefined && { spaceId: dto.spaceId }),
          ...(dto.visibility && { visibility: dto.visibility }),
        },
        include: {
          _count: {
            select: {
              pods: true,
              collaborators: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.FLOW_UPDATED, dto);

      this.logger.log(`âœ… Flow updated: ${flowId} by user ${userId}`);

      return plainToInstance(
        FlowResponseDto,
        {
          ...flow,
          podCount: flow._count.pods,
          collaboratorCount: flow._count.collaborators,
        },
        { excludeExtraneousValues: true },
      );
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error(`Failed to update flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to update flow');
    }
  }

  async deleteFlow(flowId: string, workspaceId: string, userId: string): Promise<void> {
    try {
      const flow = await this.prisma.flow.findFirst({
        where: {
          id: flowId,
          workspaceId,
        },
      });

      if (!flow) {
        throw new NotFoundException('Flow not found');
      }

      // Only owner can delete
      if (flow.createdBy !== userId) {
        throw new ForbiddenException('Only the flow owner can delete this flow');
      }

      await this.prisma.flow.delete({
        where: { id: flowId },
      });

      this.logger.log(`âœ… Flow deleted: ${flowId} by user ${userId}`);
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to delete flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to delete flow');
    }
  }

  // ==================== COLLABORATOR MANAGEMENT ====================

  async getFlowCollaborators(
    flowId: string,
    workspaceId: string,
    userId: string,
  ): Promise<CollaboratorResponseDto[]> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'VIEW');

      const collaborators = await this.prisma.flowCollaborator.findMany({
        where: { flowId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
        orderBy: { invitedAt: 'asc' },
      });

      return collaborators.map((collab) =>
        plainToInstance(CollaboratorResponseDto, collab, { excludeExtraneousValues: true }),
      );
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to fetch collaborators for flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch collaborators');
    }
  }

  async addCollaborator(
    flowId: string,
    workspaceId: string,
    userId: string,
    dto: AddCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'INVITE');

      // Find user by email
      const targetUser = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });

      if (!targetUser) {
        throw new BadRequestException('User with this email not found');
      }

      // Check if already collaborator
      const existing = await this.prisma.flowCollaborator.findUnique({
        where: {
          flowId_userId: {
            flowId,
            userId: targetUser.id,
          },
        },
      });

      if (existing) {
        throw new BadRequestException('User is already a collaborator on this flow');
      }

      // Check if user is owner
      const flow = await this.prisma.flow.findUnique({ where: { id: flowId } });
      if (flow?.createdBy === targetUser.id) {
        throw new BadRequestException('Cannot add owner as collaborator');
      }

      const collaborator = await this.prisma.flowCollaborator.create({
        data: {
          flowId,
          userId: targetUser.id,
          accessLevel: dto.accessLevel || FlowAccessLevel.EDITOR,
          invitedBy: userId,
          canEdit: dto.accessLevel !== FlowAccessLevel.VIEWER,
          canExecute: true,
          canDelete: false,
          canShare: false,
          canInvite: false,
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.COLLABORATOR_ADDED, {
        collaboratorEmail: dto.email,
        accessLevel: dto.accessLevel,
      });

      this.logger.log(`âœ… Collaborator added to flow ${flowId}: ${dto.email}`);

      return plainToInstance(CollaboratorResponseDto, collaborator, {
        excludeExtraneousValues: true,
      });
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error(`Failed to add collaborator to flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to add collaborator');
    }
  }

  async updateCollaborator(
    flowId: string,
    collaboratorId: string,
    workspaceId: string,
    userId: string,
    dto: UpdateCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'MANAGE');

      const collaborator = await this.prisma.flowCollaborator.update({
        where: { id: collaboratorId, flowId },
        data: dto,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.COLLABORATOR_PERMISSIONS_CHANGED, {
        collaboratorId,
        changes: dto,
      });

      this.logger.log(`âœ… Collaborator updated in flow ${flowId}: ${collaboratorId}`);

      return plainToInstance(CollaboratorResponseDto, collaborator, {
        excludeExtraneousValues: true,
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to update collaborator ${collaboratorId}`, error);
      throw new InternalServerErrorException('Failed to update collaborator');
    }
  }

  async removeCollaborator(
    flowId: string,
    collaboratorId: string,
    workspaceId: string,
    userId: string,
  ): Promise<void> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'MANAGE');

      const collaborator = await this.prisma.flowCollaborator.findUnique({
        where: { id: collaboratorId },
        include: { user: true },
      });

      await this.prisma.flowCollaborator.delete({
        where: { id: collaboratorId, flowId },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.COLLABORATOR_REMOVED, {
        collaboratorEmail: collaborator?.user.email,
      });

      this.logger.log(`âœ… Collaborator removed from flow ${flowId}: ${collaboratorId}`);
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to remove collaborator ${collaboratorId}`, error);
      throw new InternalServerErrorException('Failed to remove collaborator');
    }
  }

  // ==================== ACTIVITY LOG ====================

  async getFlowActivity(
    flowId: string,
    workspaceId: string,
    userId: string,
    limit: number = 50,
  ): Promise<ActivityLogResponseDto[]> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'VIEW');

      const activities = await this.prisma.flowActivityLog.findMany({
        where: { flowId },
        orderBy: { createdAt: 'desc' },
        take: limit,
      });

      // Fetch users for activities
      const userIds = activities.map((a) => a.userId).filter((id): id is string => id !== null);
      const users = await this.prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, name: true, email: true },
      });

      const userMap = new Map(users.map((u) => [u.id, u]));

      return activities.map((activity) => {
        const user = activity.userId ? userMap.get(activity.userId) || null : null;

        return plainToInstance(
          ActivityLogResponseDto,
          {
            ...activity,
            user,
          },
          { excludeExtraneousValues: true },
        );
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to fetch activity for flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch activity log');
    }
  }

  // ==================== HELPER METHODS ====================

  private async logActivity(
    flowId: string,
    userId: string | null,
    action: FlowActivityAction,
    changeData?: any,
  ): Promise<void> {
    try {
      await this.prisma.flowActivityLog.create({
        data: {
          flowId,
          userId,
          action,
          changeData,
        },
      });
    } catch (error) {
      this.logger.warn(`Failed to log activity for flow ${flowId}:`, error);
    }
  }

  private async verifyFlowExists(flowId: string, workspaceId: string): Promise<void> {
    const flow = await this.prisma.flow.findFirst({
      where: { id: flowId, workspaceId },
    });

    if (!flow) {
      throw new NotFoundException('Flow not found');
    }
  }

  private async verifyFlowAccess(
    flowId: string,
    userId: string,
    action: 'VIEW' | 'EDIT' | 'DELETE' | 'INVITE' | 'MANAGE',
  ): Promise<void> {
    const flow = await this.prisma.flow.findUnique({
      where: { id: flowId },
      include: {
        collaborators: {
          where: { userId },
        },
      },
    });

    if (!flow) {
      throw new NotFoundException('Flow not found');
    }

    // Owner has all permissions
    if (flow.createdBy === userId) {
      return;
    }

    // Workspace-visible flows can be viewed by workspace members
    if (action === 'VIEW' && flow.visibility === FlowVisibility.WORKSPACE) {
      return;
    }

    const collaborator = flow.collaborators[0];

    if (!collaborator) {
      throw new ForbiddenException('Access denied to this flow');
    }

    // Check specific permissions
    switch (action) {
      case 'VIEW':
        return; // All collaborators can view
      case 'EDIT':
        if (!collaborator.canEdit) {
          throw new ForbiddenException('Edit permission required');
        }
        break;
      case 'DELETE':
        if (!collaborator.canDelete) {
          throw new ForbiddenException('Delete permission required');
        }
        break;
      case 'INVITE':
        if (!collaborator.canInvite) {
          throw new ForbiddenException('Invite permission required');
        }
        break;
      case 'MANAGE':
        if (collaborator.accessLevel !== FlowAccessLevel.OWNER) {
          throw new ForbiddenException('Owner permission required');
        }
        break;
    }
  }
}

```

### `apps\backend\src\v1\models\dto\model-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';
import { Expose } from 'class-transformer';

export class ModelPricingDto {
  @Expose()
  @ApiProperty({ example: 'gpt-4o' })
  modelId!: string;

  @Expose()
  @ApiProperty({ example: 'gpt-4o-2024-05-13' })
  modelName!: string;

  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ example: '2.50' })
  inputTokenCost!: string;

  @Expose()
  @ApiProperty({ example: '10.00' })
  outputTokenCost!: string;

  @Expose()
  @ApiProperty({ example: '0.00', nullable: true })
  reasoningTokenCost!: string | null;

  @Expose()
  @ApiProperty({ example: 128000 })
  contextWindow!: number;

  @Expose()
  @ApiProperty({ example: true })
  supportsVision!: boolean;

  @Expose()
  @ApiProperty({ example: true })
  supportsFunctionCalling!: boolean;

  @Expose()
  @ApiProperty({ example: false })
  supportsStreaming!: boolean;

  @Expose()
  @ApiProperty({ example: true })
  isActive!: boolean;

  @Expose()
  @ApiProperty({ example: '2024-05-13T00:00:00.000Z' })
  effectiveFrom!: Date;
}

export class ModelsByProviderDto {
  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ type: [ModelPricingDto] })
  models!: ModelPricingDto[];

  @Expose()
  @ApiProperty({ example: 15 })
  count!: number;
}

```

### `apps\backend\src\v1\models\dto\provider-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';
import { Expose } from 'class-transformer';

export class ProviderInfoDto {
  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ example: 'OpenAI' })
  displayName!: string;

  @Expose()
  @ApiProperty({ example: 15 })
  modelCount!: number;

  @Expose()
  @ApiProperty({ example: true })
  isAvailable!: boolean;

  @Expose()
  @ApiProperty({
    example: ['text', 'vision', 'function-calling', 'reasoning'],
    type: [String],
  })
  capabilities!: string[];
}

```

### `apps\backend\src\v1\models\models.controller.ts`

```typescript
import { Controller, Get, Param, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam } from '@nestjs/swagger';
import { V1ModelsService } from './models.service';
import { ModelPricingDto, ModelsByProviderDto } from './dto/model-response.dto';
import { ProviderInfoDto } from './dto/provider-response.dto';
import { LLMProvider } from '@actopod/schema';
import { Public } from '../../common/decorators/common';

@ApiTags('Models & Providers')
@Controller('models')
export class V1ModelsController {
  constructor(private readonly modelsService: V1ModelsService) {}

  @Get('providers')
  @Public()
  @ApiOperation({
    summary: 'Get all available LLM providers',
    description: 'Returns list of all providers with their capabilities and model counts',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of providers',
    type: [ProviderInfoDto],
  })
  async getAllProviders(): Promise<ProviderInfoDto[]> {
    return this.modelsService.getAllProviders();
  }

  @Get()
  @Public() // Make this public so frontend can show models in UI
  @ApiOperation({
    summary: 'Get all available models',
    description: 'Returns all active models with pricing and capabilities',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of all models',
    type: [ModelPricingDto],
  })
  async getAllModels(): Promise<ModelPricingDto[]> {
    return this.modelsService.getAllModels();
  }

  @Get('grouped')
  @Public()
  @ApiOperation({
    summary: 'Get models grouped by provider',
    description: 'Returns models organized by provider',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Models grouped by provider',
    type: [ModelsByProviderDto],
  })
  async getModelsGroupedByProvider(): Promise<ModelsByProviderDto[]> {
    return this.modelsService.getModelsGroupedByProvider();
  }

  @Get('provider/:provider')
  @Public()
  @ApiOperation({
    summary: 'Get models for specific provider',
    description: 'Returns all models for the specified provider',
  })
  @ApiParam({
    name: 'provider',
    enum: LLMProvider,
    description: 'LLM provider name',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Models for the provider',
    type: ModelsByProviderDto,
  })
  async getModelsByProvider(
    @Param('provider') provider: LLMProvider,
  ): Promise<ModelsByProviderDto> {
    return this.modelsService.getModelsByProvider(provider);
  }

  @Get('provider/:provider/:modelId')
  @Public()
  @ApiOperation({
    summary: 'Get specific model details',
    description: 'Returns detailed information about a specific model',
  })
  @ApiParam({
    name: 'provider',
    enum: LLMProvider,
    description: 'LLM provider name',
  })
  @ApiParam({
    name: 'modelId',
    description: 'Model ID',
    example: 'gpt-4o',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Model details',
    type: ModelPricingDto,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Model not found',
  })
  async getModelById(
    @Param('provider') provider: LLMProvider,
    @Param('modelId') modelId: string,
  ): Promise<ModelPricingDto | null> {
    return this.modelsService.getModelById(provider, modelId);
  }
}

```

### `apps\backend\src\v1\models\models.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1ModelsController } from './models.controller';
import { V1ModelsService } from './models.service';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [V1ModelsController],
  providers: [V1ModelsService],
  exports: [V1ModelsService],
})
export class V1ModelsModule {}

```

### `apps\backend\src\v1\models\models.service.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { LLMProvider } from '@actopod/schema';
import { plainToInstance } from 'class-transformer';
import { ModelPricingDto, ModelsByProviderDto } from './dto/model-response.dto';
import { ProviderInfoDto } from './dto/provider-response.dto';

@Injectable()
export class V1ModelsService {
  private readonly logger = new Logger(V1ModelsService.name);

  // Provider display names and capabilities
  private readonly PROVIDER_INFO: Record<
    LLMProvider,
    { displayName: string; capabilities: string[] }
  > = {
    [LLMProvider.OPENAI]: {
      displayName: 'OpenAI',
      capabilities: ['text', 'vision', 'function-calling', 'reasoning', 'streaming'],
    },
    [LLMProvider.ANTHROPIC]: {
      displayName: 'Anthropic',
      capabilities: ['text', 'vision', 'function-calling', 'streaming'],
    },
    [LLMProvider.GOOGLE_GEMINI]: {
      displayName: 'Google AI',
      capabilities: ['text', 'vision', 'function-calling', 'streaming'],
    },
    [LLMProvider.PERPLEXITY]: {
      displayName: 'Perplexity',
      capabilities: ['text', 'search', 'real-time'],
    },
    [LLMProvider.MISTRAL]: {
      displayName: 'Mistral AI',
      capabilities: ['text', 'function-calling'],
    },
    [LLMProvider.COHERE]: {
      displayName: 'Cohere',
      capabilities: ['text', 'embedding', 'reranking'],
    },
    [LLMProvider.GROQ]: {
      displayName: 'Groq',
      capabilities: ['text', 'ultra-fast'],
    },
    [LLMProvider.XAI]: {
      displayName: 'xAI',
      capabilities: ['text', 'function-calling'],
    },
    [LLMProvider.DEEPSEEK]: {
      displayName: 'DeepSeek',
      capabilities: ['text', 'reasoning', 'cost-effective'],
    },
    [LLMProvider.CUSTOM]: {
      displayName: 'Custom',
      capabilities: ['text'],
    },
  };

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get all available providers with model counts
   */
  async getAllProviders(): Promise<ProviderInfoDto[]> {
    const modelCounts = await this.prisma.modelPricingTier.groupBy({
      by: ['provider'],
      where: { isActive: true },
      _count: { modelId: true },
    });

    const providers = Object.values(LLMProvider).map((provider) => {
      const count = modelCounts.find((mc) => mc.provider === provider)?._count.modelId || 0;
      const info = this.PROVIDER_INFO[provider];

      return plainToInstance(ProviderInfoDto, {
        provider,
        displayName: info.displayName,
        modelCount: count,
        isAvailable: count > 0,
        capabilities: info.capabilities,
      });
    });

    return providers.filter((p) => p.isAvailable);
  }

  /**
   * Get all active models (latest pricing for each model)
   */
  async getAllModels(): Promise<ModelPricingDto[]> {
    const models = await this.prisma.modelPricingTier.findMany({
      where: { isActive: true },
      orderBy: [{ provider: 'asc' }, { modelId: 'asc' }],
      distinct: ['provider', 'modelId'],
    });

    return models.map((model) =>
      plainToInstance(ModelPricingDto, {
        modelId: model.modelId,
        modelName: model.displayName, // âœ… FIXED: Use displayName
        provider: model.provider,
        inputTokenCost: model.inputTokenCost.toString(),
        outputTokenCost: model.outputTokenCost.toString(),
        reasoningTokenCost: model.reasoningTokenCost?.toString() || null,
        contextWindow: model.maxTokens || 0, // âœ… FIXED: Use maxTokens
        supportsVision: model.supportsVision,
        supportsFunctionCalling: model.supportsFunctions, // âœ… FIXED: Use supportsFunctions
        supportsStreaming: model.supportsStreaming,
        isActive: model.isActive,
        effectiveFrom: model.effectiveFrom,
      }),
    );
  }

  /**
   * Get models by specific provider
   */
  async getModelsByProvider(provider: LLMProvider): Promise<ModelsByProviderDto> {
    const models = await this.prisma.modelPricingTier.findMany({
      where: {
        provider,
        isActive: true,
      },
      orderBy: { modelId: 'asc' },
      distinct: ['modelId'],
    });

    const modelDtos = models.map((model) =>
      plainToInstance(ModelPricingDto, {
        modelId: model.modelId,
        modelName: model.displayName, // âœ… FIXED
        provider: model.provider,
        inputTokenCost: model.inputTokenCost.toString(),
        outputTokenCost: model.outputTokenCost.toString(),
        reasoningTokenCost: model.reasoningTokenCost?.toString() || null,
        contextWindow: model.maxTokens || 0, // âœ… FIXED
        supportsVision: model.supportsVision,
        supportsFunctionCalling: model.supportsFunctions, // âœ… FIXED
        supportsStreaming: model.supportsStreaming,
        isActive: model.isActive,
        effectiveFrom: model.effectiveFrom,
      }),
    );

    return plainToInstance(ModelsByProviderDto, {
      provider,
      models: modelDtos,
      count: modelDtos.length,
    });
  }

  /**
   * Get specific model details
   */
  async getModelById(provider: LLMProvider, modelId: string): Promise<ModelPricingDto | null> {
    const model = await this.prisma.modelPricingTier.findFirst({
      where: {
        provider,
        modelId,
        isActive: true,
      },
      orderBy: { effectiveFrom: 'desc' },
    });

    if (!model) return null;

    return plainToInstance(ModelPricingDto, {
      modelId: model.modelId,
      modelName: model.displayName, // âœ… FIXED
      provider: model.provider,
      inputTokenCost: model.inputTokenCost.toString(),
      outputTokenCost: model.outputTokenCost.toString(),
      reasoningTokenCost: model.reasoningTokenCost?.toString() || null,
      contextWindow: model.maxTokens || 0, // âœ… FIXED
      supportsVision: model.supportsVision,
      supportsFunctionCalling: model.supportsFunctions, // âœ… FIXED
      supportsStreaming: model.supportsStreaming,
      isActive: model.isActive,
      effectiveFrom: model.effectiveFrom,
    });
  }

  /**
   * Get models grouped by provider
   */
  async getModelsGroupedByProvider(): Promise<ModelsByProviderDto[]> {
    const providers = await this.getAllProviders();

    const groupedModels = await Promise.all(
      providers.map((provider) => this.getModelsByProvider(provider.provider)),
    );

    return groupedModels;
  }
}

```

### `apps\backend\src\v1\notification\dto\notification-count-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';

export class NotificationCountResponseDto {
  @ApiProperty({
    description: 'Number of notifications affected',
    example: 5,
  })
  count!: number;

  @ApiProperty({
    description: 'Success message',
    example: 'Successfully marked 5 notifications as read',
  })
  message!: string;
}

```

### `apps\backend\src\v1\notification\dto\notification-mark-read.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsString, ArrayNotEmpty, ArrayMaxSize } from 'class-validator';

export class NotificationMarkReadDto {
  @ApiProperty({
    description: 'Array of notification IDs to mark as read',
    type: [String],
    example: ['cm2abc123', 'cm2def456'],
    minItems: 1,
    maxItems: 50,
  })
  @IsArray()
  @ArrayNotEmpty()
  @ArrayMaxSize(50)
  @IsString({ each: true })
  notificationIds!: string[];
}

```

### `apps\backend\src\v1\notification\dto\notification-paginated-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { NotificationResponseDto } from './notification-response.dto';

/**
 * Compatible with your ResponseInterceptor's pagination format
 */
export class NotificationPaginationDto {
  @ApiProperty({
    description: 'Total number of items',
    example: 45,
  })
  totalItems!: number;

  @ApiProperty({
    description: 'Total number of pages',
    example: 3,
  })
  totalPages!: number;

  @ApiProperty({
    description: 'Current page number',
    example: 1,
  })
  currentPage!: number;

  @ApiProperty({
    description: 'Number of items in current page',
    example: 20,
  })
  pageSize!: number;
}

export class NotificationPaginatedResponseDto {
  @ApiProperty({
    description: 'Array of notifications',
    type: [NotificationResponseDto],
  })
  data!: NotificationResponseDto[];

  @ApiProperty({
    description: 'Pagination metadata',
    type: NotificationPaginationDto,
  })
  pagination!: NotificationPaginationDto;

  @ApiProperty({
    description: 'Number of unread notifications',
    example: 12,
  })
  unreadCount!: number;
}

```

### `apps\backend\src\v1\notification\dto\notification-query.dto.ts`

```typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, IsInt, Min, Max, IsEnum } from 'class-validator';
import { NotificationType } from '@actopod/schema';

export class NotificationQueryDto {
  @ApiPropertyOptional({
    description: 'Filter by read/unread status',
    example: false,
    type: Boolean,
    default: false,
  })
  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  unreadOnly: boolean = false;

  @ApiPropertyOptional({
    description: 'Filter by notification type',
    enum: NotificationType,
    example: NotificationType.WORKSPACE_INVITATION,
  })
  @IsOptional()
  @IsEnum(NotificationType)
  type?: NotificationType;

  @ApiPropertyOptional({
    description: 'Page number (starts from 1)',
    minimum: 1,
    default: 1,
    example: 1,
  })
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @IsOptional()
  page: number = 1;

  @ApiPropertyOptional({
    description: 'Number of items per page',
    minimum: 1,
    maximum: 100,
    default: 20,
    example: 20,
  })
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  @IsOptional()
  limit: number = 20;

  get skip(): number {
    return (this.page - 1) * this.limit;
  }
}

```

### `apps\backend\src\v1\notification\dto\notification-response.dto.ts`

```typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { NotificationType } from '@actopod/schema';
import { Exclude, Expose, Type } from 'class-transformer';

@Exclude()
export class NotificationResponseDto {
  @ApiProperty({
    description: 'Unique notification identifier',
    example: 'cm2abc123xyz',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'User ID who owns this notification',
    example: 'cm1user456',
  })
  @Expose()
  userId!: string;

  @ApiProperty({
    description: 'Type of notification',
    enum: NotificationType,
    example: NotificationType.WORKSPACE_INVITATION,
  })
  @Expose()
  type!: NotificationType;

  @ApiProperty({
    description: 'Notification title',
    example: 'Workspace Invitation: Acme Corp',
  })
  @Expose()
  title!: string;

  @ApiProperty({
    description: 'Notification body/content',
    example: "You've been invited to join Acme Corp as MEMBER",
  })
  @Expose()
  body!: string;

  @ApiPropertyOptional({
    description: 'Type of related entity',
    example: 'workspace_invitation',
    nullable: true,
  })
  @Expose()
  entityType?: string | null;

  @ApiPropertyOptional({
    description: 'ID of related entity',
    example: 'cm2workspace789',
    nullable: true,
  })
  @Expose()
  entityId?: string | null;

  @ApiPropertyOptional({
    description: 'Additional metadata',
    example: { workspaceId: 'cm2ws123', role: 'MEMBER' },
    nullable: true,
  })
  @Expose()
  metadata?: Record<string, any> | null;

  @ApiProperty({
    description: 'Whether notification has been read',
    example: false,
  })
  @Expose()
  isRead!: boolean;

  @ApiPropertyOptional({
    description: 'Timestamp when notification was read',
    example: '2025-10-16T14:30:00.000Z',
    nullable: true,
  })
  @Expose()
  @Type(() => Date)
  readAt?: Date | null;

  @ApiPropertyOptional({
    description: 'URL to navigate when notification is clicked',
    example: '/workspace/invite/abc123token',
    nullable: true,
  })
  @Expose()
  actionUrl?: string | null;

  @ApiProperty({
    description: 'Notification creation timestamp',
    example: '2025-10-16T12:00:00.000Z',
  })
  @Expose()
  @Type(() => Date)
  createdAt!: Date;

  @ApiPropertyOptional({
    description: 'Notification expiration timestamp',
    example: '2025-10-23T12:00:00.000Z',
    nullable: true,
  })
  @Expose()
  @Type(() => Date)
  expiresAt?: Date | null;
}

```

### `apps\backend\src\v1\notification\dto\notification-unread-count-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';

export class NotificationUnreadCountResponseDto {
  @ApiProperty({
    description: 'Number of unread notifications',
    example: 12,
  })
  count!: number;
}

```

### `apps\backend\src\v1\notification\notification.controller.ts`

```typescript
import {
  Controller,
  Get,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
  ValidationPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
  ApiNotFoundResponse,
  ApiInternalServerErrorResponse,
} from '@nestjs/swagger';
import { V1NotificationService } from './notification.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { NotificationQueryDto } from './dto/notification-query.dto';
import { NotificationMarkReadDto } from './dto/notification-mark-read.dto';
import { NotificationPaginatedResponseDto } from './dto/notification-paginated-response.dto';
import { NotificationUnreadCountResponseDto } from './dto/notification-unread-count-response.dto';
import { NotificationCountResponseDto } from './dto/notification-count-response.dto';

@ApiTags('Notifications')
@ApiBearerAuth('JWT')
@Controller({
  path: 'notifications',
  version: '1',
})
@ApiUnauthorizedResponse({
  description: 'Unauthorized - Invalid or missing JWT token',
})
@ApiInternalServerErrorResponse({
  description: 'Internal server error',
})
export class V1NotificationController {
  constructor(private readonly notificationService: V1NotificationService) {}

  @Get()
  @ApiOperation({
    summary: 'Get user notifications',
    description:
      'Retrieve a paginated list of notifications for the authenticated user. ' +
      'Supports filtering by read status and notification type. ' +
      'Automatically excludes expired notifications.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully retrieved notifications',
    type: NotificationPaginatedResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid query parameters',
  })
  async getNotifications(
    @GetCurrentUserId() userId: string,
    @Query(new ValidationPipe({ transform: true, whitelist: true }))
    query: NotificationQueryDto,
  ): Promise<NotificationPaginatedResponseDto> {
    return this.notificationService.getUserNotifications(userId, query);
  }

  @Get('unread-count')
  @ApiOperation({
    summary: 'Get unread notification count',
    description: 'Get the total count of unread notifications for the authenticated user.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully retrieved unread count',
    type: NotificationUnreadCountResponseDto,
  })
  async getUnreadCount(
    @GetCurrentUserId() userId: string,
  ): Promise<NotificationUnreadCountResponseDto> {
    const count = await this.notificationService.getUnreadCount(userId);
    return { count };
  }

  // âœ… REMOVED ParseUUIDPipe - CUID IDs are not UUIDs
  @Patch(':id/read')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Mark notification as read',
    description:
      'Mark a single notification as read. The notification must belong to the authenticated user.',
  })
  @ApiParam({
    name: 'id',
    description: 'Notification ID (CUID format)',
    example: 'cm2abc123xyz',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Notification successfully marked as read',
  })
  @ApiNotFoundResponse({
    description: 'Notification not found or does not belong to user',
  })
  async markAsRead(
    @Param('id') notificationId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.notificationService.markAsRead(notificationId, userId);
  }

  @Patch('read-many')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Mark multiple notifications as read',
    description:
      'Mark multiple notifications as read in a single batch operation. Maximum 50 notification IDs per request.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully marked notifications as read',
    type: NotificationCountResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid request body or too many IDs',
  })
  async markManyAsRead(
    @Body(ValidationPipe) dto: NotificationMarkReadDto,
    @GetCurrentUserId() userId: string,
  ): Promise<NotificationCountResponseDto> {
    const count = await this.notificationService.markManyAsRead(dto.notificationIds, userId);
    return {
      count,
      message: `Successfully marked ${count} notification${count !== 1 ? 's' : ''} as read`,
    };
  }

  @Patch('read-all')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Mark all notifications as read',
    description: 'Mark all unread notifications as read for the authenticated user.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully marked all notifications as read',
    type: NotificationCountResponseDto,
  })
  async markAllAsRead(@GetCurrentUserId() userId: string): Promise<NotificationCountResponseDto> {
    const count = await this.notificationService.markAllAsRead(userId);
    return {
      count,
      message: `Successfully marked ${count} notification${count !== 1 ? 's' : ''} as read`,
    };
  }

  // âœ… REMOVED ParseUUIDPipe
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete notification',
    description:
      'Permanently delete a notification. The notification must belong to the authenticated user.',
  })
  @ApiParam({
    name: 'id',
    description: 'Notification ID (CUID format)',
    example: 'cm2abc123xyz',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Notification successfully deleted',
  })
  @ApiNotFoundResponse({
    description: 'Notification not found or does not belong to user',
  })
  async deleteNotification(
    @Param('id') notificationId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.notificationService.deleteNotification(notificationId, userId);
  }

  @Delete('read')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete all read notifications',
    description: 'Delete all read notifications for the authenticated user.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully deleted read notifications',
    type: NotificationCountResponseDto,
  })
  async deleteAllRead(@GetCurrentUserId() userId: string): Promise<NotificationCountResponseDto> {
    const count = await this.notificationService.deleteAllRead(userId);
    return {
      count,
      message: `Successfully deleted ${count} notification${count !== 1 ? 's' : ''}`,
    };
  }
}

```

### `apps\backend\src\v1\notification\notification.gateway.ts`

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true,
  },
  namespace: 'notifications',
  transports: ['websocket', 'polling'],
})
export class V1NotificationGateway
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server!: Server;

  private readonly logger = new Logger(V1NotificationGateway.name);
  private userSockets = new Map<string, Set<string>>();

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  afterInit(): void {
    this.logger.log('ðŸ”Œ Notification WebSocket Gateway initialized');
  }

  async handleConnection(client: Socket): Promise<void> {
    try {
      const token =
        client.handshake.auth?.token ||
        client.handshake.headers?.authorization?.replace('Bearer ', '') ||
        client.handshake.query?.token;

      if (!token) {
        this.logger.warn(`âŒ Client ${client.id}: No token`);
        client.emit('error', { message: 'Authentication required' });
        client.disconnect(true);
        return;
      }

      const secret = this.configService.get<string>('JWT_ACCESS_TOKEN_SECRET');
      const payload = await this.jwtService.verifyAsync(token, { secret });

      // âœ… Use userId instead of sub (matches your JWT payload structure)
      const userId = payload.userId || payload.sub;

      if (!userId) {
        this.logger.warn(`âŒ Client ${client.id}: Invalid token - no userId in payload`);
        client.disconnect(true);
        return;
      }

      if (!this.userSockets.has(userId)) {
        this.userSockets.set(userId, new Set());
      }
      this.userSockets.get(userId)!.add(client.id);

      await client.join(`user:${userId}`);
      client.data.userId = userId;

      client.emit('connected', {
        message: 'Connected to notifications',
        userId,
      });

      const deviceCount = this.userSockets.get(userId)!.size;
      this.logger.log(`âœ… User ${userId} connected [${deviceCount} device(s)]`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Auth failed';
      this.logger.error(`âŒ Connection failed: ${errorMessage}`);
      client.emit('error', { message: 'Authentication failed' });
      client.disconnect(true);
    }
  }

  handleDisconnect(client: Socket): void {
    const userId = client.data.userId;
    if (userId) {
      const userSocketSet = this.userSockets.get(userId);
      if (userSocketSet) {
        userSocketSet.delete(client.id);
        if (userSocketSet.size === 0) {
          this.userSockets.delete(userId);
          this.logger.log(`ðŸ”Œ User ${userId} fully disconnected`);
        } else {
          this.logger.log(
            `ðŸ”Œ User ${userId} device disconnected [${userSocketSet.size} remaining]`,
          );
        }
      }
    }
  }

  sendNotificationToUser(userId: string, notification: any): void {
    try {
      this.server.to(`user:${userId}`).emit('notification:new', notification);
      const deviceCount = this.userSockets.get(userId)?.size || 0;
      this.logger.debug(`ðŸ“¤ Notification sent to ${userId} [${deviceCount} device(s)]`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`âŒ Failed to send notification: ${errorMessage}`);
    }
  }

  sendUnreadCountUpdate(userId: string, count: number): void {
    try {
      this.server.to(`user:${userId}`).emit('notification:unread_count', count);
      this.logger.debug(`ðŸ“Š Unread count updated: ${userId} = ${count}`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`âŒ Failed to send unread count: ${errorMessage}`);
    }
  }

  getConnectedUsersCount(): number {
    return this.userSockets.size;
  }

  isUserConnected(userId: string): boolean {
    return this.userSockets.has(userId) && this.userSockets.get(userId)!.size > 0;
  }

  getUserDeviceCount(userId: string): number {
    return this.userSockets.get(userId)?.size || 0;
  }
}

```

### `apps\backend\src\v1\notification\notification.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1NotificationController } from './notification.controller';
import { V1NotificationService } from './notification.service';
import { V1NotificationGateway } from './notification.gateway';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [V1NotificationController],
  providers: [V1NotificationService, V1NotificationGateway],
  exports: [V1NotificationService, V1NotificationGateway],
})
export class V1NotificationModule {}

```

### `apps\backend\src\v1\notification\notification.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { NotificationType, Notification, Prisma } from '@actopod/schema';
import { V1NotificationGateway } from './notification.gateway';
import { NotificationQueryDto } from './dto/notification-query.dto';
import {
  NotificationPaginatedResponseDto,
  NotificationPaginationDto,
} from './dto/notification-paginated-response.dto';
import { NotificationResponseDto } from './dto/notification-response.dto';
import { plainToInstance } from 'class-transformer';

/**
 * Production-Grade Notification Service
 * Features:
 * - Real-time WebSocket notifications
 * - Pagination support compatible with ResponseInterceptor
 * - Type-safe operations
 * - Comprehensive error handling
 * - Automatic cleanup of expired notifications
 * - Batch operations for performance
 * - Non-blocking WebSocket delivery
 */
@Injectable()
export class V1NotificationService {
  private readonly logger = new Logger(V1NotificationService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly notificationGateway: V1NotificationGateway,
  ) {}

  /**
   * Create a new notification with real-time delivery
   */
  async createNotification(data: {
    userId: string;
    type: NotificationType;
    title: string;
    body: string;
    entityType?: string;
    entityId?: string;
    metadata?: Record<string, any>;
    actionUrl?: string;
    expiresAt?: Date;
  }): Promise<Notification> {
    try {
      const notification = await this.prisma.notification.create({
        data: {
          userId: data.userId,
          type: data.type,
          title: data.title,
          body: data.body,
          entityType: data.entityType,
          entityId: data.entityId,
          metadata: data.metadata as any,
          actionUrl: data.actionUrl,
          expiresAt: data.expiresAt,
        },
      });

      this.logger.log(
        `Notification created: ${notification.id} for user ${data.userId} (type: ${data.type})`,
      );

      // âœ… Send real-time notification (non-blocking)
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(data.userId)) {
            this.notificationGateway.sendNotificationToUser(data.userId, notification);

            const unreadCount = await this.getUnreadCount(data.userId);
            this.notificationGateway.sendUnreadCountUpdate(data.userId, unreadCount);

            this.logger.debug(`Real-time notification sent to user ${data.userId}`);
          }
        } catch (wsError) {
          this.logger.warn(
            `WebSocket delivery failed for notification ${notification.id}`,
            wsError,
          );
        }
      });

      return notification;
    } catch (error) {
      this.logger.error(`Failed to create notification for user ${data.userId}`, error);
      throw new InternalServerErrorException('Failed to create notification');
    }
  }

  /**
   * Get paginated notifications with real-time metadata
   */
  async getUserNotifications(
    userId: string,
    query: NotificationQueryDto,
  ): Promise<NotificationPaginatedResponseDto> {
    try {
      const where: Prisma.NotificationWhereInput = {
        userId,
        ...(query.unreadOnly && { isRead: false }),
        ...(query.type && { type: query.type }),
        OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
      };

      const [notifications, totalItems, unreadCount] = await Promise.all([
        this.prisma.notification.findMany({
          where,
          orderBy: { createdAt: 'desc' },
          skip: query.skip,
          take: query.limit,
        }),
        this.prisma.notification.count({ where }),
        this.prisma.notification.count({
          where: {
            userId,
            isRead: false,
            OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
          },
        }),
      ]);

      const totalPages = Math.ceil(totalItems / query.limit);

      const pagination: NotificationPaginationDto = {
        totalItems,
        totalPages,
        currentPage: query.page,
        pageSize: notifications.length,
      };

      const data = plainToInstance(NotificationResponseDto, notifications, {
        excludeExtraneousValues: true,
      });

      return {
        data,
        pagination,
        unreadCount,
      };
    } catch (error) {
      this.logger.error(`Failed to fetch notifications for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to fetch notifications');
    }
  }

  /**
   * Get unread count
   */
  async getUnreadCount(userId: string): Promise<number> {
    try {
      return await this.prisma.notification.count({
        where: {
          userId,
          isRead: false,
          OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
        },
      });
    } catch (error) {
      this.logger.error(`Failed to get unread count for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to get unread count');
    }
  }

  /**
   * Mark notification as read with real-time update
   */
  async markAsRead(notificationId: string, userId: string): Promise<void> {
    try {
      const result = await this.prisma.notification.updateMany({
        where: { id: notificationId, userId },
        data: { isRead: true, readAt: new Date() },
      });

      if (result.count === 0) {
        throw new NotFoundException('Notification not found');
      }

      // âœ… Update unread count in real-time
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(userId)) {
            const unreadCount = await this.getUnreadCount(userId);
            this.notificationGateway.sendUnreadCountUpdate(userId, unreadCount);
          }
        } catch (wsError) {
          this.logger.warn('WebSocket update failed for markAsRead', wsError);
        }
      });

      this.logger.debug(`Notification ${notificationId} marked as read by user ${userId}`);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to mark notification ${notificationId} as read`, error);
      throw new InternalServerErrorException('Failed to mark notification as read');
    }
  }

  /**
   * Mark multiple notifications as read with real-time update
   */
  async markManyAsRead(notificationIds: string[], userId: string): Promise<number> {
    try {
      if (!notificationIds || notificationIds.length === 0) {
        throw new BadRequestException('No notification IDs provided');
      }

      const result = await this.prisma.notification.updateMany({
        where: {
          id: { in: notificationIds },
          userId,
        },
        data: { isRead: true, readAt: new Date() },
      });

      // âœ… Update unread count in real-time
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(userId)) {
            const unreadCount = await this.getUnreadCount(userId);
            this.notificationGateway.sendUnreadCountUpdate(userId, unreadCount);
          }
        } catch (wsError) {
          this.logger.warn('WebSocket update failed for markManyAsRead', wsError);
        }
      });

      this.logger.log(`Marked ${result.count} notifications as read for user ${userId}`);

      return result.count;
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to mark multiple notifications as read`, error);
      throw new InternalServerErrorException('Failed to mark notifications as read');
    }
  }

  /**
   * Mark all notifications as read with real-time update
   */
  async markAllAsRead(userId: string): Promise<number> {
    try {
      const result = await this.prisma.notification.updateMany({
        where: { userId, isRead: false },
        data: { isRead: true, readAt: new Date() },
      });

      // âœ… Update unread count in real-time
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(userId)) {
            this.notificationGateway.sendUnreadCountUpdate(userId, 0);
          }
        } catch (wsError) {
          this.logger.warn('WebSocket update failed for markAllAsRead', wsError);
        }
      });

      this.logger.log(`Marked all ${result.count} notifications as read for user ${userId}`);

      return result.count;
    } catch (error) {
      this.logger.error(`Failed to mark all notifications as read for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to mark all notifications as read');
    }
  }

  /**
   * Delete notification with real-time update
   */
  async deleteNotification(notificationId: string, userId: string): Promise<void> {
    try {
      // Check if notification is unread before deleting
      const notification = await this.prisma.notification.findFirst({
        where: { id: notificationId, userId },
        select: { isRead: true },
      });

      const result = await this.prisma.notification.deleteMany({
        where: { id: notificationId, userId },
      });

      if (result.count === 0) {
        throw new NotFoundException('Notification not found');
      }

      // âœ… Update unread count if deleted notification was unread
      if (notification && !notification.isRead) {
        setImmediate(async () => {
          try {
            if (this.notificationGateway.isUserConnected(userId)) {
              const unreadCount = await this.getUnreadCount(userId);
              this.notificationGateway.sendUnreadCountUpdate(userId, unreadCount);
            }
          } catch (wsError) {
            this.logger.warn('WebSocket update failed for deleteNotification', wsError);
          }
        });
      }

      this.logger.debug(`Notification ${notificationId} deleted by user ${userId}`);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to delete notification ${notificationId}`, error);
      throw new InternalServerErrorException('Failed to delete notification');
    }
  }

  /**
   * Delete all read notifications
   */
  async deleteAllRead(userId: string): Promise<number> {
    try {
      const result = await this.prisma.notification.deleteMany({
        where: { userId, isRead: true },
      });

      this.logger.log(`Deleted ${result.count} read notifications for user ${userId}`);

      return result.count;
    } catch (error) {
      this.logger.error(`Failed to delete read notifications for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to delete read notifications');
    }
  }

  /**
   * Cleanup expired notifications (CRON job)
   */
  async cleanupExpiredNotifications(): Promise<number> {
    try {
      const result = await this.prisma.notification.deleteMany({
        where: {
          expiresAt: { lt: new Date() },
        },
      });

      this.logger.log(`Cleaned up ${result.count} expired notifications`);

      return result.count;
    } catch (error) {
      this.logger.error('Failed to cleanup expired notifications', error);
      throw new InternalServerErrorException('Failed to cleanup expired notifications');
    }
  }
}

```

### `apps\backend\src\v1\notification\types\notification.types.ts`

```typescript
import { NotificationType } from '@actopod/schema';

export interface NotificationResponse {
  id: string;
  userId: string;
  type: NotificationType;
  title: string;
  body: string;
  entityType?: string | null;
  entityId?: string | null;
  metadata?: Record<string, any> | null;
  isRead: boolean;
  readAt?: Date | null;
  actionUrl?: string | null;
  createdAt: Date;
  expiresAt?: Date | null;
}

export interface NotificationListResponse {
  notifications: NotificationResponse[];
  unreadCount: number;
  total: number;
}

export interface UnreadCountResponse {
  count: number;
}

export type NotificationCreateInput = {
  userId: string;
  type: NotificationType;
  title: string;
  body: string;
  entityType?: string;
  entityId?: string;
  metadata?: Record<string, any>;
  actionUrl?: string;
  expiresAt?: Date;
};

```

### `apps\backend\src\v1\pods\dto\create-edge.dto.ts`

```typescript
import { IsString, IsOptional, IsBoolean } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateEdgeDto {
  @ApiProperty()
  @IsString()
  flowId!: string;

  @ApiProperty()
  @IsString()
  sourcePodId!: string;

  @ApiProperty()
  @IsString()
  targetPodId!: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  sourceHandle?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  targetHandle?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  animated?: boolean;
}

```

### `apps\backend\src\v1\pods\dto\create-pod.dto.ts`

```typescript
// dto/create-pod.dto.ts

import {
  IsString,
  IsEnum,
  IsObject,
  ValidateNested,
  IsOptional,
  IsNumber,
  IsArray,
  Min,
  Max,
} from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PodType, LLMProvider } from '@actopod/schema';

export class PositionDto {
  @ApiProperty()
  @IsNumber()
  x!: number;

  @ApiProperty()
  @IsNumber()
  y!: number;
}

export class LLMConfigDto {
  @ApiProperty({ enum: LLMProvider })
  @IsEnum(LLMProvider)
  provider!: LLMProvider;

  @ApiProperty({ example: 'gpt-4' })
  @IsString()
  model!: string;

  @ApiPropertyOptional({
    description: 'Custom system prompt. If not provided, uses default.',
    example: 'You are a helpful assistant specialized in data analysis.',
  })
  @IsOptional()
  @IsString()
  systemPrompt?: string;

  @ApiPropertyOptional({
    example: 'Analyze the following data: {{input}}',
    description: 'User prompt template. Can be empty initially.',
  })
  @IsOptional()
  @IsString()
  userPrompt?: string;

  @ApiPropertyOptional({
    minimum: 0,
    maximum: 2,
    default: 0.7,
    description: 'Controls randomness. Lower = more focused, Higher = more creative',
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(2)
  temperature?: number;

  @ApiPropertyOptional({
    minimum: 1,
    default: 4096,
    description: 'Maximum tokens in response',
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  maxTokens?: number;

  @ApiPropertyOptional({
    description: 'Thinking budget for reasoning models (o1, o3)',
    example: 10000,
  })
  @IsOptional()
  @IsNumber()
  thinkingBudget?: number;

  @ApiPropertyOptional({ minimum: 0, maximum: 1, default: 1.0 })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(1)
  topP?: number;

  @ApiPropertyOptional({ minimum: -2, maximum: 2, default: 0 })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  presencePenalty?: number;

  @ApiPropertyOptional({ minimum: -2, maximum: 2, default: 0 })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  frequencyPenalty?: number;

  @ApiPropertyOptional({ enum: ['text', 'json', 'json_object'], default: 'text' })
  @IsOptional()
  @IsString()
  responseFormat?: 'text' | 'json' | 'json_object';

  @ApiPropertyOptional({ default: false })
  @IsOptional()
  streamEnabled?: boolean;
}

export class CreatePodDto {
  @ApiProperty()
  @IsString()
  flowId!: string;

  @ApiProperty({ enum: PodType })
  @IsEnum(PodType)
  type!: PodType;

  @ApiProperty()
  @ValidateNested()
  @Type(() => PositionDto)
  position!: PositionDto;

  @ApiProperty()
  @IsString()
  label!: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description?: string;

  @ApiProperty({ description: 'Pod configuration (type-specific)' })
  @IsObject()
  config!: any; // Will be LLMConfigDto for LLM pods

  @ApiPropertyOptional()
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextPods?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}

```

### `apps\backend\src\v1\pods\dto\pod-config-response.dto.ts`

```typescript
import { Expose } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';

export class PodConfigResponseDto {
  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ example: 'gpt-4o' })
  model!: string;

  @Expose()
  @ApiPropertyOptional()
  systemPrompt?: string;

  @Expose()
  @ApiProperty()
  temperature!: number;

  @Expose()
  @ApiProperty()
  maxTokens!: number;

  @Expose()
  @ApiPropertyOptional()
  thinkingBudget?: number;

  @Expose()
  @ApiPropertyOptional()
  topP?: number;

  @Expose()
  @ApiPropertyOptional()
  presencePenalty?: number;

  @Expose()
  @ApiPropertyOptional()
  frequencyPenalty?: number;

  @Expose()
  @ApiPropertyOptional()
  responseFormat?: 'text' | 'json' | 'json_object';

  @Expose()
  @ApiPropertyOptional()
  streamEnabled?: boolean;
}

```

### `apps\backend\src\v1\pods\dto\pod-response.dto.ts`

```typescript
import { Expose } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';
import { PodType, PodExecutionStatus } from '@actopod/schema';

export class PodResponseDto {
  @Expose()
  @ApiProperty()
  id!: string;

  @Expose()
  @ApiProperty()
  flowId!: string;

  @Expose()
  @ApiProperty({ enum: PodType })
  type!: PodType;

  @Expose()
  @ApiProperty()
  position!: any;

  @Expose()
  @ApiProperty({ enum: PodExecutionStatus })
  executionStatus!: PodExecutionStatus;

  @Expose()
  @ApiProperty()
  createdAt!: Date;

  @Expose()
  @ApiProperty()
  updatedAt!: Date;

  @Expose()
  @ApiProperty({ description: 'Pod content from DynamoDB' })
  content?: any;

  @Expose()
  @ApiProperty({ description: 'Context pods attached' })
  contextPods?: string[];

  @Expose()
  @ApiProperty({ description: 'Lock information' })
  lockedBy?: string | null;

  @Expose()
  @ApiProperty()
  lockedAt?: Date | null;
}

export class EdgeResponseDto {
  @Expose()
  @ApiProperty()
  id!: string;

  @Expose()
  @ApiProperty()
  flowId!: string;

  @Expose()
  @ApiProperty()
  sourcePodId!: string;

  @Expose()
  @ApiProperty()
  targetPodId!: string;

  @Expose()
  @ApiProperty()
  sourceHandle!: string | null;

  @Expose()
  @ApiProperty()
  targetHandle!: string | null;

  @Expose()
  @ApiProperty()
  animated!: boolean;

  @Expose()
  @ApiProperty()
  createdAt!: Date;
}

export class FlowCanvasResponseDto {
  @ApiProperty({ type: [PodResponseDto] })
  pods!: PodResponseDto[];

  @ApiProperty({ type: [EdgeResponseDto] })
  edges!: EdgeResponseDto[];
}

```

### `apps\backend\src\v1\pods\dto\update-pod.dto.ts`

```typescript
// dto/update-pod.dto.ts

import { IsOptional, IsString, IsObject, ValidateNested, IsArray } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { PositionDto, LLMConfigDto } from './create-pod.dto';

export class UpdatePodDto {
  @ApiPropertyOptional()
  @IsOptional()
  @ValidateNested()
  @Type(() => PositionDto)
  position?: PositionDto;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  label?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({
    description:
      'Partial config update. For LLM pods, can update individual fields like systemPrompt, temperature, etc.',
  })
  @IsOptional()
  @IsObject()
  config?: Partial<LLMConfigDto> | any;

  @ApiPropertyOptional()
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextPods?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}

```

### `apps\backend\src\v1\pods\edge.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';
import { plainToInstance } from 'class-transformer';
import { CreateEdgeDto } from './dto/create-edge.dto';
import { EdgeResponseDto } from './dto/pod-response.dto';
import { V1FlowGateway } from '../flow/flow.gateway';

@Injectable()
export class V1EdgeService {
  private readonly logger = new Logger(V1EdgeService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
    private readonly flowGateway: V1FlowGateway,
  ) {}

  /**
   * Create an edge connection between two pods
   */
  async createEdge(
    workspaceId: string,
    userId: string,
    dto: CreateEdgeDto,
  ): Promise<EdgeResponseDto> {
    try {
      // Verify flow exists in workspace
      const flow = await this.prisma.flow.findFirst({
        where: { id: dto.flowId, workspaceId },
      });

      if (!flow) {
        throw new NotFoundException(`Flow ${dto.flowId} not found`);
      }

      // Verify both pods exist in the flow
      const [sourcePod, targetPod] = await Promise.all([
        this.prisma.pod.findFirst({
          where: { id: dto.sourcePodId, flowId: dto.flowId },
        }),
        this.prisma.pod.findFirst({
          where: { id: dto.targetPodId, flowId: dto.flowId },
        }),
      ]);

      if (!sourcePod) {
        throw new BadRequestException(`Source pod ${dto.sourcePodId} not found in flow`);
      }

      if (!targetPod) {
        throw new BadRequestException(`Target pod ${dto.targetPodId} not found in flow`);
      }

      // Prevent self-loops
      if (dto.sourcePodId === dto.targetPodId) {
        throw new BadRequestException('Cannot create edge from pod to itself');
      }

      // Check for duplicate edges
      const existingEdge = await this.prisma.edge.findFirst({
        where: {
          flowId: dto.flowId,
          sourcePodId: dto.sourcePodId,
          targetPodId: dto.targetPodId,
          sourceHandle: dto.sourceHandle || null,
          targetHandle: dto.targetHandle || null,
        },
      });

      if (existingEdge) {
        throw new BadRequestException('Edge already exists between these pods and handles');
      }

      // Create edge in PostgreSQL
      const edge = await this.prisma.edge.create({
        data: {
          flowId: dto.flowId,
          sourcePodId: dto.sourcePodId,
          targetPodId: dto.targetPodId,
          sourceHandle: dto.sourceHandle,
          targetHandle: dto.targetHandle,
          animated: dto.animated || false,
        },
      });

      // Update DynamoDB connectedPods
      const tableName = this.dynamoDb.getTableNames().pods;
      try {
        const sourceItem = await this.dynamoDb.getItem(tableName, {
          pk: sourcePod.dynamoPartitionKey,
          sk: sourcePod.dynamoSortKey,
        });

        if (sourceItem) {
          const updatedConnectedPods = [
            ...new Set([...(sourceItem.connectedPods || []), dto.targetPodId]),
          ];
          await this.dynamoDb.putItem(tableName, {
            ...sourceItem,
            connectedPods: updatedConnectedPods,
            updatedAt: new Date().toISOString(),
          });
        }
      } catch (dynamoError) {
        this.logger.warn(
          `Failed to update connectedPods in DynamoDB for pod ${dto.sourcePodId}:`,
          dynamoError,
        );
        // Don't fail edge creation if DynamoDB update fails
      }

      this.logger.log(
        `âœ… Edge created: ${edge.id} (${dto.sourcePodId} â†’ ${dto.targetPodId}) by user ${userId}`,
      );

      const result = plainToInstance(EdgeResponseDto, edge, {
        excludeExtraneousValues: true,
      });

      // Broadcast to all users
      this.flowGateway.broadcastToFlow(dto.flowId, 'edge:created', {
        edge: result,
        userId,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof BadRequestException) throw error;
      this.logger.error('âŒ Failed to create edge', error);
      throw new InternalServerErrorException('Failed to create edge');
    }
  }

  /**
   * Delete an edge connection
   */
  async deleteEdge(edgeId: string, workspaceId: string, userId: string): Promise<void> {
    try {
      // Fetch edge with related pods
      const edge = await this.prisma.edge.findFirst({
        where: {
          id: edgeId,
          flow: { workspaceId },
        },
        include: {
          sourcePod: true,
          targetPod: true,
        },
      });

      if (!edge) {
        throw new NotFoundException(`Edge ${edgeId} not found`);
      }

      const flowId = edge.flowId;

      // Update DynamoDB connectedPods
      const tableName = this.dynamoDb.getTableNames().pods;
      try {
        const sourceItem = await this.dynamoDb.getItem(tableName, {
          pk: edge.sourcePod.dynamoPartitionKey,
          sk: edge.sourcePod.dynamoSortKey,
        });

        if (sourceItem) {
          const updatedConnectedPods = (sourceItem.connectedPods || []).filter(
            (podId: string) => podId !== edge.targetPodId,
          );
          await this.dynamoDb.putItem(tableName, {
            ...sourceItem,
            connectedPods: updatedConnectedPods,
            updatedAt: new Date().toISOString(),
          });
        }
      } catch (dynamoError) {
        this.logger.warn(
          `Failed to update connectedPods in DynamoDB for pod ${edge.sourcePodId}:`,
          dynamoError,
        );
        // Don't fail edge deletion if DynamoDB update fails
      }

      // Delete edge from PostgreSQL
      await this.prisma.edge.delete({
        where: { id: edgeId },
      });

      this.logger.log(`âœ… Edge deleted: ${edgeId} by user ${userId}`);

      // Broadcast deletion
      this.flowGateway.broadcastToFlow(flowId, 'edge:deleted', {
        edgeId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`âŒ Failed to delete edge ${edgeId}`, error);
      throw new InternalServerErrorException('Failed to delete edge');
    }
  }
}

```

### `apps\backend\src\v1\pods\pod.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  HttpCode,
  HttpStatus,
  ValidationPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
  ApiNotFoundResponse,
} from '@nestjs/swagger';
import { V1PodService } from './pod.service';
import { V1EdgeService } from './edge.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { CreatePodDto } from './dto/create-pod.dto';
import { UpdatePodDto } from './dto/update-pod.dto';
import { CreateEdgeDto } from './dto/create-edge.dto';
import { PodResponseDto, EdgeResponseDto, FlowCanvasResponseDto } from './dto/pod-response.dto';

@ApiTags('Pods & Edges')
@ApiBearerAuth('JWT')
@Controller({
  path: 'workspaces/:workspaceId/flows/:flowId/canvas',
  version: '1',
})
@ApiUnauthorizedResponse({ description: 'Unauthorized' })
export class V1PodController {
  constructor(
    private readonly podService: V1PodService,
    private readonly edgeService: V1EdgeService,
  ) {}

  // ==================== CANVAS ====================

  @Get()
  @ApiOperation({ summary: 'Get complete canvas (pods + edges)' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiResponse({ status: 200, type: FlowCanvasResponseDto })
  async getCanvas(
    @Param('workspaceId') workspaceId: string,
    @Param('flowId') flowId: string,
  ): Promise<FlowCanvasResponseDto> {
    return this.podService.getFlowCanvas(flowId, workspaceId);
  }

  // ==================== PODS ====================

  @Post('pods')
  @ApiOperation({ summary: 'Create a new pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiResponse({ status: 201, type: PodResponseDto })
  @ApiBadRequestResponse({ description: 'Invalid input' })
  async createPod(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: CreatePodDto,
  ): Promise<PodResponseDto> {
    return this.podService.createPod(workspaceId, userId, dto);
  }

  @Patch('pods/:podId')
  @ApiOperation({ summary: 'Update a pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 200, type: PodResponseDto })
  @ApiNotFoundResponse({ description: 'Pod not found' })
  async updatePod(
    @Param('workspaceId') workspaceId: string,
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: UpdatePodDto,
  ): Promise<PodResponseDto> {
    return this.podService.updatePod(podId, workspaceId, userId, dto);
  }

  @Delete('pods/:podId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete a pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 204, description: 'Pod deleted' })
  @ApiNotFoundResponse({ description: 'Pod not found' })
  async deletePod(
    @Param('workspaceId') workspaceId: string,
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.podService.deletePod(podId, workspaceId, userId);
  }

  @Post('pods/:podId/lock')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Lock pod for editing' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 200, description: 'Pod locked' })
  async lockPod(
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<{ message: string }> {
    await this.podService.lockPod(podId, userId);
    return { message: 'Pod locked successfully' };
  }

  @Post('pods/:podId/unlock')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Unlock pod' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 200, description: 'Pod unlocked' })
  async unlockPod(
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<{ message: string }> {
    await this.podService.unlockPod(podId, userId);
    return { message: 'Pod unlocked successfully' };
  }

  // ==================== EDGES ====================

  @Post('edges')
  @ApiOperation({ summary: 'Create an edge (connection)' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiResponse({ status: 201, type: EdgeResponseDto })
  @ApiBadRequestResponse({ description: 'Invalid input' })
  async createEdge(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: CreateEdgeDto,
  ): Promise<EdgeResponseDto> {
    return this.edgeService.createEdge(workspaceId, userId, dto);
  }

  @Delete('edges/:edgeId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete an edge' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'edgeId', description: 'Edge ID' })
  @ApiResponse({ status: 204, description: 'Edge deleted' })
  @ApiNotFoundResponse({ description: 'Edge not found' })
  async deleteEdge(
    @Param('workspaceId') workspaceId: string,
    @Param('edgeId') edgeId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.edgeService.deleteEdge(edgeId, workspaceId, userId);
  }
}

```

### `apps\backend\src\v1\pods\pod.module.ts`

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { V1PodController } from './pod.controller';
import { V1PodService } from './pod.service';
import { V1EdgeService } from './edge.service';
import { PrismaModule } from '../../prisma/prisma.module';
import { AwsModule } from '../../common/aws/aws.module';
import { V1FlowModule } from '../flow/flow.module';

@Module({
  imports: [PrismaModule, AwsModule, forwardRef(() => V1FlowModule)],
  controllers: [V1PodController],
  providers: [V1PodService, V1EdgeService],
  exports: [V1PodService, V1EdgeService],
})
export class V1PodModule {}

```

### `apps\backend\src\v1\pods\pod.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  InternalServerErrorException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { PodType, PodExecutionStatus } from '@actopod/schema';
import { plainToInstance } from 'class-transformer';
import { CreatePodDto } from './dto/create-pod.dto';
import { UpdatePodDto } from './dto/update-pod.dto';
import { PodResponseDto, EdgeResponseDto, FlowCanvasResponseDto } from './dto/pod-response.dto';
import { DynamoPodItem, PodContent } from './types/pod-content.types';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';
import { V1FlowGateway } from '../flow/flow.gateway';

@Injectable()
export class V1PodService {
  private readonly logger = new Logger(V1PodService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
    private readonly flowGateway: V1FlowGateway,
  ) {}

  /**
   * Get all pods and edges in a flow
   * Fetches metadata from PostgreSQL and content from DynamoDB
   */
  async getFlowCanvas(flowId: string, workspaceId: string): Promise<FlowCanvasResponseDto> {
    try {
      // Verify flow exists and user has access
      const flow = await this.prisma.flow.findFirst({
        where: { id: flowId, workspaceId },
      });

      if (!flow) {
        throw new NotFoundException(`Flow ${flowId} not found`);
      }

      const [pods, edges] = await Promise.all([
        this.prisma.pod.findMany({
          where: { flowId },
          orderBy: { createdAt: 'asc' },
        }),
        this.prisma.edge.findMany({
          where: { flowId },
          orderBy: { createdAt: 'asc' },
        }),
      ]);

      const tableName = this.dynamoDb.getTableNames().pods;

      // Fetch DynamoDB content for all pods
      const podsWithContent = await Promise.all(
        pods.map(async (pod) => {
          try {
            const dynamoItem = await this.dynamoDb.getItem(tableName, {
              pk: pod.dynamoPartitionKey,
              sk: pod.dynamoSortKey,
            });

            return plainToInstance(
              PodResponseDto,
              {
                ...pod,
                content: dynamoItem?.content || null,
                contextPods: dynamoItem?.contextPods || [],
              },
              { excludeExtraneousValues: true },
            );
          } catch (err) {
            this.logger.warn(
              `Failed to fetch content for pod ${pod.id}: ${err instanceof Error ? err.message : 'Unknown error'}`,
            );
            // Return pod with null content instead of failing entire request
            return plainToInstance(
              PodResponseDto,
              { ...pod, content: null, contextPods: [] },
              { excludeExtraneousValues: true },
            );
          }
        }),
      );

      const edgeResponses = edges.map((edge) =>
        plainToInstance(EdgeResponseDto, edge, { excludeExtraneousValues: true }),
      );

      this.logger.debug(
        `âœ… Fetched canvas for flow ${flowId}: ${podsWithContent.length} pods, ${edgeResponses.length} edges`,
      );

      return {
        pods: podsWithContent,
        edges: edgeResponses,
      };
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to fetch canvas for flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch flow canvas');
    }
  }

  /**
   * Create a new pod with content in DynamoDB
   */
  async createPod(workspaceId: string, userId: string, dto: CreatePodDto): Promise<PodResponseDto> {
    try {
      // Verify flow exists
      const flow = await this.prisma.flow.findFirst({
        where: { id: dto.flowId, workspaceId },
      });

      if (!flow) {
        throw new NotFoundException(`Flow ${dto.flowId} not found`);
      }

      // Validate config based on pod type
      this.validatePodConfig(dto.type, dto.config);

      const podId = this.generateId();
      const pk = `WORKSPACE#${workspaceId}`;
      const sk = `FLOW#${dto.flowId}#POD#${podId}`;
      const gsi1pk = `FLOW#${dto.flowId}`;
      const gsi1sk = `POD#${podId}`;

      // Serialize position to plain object
      const positionPlain = this.serializePosition(dto.position);

      const content: PodContent = {
        type: dto.type,
        label: dto.label,
        description: dto.description,
        position: positionPlain,
        config: dto.config,
        inputs: this.getDefaultInputs(dto.type),
        outputs: this.getDefaultOutputs(dto.type),
        metadata: dto.metadata || {},
      } as any;

      const dynamoItem: DynamoPodItem = {
        pk,
        sk,
        gsi1pk,
        gsi1sk,
        podId,
        flowId: dto.flowId,
        workspaceId,
        content,
        connectedPods: [],
        contextPods: dto.contextPods || [],
        version: 1,
        createdBy: userId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Save to DynamoDB first
      const tableName = this.dynamoDb.getTableNames().pods;
      await this.dynamoDb.putItem(tableName, dynamoItem);

      // Then save to PostgreSQL
      const pod = await this.prisma.pod.create({
        data: {
          id: podId,
          flowId: dto.flowId,
          type: dto.type,
          position: positionPlain,
          executionStatus: PodExecutionStatus.IDLE,
          dynamoPartitionKey: pk,
          dynamoSortKey: sk,
        },
      });

      this.logger.log(
        `âœ… Pod created: ${pod.id} (${dto.type}) in flow ${dto.flowId} by user ${userId}`,
      );

      const result = plainToInstance(
        PodResponseDto,
        {
          ...pod,
          content,
          contextPods: dto.contextPods || [],
        },
        { excludeExtraneousValues: true },
      );

      // Broadcast to all users in the flow
      this.flowGateway.broadcastToFlow(dto.flowId, 'pod:created', {
        pod: result,
        userId,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof BadRequestException) throw error;
      this.logger.error('âŒ Failed to create pod', error);
      throw new InternalServerErrorException('Failed to create pod');
    }
  }

  /**
   * Update pod content in DynamoDB
   */
  async updatePod(
    podId: string,
    workspaceId: string,
    userId: string,
    dto: UpdatePodDto,
  ): Promise<PodResponseDto> {
    try {
      // Fetch pod with flow for workspace validation
      const pod = await this.prisma.pod.findFirst({
        where: {
          id: podId,
          flow: { workspaceId },
        },
      });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      // Check if pod is locked by another user
      if (pod.lockedBy && pod.lockedBy !== userId) {
        throw new ConflictException(`Pod is locked by user ${pod.lockedBy}`);
      }

      const tableName = this.dynamoDb.getTableNames().pods;
      const existingItem = (await this.dynamoDb.getItem(tableName, {
        pk: pod.dynamoPartitionKey,
        sk: pod.dynamoSortKey,
      })) as DynamoPodItem | null;

      if (!existingItem) {
        throw new NotFoundException('Pod content not found in DynamoDB');
      }

      // Serialize position if provided
      const positionPlain = dto.position ? this.serializePosition(dto.position) : undefined;

      // Merge config changes (deep merge for partial updates)
      const updatedConfig = dto.config
        ? this.mergeConfig(existingItem.content.config, dto.config)
        : existingItem.content.config;

      const updatedContent: PodContent = {
        ...existingItem.content,
        ...(dto.label && { label: dto.label }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(positionPlain && { position: positionPlain }),
        config: updatedConfig,
        ...(dto.metadata && {
          metadata: { ...existingItem.content.metadata, ...dto.metadata },
        }),
      };

      const updatedItem: DynamoPodItem = {
        ...existingItem,
        content: updatedContent,
        contextPods: dto.contextPods ?? existingItem.contextPods,
        version: existingItem.version + 1,
        updatedAt: new Date().toISOString(),
      };

      // Update DynamoDB
      await this.dynamoDb.putItem(tableName, updatedItem);

      // Update PostgreSQL position if changed
      if (positionPlain) {
        await this.prisma.pod.update({
          where: { id: podId },
          data: { position: positionPlain },
        });
      }

      this.logger.log(`âœ… Pod updated: ${podId} by user ${userId}`);

      const result = plainToInstance(
        PodResponseDto,
        {
          ...pod,
          position: positionPlain || pod.position,
          content: updatedContent,
          contextPods: updatedItem.contextPods,
        },
        { excludeExtraneousValues: true },
      );

      // Broadcast update to all users
      this.flowGateway.broadcastToFlow(pod.flowId, 'pod:updated', {
        podId,
        updates: result,
        userId,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof BadRequestException
      )
        throw error;
      this.logger.error(`âŒ Failed to update pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to update pod');
    }
  }

  /**
   * Delete pod from both PostgreSQL and DynamoDB
   */
  async deletePod(podId: string, workspaceId: string, userId: string): Promise<void> {
    try {
      const pod = await this.prisma.pod.findFirst({
        where: {
          id: podId,
          flow: { workspaceId },
        },
      });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      const flowId = pod.flowId;

      // Delete from DynamoDB first
      const tableName = this.dynamoDb.getTableNames().pods;
      await this.dynamoDb.deleteItem(tableName, {
        pk: pod.dynamoPartitionKey,
        sk: pod.dynamoSortKey,
      });

      // Then delete from PostgreSQL (cascades edges automatically via schema)
      await this.prisma.pod.delete({
        where: { id: podId },
      });

      this.logger.log(`âœ… Pod deleted: ${podId} by user ${userId}`);

      // Broadcast deletion
      this.flowGateway.broadcastToFlow(flowId, 'pod:deleted', {
        podId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`âŒ Failed to delete pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to delete pod');
    }
  }

  /**
   * Lock pod for editing
   */
  async lockPod(podId: string, userId: string): Promise<void> {
    try {
      const pod = await this.prisma.pod.findUnique({ where: { id: podId } });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      if (pod.lockedBy && pod.lockedBy !== userId) {
        throw new ConflictException(`Pod is already locked by user ${pod.lockedBy}`);
      }

      await this.prisma.pod.update({
        where: { id: podId },
        data: {
          lockedBy: userId,
          lockedAt: new Date(),
        },
      });

      this.logger.debug(`ðŸ”’ Pod locked: ${podId} by user ${userId}`);

      // Broadcast lock status
      this.flowGateway.broadcastToFlow(pod.flowId, 'pod:locked', {
        podId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ConflictException) throw error;
      this.logger.error(`Failed to lock pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to lock pod');
    }
  }

  /**
   * Unlock pod after editing
   */
  async unlockPod(podId: string, userId: string): Promise<void> {
    try {
      const pod = await this.prisma.pod.findUnique({ where: { id: podId } });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      if (pod.lockedBy && pod.lockedBy !== userId) {
        throw new ConflictException(`Cannot unlock pod locked by another user`);
      }

      await this.prisma.pod.update({
        where: { id: podId },
        data: {
          lockedBy: null,
          lockedAt: null,
        },
      });

      this.logger.debug(`ðŸ”“ Pod unlocked: ${podId} by user ${userId}`);

      // Broadcast unlock status
      this.flowGateway.broadcastToFlow(pod.flowId, 'pod:unlocked', {
        podId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ConflictException) throw error;
      this.logger.error(`Failed to unlock pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to unlock pod');
    }
  }

  // ==================== PRIVATE HELPER METHODS ====================

  private validatePodConfig(type: PodType, config: any): void {
    if (type === PodType.LLM_PROMPT) {
      if (!config.provider || !config.model) {
        throw new BadRequestException('LLM pods require provider and model in config');
      }
    }
  }

  private serializePosition(position: any): { x: number; y: number } {
    return JSON.parse(JSON.stringify(position));
  }

  private mergeConfig(existing: any, updates: any): any {
    return { ...existing, ...updates };
  }

  private getDefaultInputs(type: PodType) {
    switch (type) {
      case PodType.LLM_PROMPT:
        return [
          { id: 'input', label: 'Input', type: 'target' as const, dataType: 'string' as const },
          {
            id: 'context',
            label: 'Context',
            type: 'target' as const,
            dataType: 'document' as const,
          },
        ];
      case PodType.TEXT_OUTPUT:
      case PodType.IMAGE_OUTPUT:
        return [{ id: 'input', label: 'Input', type: 'target' as const, dataType: 'any' as const }];
      default:
        return [];
    }
  }

  private getDefaultOutputs(type: PodType) {
    switch (type) {
      case PodType.TEXT_INPUT:
      case PodType.LLM_PROMPT:
      case PodType.CODE_EXECUTION:
        return [
          { id: 'output', label: 'Output', type: 'source' as const, dataType: 'string' as const },
        ];
      case PodType.DOCUMENT_INPUT:
        return [
          {
            id: 'output',
            label: 'Document',
            type: 'source' as const,
            dataType: 'document' as const,
          },
        ];
      case PodType.IMAGE_INPUT:
        return [
          { id: 'output', label: 'Image', type: 'source' as const, dataType: 'image' as const },
        ];
      default:
        return [];
    }
  }

  private generateId(): string {
    return `pod_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

```

### `apps\backend\src\v1\pods\types\pod-content.types.ts`

```typescript
import { LLMProvider } from '@actopod/schema';

// ==========================================
// CORE TYPES
// ==========================================

export type PodPort = {
  id: string;
  label: string;
  type: 'source' | 'target';
  dataType:
    | 'string'
    | 'number'
    | 'boolean'
    | 'object'
    | 'array'
    | 'document'
    | 'image'
    | 'video'
    | 'audio'
    | 'any';
};

export type Position = {
  x: number;
  y: number;
};

// ==========================================
// POD CONFIGURATIONS (TYPE-SPECIFIC)
// ==========================================

export type LLMConfig = {
  provider: LLMProvider;
  model: string;
  systemPrompt?: string;
  userPrompt: string;
  temperature?: number;
  maxTokens?: number;
  thinkingBudget?: number;
  topP?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;
  responseFormat?: 'text' | 'json' | 'json_object';
  streamEnabled?: boolean;
};

export type TextInputConfig = {
  text: string;
  placeholder?: string;
  multiline?: boolean;
  maxLength?: number;
};

export type DocumentInputConfig = {
  documentId: string;
  extractionType: 'full' | 'chunk';
  chunkSize?: number;
  chunkOverlap?: number;
};

export type URLInputConfig = {
  url: string;
  extractionType: 'full' | 'summary';
  timeout?: number;
};

export type ImageInputConfig = {
  imageUrl?: string;
  imageS3Key?: string;
  altText?: string;
};

export type VideoInputConfig = {
  videoUrl?: string;
  videoS3Key?: string;
  transcriptionEnabled?: boolean;
};

export type AudioInputConfig = {
  audioUrl?: string;
  audioS3Key?: string;
  transcriptionEnabled?: boolean;
};

export type CodeExecutionConfig = {
  language: 'javascript' | 'python' | 'typescript';
  code: string;
  timeout?: number;
};

export type EmbeddingConfig = {
  provider: LLMProvider;
  model: string;
  dimensions?: number;
};

export type ToolConfig = {
  toolName: string;
  toolParameters: Record<string, any>;
};

export type OutputConfig = {
  format?: 'text' | 'json' | 'markdown';
  saveToS3?: boolean;
};

export type ContextModuleConfig = {
  contextModuleId: string;
  parameters?: Record<string, any>;
};

export type FlowContextInputConfig = {
  sourceFlowId: string;
  selectedPodIds?: string[];
};

// ==========================================
// UNIFIED POD CONTENT (ALL TYPES)
// ==========================================

export type PodContent =
  | {
      type: 'LLM_PROMPT';
      label: string;
      description?: string;
      position: Position;
      config: LLMConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'TEXT_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: TextInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'DOCUMENT_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: DocumentInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'URL_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: URLInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'IMAGE_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: ImageInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'VIDEO_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: VideoInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'AUDIO_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: AudioInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'CODE_EXECUTION';
      label: string;
      description?: string;
      position: Position;
      config: CodeExecutionConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'EMBEDDING_POD';
      label: string;
      description?: string;
      position: Position;
      config: EmbeddingConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'TOOL_POD';
      label: string;
      description?: string;
      position: Position;
      config: ToolConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'TEXT_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'IMAGE_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'VIDEO_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'AUDIO_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'CONTEXT_MODULE';
      label: string;
      description?: string;
      position: Position;
      config: ContextModuleConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'FLOW_CONTEXT_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: FlowContextInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    };

// ==========================================
// CONTEXT MAPPINGS (PINNED EXECUTIONS)
// ==========================================

export type PodContextMapping = {
  sourcePodId: string;
  pinnedExecutionId: string | null;
};

// ==========================================
// DYNAMODB POD ITEM
// ==========================================

export type DynamoPodItem = {
  pk: string;
  sk: string;
  gsi1pk: string;
  gsi1sk: string;
  podId: string;
  flowId: string;
  workspaceId: string;
  content: PodContent;
  connectedPods: string[];
  contextPods: string[];
  contextMappings?: PodContextMapping[];
  version: number;
  createdBy: string;
  createdAt: string;
  updatedAt: string;
  ttl?: number;
};

// ==========================================
// TYPE GUARDS (ALL POD TYPES)
// ==========================================

export type LLMPromptPodContent = Extract<PodContent, { type: 'LLM_PROMPT' }>;
export type TextInputPodContent = Extract<PodContent, { type: 'TEXT_INPUT' }>;
export type DocumentInputPodContent = Extract<PodContent, { type: 'DOCUMENT_INPUT' }>;
export type URLInputPodContent = Extract<PodContent, { type: 'URL_INPUT' }>;
export type ImageInputPodContent = Extract<PodContent, { type: 'IMAGE_INPUT' }>;
export type VideoInputPodContent = Extract<PodContent, { type: 'VIDEO_INPUT' }>;
export type AudioInputPodContent = Extract<PodContent, { type: 'AUDIO_INPUT' }>;
export type CodeExecutionPodContent = Extract<PodContent, { type: 'CODE_EXECUTION' }>;
export type EmbeddingPodContent = Extract<PodContent, { type: 'EMBEDDING_POD' }>;
export type ToolPodContent = Extract<PodContent, { type: 'TOOL_POD' }>;
export type TextOutputPodContent = Extract<PodContent, { type: 'TEXT_OUTPUT' }>;
export type ImageOutputPodContent = Extract<PodContent, { type: 'IMAGE_OUTPUT' }>;
export type VideoOutputPodContent = Extract<PodContent, { type: 'VIDEO_OUTPUT' }>;
export type AudioOutputPodContent = Extract<PodContent, { type: 'AUDIO_OUTPUT' }>;
export type ContextModulePodContent = Extract<PodContent, { type: 'CONTEXT_MODULE' }>;
export type FlowContextInputPodContent = Extract<PodContent, { type: 'FLOW_CONTEXT_INPUT' }>;

```

### `apps\backend\src\v1\server\health\health.controller.ts`

```typescript
import { Controller, Get } from '@nestjs/common';
import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';
import { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';
import { PrismaHealthIndicator } from './prisma.health';
import { Public } from '../../../common/decorators/common';

@Controller({ version: '1', path: 'health' })
@ApiTags('Health')
export class V1HealthController {
  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
    private prismaHealthIndicator: PrismaHealthIndicator,
  ) {}

  @Public()
  @Get()
  @HealthCheck()
  @ApiOperation({ summary: 'Perform health checks for the application' })
  @ApiResponse({
    status: 200,
    description: 'Health check successful',
    schema: {
      example: {
        statusCode: 200,
        message: 'Health check successful',
        data: {
          details: {
            google: { status: 'up' },
            database: { status: 'up' },
          },
          error: {},
          info: {
            google: { status: 'up' },
            database: { status: 'up' },
          },
        },
        errors: [],
        timestamp: '2024-09-08T17:38:42.611Z',
      },
    },
  })
  @ApiResponse({
    status: 500,
    description: 'Health check failed',
    schema: {
      example: {
        statusCode: 500,
        message: 'Health check failed',
        data: null,
        errors: ['Health check failure message'],
        timestamp: '2024-09-08T17:38:42.611Z',
      },
    },
  })
  async check() {
    const healthChecks = [
      () => this.http.pingCheck('google', 'https://www.google.com'),
      () => this.prismaHealthIndicator.isHealthy('database'),
    ];

    try {
      const result = await this.health.check(healthChecks);

      return {
        statusCode: 200,
        message: 'Health check successful',
        data: result,
        errors: [],
        timestamp: new Date().toISOString(),
      };
    } catch (error: any) {
      return {
        statusCode: error?.response?.status || 500,
        message: 'Health check failed',
        data: error?.response || null,
        errors: [error?.message || 'Unknown error'],
        timestamp: new Date().toISOString(),
      };
    }
  }
}

```

### `apps\backend\src\v1\server\health\health.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HttpModule } from '@nestjs/axios';
import { V1HealthController } from './health.controller';
import { PrismaHealthIndicator } from './prisma.health';
import { PrismaModule } from '../../../prisma/prisma.module';

@Module({
  imports: [TerminusModule, HttpModule, PrismaModule],
  controllers: [V1HealthController],
  providers: [PrismaHealthIndicator],
})
export class V1HealthModule {}

```

### `apps\backend\src\v1\server\health\prisma.health.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class PrismaHealthIndicator extends HealthIndicator {
  constructor(private readonly prisma: PrismaService) {
    super();
  }

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return this.getStatus(key, true);
    } catch (error: any) {
      const status = this.getStatus(key, false, { message: error?.message });
      throw new HealthCheckError('Prisma check failed', status);
    }
  }
}

```

### `apps\backend\src\v1\server\server.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1HealthModule as V1HealthModule } from './health/health.module';

@Module({
  imports: [V1HealthModule],
  exports: [V1HealthModule],
})
export class V1ServerModule {}

```

### `apps\backend\src\v1\user\user.controller.ts`

```typescript
import { Controller, Get, Logger } from '@nestjs/common';
import { V1UserService } from './user.service';
import { GetCurrentUserId } from '../../common/decorators/user';

@Controller('users')
export class V1UserController {
  private readonly logger = new Logger(V1UserController.name);

  constructor(private readonly userService: V1UserService) {}

  /**
   * GET /api/v1/users/me
   * Get current authenticated user
   */
  @Get('me')
  async getMe(@GetCurrentUserId('userId') userId: string) {
    this.logger.log(`User me endpoint called by: ${userId}`);

    const user = await this.userService.getCurrentUser(userId);

    return {
      statusCode: 200,
      message: 'User fetched successfully',
      data: {
        userId: user.id,
        email: user.email,
        name: user.name,
        image: user.image,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      errors: [],
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * GET /api/v1/users/me/verification-status
   * Check email verification status
   */
  @Get('me/verification-status')
  async getVerificationStatus(@GetCurrentUserId('userId') userId: string) {
    this.logger.log(`Verification status check for: ${userId}`);

    const status = await this.userService.checkEmailVerificationStatus(userId);

    return {
      statusCode: 200,
      message: 'Verification status fetched successfully',
      data: status,
      errors: [],
      timestamp: new Date().toISOString(),
    };
  }
}

```

### `apps\backend\src\v1\user\user.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { V1UserController } from './user.controller';
import { V1UserService } from './user.service';

@Module({
  imports: [PrismaModule],
  controllers: [V1UserController],
  providers: [V1UserService],
  exports: [V1UserService],
})
export class V1UserModule {}

```

### `apps\backend\src\v1\user\user.service.ts`

```typescript
import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class V1UserService {
  private readonly logger = new Logger(V1UserService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get user by ID with selected fields
   */
  async findById(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        image: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  /**
   * Get current authenticated user
   */
  async getCurrentUser(userId: string) {
    this.logger.log(`Fetching user data for: ${userId}`);
    return this.findById(userId);
  }

  /**
   * Get user with accounts (for checking email verification status)
   */
  async getUserWithAccounts(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        accounts: {
          select: {
            provider: true,
            providerAccountId: true,
            accessToken: true,
          },
        },
      },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  /**
   * Check if user's email is verified
   */
  async checkEmailVerificationStatus(userId: string): Promise<{
    isVerified: boolean;
    email: string;
  }> {
    const user = await this.getUserWithAccounts(userId);

    // Find email account
    const emailAccount = user.accounts.find((acc) => acc.provider === 'EMAIL');

    // Email is verified if:
    // 1. No email account exists (OAuth user)
    // 2. Email account exists but accessToken is null (verified)
    const isVerified = !emailAccount || !emailAccount.accessToken;

    return {
      isVerified,
      email: user.email,
    };
  }
}

```

### `apps\backend\src\v1\workspace\dto\workspace-add-api-key.dto.ts`

```typescript
// src/modules/workspace/dto/workspace-add-api-key.dto.ts

import { IsString, IsEnum, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';

export class WorkspaceAddApiKeyDto {
  @ApiProperty({
    description: 'LLM provider',
    enum: LLMProvider,
    example: 'OPENAI',
  })
  @IsEnum(LLMProvider)
  provider!: LLMProvider;

  @ApiProperty({
    description: 'Display name for the key',
    example: 'My OpenAI Key',
    maxLength: 100,
  })
  @IsString()
  @MaxLength(100)
  displayName!: string;

  @ApiProperty({
    description: 'The API key (will be encrypted)',
    example: 'sk-proj-abc123...',
  })
  @IsString()
  apiKey!: string;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-create.dto.ts`

```typescript
import { IsString, IsNotEmpty, MaxLength, IsEnum, IsOptional } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { WorkspaceType } from '@actopod/schema';

/**
 * DTO for creating a new workspace
 * Only TEAM workspaces can be created via API (PERSONAL auto-created on registration)
 */
export class WorkspaceCreateDto {
  @ApiProperty({
    description: 'Workspace name',
    example: 'My Team Workspace',
    maxLength: 255,
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  name!: string;

  @ApiProperty({
    description: 'Workspace type (PERSONAL workspaces are auto-created)',
    enum: WorkspaceType,
    default: WorkspaceType.TEAM,
    required: false,
  })
  @IsEnum(WorkspaceType)
  @IsOptional()
  type?: WorkspaceType = WorkspaceType.TEAM;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-send-invitation.dto.ts`

```typescript
import { IsEmail, IsEnum, IsOptional, IsObject } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { WorkspaceRole } from '@actopod/schema';

/**
 * DTO for sending workspace invitation via email
 * Requires canInviteMembers permission
 */
export class WorkspaceSendInvitationDto {
  @ApiProperty({
    description: 'Email to send invitation',
    example: 'invite@example.com',
  })
  @IsEmail()
  email!: string;

  @ApiProperty({
    description: 'Role for invited user',
    enum: WorkspaceRole,
    default: WorkspaceRole.MEMBER,
    required: false,
  })
  @IsEnum(WorkspaceRole)
  @IsOptional()
  role?: WorkspaceRole = WorkspaceRole.MEMBER;

  @ApiProperty({
    description: 'Custom permissions (optional override)',
    required: false,
    example: { canCreateCanvas: true, canDeleteCanvas: false },
  })
  @IsObject()
  @IsOptional()
  permissions?: Record<string, boolean>;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-update.dto.ts`

```typescript
import { IsString, IsNotEmpty, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

/**
 * DTO for updating workspace details
 * Currently only name is updatable
 */
export class WorkspaceUpdateDto {
  @ApiProperty({
    description: 'Updated workspace name',
    example: 'Updated Team Name',
    maxLength: 255,
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  name!: string;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-update-api-key.dto.ts`

```typescript
// src/modules/workspace/dto/workspace-update-api-key.dto.ts

import { IsString, IsOptional, IsBoolean, MaxLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';

export class WorkspaceUpdateApiKeyDto {
  @ApiPropertyOptional({
    description: 'Display name',
    example: 'Updated Key Name',
    maxLength: 100,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  displayName?: string;

  @ApiPropertyOptional({
    description: 'New API key (for rotation)',
    example: 'sk-proj-xyz789...',
  })
  @IsOptional()
  @IsString()
  apiKey?: string;

  @ApiPropertyOptional({
    description: 'Active status',
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-update-member.dto.ts`

```typescript
import { IsEnum, IsOptional, IsBoolean } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { WorkspaceRole } from '@actopod/schema';

/**
 * DTO for updating existing member's role and permissions
 * Cannot modify workspace OWNER
 */
export class WorkspaceUpdateMemberDto {
  @ApiProperty({
    description: 'Updated role',
    enum: WorkspaceRole,
    required: false,
  })
  @IsEnum(WorkspaceRole)
  @IsOptional()
  role?: WorkspaceRole;

  @ApiProperty({
    description: 'Can create canvas',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canCreateCanvas?: boolean;

  @ApiProperty({
    description: 'Can delete canvas',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canDeleteCanvas?: boolean;

  @ApiProperty({
    description: 'Can invite members',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canInviteMembers?: boolean;

  @ApiProperty({
    description: 'Can manage members',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canManageMembers?: boolean;

  @ApiProperty({
    description: 'Can manage API keys',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canManageApiKeys?: boolean;
}

```

### `apps\backend\src\v1\workspace\types\workspace.types.ts`

```typescript
// src/modules/workspace/types/workspace.types.ts

import { WorkspaceType, WorkspaceRole, InvitationStatus, LLMProvider } from '@actopod/schema';

export interface InvitationDetailsResponse {
  workspace: {
    id: string;
    name: string;
    type: string;
  };
  email: string;
  role: string;
  permissions: Record<string, boolean> | null;
  expiresAt: Date;
  status: string;
}
/**
 * Response type for workspace list
 */
export interface WorkspaceListItem {
  id: string;
  name: string;
  type: WorkspaceType;
  role: WorkspaceRole;
  permissions: {
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
  };
  memberCount: number;
  canvasCount: number;
  joinedAt: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Response type for workspace details
 */
export interface WorkspaceDetails {
  id: string;
  name: string;
  type: WorkspaceType;
  createdAt: Date;
  updatedAt: Date;
  members: Array<{
    userId: string;
    workspaceId: string;
    role: WorkspaceRole;
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
    joinedAt: Date;
    invitedBy: string | null;
    user: {
      id: string;
      email: string;
      name: string | null;
      image: string | null;
    };
  }>;
  _count: {
    flows: number;
    documents: number;
    apiKeys: number;
  };
  currentUserRole: WorkspaceRole;
  currentUserPermissions: {
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
  };
}

/**
 * Response type for workspace member
 */
export interface WorkspaceMemberResponse {
  userId: string;
  workspaceId: string;
  role: WorkspaceRole;
  canCreateCanvas: boolean;
  canDeleteCanvas: boolean;
  canManageBilling: boolean;
  canInviteMembers: boolean;
  canManageMembers: boolean;
  canManageApiKeys: boolean;
  joinedAt: Date;
  invitedBy: string | null;
  user: {
    id: string;
    email: string;
    name: string | null;
    image: string | null;
  };
}

/**
 * Simplified API key response (with usage tracking)
 */
export interface ApiKeyResponse {
  id: string;
  provider: LLMProvider;
  displayName: string;
  isActive: boolean;
  lastUsedAt: Date | null;
  createdAt: Date;

  // Usage metrics
  usageCount: number;
  totalTokens: string; // BigInt as string
  totalCost: number;

  // Error tracking
  lastErrorAt: Date | null;

  // Creator
  createdBy: {
    id: string;
    name: string | null;
    email: string;
  };
}

/**
 * Response type for invitations
 */
export interface InvitationResponse {
  id: string;
  workspaceId: string;
  email: string;
  role: WorkspaceRole;
  permissions: any;
  token: string;
  status: InvitationStatus;
  expiresAt: Date;
  createdAt: Date;
  invitedBy: string;
  invitedUserId: string | null;
  acceptedAt: Date | null;
}

/**
 * Response type for invitation acceptance
 */
export interface AcceptInvitationResponse {
  workspace: {
    id: string;
    name: string;
    type: WorkspaceType;
    createdAt: Date;
    updatedAt: Date;
  };
  member: any;
  message: string;
}

/**
 * Standard message response
 */
export interface MessageResponse {
  message: string;
}

/**
 * API key usage statistics (simplified)
 */
export interface ApiKeyUsageStats {
  totalKeys: number;
  activeKeys: number;
  inactiveKeys: number;
  providerBreakdown: Record<string, number>;

  // Cumulative metrics
  totalUsageCount: number;
  totalTokensConsumed: string; // BigInt as string
  totalCostIncurred: number;
}

/**
 * Usage metric response (daily aggregated)
 */
export interface UsageMetricResponse {
  id: string;
  date: Date;
  requestCount: number;
  successCount: number;
  errorCount: number;
  promptTokens: string; // BigInt as string
  completionTokens: string; // BigInt as string
  totalTokens: string; // BigInt as string
  estimatedCost: number;
}

```

### `apps\backend\src\v1\workspace\workspace.controller.ts`

```typescript
// src/modules/workspace/workspace.controller.ts

import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  HttpCode,
  HttpStatus,
  Query,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { V1WorkspaceService } from './workspace.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { WorkspaceCreateDto } from './dto/workspace-create.dto';
import { WorkspaceUpdateDto } from './dto/workspace-update.dto';
import { WorkspaceUpdateMemberDto } from './dto/workspace-update-member.dto';
import { WorkspaceSendInvitationDto } from './dto/workspace-send-invitation.dto';
import { WorkspaceAddApiKeyDto } from './dto/workspace-add-api-key.dto';
import { WorkspaceUpdateApiKeyDto } from './dto/workspace-update-api-key.dto';
import {
  WorkspaceListItem,
  WorkspaceDetails,
  WorkspaceMemberResponse,
  ApiKeyResponse,
  InvitationResponse,
  MessageResponse,
  UsageMetricResponse,
  ApiKeyUsageStats,
} from './types/workspace.types';
import { Public } from '../../common/decorators/common';

/**
 * V1 Workspace Controller
 *
 * @description Comprehensive workspace management controller handling:
 * - Workspace CRUD operations (create, read, update, delete)
 * - Team member management (add, update, remove)
 * - Email-based invitation system with secure tokens
 * - LLM provider API key management with AES-256-GCM encryption
 * - API key usage tracking and cost analytics
 * - Ownership transfer and workspace statistics
 *
 * @security Requires JWT Bearer token authentication for all endpoints
 * @version 1.0.0
 * @author Actopod Team
 * @see {@link V1WorkspaceService} for business logic implementation
 *
 * @remarks
 * All endpoints enforce workspace membership and permission checks.
 * OWNER role has all permissions by default.
 * PERSONAL workspaces cannot be created manually or deleted.
 */
@ApiTags('Workspaces')
@ApiBearerAuth()
@Controller({ path: 'workspaces', version: '1' })
export class V1WorkspaceController {
  constructor(private readonly workspaceService: V1WorkspaceService) {}

  // ==========================================
  // WORKSPACE CRUD OPERATIONS
  // ==========================================

  /**
   * Get all workspaces for current user
   *
   * @description Retrieves all workspaces where the authenticated user is a member.
   * Returns comprehensive information including role, granular permissions,
   * member count, canvas count, and join date for each workspace.
   *
   * @returns {Promise<WorkspaceListItem[]>} Array of workspace summaries
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   *
   * @example
   * ```
   * GET /api/v1/workspaces
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * [
   *   {
   *     "id": "clx123abc",
   *     "name": "My Team",
   *     "type": "TEAM",
   *     "role": "OWNER",
   *     "permissions": {
   *       "canCreateCanvas": true,
   *       "canDeleteCanvas": true,
   *       "canManageBilling": true,
   *       "canInviteMembers": true,
   *       "canManageMembers": true,
   *       "canManageApiKeys": true
   *     },
   *     "memberCount": 5,
   *     "canvasCount": 12,
   *     "joinedAt": "2025-01-15T10:30:00Z",
   *     "createdAt": "2025-01-15T10:30:00Z",
   *     "updatedAt": "2025-10-10T14:22:00Z"
   *   }
   * ]
   * ```
   */
  @Get()
  @ApiOperation({
    summary: 'List all workspaces for current user',
    description:
      'Retrieves all workspaces where the user is a member, ordered by join date (newest first)',
  })
  @ApiResponse({
    status: 200,
    description: 'Workspaces retrieved successfully',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string', example: 'clx123abc' },
          name: { type: 'string', example: 'My Team Workspace' },
          type: { type: 'string', enum: ['PERSONAL', 'TEAM'], example: 'TEAM' },
          role: { type: 'string', enum: ['OWNER', 'ADMIN', 'MEMBER', 'VIEWER'], example: 'OWNER' },
          permissions: {
            type: 'object',
            properties: {
              canCreateCanvas: { type: 'boolean' },
              canDeleteCanvas: { type: 'boolean' },
              canManageBilling: { type: 'boolean' },
              canInviteMembers: { type: 'boolean' },
              canManageMembers: { type: 'boolean' },
              canManageApiKeys: { type: 'boolean' },
            },
          },
          memberCount: { type: 'number', example: 5 },
          canvasCount: { type: 'number', example: 12 },
          joinedAt: { type: 'string', format: 'date-time' },
          createdAt: { type: 'string', format: 'date-time' },
          updatedAt: { type: 'string', format: 'date-time' },
        },
      },
    },
  })
  @ApiResponse({ status: 401, description: 'Unauthorized - Invalid or missing token' })
  async getAllWorkspaces(@GetCurrentUserId() userId: string): Promise<WorkspaceListItem[]> {
    return this.workspaceService.getAllWorkspaces(userId);
  }

  /**
   * Get workspace details by ID
   *
   * @description Retrieves complete workspace information including all members,
   * their roles and permissions, aggregate counts, and the current user's
   * access level.
   *
   * @param {string} id - Workspace unique identifier (CUID)
   * @returns {Promise<WorkspaceDetails>} Complete workspace data
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a member of this workspace
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "id": "clx123abc",
   *   "name": "My Team",
   *   "type": "TEAM",
   *   "members": [...],
   *   "_count": {
   *     "flows": 24,
   *     "documents": 45,
   *     "apiKeys": 3
   *   },
   *   "currentUserRole": "OWNER",
   *   "currentUserPermissions": {...}
   * }
   * ```
   */
  @Get(':id')
  @ApiOperation({
    summary: 'Get workspace details by ID',
    description:
      'Retrieves detailed workspace information including members, counts, and permissions',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID (CUID)', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Workspace details retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized - Invalid or missing token' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getWorkspaceById(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<WorkspaceDetails> {
    return this.workspaceService.getWorkspaceById(id, userId);
  }

  /**
   * Get workspace statistics
   *
   * @description Retrieves aggregate statistics and analytics for a workspace,
   * including total members, flows, documents, API keys, and role distribution.
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<any>} Workspace statistics object
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a workspace member
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/stats
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "totalMembers": 8,
   *   "totalFlows": 24,
   *   "totalDocuments": 45,
   *   "totalApiKeys": 3,
   *   "roleDistribution": {
   *     "owners": 1,
   *     "admins": 2,
   *     "members": 5
   *   }
   * }
   * ```
   */
  @Get(':id/stats')
  @ApiOperation({
    summary: 'Get workspace statistics and analytics',
    description: 'Retrieves aggregate counts and role distribution for workspace',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Statistics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getWorkspaceStats(@Param('id') id: string, @GetCurrentUserId() userId: string) {
    return this.workspaceService.getWorkspaceStats(id, userId);
  }

  /**
   * Create a new workspace
   *
   * @description Creates a new TEAM workspace with the creator automatically
   * assigned as OWNER with full permissions. PERSONAL workspaces cannot be
   * created manually (they are auto-created during user registration).
   *
   * @param {WorkspaceCreateDto} dto - Workspace creation data (name and type)
   * @returns {Promise<any>} Created workspace with initial member
   *
   * @throws {400} Bad Request - Attempting to create PERSONAL workspace or invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   *
   * @example
   * ```
   * POST /api/v1/workspaces
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "name": "My New Team",
   *   "type": "TEAM"
   * }
   * ```
   */
  @Post()
  @ApiOperation({
    summary: 'Create a new workspace',
    description:
      'Creates a new TEAM workspace with creator as OWNER (PERSONAL workspaces auto-created)',
  })
  @ApiResponse({ status: 201, description: 'Workspace created successfully' })
  @ApiResponse({
    status: 400,
    description: 'Bad Request - Invalid input or PERSONAL workspace attempt',
  })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async createWorkspace(
    @Body() dto: WorkspaceCreateDto,
    @GetCurrentUserId() userId: string,
  ): Promise<any> {
    return this.workspaceService.createWorkspace(userId, dto);
  }

  /**
   * Update workspace name
   *
   * @description Updates the workspace name. Requires `canManageMembers` permission.
   * Only the workspace name can be modified; type cannot be changed after creation.
   *
   * @param {string} id - Workspace unique identifier
   * @param {WorkspaceUpdateDto} dto - Update data (name)
   * @returns {Promise<any>} Updated workspace object
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageMembers)
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * PATCH /api/v1/workspaces/clx123abc
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "name": "Updated Team Name"
   * }
   * ```
   */
  @Patch(':id')
  @ApiOperation({
    summary: 'Update workspace name',
    description: 'Updates workspace name (requires canManageMembers permission)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Workspace updated successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async updateWorkspace(
    @Param('id') id: string,
    @Body() dto: WorkspaceUpdateDto,
    @GetCurrentUserId() userId: string,
  ): Promise<any> {
    return this.workspaceService.updateWorkspace(id, userId, dto);
  }

  /**
   * Delete workspace permanently
   *
   * @description Permanently deletes a workspace and all associated data.
   * Only workspace OWNERs can delete workspaces. PERSONAL workspaces
   * cannot be deleted (tied to user account lifecycle).
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {400} Bad Request - Attempting to delete PERSONAL workspace
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Only OWNER can delete workspaces
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "message": "Workspace deleted successfully"
   * }
   * ```
   */
  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete workspace',
    description: 'Permanently deletes workspace (OWNER only, not PERSONAL workspaces)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Workspace deleted successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Cannot delete PERSONAL workspace' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Only OWNER can delete' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async deleteWorkspace(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.deleteWorkspace(id, userId);
  }

  /**
   * Transfer workspace ownership
   *
   * @description Transfers workspace ownership to another member. The current
   * OWNER is demoted to ADMIN, and the target member is promoted to OWNER
   * with all permissions. Only the current OWNER can initiate transfer.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} newOwnerId - User ID of new owner (must be existing member)
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Only current OWNER can transfer ownership
   * @throws {404} Not Found - Workspace or target user not found
   *
   * @example
   * ```
   * POST /api/v1/workspaces/clx123abc/transfer-ownership/user_456
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Post(':id/transfer-ownership/:userId')
  @ApiOperation({
    summary: 'Transfer workspace ownership',
    description: 'Transfers ownership to another member (current OWNER becomes ADMIN)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'userId', description: 'New owner user ID', example: 'user_456' })
  @ApiResponse({ status: 200, description: 'Ownership transferred successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Only OWNER can transfer' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace or user not found' })
  async transferOwnership(
    @Param('id') id: string,
    @Param('userId') newOwnerId: string,
    @GetCurrentUserId() currentUserId: string,
  ) {
    return this.workspaceService.transferOwnership(id, currentUserId, newOwnerId);
  }

  // ==========================================
  // MEMBER MANAGEMENT
  // ==========================================

  /**
   * Get all workspace members
   *
   * @description Retrieves all members of a workspace with their roles,
   * granular permissions, join dates, and user profile information.
   * Results are ordered by join date (newest first).
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<WorkspaceMemberResponse[]>} Array of workspace members
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a workspace member
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/members
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/members')
  @ApiOperation({
    summary: 'List all workspace members',
    description: 'Retrieves all members with roles, permissions, and profile info',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Members retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getMembers(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<WorkspaceMemberResponse[]> {
    return this.workspaceService.getMembers(id, userId);
  }

  /**
   * Update workspace member
   *
   * @description Updates an existing member's role and granular permissions.
   * Cannot modify workspace OWNER. Requires `canManageMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} targetUserId - User ID of member to update
   * @param {WorkspaceUpdateMemberDto} dto - Update data (role, permissions)
   * @returns {Promise<WorkspaceMemberResponse>} Updated member record
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Cannot modify OWNER or insufficient permissions
   * @throws {404} Not Found - Member not found
   *
   * @example
   * ```
   * PATCH /api/v1/workspaces/clx123abc/members/user_456
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "role": "ADMIN",
   *   "canDeleteCanvas": true,
   *   "canManageMembers": true
   * }
   * ```
   */
  @Patch(':id/members/:userId')
  @ApiOperation({
    summary: 'Update member role and permissions',
    description: 'Updates member role/permissions (cannot modify OWNER, requires canManageMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'userId', description: 'Target user ID', example: 'user_456' })
  @ApiResponse({ status: 200, description: 'Member updated successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Cannot modify OWNER or insufficient permissions',
  })
  @ApiResponse({ status: 404, description: 'Not Found - Member not found' })
  async updateMember(
    @Param('id') id: string,
    @Param('userId') targetUserId: string,
    @Body() dto: WorkspaceUpdateMemberDto,
    @GetCurrentUserId() currentUserId: string,
  ): Promise<WorkspaceMemberResponse> {
    return this.workspaceService.updateMember(id, targetUserId, currentUserId, dto);
  }

  /**
   * Remove member from workspace
   *
   * @description Removes a member from the workspace. Cannot remove workspace
   * OWNER. Auto-converts TEAM workspace to PERSONAL if only 1 member remains.
   * Requires `canManageMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} targetUserId - User ID of member to remove
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Cannot remove OWNER or insufficient permissions
   * @throws {404} Not Found - Member not found
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc/members/user_456
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Delete(':id/members/:userId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Remove member from workspace',
    description: 'Removes member (cannot remove OWNER, requires canManageMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'userId', description: 'Target user ID', example: 'user_456' })
  @ApiResponse({ status: 200, description: 'Member removed successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Cannot remove OWNER or insufficient permissions',
  })
  @ApiResponse({ status: 404, description: 'Not Found - Member not found' })
  async removeMember(
    @Param('id') id: string,
    @Param('userId') targetUserId: string,
    @GetCurrentUserId() currentUserId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.removeMember(id, targetUserId, currentUserId);
  }

  // ==========================================
  // INVITATION SYSTEM
  // ==========================================

  /**
   * Send workspace invitation via email
   *
   * @description Sends an email invitation with a secure token to join the workspace.
   * Token expires in 7 days. Invitation can be sent to both registered and
   * unregistered users. Requires `canInviteMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {WorkspaceSendInvitationDto} dto - Invitation data (email, role, permissions)
   * @returns {Promise<InvitationResponse & MessageResponse>} Created invitation with token
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canInviteMembers)
   * @throws {404} Not Found - Workspace does not exist
   * @throws {409} Conflict - User already invited or is a member
   *
   * @example
   * ```
   * POST /api/v1/workspaces/clx123abc/invitations
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "email": "newuser@example.com",
   *   "role": "MEMBER",
   *   "permissions": {
   *     "canCreateCanvas": true,
   *     "canDeleteCanvas": false
   *   }
   * }
   * ```
   */
  @Post(':id/invitations')
  @ApiOperation({
    summary: 'Send workspace invitation',
    description: 'Sends email invitation with 7-day token (requires canInviteMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 201, description: 'Invitation sent successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  @ApiResponse({ status: 409, description: 'Conflict - User already invited or is member' })
  async sendInvitation(
    @Param('id') id: string,
    @Body() dto: WorkspaceSendInvitationDto,
    @GetCurrentUserId() userId: string,
  ): Promise<InvitationResponse & MessageResponse> {
    return this.workspaceService.sendInvitation(id, userId, dto);
  }

  /**
   * Get pending invitations
   *
   * @description Retrieves all pending invitations for the workspace.
   * Shows email, role, permissions, expiration date, and invitation status.
   * Ordered by creation date (newest first).
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<InvitationResponse[]>} Array of pending invitations
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a workspace member
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/invitations
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/invitations')
  @ApiOperation({
    summary: 'List pending invitations',
    description: 'Retrieves all pending workspace invitations',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Invitations retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getInvitations(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<InvitationResponse[]> {
    return this.workspaceService.getInvitations(id, userId);
  }

  /**
   * GET INVITATION DETAILS (PUBLIC - No Auth Required)
   * This endpoint should be accessible without authentication
   */
  @Get('invitations/:token/details')
  @Public()
  @ApiOperation({
    summary: 'Get invitation details (public)',
    description:
      'Get workspace invitation details for preview before acceptance. No authentication required.',
  })
  @ApiParam({
    name: 'token',
    description: 'Invitation token',
    example: 'ff08ff32428b36add715719515d133d806ae0b759792952dd6815931827cc92d',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Invitation details retrieved successfully',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Invitation not found',
  })
  async getInvitationDetails(@Param('token') token: string) {
    return this.workspaceService.getInvitationDetails(token);
  }

  /**
   * Accept workspace invitation
   *
   * @description Accepts an invitation via token and joins the workspace.
   * Validates email match, token expiration, and prevents duplicate membership.
   * Marks invitation as ACCEPTED upon success.
   *
   * @param {string} token - Invitation token from email (32-byte hex string)
   * @returns {Promise<AcceptInvitationResponse>} Workspace and member info
   *
   * @throws {400} Bad Request - Invalid or expired invitation
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Email mismatch (invitation sent to different email)
   * @throws {404} Not Found - Invitation not found
   * @throws {409} Conflict - User is already a workspace member
   *
   * @example
   * ```
   * POST /api/v1/workspaces/invitations/abc123def456.../accept
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  /**
   * ACCEPT INVITATION
   * Requires authentication - user must be logged in
   */
  @Post('invitations/:token/accept')
  @ApiOperation({
    summary: 'Accept workspace invitation',
    description: 'Accept a workspace invitation and join the workspace. Requires authentication.',
  })
  @ApiParam({
    name: 'token',
    description: 'Invitation token',
    example: 'ff08ff32428b36add715719515d133d806ae0b759792952dd6815931827cc92d',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Invitation accepted successfully',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invitation is invalid, expired, or already used',
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: 'Email mismatch - invitation sent to different email',
  })
  async acceptInvitation(@Param('token') token: string, @GetCurrentUserId() userId: string) {
    return this.workspaceService.acceptInvitation(token, userId);
  }
  /**
   * Revoke pending invitation
   *
   * @description Revokes a pending invitation, preventing it from being accepted.
   * Marks invitation status as REVOKED. Requires `canInviteMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} invitationId - Invitation unique identifier
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canInviteMembers)
   * @throws {404} Not Found - Invitation not found
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc/invitations/inv_789
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Delete(':id/invitations/:invitationId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Revoke pending invitation',
    description: 'Revokes invitation (requires canInviteMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'invitationId', description: 'Invitation ID', example: 'inv_789' })
  @ApiResponse({ status: 200, description: 'Invitation revoked successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Invitation not found' })
  async revokeInvitation(
    @Param('id') id: string,
    @Param('invitationId') invitationId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.revokeInvitation(invitationId, id, userId);
  }

  // ==========================================
  // API KEY MANAGEMENT (LLM PROVIDERS)
  // ==========================================

  /**
   * Get API key usage statistics
   *
   * @description Retrieves aggregate statistics for all API keys in the workspace,
   * including totals, provider breakdown, and usage metrics.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<ApiKeyUsageStats>} Aggregate statistics
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/api-keys/stats
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "totalKeys": 5,
   *   "activeKeys": 4,
   *   "inactiveKeys": 1,
   *   "providerBreakdown": {
   *     "OPENAI": 2,
   *     "ANTHROPIC": 2,
   *     "PERPLEXITY": 1
   *   },
   *   "totalUsageCount": 1247,
   *   "totalTokensConsumed": "5234812",
   *   "totalCostIncurred": 127.45
   * }
   * ```
   */
  @Get(':id/api-keys/stats')
  @ApiOperation({
    summary: 'Get API key usage statistics',
    description: 'Retrieves aggregate stats for all workspace API keys',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Statistics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getApiKeyUsageStats(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyUsageStats> {
    return this.workspaceService.getApiKeyUsageStats(id, userId);
  }

  /**
   * Get all workspace API keys
   *
   * @description Retrieves all API keys for the workspace with usage metrics.
   * Excludes sensitive keyHash for security. Includes status, usage statistics,
   * and creator info. Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<ApiKeyResponse[]>} Array of API keys
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/api-keys
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/api-keys')
  @ApiOperation({
    summary: 'List all workspace API keys',
    description: 'Retrieves all API keys with usage metrics (excludes keyHash for security)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'API keys retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getApiKeys(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyResponse[]> {
    return this.workspaceService.getApiKeys(id, userId);
  }

  /**
   * Get daily usage metrics for API key
   *
   * @description Retrieves time-series usage metrics for a specific API key,
   * aggregated by day. Includes request counts, token consumption, cost estimates.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} keyId - API key unique identifier
   * @param {string} startDate - Start date (ISO 8601, optional)
   * @param {string} endDate - End date (ISO 8601, optional)
   * @returns {Promise<UsageMetricResponse[]>} Array of daily metrics (last 30 days)
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace or API key does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/api-keys/key_789/metrics?startDate=2025-10-01&endDate=2025-10-15
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/api-keys/:keyId/metrics')
  @ApiOperation({
    summary: 'Get daily usage metrics for API key',
    description: 'Retrieves time-series usage data (requests, tokens, cost)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'keyId', description: 'API key ID', example: 'key_789' })
  @ApiQuery({
    name: 'startDate',
    required: false,
    description: 'Start date (ISO 8601)',
    example: '2025-10-01',
  })
  @ApiQuery({
    name: 'endDate',
    required: false,
    description: 'End date (ISO 8601)',
    example: '2025-10-15',
  })
  @ApiResponse({ status: 200, description: 'Usage metrics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace or API key not found' })
  async getUsageMetrics(
    @Param('id') id: string,
    @Param('keyId') keyId: string,
    @GetCurrentUserId() userId: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
  ): Promise<UsageMetricResponse[]> {
    return this.workspaceService.getUsageMetrics(
      id,
      keyId,
      userId,
      startDate ? new Date(startDate) : undefined,
      endDate ? new Date(endDate) : undefined,
    );
  }

  /**
   * Add new API key
   *
   * @description Adds an encrypted API key for an LLM provider.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {WorkspaceAddApiKeyDto} dto - API key data (provider, key, name)
   * @returns {Promise<ApiKeyResponse>} Created API key (excludes keyHash)
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace does not exist
   * @throws {409} Conflict - API key name already exists for provider
   *
   * @example
   * ```
   * POST /api/v1/workspaces/clx123abc/api-keys
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "provider": "OPENAI",
   *   "displayName": "Production Key",
   *   "apiKey": "sk-proj-abc123..."
   * }
   * ```
   */
  @Post(':id/api-keys')
  @ApiOperation({
    summary: 'Add new API key',
    description: 'Adds encrypted LLM provider API key',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 201, description: 'API key added successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  @ApiResponse({ status: 409, description: 'Conflict - API key name already exists' })
  async addApiKey(
    @Param('id') id: string,
    @Body() dto: WorkspaceAddApiKeyDto,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyResponse> {
    return this.workspaceService.addApiKey(id, userId, dto);
  }

  /**
   * Update API key
   *
   * @description Updates API key properties. Can rotate the key value (re-encrypts).
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} keyId - API key unique identifier
   * @param {WorkspaceUpdateApiKeyDto} dto - Update data
   * @returns {Promise<ApiKeyResponse>} Updated API key
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - API key not found
   *
   * @example
   * ```
   * PATCH /api/v1/workspaces/clx123abc/api-keys/key_789
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "displayName": "Updated Production Key",
   *   "isActive": false
   * }
   * ```
   */
  @Patch(':id/api-keys/:keyId')
  @ApiOperation({
    summary: 'Update API key',
    description: 'Updates API key properties (can rotate key, requires canManageApiKeys)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'keyId', description: 'API key ID', example: 'key_789' })
  @ApiResponse({ status: 200, description: 'API key updated successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - API key not found' })
  async updateApiKey(
    @Param('id') id: string,
    @Param('keyId') keyId: string,
    @Body() dto: WorkspaceUpdateApiKeyDto,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyResponse> {
    return this.workspaceService.updateApiKey(id, keyId, userId, dto);
  }

  /**
   * Delete API key
   *
   * @description Permanently deletes an API key. This action cannot be undone.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} keyId - API key unique identifier
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - API key not found
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc/api-keys/key_789
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "message": "API key deleted successfully"
   * }
   * ```
   */
  @Delete(':id/api-keys/:keyId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete API key',
    description: 'Permanently deletes API key (requires canManageApiKeys)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'keyId', description: 'API key ID', example: 'key_789' })
  @ApiResponse({ status: 200, description: 'API key deleted successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - API key not found' })
  async deleteApiKey(
    @Param('id') id: string,
    @Param('keyId') keyId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.deleteApiKey(id, keyId, userId);
  }
}

```

### `apps\backend\src\v1\workspace\workspace.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1WorkspaceController } from './workspace.controller';
import { V1WorkspaceService } from './workspace.service';
import { V1NotificationModule } from '../notification/notification.module';

@Module({
  imports: [V1NotificationModule],
  controllers: [V1WorkspaceController],
  providers: [V1WorkspaceService],
  exports: [V1WorkspaceService],
})
export class V1WorkspaceModule {}

```

### `apps\backend\src\v1\workspace\workspace.service.ts`

```typescript
// src/modules/workspace/workspace.service.ts

import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  ConflictException,
  BadRequestException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AwsSesEmailService } from '../../common/aws/ses/ses-email.service';
import { ConfigService } from '@nestjs/config';
import { WorkspaceCreateDto } from './dto/workspace-create.dto';
import { WorkspaceUpdateDto } from './dto/workspace-update.dto';
import { WorkspaceUpdateMemberDto } from './dto/workspace-update-member.dto';
import { WorkspaceSendInvitationDto } from './dto/workspace-send-invitation.dto';
import { WorkspaceAddApiKeyDto } from './dto/workspace-add-api-key.dto';
import { WorkspaceUpdateApiKeyDto } from './dto/workspace-update-api-key.dto';
import { WorkspaceType, WorkspaceRole, InvitationStatus, NotificationType } from '@actopod/schema';
import * as crypto from 'crypto';
import { workspaceInvitationTemplate } from '../../common/aws/ses/templates/workspace/invitation.template';
import {
  WorkspaceListItem,
  WorkspaceDetails,
  WorkspaceMemberResponse,
  ApiKeyResponse,
  InvitationResponse,
  AcceptInvitationResponse,
  MessageResponse,
  ApiKeyUsageStats,
  UsageMetricResponse,
  InvitationDetailsResponse,
} from './types/workspace.types';
import { V1NotificationService } from '../notification/notification.service';

/**
 * PRODUCTION-GRADE Workspace Service
 * Features:
 * - AES-256-GCM encryption (12-byte IV, new standard)
 * - Backward compatibility (16-byte IV, legacy format)
 * - Auto workspace type switching (PERSONAL â†” TEAM)
 * - Comprehensive error handling
 * - Audit logging
 * - Permission management
 */
@Injectable()
export class V1WorkspaceService {
  private readonly logger = new Logger(V1WorkspaceService.name);
  private readonly encryptionKey: Buffer;
  private readonly encryptionAlgorithm = 'aes-256-gcm';
  private readonly NEW_IV_LENGTH = 12; // 96-bit IV (GCM standard)
  private readonly OLD_IV_LENGTH = 16; // 128-bit IV (legacy)
  private readonly AUTH_TAG_LENGTH = 16; // 128-bit auth tag

  constructor(
    private readonly prisma: PrismaService,
    private readonly emailService: AwsSesEmailService,
    private readonly configService: ConfigService,
    private readonly notificationService: V1NotificationService,
  ) {
    this.encryptionKey = this.initializeEncryption();
  }

  /**
   * Initialize and validate encryption key
   */
  private initializeEncryption(): Buffer {
    try {
      const key = this.configService.get<string>('API_KEY_ENCRYPTION_SECRET');

      if (!key) {
        const errorMsg =
          'CRITICAL: API_KEY_ENCRYPTION_SECRET environment variable is not set. ' +
          "Generate one using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"";
        this.logger.error(errorMsg);
        throw new Error(errorMsg);
      }

      // Validate hex format
      if (!/^[0-9a-fA-F]{64}$/.test(key)) {
        throw new Error(
          'API_KEY_ENCRYPTION_SECRET must be a 64-character hexadecimal string (32 bytes). ' +
            "Generate using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"",
        );
      }

      const keyBuffer = Buffer.from(key, 'hex');

      if (keyBuffer.length !== 32) {
        throw new Error(
          `API_KEY_ENCRYPTION_SECRET must be exactly 32 bytes (64 hex characters). Current: ${keyBuffer.length} bytes`,
        );
      }

      this.logger.log('âœ… Encryption key validated successfully');
      return keyBuffer;
    } catch (error) {
      this.logger.error('Failed to initialize encryption:', error);
      throw error;
    }
  }

  // ==================== WORKSPACE CRUD ====================

  /**
   * AUTO-SWITCH WORKSPACE TYPE LOGIC
   * - 1 member = PERSONAL
   * - 2+ members = TEAM
   */
  private async autoSwitchWorkspaceType(workspaceId: string): Promise<void> {
    try {
      const memberCount = await this.prisma.workspaceUser.count({
        where: { workspaceId },
      });

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
        select: { type: true },
      });

      if (!workspace) return;

      // Switch to TEAM if 2+ members
      if (memberCount >= 2 && workspace.type === WorkspaceType.PERSONAL) {
        await this.prisma.workspace.update({
          where: { id: workspaceId },
          data: { type: WorkspaceType.TEAM },
        });
        this.logger.log(
          `ðŸ”„ Workspace ${workspaceId} auto-switched to TEAM (${memberCount} members)`,
        );
      }

      // Switch to PERSONAL if only 1 member
      if (memberCount === 1 && workspace.type === WorkspaceType.TEAM) {
        await this.prisma.workspace.update({
          where: { id: workspaceId },
          data: { type: WorkspaceType.PERSONAL },
        });
        this.logger.log(`ðŸ”„ Workspace ${workspaceId} auto-switched to PERSONAL (1 member)`);
      }
    } catch (error) {
      this.logger.error(`Failed to auto-switch workspace type for ${workspaceId}:`, error);
      // Don't throw - this is a non-critical operation
    }
  }

  async getAllWorkspaces(userId: string): Promise<WorkspaceListItem[]> {
    try {
      const workspaceUsers = await this.prisma.workspaceUser.findMany({
        where: { userId },
        include: {
          workspace: {
            include: {
              _count: {
                select: {
                  members: true,
                  flows: true,
                },
              },
            },
          },
        },
        orderBy: {
          joinedAt: 'desc',
        },
      });

      return workspaceUsers.map((wu) => ({
        id: wu.workspace.id,
        name: wu.workspace.name,
        type: wu.workspace.type,
        role: wu.role,
        permissions: {
          canCreateCanvas: wu.canCreateCanvas,
          canDeleteCanvas: wu.canDeleteCanvas,
          canManageBilling: wu.canManageBilling,
          canInviteMembers: wu.canInviteMembers,
          canManageMembers: wu.canManageMembers,
          canManageApiKeys: wu.canManageApiKeys,
        },
        memberCount: wu.workspace._count.members,
        canvasCount: wu.workspace._count.flows,
        joinedAt: wu.joinedAt,
        createdAt: wu.workspace.createdAt,
        updatedAt: wu.workspace.updatedAt,
      }));
    } catch (error) {
      this.logger.error(`Failed to get workspaces for user ${userId}:`, error);
      throw new InternalServerErrorException('Failed to fetch workspaces');
    }
  }

  async getWorkspaceById(workspaceId: string, userId: string): Promise<WorkspaceDetails> {
    try {
      const member = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId, workspaceId },
        },
      });

      if (!member) {
        throw new ForbiddenException('You do not have access to this workspace');
      }

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  email: true,
                  name: true,
                  image: true,
                },
              },
            },
          },
          _count: {
            select: {
              flows: true,
              documents: true,
              apiKeys: true,
            },
          },
        },
      });

      if (!workspace) {
        throw new NotFoundException('Workspace not found');
      }

      return {
        id: workspace.id,
        name: workspace.name,
        type: workspace.type,
        createdAt: workspace.createdAt,
        updatedAt: workspace.updatedAt,
        members: workspace.members,
        _count: workspace._count,
        currentUserRole: member.role,
        currentUserPermissions: {
          canCreateCanvas: member.canCreateCanvas,
          canDeleteCanvas: member.canDeleteCanvas,
          canManageBilling: member.canManageBilling,
          canInviteMembers: member.canInviteMembers,
          canManageMembers: member.canManageMembers,
          canManageApiKeys: member.canManageApiKeys,
        },
      };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch workspace');
    }
  }

  async createWorkspace(userId: string, dto: WorkspaceCreateDto): Promise<any> {
    try {
      const workspace = await this.prisma.workspace.create({
        data: {
          name: dto.name,
          type: dto.type ?? WorkspaceType.PERSONAL,
          members: {
            create: {
              userId,
              role: WorkspaceRole.OWNER,
              canCreateCanvas: true,
              canDeleteCanvas: true,
              canManageBilling: true,
              canInviteMembers: true,
              canManageMembers: true,
              canManageApiKeys: true,
            },
          },
        },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  email: true,
                  name: true,
                  image: true,
                },
              },
            },
          },
        },
      });

      this.logger.log(`âœ… Workspace created: ${workspace.id} by user ${userId}`);
      return workspace;
    } catch (error) {
      this.logger.error('Failed to create workspace:', error);
      throw new InternalServerErrorException('Failed to create workspace');
    }
  }

  async updateWorkspace(
    workspaceId: string,
    userId: string,
    dto: WorkspaceUpdateDto,
  ): Promise<any> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageMembers');

      const workspace = await this.prisma.workspace.update({
        where: { id: workspaceId },
        data: { name: dto.name },
      });

      this.logger.log(`âœ… Workspace updated: ${workspaceId} by user ${userId}`);
      return workspace;
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to update workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to update workspace');
    }
  }

  async deleteWorkspace(workspaceId: string, userId: string): Promise<MessageResponse> {
    try {
      const member = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId, workspaceId },
        },
      });

      if (!member || member.role !== WorkspaceRole.OWNER) {
        throw new ForbiddenException('Only workspace owners can delete workspaces');
      }

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
      });

      if (!workspace) {
        throw new NotFoundException('Workspace not found');
      }

      if (workspace.type === WorkspaceType.PERSONAL) {
        throw new BadRequestException('Personal workspaces cannot be deleted');
      }

      await this.prisma.workspace.delete({
        where: { id: workspaceId },
      });

      this.logger.log(`âœ… Workspace deleted: ${workspaceId} by user ${userId}`);
      return { message: 'Workspace deleted successfully' };
    } catch (error) {
      if (
        error instanceof ForbiddenException ||
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      )
        throw error;
      this.logger.error(`Failed to delete workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to delete workspace');
    }
  }

  async transferOwnership(
    workspaceId: string,
    currentOwnerId: string,
    newOwnerId: string,
  ): Promise<MessageResponse> {
    try {
      const currentOwner = await this.prisma.workspaceUser.findUnique({
        where: { userId_workspaceId: { userId: currentOwnerId, workspaceId } },
      });

      if (!currentOwner || currentOwner.role !== WorkspaceRole.OWNER) {
        throw new ForbiddenException('Only the workspace owner can transfer ownership');
      }

      const newOwner = await this.prisma.workspaceUser.findUnique({
        where: { userId_workspaceId: { userId: newOwnerId, workspaceId } },
      });

      if (!newOwner) {
        throw new NotFoundException('Target user is not a member of this workspace');
      }

      await this.prisma.$transaction([
        this.prisma.workspaceUser.update({
          where: { userId_workspaceId: { userId: currentOwnerId, workspaceId } },
          data: { role: WorkspaceRole.ADMIN },
        }),
        this.prisma.workspaceUser.update({
          where: { userId_workspaceId: { userId: newOwnerId, workspaceId } },
          data: {
            role: WorkspaceRole.OWNER,
            canCreateCanvas: true,
            canDeleteCanvas: true,
            canManageBilling: true,
            canInviteMembers: true,
            canManageMembers: true,
            canManageApiKeys: true,
          },
        }),
      ]);

      this.logger.log(`âœ… Ownership transferred: ${currentOwnerId} â†’ ${newOwnerId}`);
      return { message: 'Ownership transferred successfully' };
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error('Failed to transfer ownership:', error);
      throw new InternalServerErrorException('Failed to transfer ownership');
    }
  }

  async getWorkspaceStats(workspaceId: string, userId: string) {
    try {
      await this.verifyMembership(workspaceId, userId);

      const stats = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
        include: {
          _count: {
            select: {
              members: true,
              flows: true,
              documents: true,
              apiKeys: true,
            },
          },
          members: {
            select: { role: true },
          },
        },
      });

      if (!stats) {
        throw new NotFoundException('Workspace not found');
      }

      return {
        totalMembers: stats._count.members,
        totalFlows: stats._count.flows,
        totalDocuments: stats._count.documents,
        totalApiKeys: stats._count.apiKeys,
        roleDistribution: {
          owners: stats.members.filter((m) => m.role === WorkspaceRole.OWNER).length,
          admins: stats.members.filter((m) => m.role === WorkspaceRole.ADMIN).length,
          members: stats.members.filter((m) => m.role === WorkspaceRole.MEMBER).length,
        },
      };
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to get workspace stats for ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch workspace stats');
    }
  }

  // ==================== MEMBERS ====================

  async getMembers(workspaceId: string, userId: string): Promise<WorkspaceMemberResponse[]> {
    try {
      await this.verifyMembership(workspaceId, userId);

      const members = await this.prisma.workspaceUser.findMany({
        where: { workspaceId },
        include: {
          user: {
            select: {
              id: true,
              email: true,
              name: true,
              image: true,
            },
          },
        },
        orderBy: {
          joinedAt: 'desc',
        },
      });

      return members as WorkspaceMemberResponse[];
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get members for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch members');
    }
  }

  async updateMember(
    workspaceId: string,
    targetUserId: string,
    currentUserId: string,
    dto: WorkspaceUpdateMemberDto,
  ): Promise<WorkspaceMemberResponse> {
    try {
      await this.verifyPermission(workspaceId, currentUserId, 'canManageMembers');

      const targetMember = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
      });

      if (!targetMember) {
        throw new NotFoundException('Member not found');
      }

      if (targetMember.role === WorkspaceRole.OWNER) {
        throw new ForbiddenException('Cannot modify workspace owner');
      }

      const updatedMember = await this.prisma.workspaceUser.update({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
        data: dto,
        include: {
          user: {
            select: {
              id: true,
              email: true,
              name: true,
              image: true,
            },
          },
        },
      });

      this.logger.log(`âœ… Member updated: ${targetUserId} in workspace ${workspaceId}`);
      return updatedMember as WorkspaceMemberResponse;
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to update member ${targetUserId}:`, error);
      throw new InternalServerErrorException('Failed to update member');
    }
  }

  async removeMember(
    workspaceId: string,
    targetUserId: string,
    currentUserId: string,
  ): Promise<MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, currentUserId, 'canManageMembers');

      const targetMember = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
      });

      if (!targetMember) {
        throw new NotFoundException('Member not found');
      }

      if (targetMember.role === WorkspaceRole.OWNER) {
        throw new ForbiddenException('Cannot remove workspace owner');
      }

      await this.prisma.workspaceUser.delete({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
      });

      // Auto-switch workspace type
      await this.autoSwitchWorkspaceType(workspaceId);

      this.logger.log(`âœ… Member removed: ${targetUserId} from workspace ${workspaceId}`);
      return { message: 'Member removed successfully' };
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to remove member ${targetUserId}:`, error);
      throw new InternalServerErrorException('Failed to remove member');
    }
  }

  // ==================== INVITATIONS ====================

  async sendInvitation(
    workspaceId: string,
    userId: string,
    dto: WorkspaceSendInvitationDto,
  ): Promise<InvitationResponse & MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canInviteMembers');

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
      });

      if (!workspace) {
        throw new NotFoundException('Workspace not found');
      }

      const existingUser = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });

      if (existingUser) {
        const isMember = await this.prisma.workspaceUser.findUnique({
          where: {
            userId_workspaceId: { userId: existingUser.id, workspaceId },
          },
        });

        if (isMember) {
          throw new ConflictException('User is already a member of this workspace');
        }
      }

      const existing = await this.prisma.workspaceInvitation.findFirst({
        where: {
          workspaceId,
          email: dto.email,
          status: InvitationStatus.PENDING,
        },
      });

      if (existing) {
        throw new ConflictException('An invitation has already been sent to this email');
      }

      const token = crypto.randomBytes(32).toString('hex');

      const invitation = await this.prisma.workspaceInvitation.create({
        data: {
          workspaceId,
          email: dto.email,
          role: dto.role ?? WorkspaceRole.MEMBER,
          permissions: dto.permissions as any,
          invitedBy: userId,
          invitedUserId: existingUser?.id,
          token,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        },
      });

      // Create in-app notification if user exists
      if (existingUser) {
        await this.notificationService.createNotification({
          userId: existingUser.id,
          type: NotificationType.WORKSPACE_INVITATION,
          title: `Workspace Invitation: ${workspace.name}`,
          body: `You've been invited to join ${workspace.name} as ${dto.role ?? WorkspaceRole.MEMBER}`,
          entityType: 'workspace_invitation',
          entityId: invitation.id,
          metadata: {
            workspaceId,
            workspaceName: workspace.name,
            role: dto.role ?? WorkspaceRole.MEMBER,
            inviterName: userId,
          },
          actionUrl: `/workspace/invite/${token}`,
          expiresAt: invitation.expiresAt,
        });
      }

      const inviteLink = `${this.configService.get('FRONTEND_URL')}/workspace/invite/${token}`;

      await this.emailService.sendEmail({
        to: dto.email,
        subject: `You've been invited to join ${workspace.name} on Actopod`,
        bodyHtml: workspaceInvitationTemplate(
          workspace.name,
          inviteLink,
          dto.role ?? WorkspaceRole.MEMBER,
        ),
      });

      this.logger.log(`âœ… Invitation sent to ${dto.email} for workspace ${workspaceId}`);
      return {
        ...(invitation as InvitationResponse),
        message: 'Invitation sent successfully',
      };
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error('Failed to send invitation:', error);
      throw new InternalServerErrorException('Failed to send invitation');
    }
  }

  async getInvitations(workspaceId: string, userId: string): Promise<InvitationResponse[]> {
    try {
      await this.verifyMembership(workspaceId, userId);

      const invitations = await this.prisma.workspaceInvitation.findMany({
        where: {
          workspaceId,
          status: InvitationStatus.PENDING,
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      return invitations as InvitationResponse[];
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get invitations for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch invitations');
    }
  }

  async acceptInvitation(token: string, userId: string): Promise<AcceptInvitationResponse> {
    try {
      const invitation = await this.prisma.workspaceInvitation.findUnique({
        where: { token },
        include: { workspace: true },
      });

      if (!invitation) {
        throw new NotFoundException('Invitation not found');
      }

      if (invitation.status !== InvitationStatus.PENDING) {
        throw new BadRequestException('Invitation is no longer valid');
      }

      if (invitation.expiresAt < new Date()) {
        await this.prisma.workspaceInvitation.update({
          where: { id: invitation.id },
          data: { status: InvitationStatus.EXPIRED },
        });
        throw new BadRequestException('Invitation has expired');
      }

      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user || user.email !== invitation.email) {
        throw new ForbiddenException('This invitation was sent to a different email address');
      }

      const existing = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId, workspaceId: invitation.workspaceId },
        },
      });

      if (existing) {
        throw new ConflictException('You are already a member of this workspace');
      }

      const permissions = (invitation.permissions as Record<string, boolean> | null) || {};

      const defaultPermissions = {
        canCreateCanvas: true,
        canDeleteCanvas: false,
        canInviteMembers: false,
        canManageMembers: false,
        canManageApiKeys: false,
        canManageBilling: false,
      };

      const member = await this.prisma.workspaceUser.create({
        data: {
          userId,
          workspaceId: invitation.workspaceId,
          role: invitation.role,
          canCreateCanvas: permissions.canCreateCanvas ?? defaultPermissions.canCreateCanvas,
          canDeleteCanvas: permissions.canDeleteCanvas ?? defaultPermissions.canDeleteCanvas,
          canInviteMembers: permissions.canInviteMembers ?? defaultPermissions.canInviteMembers,
          canManageMembers: permissions.canManageMembers ?? defaultPermissions.canManageMembers,
          canManageApiKeys: permissions.canManageApiKeys ?? defaultPermissions.canManageApiKeys,
          canManageBilling: permissions.canManageBilling ?? defaultPermissions.canManageBilling,
          invitedBy: invitation.invitedBy,
        },
      });

      await this.prisma.workspaceInvitation.update({
        where: { id: invitation.id },
        data: {
          status: InvitationStatus.ACCEPTED,
          acceptedAt: new Date(),
        },
      });

      // Auto-switch workspace type
      await this.autoSwitchWorkspaceType(invitation.workspaceId);

      // Notify workspace admins/owner
      const admins = await this.prisma.workspaceUser.findMany({
        where: {
          workspaceId: invitation.workspaceId,
          role: { in: [WorkspaceRole.OWNER, WorkspaceRole.ADMIN] },
        },
      });

      for (const admin of admins) {
        await this.notificationService.createNotification({
          userId: admin.userId,
          type: NotificationType.WORKSPACE_MEMBER_JOINED,
          title: 'New Member Joined',
          body: `${user.name || user.email} has joined ${invitation.workspace.name}`,
          entityType: 'workspace',
          entityId: invitation.workspaceId,
          metadata: {
            workspaceId: invitation.workspaceId,
            newMemberEmail: user.email,
            newMemberName: user.name,
            role: invitation.role,
          },
          actionUrl: `/settings?tab=members`,
        });
      }

      this.logger.log(`âœ… Invitation accepted: ${token} by user ${userId}`);
      return {
        workspace: invitation.workspace,
        member,
        message: 'Successfully joined workspace',
      };
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException ||
        error instanceof ForbiddenException ||
        error instanceof ConflictException
      )
        throw error;
      this.logger.error('Failed to accept invitation:', error);
      throw new InternalServerErrorException('Failed to accept invitation');
    }
  }

  async getInvitationDetails(token: string): Promise<InvitationDetailsResponse> {
    try {
      const invitation = await this.prisma.workspaceInvitation.findUnique({
        where: { token },
        include: { workspace: true },
      });

      if (!invitation) {
        throw new NotFoundException('Invitation not found');
      }

      if (invitation.status !== InvitationStatus.PENDING) {
        throw new BadRequestException(`Invitation is ${invitation.status.toLowerCase()}`);
      }

      return {
        workspace: {
          id: invitation.workspace.id,
          name: invitation.workspace.name,
          type: invitation.workspace.type,
        },
        email: invitation.email,
        role: invitation.role,
        permissions: invitation.permissions as Record<string, boolean> | null,
        expiresAt: invitation.expiresAt,
        status: invitation.status,
      };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof BadRequestException) throw error;
      this.logger.error('Failed to get invitation details:', error);
      throw new InternalServerErrorException('Failed to fetch invitation details');
    }
  }

  async revokeInvitation(
    invitationId: string,
    workspaceId: string,
    userId: string,
  ): Promise<MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canInviteMembers');

      const invitation = await this.prisma.workspaceInvitation.findUnique({
        where: { id: invitationId },
      });

      if (!invitation || invitation.workspaceId !== workspaceId) {
        throw new NotFoundException('Invitation not found');
      }

      await this.prisma.workspaceInvitation.update({
        where: { id: invitationId },
        data: { status: InvitationStatus.REVOKED },
      });

      this.logger.log(`âœ… Invitation revoked: ${invitationId}`);
      return { message: 'Invitation revoked successfully' };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to revoke invitation ${invitationId}:`, error);
      throw new InternalServerErrorException('Failed to revoke invitation');
    }
  }

  // ==================== API KEYS ====================

  async getApiKeys(workspaceId: string, userId: string): Promise<ApiKeyResponse[]> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const apiKeys = await this.prisma.providerAPIKey.findMany({
        where: { workspaceId },
        select: {
          id: true,
          provider: true,
          displayName: true,
          isActive: true,
          lastUsedAt: true,
          createdAt: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
          lastErrorAt: true,
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      });

      return apiKeys.map((key) => ({
        ...key,
        totalTokens: key.totalTokens.toString(),
        totalCost: Number(key.totalCost),
      })) as ApiKeyResponse[];
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get API keys for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch API keys');
    }
  }

  async addApiKey(
    workspaceId: string,
    userId: string,
    dto: WorkspaceAddApiKeyDto,
  ): Promise<ApiKeyResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const existing = await this.prisma.providerAPIKey.findUnique({
        where: {
          workspaceId_provider_displayName: {
            workspaceId,
            provider: dto.provider,
            displayName: dto.displayName,
          },
        },
      });

      if (existing) {
        throw new ConflictException('An API key with this name already exists for this provider');
      }

      const keyHash = this.encryptApiKey(dto.apiKey);

      const apiKey = await this.prisma.providerAPIKey.create({
        data: {
          workspaceId,
          provider: dto.provider,
          displayName: dto.displayName,
          keyHash,
          createdById: userId,
        },
        select: {
          id: true,
          provider: true,
          displayName: true,
          isActive: true,
          lastUsedAt: true,
          createdAt: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
          lastErrorAt: true,
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      this.logger.log(`âœ… API key added: ${dto.provider}/${dto.displayName} by user ${userId}`);

      return {
        ...apiKey,
        totalTokens: apiKey.totalTokens.toString(),
        totalCost: Number(apiKey.totalCost),
      } as ApiKeyResponse;
    } catch (error) {
      if (error instanceof ConflictException || error instanceof ForbiddenException) throw error;
      this.logger.error('Failed to add API key:', error);
      throw new InternalServerErrorException('Failed to add API key');
    }
  }

  async updateApiKey(
    workspaceId: string,
    keyId: string,
    userId: string,
    dto: WorkspaceUpdateApiKeyDto,
  ): Promise<ApiKeyResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const existing = await this.prisma.providerAPIKey.findFirst({
        where: {
          id: keyId,
          workspaceId,
        },
      });

      if (!existing) {
        throw new NotFoundException('API key not found');
      }

      if (dto.displayName && dto.displayName !== existing.displayName) {
        const duplicate = await this.prisma.providerAPIKey.findUnique({
          where: {
            workspaceId_provider_displayName: {
              workspaceId,
              provider: existing.provider,
              displayName: dto.displayName,
            },
          },
        });

        if (duplicate) {
          throw new ConflictException('An API key with this name already exists');
        }
      }

      const updateData: any = {};

      if (dto.displayName !== undefined) {
        updateData.displayName = dto.displayName;
      }

      if (dto.isActive !== undefined) {
        updateData.isActive = dto.isActive;
      }

      if (dto.apiKey) {
        updateData.keyHash = this.encryptApiKey(dto.apiKey);
      }

      const apiKey = await this.prisma.providerAPIKey.update({
        where: { id: keyId },
        data: updateData,
        select: {
          id: true,
          provider: true,
          displayName: true,
          isActive: true,
          lastUsedAt: true,
          createdAt: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
          lastErrorAt: true,
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      this.logger.log(`âœ… API key updated: ${keyId} by user ${userId}`);

      return {
        ...apiKey,
        totalTokens: apiKey.totalTokens.toString(),
        totalCost: Number(apiKey.totalCost),
      } as ApiKeyResponse;
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error(`Failed to update API key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to update API key');
    }
  }

  async deleteApiKey(workspaceId: string, keyId: string, userId: string): Promise<MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const apiKey = await this.prisma.providerAPIKey.findFirst({
        where: {
          id: keyId,
          workspaceId,
        },
      });

      if (!apiKey) {
        throw new NotFoundException('API key not found');
      }

      await this.prisma.providerAPIKey.delete({
        where: { id: keyId },
      });

      this.logger.log(`âœ… API key deleted: ${keyId} by user ${userId}`);

      return { message: 'API key deleted successfully' };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to delete API key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to delete API key');
    }
  }

  async getApiKeyUsageStats(workspaceId: string, userId: string): Promise<ApiKeyUsageStats> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const apiKeys = await this.prisma.providerAPIKey.findMany({
        where: { workspaceId },
        select: {
          provider: true,
          isActive: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
        },
      });

      const totalKeys = apiKeys.length;
      const activeKeys = apiKeys.filter((k) => k.isActive).length;
      const inactiveKeys = totalKeys - activeKeys;

      const providerBreakdown = apiKeys.reduce(
        (acc, key) => {
          acc[key.provider] = (acc[key.provider] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      const totalUsageCount = apiKeys.reduce((sum, k) => sum + k.usageCount, 0);

      const totalTokensConsumed = apiKeys.reduce(
        (sum, k) => sum + BigInt(k.totalTokens),
        BigInt(0),
      );

      const totalCostIncurred = apiKeys.reduce((sum, k) => sum + Number(k.totalCost), 0);

      return {
        totalKeys,
        activeKeys,
        inactiveKeys,
        providerBreakdown,
        totalUsageCount,
        totalTokensConsumed: totalTokensConsumed.toString(),
        totalCostIncurred,
      };
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get usage stats for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch usage stats');
    }
  }

  async getUsageMetrics(
    workspaceId: string,
    keyId: string,
    userId: string,
    startDate?: Date,
    endDate?: Date,
  ): Promise<UsageMetricResponse[]> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const whereClause: any = { workspaceId, keyId };
      if (startDate || endDate) {
        whereClause.date = {};
        if (startDate) whereClause.date.gte = startDate;
        if (endDate) whereClause.date.lte = endDate;
      }

      const metrics = await this.prisma.usageMetric.findMany({
        where: whereClause,
        orderBy: { date: 'desc' },
        take: 30,
      });

      return metrics.map((m) => ({
        id: m.id,
        date: m.date,
        requestCount: m.requestCount,
        successCount: m.successCount,
        errorCount: m.errorCount,
        promptTokens: m.promptTokens.toString(),
        completionTokens: m.completionTokens.toString(),
        totalTokens: m.totalTokens.toString(),
        estimatedCost: Number(m.estimatedCost),
      }));
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get usage metrics for key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to fetch usage metrics');
    }
  }

  async getDecryptedApiKey(keyId: string, workspaceId: string): Promise<string> {
    try {
      const apiKey = await this.prisma.providerAPIKey.findFirst({
        where: {
          id: keyId,
          workspaceId,
          isActive: true,
        },
        select: {
          keyHash: true,
        },
      });

      if (!apiKey) {
        throw new NotFoundException('API key not found or inactive');
      }

      return this.decryptApiKey(apiKey.keyHash);
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to decrypt API key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to decrypt API key');
    }
  }

  // ==================== PRIVATE HELPERS ====================

  private async verifyMembership(workspaceId: string, userId: string): Promise<any> {
    const member = await this.prisma.workspaceUser.findUnique({
      where: {
        userId_workspaceId: { userId, workspaceId },
      },
    });

    if (!member) {
      throw new ForbiddenException('You do not have access to this workspace');
    }

    return member;
  }

  private async verifyPermission(
    workspaceId: string,
    userId: string,
    permission: string,
  ): Promise<any> {
    const member = await this.verifyMembership(workspaceId, userId);

    if (member.role === WorkspaceRole.OWNER) {
      return member;
    }

    if (!(member as any)[permission]) {
      throw new ForbiddenException('You do not have permission to perform this action');
    }

    return member;
  }

  /**
   * Encrypt API key using AES-256-GCM with NEW 12-byte IV format
   * Format: iv:authTag:encrypted
   */
  private encryptApiKey(plaintext: string): string {
    try {
      if (!plaintext || typeof plaintext !== 'string' || plaintext.trim().length === 0) {
        throw new Error('Cannot encrypt empty API key');
      }

      const iv = crypto.randomBytes(this.NEW_IV_LENGTH);
      const cipher = crypto.createCipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);

      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      const authTag = cipher.getAuthTag();

      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(`Invalid auth tag length: ${authTag.length}`);
      }

      const result = `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;

      this.logger.debug('API key encrypted successfully with 12-byte IV');
      return result;
    } catch (error) {
      this.logger.error('Encryption failed:', error);
      throw new InternalServerErrorException(
        `Failed to encrypt API key: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Decrypt API key with BACKWARD COMPATIBILITY for both 12-byte and 16-byte IV formats
   * Format: iv:authTag:encrypted
   */
  private decryptApiKey(encryptedData: string): string {
    try {
      if (!encryptedData || typeof encryptedData !== 'string') {
        throw new Error('Invalid encrypted data');
      }

      const parts = encryptedData.split(':');

      if (parts.length !== 3) {
        throw new Error(`Invalid encrypted data format: expected 3 parts, got ${parts.length}`);
      }

      const [ivHex, authTagHex, encrypted] = parts;

      if (!ivHex || !authTagHex || !encrypted) {
        throw new Error('One or more encrypted data components are empty');
      }

      if (
        !/^[0-9a-fA-F]+$/.test(ivHex) ||
        !/^[0-9a-fA-F]+$/.test(authTagHex) ||
        !/^[0-9a-fA-F]+$/.test(encrypted)
      ) {
        throw new Error('Encrypted data contains invalid hexadecimal characters');
      }

      const iv = Buffer.from(ivHex, 'hex');
      const authTag = Buffer.from(authTagHex, 'hex');

      const ivLength = iv.length;

      if (ivLength !== this.NEW_IV_LENGTH && ivLength !== this.OLD_IV_LENGTH) {
        throw new Error(
          `Invalid IV length: expected ${this.NEW_IV_LENGTH} bytes (new) or ${this.OLD_IV_LENGTH} bytes (legacy), got ${ivLength} bytes`,
        );
      }

      if (ivLength === this.OLD_IV_LENGTH) {
        this.logger.warn(
          `Decrypting API key with legacy 16-byte IV format. Consider re-encrypting with the new 12-byte format.`,
        );
      }

      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(`Invalid auth tag length: ${authTag.length} bytes`);
      }

      const decipher = crypto.createDecipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);
      decipher.setAuthTag(authTag);

      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      if (!decrypted || decrypted.length === 0) {
        throw new Error('Decryption produced empty result');
      }

      this.logger.debug(`API key decrypted successfully (IV length: ${ivLength} bytes)`);
      return decrypted;
    } catch (error) {
      this.logger.error('Decryption failed:', error);

      if (error instanceof Error) {
        if (error.message.includes('Unsupported state') || error.message.includes('auth')) {
          throw new InternalServerErrorException(
            'Authentication failed: API key may be corrupted or tampered with',
          );
        }
        if (error.message.includes('bad decrypt')) {
          throw new InternalServerErrorException(
            'Decryption failed: Incorrect encryption key or corrupted data',
          );
        }
      }

      throw new InternalServerErrorException(
        `Failed to decrypt API key: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }
}

```

---

## Frontend Source Code (React/Vite)

### `apps\frontend\src\components\common\app-sidebar.tsx`

```typescript
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from '@/components/ui/sidebar';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useWorkspaces } from '@/hooks/use-workspaces';
import { useAuth } from '@/hooks/use-auth';
import {
  FileText,
  FolderOpen,
  Database,
  User2,
  LogOut,
  Settings,
  Plus,
  Workflow,
  LayoutDashboard,
  ChevronsUpDown,
} from 'lucide-react';
import { Link, useLocation } from 'react-router-dom';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { cn } from '@/lib/utils';

const navData = [
  {
    title: 'Overview',
    items: [
      { title: 'Dashboard', url: '/dashboard', icon: LayoutDashboard },
      { title: 'Flows', url: '/dashboard/flows', icon: Workflow },
    ],
  },
  {
    title: 'Resources',
    items: [
      { title: 'Spaces', url: '/dashboard/spaces', icon: FolderOpen },
      { title: 'Documents', url: '/dashboard/documents', icon: FileText },
      { title: 'Sources', url: '/dashboard/sources', icon: Database },
    ],
  },
  {
    title: 'Workspace',
    items: [{ title: 'Settings', url: '/dashboard/settings', icon: Settings }],
  },
];

export function AppSidebar() {
  const { workspaces, currentWorkspace, switchWorkspace, isLoading } = useWorkspaces();
  const { user, logout } = useAuth();
  const location = useLocation();
  const { state, isMobile } = useSidebar();

  // Determine if we should use "collapsed" behavior
  const isCollapsedMode = !isMobile && state === 'collapsed';

  return (
    <Sidebar variant="floating" collapsible="icon">
      {/* ==================== HEADER: WORKSPACE SELECTOR ==================== */}
      <SidebarHeader>
        <SidebarMenu>
          <SidebarMenuItem>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <SidebarMenuButton
                  size="lg"
                  className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground hover:bg-sidebar-accent/50"
                >
                  {isLoading ? (
                    <div className="flex w-full items-center gap-2">
                      <Skeleton className="size-8 shrink-0 rounded-lg" />
                      {(state === 'expanded' || isMobile) && (
                        <div className="min-w-0 flex-1">
                          <Skeleton className="mb-1 h-4 w-20" />
                          <Skeleton className="h-3 w-16" />
                        </div>
                      )}
                    </div>
                  ) : (
                    <>
                      <div className="bg-sidebar-primary text-sidebar-primary-foreground flex size-8 shrink-0 items-center justify-center rounded-lg font-semibold">
                        {currentWorkspace?.name?.charAt(0)?.toUpperCase() || 'F'}
                      </div>
                      {(state === 'expanded' || isMobile) && (
                        <>
                          <div className="flex min-w-0 flex-1 flex-col gap-0.5 text-left text-sm leading-tight">
                            <span className="truncate font-semibold">
                              {currentWorkspace?.name || 'Select Workspace'}
                            </span>
                            <span className="text-muted-foreground truncate text-xs">
                              {currentWorkspace?.type || 'No workspace'}
                            </span>
                          </div>
                          <ChevronsUpDown className="ml-auto size-4 shrink-0 opacity-50" />
                        </>
                      )}
                    </>
                  )}
                </SidebarMenuButton>
              </DropdownMenuTrigger>
              <DropdownMenuContent
                className={cn(
                  'cursor-pointer rounded-lg',
                  isCollapsedMode ? 'w-56' : 'w-[var(--radix-dropdown-menu-trigger-width)]'
                )}
                side={isCollapsedMode ? 'right' : 'bottom'}
                align="start"
                sideOffset={isCollapsedMode ? 8 : 4}
                alignOffset={isCollapsedMode ? -8 : 0}
              >
                <DropdownMenuLabel className="text-muted-foreground text-xs font-medium">
                  Workspaces
                </DropdownMenuLabel>
                <DropdownMenuSeparator />
                <div className="max-h-[300px] overflow-y-auto">
                  {workspaces.map((workspace) => (
                    <DropdownMenuItem
                      key={workspace.id}
                      onClick={() => switchWorkspace(workspace.id)}
                      className="cursor-pointer gap-2 p-2"
                    >
                      <div className="bg-background flex size-8 shrink-0 items-center justify-center rounded-md border">
                        <span className="text-sm font-semibold">
                          {workspace.name.charAt(0).toUpperCase()}
                        </span>
                      </div>
                      <div className="min-w-0 flex-1 overflow-hidden">
                        <div className="no-scrollbar overflow-x-auto text-sm font-medium whitespace-nowrap">
                          {workspace.name}
                        </div>
                        <div className="text-muted-foreground truncate text-xs">
                          {workspace.type} â€¢ {workspace.memberCount} members
                        </div>
                      </div>
                      {workspace.id === currentWorkspace?.id && (
                        <Badge
                          variant="secondary"
                          className="ml-auto shrink-0 px-1.5 py-0 text-[10px]"
                        >
                          Active
                        </Badge>
                      )}
                    </DropdownMenuItem>
                  ))}
                </div>
                <DropdownMenuSeparator />
                <DropdownMenuItem className="cursor-pointer gap-2 p-2">
                  <div className="flex size-8 shrink-0 items-center justify-center rounded-md border border-dashed">
                    <Plus className="size-4" />
                  </div>
                  <div className="text-muted-foreground truncate text-sm font-medium">
                    Create workspace
                  </div>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarHeader>

      {/* ==================== NAVIGATION MENU ==================== */}
      <SidebarContent className="overflow-y-auto">
        {navData.map((section) => (
          <SidebarGroup key={section.title}>
            <SidebarGroupLabel className="text-xs">{section.title}</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu className="gap-0.5">
                {section.items.map((item) => {
                  const isActive = location.pathname === item.url;
                  return (
                    <SidebarMenuItem key={item.title}>
                      <SidebarMenuButton asChild isActive={isActive} tooltip={item.title}>
                        <Link to={item.url} className="gap-2">
                          <item.icon className="size-4 shrink-0" />
                          <span className="truncate">{item.title}</span>
                        </Link>
                      </SidebarMenuButton>
                    </SidebarMenuItem>
                  );
                })}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        ))}
      </SidebarContent>

      {/* ==================== FOOTER: USER MENU ==================== */}
      <SidebarFooter>
        <SidebarMenu>
          <SidebarMenuItem>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <SidebarMenuButton
                  size="lg"
                  className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground hover:bg-sidebar-accent/50"
                >
                  <Avatar className="size-8 shrink-0 rounded-lg">
                    <AvatarImage src={user?.image || ''} alt={user?.name || user?.email} />
                    <AvatarFallback className="bg-sidebar-primary text-sidebar-primary-foreground rounded-lg">
                      <User2 className="size-4" />
                    </AvatarFallback>
                  </Avatar>
                  {(state === 'expanded' || isMobile) && (
                    <>
                      <div className="flex min-w-0 flex-1 flex-col gap-0.5 text-left text-sm leading-tight">
                        <span className="truncate font-semibold">{user?.name || 'User'}</span>
                        <span className="text-muted-foreground truncate text-xs">
                          {user?.email}
                        </span>
                      </div>
                      <ChevronsUpDown className="ml-auto size-4 shrink-0 opacity-50" />
                    </>
                  )}
                </SidebarMenuButton>
              </DropdownMenuTrigger>
              <DropdownMenuContent
                className={cn(
                  'rounded-lg',
                  isCollapsedMode ? 'w-56' : 'w-[var(--radix-dropdown-menu-trigger-width)]'
                )}
                side={isCollapsedMode ? 'right' : 'top'}
                align="end"
                sideOffset={isCollapsedMode ? 14 : 4}
                alignOffset={isCollapsedMode ? -8 : 0}
              >
                <DropdownMenuLabel className="p-0 px-2 py-1.5 font-normal">
                  <div className="flex items-center gap-2">
                    <Avatar className="size-8 shrink-0 rounded-lg">
                      <AvatarImage src={user?.image || ''} alt={user?.name || user?.email} />
                      <AvatarFallback className="rounded-lg">
                        <User2 className="size-4" />
                      </AvatarFallback>
                    </Avatar>
                    <div className="flex min-w-0 flex-col">
                      <p className="truncate text-sm leading-none font-medium">
                        {user?.name || 'User'}
                      </p>
                      <p className="text-muted-foreground mt-1 truncate text-xs leading-none">
                        {user?.email}
                      </p>
                    </div>
                  </div>
                </DropdownMenuLabel>
                <DropdownMenuSeparator />
                <DropdownMenuItem asChild className="cursor-pointer">
                  <Link to="/dashboard/profile">
                    <User2 className="mr-2 size-4 shrink-0" />
                    <span>Profile</span>
                  </Link>
                </DropdownMenuItem>
                <DropdownMenuItem asChild className="cursor-pointer">
                  <Link to="/dashboard/settings">
                    <Settings className="mr-2 size-4 shrink-0" />
                    <span>Settings</span>
                  </Link>
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  onClick={logout}
                  className="text-destructive focus:text-destructive cursor-pointer"
                >
                  <LogOut className="mr-2 size-4 shrink-0" />
                  <span>Sign out</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarFooter>
    </Sidebar>
  );
}

```

### `apps\frontend\src\components\common\notifications\notifications-dropdown.tsx`

```typescript
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Bell, CheckCheck, Trash2, Loader2, Inbox, Mail, Users, Settings } from 'lucide-react';
import { useNotifications } from '@/hooks/notifications/use-notifications';
import { useWorkspaces } from '@/hooks/use-workspaces';
import { formatDistanceToNow } from 'date-fns';
import { cn } from '@/lib/utils';

const notificationIcons: Record<string, any> = {
  WORKSPACE_INVITATION: Mail,
  WORKSPACE_MEMBER_JOINED: Users,
  WORKSPACE_UPDATED: Settings,
  default: Bell,
};

export function NotificationsDropdown() {
  const navigate = useNavigate();
  const { switchWorkspace } = useWorkspaces();
  const [open, setOpen] = useState(false);

  const {
    notifications,
    unreadCount,
    isLoading,
    hasMore,
    loadMore,
    markAsRead,
    markAllAsRead,
    deleteNotification,
  } = useNotifications();

  const handleNotificationClick = async (notification: any) => {
    if (!notification.isRead) {
      await markAsRead(notification.id);
    }

    if (notification.actionUrl) {
      setOpen(false);

      const metadata = notification.metadata || {};

      if (notification.actionUrl.includes('/workspace/invite/')) {
        navigate(notification.actionUrl);
      } else if (metadata.workspaceId) {
        switchWorkspace(metadata.workspaceId);

        if (notification.actionUrl.includes('/members')) {
          navigate('/dashboard/settings?tab=members');
        } else if (notification.actionUrl.includes('/settings')) {
          navigate('/dashboard/settings');
        } else {
          navigate('/dashboard');
        }
      } else {
        navigate(notification.actionUrl);
      }
    }
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen}>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon" className="relative h-8 w-8">
          <Bell className="h-4 w-4" />

          {unreadCount > 0 && (
            <Badge
              className="border-background absolute -top-1 -right-1 flex h-5 min-w-5 animate-pulse items-center justify-center rounded-full border-2 p-0 text-xs"
              style={{
                backgroundColor: 'hsl(var(--primary))',
                color: 'hsl(var(--primary-foreground))',
              }}
            >
              {unreadCount > 99 ? '99+' : unreadCount}
            </Badge>
          )}
        </Button>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="end" className="w-[380px] p-0 sm:w-[420px]" sideOffset={8}>
        <div className="flex items-center justify-between border-b p-4">
          <div>
            <h3 className="font-semibold">Notifications</h3>
            <p className="text-muted-foreground text-xs">
              {unreadCount > 0 ? `${unreadCount} unread` : 'All caught up'}
            </p>
          </div>
          {notifications.length > 0 && (
            <Button variant="ghost" size="sm" onClick={markAllAsRead} disabled={unreadCount === 0}>
              <CheckCheck className="mr-2 h-4 w-4" />
              Mark all read
            </Button>
          )}
        </div>

        <ScrollArea className="h-[400px]">
          {isLoading && notifications.length === 0 ? (
            <div className="flex h-40 items-center justify-center">
              <Loader2 className="text-muted-foreground h-6 w-6 animate-spin" />
            </div>
          ) : notifications.length === 0 ? (
            <div className="flex h-40 flex-col items-center justify-center text-center">
              <Inbox className="text-muted-foreground mb-2 h-8 w-8" />
              <p className="text-sm font-medium">No notifications</p>
              <p className="text-muted-foreground text-xs">You&apos;re all caught up!</p>
            </div>
          ) : (
            <>
              {notifications.map((notification, index) => {
                const Icon = notificationIcons[notification.type] || notificationIcons.default;

                return (
                  <div key={notification.id}>
                    <div
                      onClick={() => handleNotificationClick(notification)}
                      className={cn(
                        'group hover:bg-accent flex cursor-pointer items-start gap-3 p-4 transition-colors',
                        !notification.isRead && 'bg-muted/50'
                      )}
                    >
                      <div
                        className={cn(
                          'mt-0.5 flex h-8 w-8 shrink-0 items-center justify-center rounded-full',
                          notification.isRead ? 'bg-muted' : 'bg-primary/10'
                        )}
                      >
                        <Icon
                          className={cn(
                            'h-4 w-4',
                            notification.isRead ? 'text-muted-foreground' : 'text-primary'
                          )}
                        />
                      </div>

                      <div className="min-w-0 flex-1">
                        <div className="flex items-start justify-between gap-2">
                          <p
                            className={cn(
                              'text-sm font-medium',
                              !notification.isRead && 'font-semibold'
                            )}
                          >
                            {notification.title}
                          </p>
                          {!notification.isRead && (
                            <div className="bg-primary h-2 w-2 shrink-0 rounded-full" />
                          )}
                        </div>
                        <p className="text-muted-foreground mt-1 line-clamp-2 text-xs">
                          {notification.body}
                        </p>
                        <div className="mt-2 flex items-center gap-2">
                          <p className="text-muted-foreground text-xs">
                            {formatDistanceToNow(new Date(notification.createdAt), {
                              addSuffix: true,
                            })}
                          </p>
                        </div>
                      </div>

                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-7 w-7 shrink-0 opacity-0 group-hover:opacity-100"
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteNotification(notification.id);
                        }}
                      >
                        <Trash2 className="h-3.5 w-3.5" />
                      </Button>
                    </div>
                    {index < notifications.length - 1 && <Separator />}
                  </div>
                );
              })}

              {hasMore && (
                <div className="border-t p-3">
                  <Button
                    variant="ghost"
                    className="w-full"
                    size="sm"
                    onClick={loadMore}
                    disabled={isLoading}
                  >
                    {isLoading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Loading...
                      </>
                    ) : (
                      'Load more'
                    )}
                  </Button>
                </div>
              )}
            </>
          )}
        </ScrollArea>

        {notifications.length > 0 && (
          <>
            <Separator />
            <div className="p-2">
              <Button
                variant="ghost"
                className="w-full justify-start"
                size="sm"
                onClick={() => {
                  setOpen(false);
                  navigate('/dashboard/notifications');
                }}
              >
                View all notifications
              </Button>
            </div>
          </>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### `apps\frontend\src\components\shared\error-boundary.tsx`

```typescript
import { useRouteError, isRouteErrorResponse, Link } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    if (error.status === 404) {
      return (
        <div className="bg-background flex min-h-screen items-center justify-center p-4">
          <Card className="w-full max-w-md">
            <CardHeader>
              <CardTitle>404 - Page Not Found</CardTitle>
              <CardDescription>
                The page you&apos;re looking for doesn&apos;t exist.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <p className="text-muted-foreground text-sm">
                The page <code className="bg-muted rounded px-1 py-0.5">{error.statusText}</code>{' '}
                could not be found.
              </p>
              <Button asChild className="w-full">
                <Link to="/dashboard">Go to Dashboard</Link>
              </Button>
            </CardContent>
          </Card>
        </div>
      );
    }

    return (
      <div className="bg-background flex min-h-screen items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <CardTitle>{error.status} Error</CardTitle>
            <CardDescription>{error.statusText}</CardDescription>
          </CardHeader>
          <CardContent>
            <Button asChild className="w-full">
              <Link to="/dashboard">Go to Dashboard</Link>
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="bg-background flex min-h-screen items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Oops! Something went wrong</CardTitle>
          <CardDescription>An unexpected error occurred</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-muted-foreground text-sm">
            {error instanceof Error ? error.message : 'Unknown error'}
          </p>
          <Button asChild className="w-full">
            <Link to="/dashboard">Go to Dashboard</Link>
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}

```

### `apps\frontend\src\components\shared\protected-route.tsx`

```typescript
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/hooks/use-auth';

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="flex min-h-screen items-center justify-center">
        <div className="border-primary h-8 w-8 animate-spin rounded-full border-4 border-t-transparent" />
      </div>
    );
  }

  if (!user) {
    const returnUrl = location.pathname + location.search;
    return <Navigate to={`/auth/login?returnUrl=${encodeURIComponent(returnUrl)}`} replace />;
  }

  return <>{children}</>;
}

```

### `apps\frontend\src\components\shared\theme\theme-provider.tsx`

```typescript
import { createContext, useEffect, useState } from 'react';

type Theme = 'dark' | 'light' | 'system';

type ThemeProviderProps = {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
};

type ThemeProviderState = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
  theme: 'dark',
  setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
  children,
  defaultTheme = 'dark',
  storageKey = 'actopod-ui-theme',
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  );

  useEffect(() => {
    const root = window.document.documentElement;

    root.classList.remove('light', 'dark');

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches
        ? 'dark'
        : 'light';

      root.classList.add(systemTheme);
      return;
    }

    root.classList.add(theme);
  }, [theme]);

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme);
      setTheme(theme);
    },
  };

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

// Export the context separately for the hook
export { ThemeProviderContext };

```

### `apps\frontend\src\components\shared\theme\theme-toggle.tsx`

```typescript
import { Moon, Sun } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useTheme } from '@/hooks/use-theme';

export function ThemeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### `apps\frontend\src\components\ui\alert.tsx`

```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

```

### `apps\frontend\src\components\ui\alert-dialog.tsx`

```typescript
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

```

### `apps\frontend\src\components\ui\avatar.tsx`

```typescript
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

```

### `apps\frontend\src\components\ui\badge.tsx`

```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }

```

### `apps\frontend\src\components\ui\breadcrumb.tsx`

```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

```

### `apps\frontend\src\components\ui\button.tsx`

```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

```

### `apps\frontend\src\components\ui\card.tsx`

```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

```

### `apps\frontend\src\components\ui\checkbox.tsx`

```typescript
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }

```

### `apps\frontend\src\components\ui\collapsible.tsx`

```typescript
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

```

### `apps\frontend\src\components\ui\dialog.tsx`

```typescript
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

```

### `apps\frontend\src\components\ui\dropdown-menu.tsx`

```typescript
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}

```

### `apps\frontend\src\components\ui\field.tsx`

```typescript
import { useMemo } from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"
import { Separator } from "@/components/ui/separator"

function FieldSet({ className, ...props }: React.ComponentProps<"fieldset">) {
  return (
    <fieldset
      data-slot="field-set"
      className={cn(
        "flex flex-col gap-6",
        "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
        className
      )}
      {...props}
    />
  )
}

function FieldLegend({
  className,
  variant = "legend",
  ...props
}: React.ComponentProps<"legend"> & { variant?: "legend" | "label" }) {
  return (
    <legend
      data-slot="field-legend"
      data-variant={variant}
      className={cn(
        "mb-3 font-medium",
        "data-[variant=legend]:text-base",
        "data-[variant=label]:text-sm",
        className
      )}
      {...props}
    />
  )
}

function FieldGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="field-group"
      className={cn(
        "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
        className
      )}
      {...props}
    />
  )
}

const fieldVariants = cva(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px",
        ],
        responsive: [
          "flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px",
        ],
      },
    },
    defaultVariants: {
      orientation: "vertical",
    },
  }
)

function Field({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof fieldVariants>) {
  return (
    <div
      role="group"
      data-slot="field"
      data-orientation={orientation}
      className={cn(fieldVariants({ orientation }), className)}
      {...props}
    />
  )
}

function FieldContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="field-content"
      className={cn(
        "group/field-content flex flex-1 flex-col gap-1.5 leading-snug",
        className
      )}
      {...props}
    />
  )
}

function FieldLabel({
  className,
  ...props
}: React.ComponentProps<typeof Label>) {
  return (
    <Label
      data-slot="field-label"
      className={cn(
        "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
        "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4",
        "has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10",
        className
      )}
      {...props}
    />
  )
}

function FieldTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="field-label"
      className={cn(
        "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
        className
      )}
      {...props}
    />
  )
}

function FieldDescription({ className, ...props }: React.ComponentProps<"p">) {
  return (
    <p
      data-slot="field-description"
      className={cn(
        "text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance",
        "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
        "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4",
        className
      )}
      {...props}
    />
  )
}

function FieldSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  children?: React.ReactNode
}) {
  return (
    <div
      data-slot="field-separator"
      data-content={!!children}
      className={cn(
        "relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2",
        className
      )}
      {...props}
    >
      <Separator className="absolute inset-0 top-1/2" />
      {children && (
        <span
          className="bg-background text-muted-foreground relative mx-auto block w-fit px-2"
          data-slot="field-separator-content"
        >
          {children}
        </span>
      )}
    </div>
  )
}

function FieldError({
  className,
  children,
  errors,
  ...props
}: React.ComponentProps<"div"> & {
  errors?: Array<{ message?: string } | undefined>
}) {
  const content = useMemo(() => {
    if (children) {
      return children
    }

    if (!errors?.length) {
      return null
    }

    if (errors?.length == 1) {
      return errors[0]?.message
    }

    return (
      <ul className="ml-4 flex list-disc flex-col gap-1">
        {errors.map(
          (error, index) =>
            error?.message && <li key={index}>{error.message}</li>
        )}
      </ul>
    )
  }, [children, errors])

  if (!content) {
    return null
  }

  return (
    <div
      role="alert"
      data-slot="field-error"
      className={cn("text-destructive text-sm font-normal", className)}
      {...props}
    >
      {content}
    </div>
  )
}

export {
  Field,
  FieldLabel,
  FieldDescription,
  FieldError,
  FieldGroup,
  FieldLegend,
  FieldSeparator,
  FieldSet,
  FieldContent,
  FieldTitle,
}

```

### `apps\frontend\src\components\ui\form.tsx`

```typescript
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

```

### `apps\frontend\src\components\ui\input.tsx`

```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

```

### `apps\frontend\src\components\ui\label.tsx`

```typescript
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

```

### `apps\frontend\src\components\ui\popover.tsx`

```typescript
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

```

### `apps\frontend\src\components\ui\scroll-area.tsx`

```typescript
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

```

### `apps\frontend\src\components\ui\select.tsx`

```typescript
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

```

### `apps\frontend\src\components\ui\separator.tsx`

```typescript
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

```

### `apps\frontend\src\components\ui\sheet.tsx`

```typescript
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

```

### `apps\frontend\src\components\ui\sidebar.tsx`

```typescript
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, VariantProps } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

```

### `apps\frontend\src\components\ui\skeleton.tsx`

```typescript
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }

```

### `apps\frontend\src\components\ui\sonner.tsx`

```typescript
import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }

```

### `apps\frontend\src\components\ui\switch.tsx`

```typescript
import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }

```

### `apps\frontend\src\components\ui\table.tsx`

```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

```

### `apps\frontend\src\components\ui\tabs.tsx`

```typescript
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

```

### `apps\frontend\src\components\ui\textarea.tsx`

```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

```

### `apps\frontend\src\components\ui\tooltip.tsx`

```typescript
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

```

### `apps\frontend\src\context\auth-context.tsx`

```typescript
import { createContext } from 'react';
import { User, LoginData, RegisterData } from '@/types/auth';

export interface AuthContextType {
  user: User | null;
  loading: boolean;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (data: LoginData) => Promise<void>;
  logout: () => Promise<void>;
  register: (data: RegisterData) => Promise<void>;
  setUser: (user: User | null) => void;
}

export const AuthContext = createContext<AuthContextType | undefined>(undefined);

```

### `apps\frontend\src\context\auth-provider.tsx`

```typescript
import { useState, useEffect, ReactNode, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { toast } from '@/lib/toast-utils';
import { axiosInstance } from '@/lib/axios-instance';
import { AuthContext, AuthContextType } from './auth-context';
import { User, LoginData, RegisterData, LoginResponse, UserMeResponse } from '@/types/auth';
import { getAuthTokens, setAuthTokens, clearAuthTokens, setDeviceName } from '@/utils/token-utils';

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  const fetchUser = useCallback(async () => {
    const tokens = getAuthTokens();
    if (!tokens?.accessToken) {
      setLoading(false);
      return;
    }

    try {
      const response = await axiosInstance.get<UserMeResponse>('/users/me');

      setUser({
        userId: response.data.data.userId,
        email: response.data.data.email,
        name: response.data.data.name,
        image: response.data.data.image,
        createdAt: response.data.data.createdAt,
        updatedAt: response.data.data.updatedAt,
      });
    } catch (error: any) {
      console.error('Failed to fetch user:', error);

      if (error.response?.status === 401) {
        clearAuthTokens();
        setUser(null);
      }
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  const getRedirectPath = () => {
    // âœ… Check sessionStorage first
    const pendingInvitation = sessionStorage.getItem('pendingInvitation');
    if (pendingInvitation) {
      sessionStorage.removeItem('pendingInvitation');
      return `/workspace/invite/${pendingInvitation}`;
    }

    // âœ… Check URL params
    const urlParams = new URLSearchParams(window.location.search);
    const returnUrl = urlParams.get('returnUrl');
    if (returnUrl) {
      return decodeURIComponent(returnUrl);
    }

    // âœ… Default
    return '/dashboard';
  };

  const login = async (data: LoginData) => {
    try {
      const response = await axiosInstance.post<LoginResponse>('/auth/login', {
        email: data.email,
        password: data.password,
      });

      const responseData = response.data.data;

      setAuthTokens({
        accessToken: responseData.accessToken,
        refreshToken: responseData.refreshToken,
        deviceId: responseData.deviceId,
      });

      setDeviceName(responseData.deviceName);

      await fetchUser();

      toast.success('Logged in successfully');

      // âœ… Use the helper function
      const redirectPath = getRedirectPath();
      navigate(redirectPath);
    } catch (error: any) {
      const message = error.response?.data?.message || 'Login failed';
      toast.error(message);
      throw error;
    }
  };

  const register = async (data: RegisterData) => {
    try {
      const response = await axiosInstance.post<LoginResponse>('/auth/register', {
        name: data.name,
        email: data.email,
        password: data.password,
      });

      const responseData = response.data.data;

      setAuthTokens({
        accessToken: responseData.accessToken,
        refreshToken: responseData.refreshToken,
        deviceId: responseData.deviceId,
      });

      setDeviceName(responseData.deviceName);

      await fetchUser();

      toast.success('Account created successfully');

      // âœ… Use the helper function
      const redirectPath = getRedirectPath();
      navigate(redirectPath);
    } catch (error: any) {
      const message = error.response?.data?.message || 'Registration failed';
      toast.error(message);
      throw error;
    }
  };

  const logout = async () => {
    try {
      const tokens = getAuthTokens();
      if (tokens?.deviceId) {
        await axiosInstance.post('/auth/logout', { deviceId: tokens.deviceId });
      }
      toast.success('Logged out successfully');
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      clearAuthTokens();
      setUser(null);
      navigate('/auth/login');
    }
  };

  const isAuthenticated = useMemo(() => !!user, [user]);
  const isLoading = loading;

  const value: AuthContextType = {
    user,
    loading,
    isAuthenticated,
    isLoading,
    login,
    logout,
    register,
    setUser,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

```

### `apps\frontend\src\context\breadcrumb-context.tsx`

```typescript
// contexts/breadcrumb-context.tsx
import { BreadcrumbContext } from '@/hooks/use-breadcrumbs';
import { useState, useCallback, ReactNode } from 'react';

interface BreadcrumbItem {
  label: string;
  to: string;
  isLast?: boolean;
}

export function BreadcrumbProvider({ children }: { children: ReactNode }) {
  const [customBreadcrumbs, setCustomBreadcrumbs] = useState<BreadcrumbItem[] | null>(null);

  // âœ… Memoize the setter function
  const updateBreadcrumbs = useCallback((breadcrumbs: BreadcrumbItem[] | null) => {
    setCustomBreadcrumbs(breadcrumbs);
  }, []);

  return (
    <BreadcrumbContext.Provider
      value={{ customBreadcrumbs, setCustomBreadcrumbs: updateBreadcrumbs }}
    >
      {children}
    </BreadcrumbContext.Provider>
  );
}

```

### `apps\frontend\src\hooks\notifications\use-notifications.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { axiosInstance } from '@/lib/axios-instance';
import { toast } from '@/lib/toast-utils';
import { useNotificationSocket } from './use-notification-socket';

export interface Notification {
  id: string;
  type: string;
  title: string;
  body: string;
  isRead: boolean;
  createdAt: string;
  actionUrl?: string;
  entityType?: string;
  entityId?: string;
  metadata?: Record<string, any>;
}

export function useNotifications() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [hasMore, setHasMore] = useState(false);

  const fetchNotifications = useCallback(async (page = 1, append = false) => {
    try {
      setIsLoading(true);
      const response = await axiosInstance.get('/notifications', {
        params: { page, limit: 10 },
      });

      const responseData = response.data?.data || response.data;
      const newNotifications = Array.isArray(responseData) ? responseData : responseData.data || [];
      const pagination = responseData.pagination || {
        totalPages: 1,
        currentPage: 1,
      };
      const unread = responseData.unreadCount || 0;

      if (append) {
        setNotifications((prev) => [...prev, ...newNotifications]);
      } else {
        setNotifications(newNotifications);
      }

      setUnreadCount(unread);
      setCurrentPage(pagination.currentPage);
      setTotalPages(pagination.totalPages);
      setHasMore(pagination.currentPage < pagination.totalPages);
    } catch (error) {
      console.error('Failed to fetch notifications:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // âœ… Handle real-time new notification
  const handleNewNotification = useCallback((notification: Notification) => {
    setNotifications((prev) => {
      // Prevent duplicates
      if (prev.some((n) => n.id === notification.id)) {
        return prev;
      }
      return [notification, ...prev];
    });
    setUnreadCount((prev) => prev + 1);
  }, []);

  // âœ… Handle real-time unread count update
  const handleUnreadCountUpdate = useCallback((count: number) => {
    setUnreadCount(count);
  }, []);

  // âœ… Connect to WebSocket (no return value needed)
  useNotificationSocket(handleNewNotification, handleUnreadCountUpdate);

  const loadMore = useCallback(() => {
    if (!isLoading && hasMore) {
      fetchNotifications(currentPage + 1, true);
    }
  }, [currentPage, hasMore, isLoading, fetchNotifications]);

  const markAsRead = useCallback(async (notificationId: string) => {
    try {
      await axiosInstance.patch(`/notifications/${notificationId}/read`);

      setNotifications((prev) =>
        prev.map((n) => (n.id === notificationId ? { ...n, isRead: true } : n))
      );
      // WebSocket will handle unread count update
    } catch (error) {
      console.error('Failed to mark as read:', error);
      toast.error('Failed to mark as read');
    }
  }, []);

  const markAllAsRead = useCallback(async () => {
    try {
      await axiosInstance.patch('/notifications/read-all');

      setNotifications((prev) => prev.map((n) => ({ ...n, isRead: true })));
      toast.success('All notifications marked as read');
    } catch (error) {
      console.error('Failed to mark all as read:', error);
      toast.error('Failed to mark all as read');
    }
  }, []);

  const deleteNotification = useCallback(async (notificationId: string) => {
    try {
      await axiosInstance.delete(`/notifications/${notificationId}`);

      setNotifications((prev) => prev.filter((n) => n.id !== notificationId));
      toast.success('Notification deleted');
    } catch (error) {
      console.error('Failed to delete notification:', error);
      toast.error('Failed to delete notification');
    }
  }, []);

  useEffect(() => {
    fetchNotifications();
  }, [fetchNotifications]);

  return {
    notifications,
    unreadCount,
    isLoading,
    hasMore,
    totalPages,
    fetchNotifications,
    loadMore,
    markAsRead,
    markAllAsRead,
    deleteNotification,
  };
}

```

### `apps\frontend\src\hooks\notifications\use-notification-socket.ts`

```typescript
import { useEffect, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';
import { toast } from '@/lib/toast-utils';
import { getAuthTokens } from '@/utils/token-utils';

const SOCKET_URL = import.meta.env.VITE_WS_URL || 'http://localhost:8000';

export function useNotificationSocket(
  onNewNotification: (notification: any) => void,
  onUnreadCountUpdate: (count: number) => void
) {
  const socketRef = useRef<Socket | null>(null);
  const reconnectAttempts = useRef(0);
  const isConnecting = useRef(false);
  const MAX_RECONNECT_ATTEMPTS = 5;

  const connect = useCallback(() => {
    const tokens = getAuthTokens();
    if (!tokens?.accessToken) {
      return;
    }

    // âœ… Prevent duplicate connections
    if (socketRef.current?.connected || isConnecting.current) {
      return;
    }

    isConnecting.current = true;

    socketRef.current = io(`${SOCKET_URL}/notifications`, {
      auth: { token: tokens.accessToken },
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      // âœ… Timeout for connection attempt
      timeout: 10000,
    });

    const socket = socketRef.current;

    socket.on('connect', () => {
      reconnectAttempts.current = 0;
      isConnecting.current = false;
    });

    socket.on('connected', () => {
      // Successfully authenticated
    });

    socket.on('disconnect', (reason: string) => {
      isConnecting.current = false;
      if (reason === 'io server disconnect') {
        // Server disconnected us, could be auth failure
        console.warn('Disconnected by server');
      }
    });

    socket.on('connect_error', (error: Error) => {
      if (error) {
        //Empty
      }
      isConnecting.current = false;
      reconnectAttempts.current += 1;

      if (reconnectAttempts.current >= MAX_RECONNECT_ATTEMPTS) {
        console.error('Max reconnection attempts reached');
        socket.disconnect();
      }
    });

    socket.on('error', (error: any) => {
      if (error.message?.includes('Authentication')) {
        socket.disconnect();
      }
    });

    socket.on('notification:new', (notification: any) => {
      onNewNotification(notification);

      toast.info(notification.title, {
        description: notification.body,
      });
    });

    socket.on('notification:unread_count', (count: number) => {
      onUnreadCountUpdate(count);
    });
  }, [onNewNotification, onUnreadCountUpdate]);

  useEffect(() => {
    connect();

    return () => {
      if (socketRef.current) {
        isConnecting.current = false;
        socketRef.current.disconnect();
        socketRef.current = null;
      }
    };
  }, [connect]);
}

```

### `apps\frontend\src\hooks\use-auth.ts`

```typescript
import { useContext } from 'react';
import { AuthContext } from '@/context/auth-context';

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

```

### `apps\frontend\src\hooks\use-breadcrumbs.ts`

```typescript
import { createContext, useContext } from 'react';

interface BreadcrumbItem {
  label: string;
  to: string;
  isLast?: boolean;
}

interface BreadcrumbContextType {
  customBreadcrumbs: BreadcrumbItem[] | null;
  setCustomBreadcrumbs: (breadcrumbs: BreadcrumbItem[] | null) => void;
}

export const BreadcrumbContext = createContext<BreadcrumbContextType | undefined>(undefined);

export function useBreadcrumbs() {
  const context = useContext(BreadcrumbContext);
  if (!context) {
    throw new Error('useBreadcrumbs must be used within BreadcrumbProvider');
  }
  return context;
}

```

### `apps\frontend\src\hooks\use-mobile.ts`

```typescript
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

```

### `apps\frontend\src\hooks\use-set-breadcrumbs.ts`

```typescript
// hooks/use-set-breadcrumbs.ts
import { useEffect, useMemo } from 'react';
import { useBreadcrumbs } from './use-breadcrumbs';

interface BreadcrumbItem {
  label: string;
  to: string;
  isLast?: boolean;
}

export function useSetBreadcrumbs(breadcrumbs: BreadcrumbItem[] | null) {
  const { setCustomBreadcrumbs } = useBreadcrumbs();

  // âœ… Memoize breadcrumbs to prevent unnecessary re-renders
  const memoizedBreadcrumbs = useMemo(() => {
    return breadcrumbs ? JSON.stringify(breadcrumbs) : null;
  }, [breadcrumbs]);

  useEffect(() => {
    if (memoizedBreadcrumbs) {
      setCustomBreadcrumbs(JSON.parse(memoizedBreadcrumbs));
    } else {
      setCustomBreadcrumbs(null);
    }

    return () => {
      setCustomBreadcrumbs(null);
    };
    // âœ… Only depend on stringified version
  }, [memoizedBreadcrumbs, setCustomBreadcrumbs]);
}

```

### `apps\frontend\src\hooks\use-theme.ts`

```typescript
import { ThemeProviderContext } from '@/components/shared/theme/theme-provider';
import { useContext } from 'react';

export function useTheme() {
  const context = useContext(ThemeProviderContext);

  if (context === undefined) throw new Error('useTheme must be used within a ThemeProvider');

  return context;
}

```

### `apps\frontend\src\hooks\use-workspaces.ts`

```typescript
// src/hooks/use-workspaces.ts
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useWorkspaceStore } from '@/store/workspace-store';
import { useEffect } from 'react';
import axiosInstance from '@/lib/axios-instance';

interface Workspace {
  id: string;
  name: string;
  type: 'PERSONAL' | 'TEAM';
  role: 'OWNER' | 'ADMIN' | 'MEMBER';
  permissions: {
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
  };
  memberCount: number;
  canvasCount: number;
  joinedAt: string;
  createdAt: string;
  updatedAt: string;
}

export const useWorkspaces = () => {
  const queryClient = useQueryClient();
  const { currentWorkspaceId, setCurrentWorkspaceId } = useWorkspaceStore();

  const {
    data: workspaces,
    isLoading,
    error,
  } = useQuery<Workspace[]>({
    queryKey: ['workspaces'],
    queryFn: async () => {
      const response = await axiosInstance.get('/workspaces');
      return response.data.data || response.data;
    },
    // âœ… Ensure workspace is selected immediately
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
  });

  // âœ… CRITICAL FIX: Auto-select first workspace IMMEDIATELY when data loads
  useEffect(() => {
    if (!isLoading && workspaces && workspaces.length > 0) {
      // If no workspace is selected OR selected workspace doesn't exist
      const workspaceExists = workspaces.some((ws) => ws.id === currentWorkspaceId);

      if (!currentWorkspaceId || !workspaceExists) {
        // âœ… Prioritize PERSONAL workspace, fallback to first
        const defaultWorkspace = workspaces.find((ws) => ws.type === 'PERSONAL') || workspaces[0];

        setCurrentWorkspaceId(defaultWorkspace.id);
        console.log('âœ… Auto-selected workspace:', defaultWorkspace.name);
      }
    }
  }, [workspaces, currentWorkspaceId, setCurrentWorkspaceId, isLoading]);

  const currentWorkspace = workspaces?.find((ws) => ws.id === currentWorkspaceId);

  const switchWorkspace = (workspaceId: string) => {
    setCurrentWorkspaceId(workspaceId);
    // Invalidate relevant queries when switching workspace
    queryClient.invalidateQueries({ queryKey: ['workspace', workspaceId] });
    queryClient.invalidateQueries({ queryKey: ['flows'] });
  };

  return {
    workspaces: workspaces || [],
    currentWorkspace,
    currentWorkspaceId: currentWorkspaceId || workspaces?.[0]?.id || null, // âœ… Fallback
    switchWorkspace,
    isLoading,
    error,
    // âœ… Helper to check if workspace is ready
    isReady: !isLoading && !!currentWorkspaceId,
  };
};

```

### `apps\frontend\src\layout\auth-layout.tsx`

```typescript
import { Outlet } from 'react-router-dom';
import { ThemeToggle } from '@/components/shared/theme/theme-toggle';

export function AuthLayout() {
  return (
    <div className="bg-background relative flex min-h-screen items-center justify-center">
      <div className="absolute top-4 right-4">
        <ThemeToggle />
      </div>
      <Outlet />
    </div>
  );
}

```

### `apps\frontend\src\layout\dashboard-layout.tsx`

```typescript
// layouts/dashboard-layout.tsx
import { Outlet, useLocation, Link } from 'react-router-dom';
import { SidebarProvider, SidebarTrigger, SidebarInset } from '@/components/ui/sidebar';
import { ThemeToggle } from '@/components/shared/theme/theme-toggle';
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from '@/components/ui/breadcrumb';
import { AppSidebar } from '@/components/common/app-sidebar';
import { NotificationsDropdown } from '@/components/common/notifications/notifications-dropdown';
import { useBreadcrumbs } from '@/hooks/use-breadcrumbs';
import { Button } from '@/components/ui/button';
import { Users } from 'lucide-react';

export function DashboardLayout() {
  const location = useLocation();
  const { customBreadcrumbs } = useBreadcrumbs();

  const generateBreadcrumbs = () => {
    const pathnames = location.pathname.split('/').filter((x) => x);

    return pathnames.map((value, index) => {
      const to = `/${pathnames.slice(0, index + 1).join('/')}`;
      const isLast = index === pathnames.length - 1;

      const label = value
        .split('-')
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

      return {
        label,
        to,
        isLast,
      };
    });
  };

  const breadcrumbs = customBreadcrumbs || generateBreadcrumbs();
  const isFlowEditor = location.pathname.match(/^\/dashboard\/flows\/[^/]+$/);

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset className="flex flex-col overflow-hidden">
        <header className="bg-background sticky top-0 z-10 flex h-16 shrink-0 items-center gap-4 border-b px-4 sm:px-6">
          <SidebarTrigger className="-ml-1 translate-y-px cursor-pointer" />
          <Breadcrumb className="hidden sm:block">
            <BreadcrumbList className="gap-2">
              {breadcrumbs.map((crumb, index) => (
                <div key={crumb.to} className="flex items-center gap-2">
                  {index > 0 && <BreadcrumbSeparator className="mx-0 translate-y-0.5" />}
                  <BreadcrumbItem>
                    {crumb.isLast ? (
                      <BreadcrumbPage>{crumb.label}</BreadcrumbPage>
                    ) : (
                      <BreadcrumbLink asChild>
                        <Link to={crumb.to}>{crumb.label}</Link>
                      </BreadcrumbLink>
                    )}
                  </BreadcrumbItem>
                </div>
              ))}
            </BreadcrumbList>
          </Breadcrumb>
          <div className="ml-auto flex items-center gap-2">
            {/* âœ… Only show Users button on flow editor */}
            {isFlowEditor && (
              <Button variant="ghost" size="icon">
                <Users className="h-4 w-4" />
              </Button>
            )}
            <NotificationsDropdown />
            <ThemeToggle />
          </div>
        </header>
        <main
          className={
            isFlowEditor
              ? 'relative flex-1 overflow-hidden'
              : 'flex flex-1 flex-col gap-4 p-4 md:p-6'
          }
        >
          <Outlet />
        </main>
      </SidebarInset>
    </SidebarProvider>
  );
}

```

### `apps\frontend\src\layout\root-layout.tsx`

```typescript
import { Outlet } from 'react-router-dom';
import { AuthProvider } from '@/context/auth-provider';

export function RootLayout() {
  return (
    <AuthProvider>
      <Outlet />
    </AuthProvider>
  );
}

```

### `apps\frontend\src\lib\axios-instance.ts`

```typescript
// lib/axios-instance.ts

import axios, { AxiosError, AxiosHeaders, InternalAxiosRequestConfig, AxiosResponse } from 'axios';
import { toast } from '@/lib/toast-utils';
import { getAuthTokens, setAuthTokens, clearAuthTokens } from '@/utils/token-utils';
import { AuthTokens } from '@/types/auth';

interface CustomAxiosRequestConfig extends InternalAxiosRequestConfig {
  _retry?: boolean;
  showErrorToast?: boolean; // âœ… NEW: Optional flag to show error toast
}

const BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api/v1';

export const axiosInstance = axios.create({
  baseURL: BASE_URL,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json',
  },
});

// ==========================================
// OFFLINE REDIRECT HELPERS
// ==========================================

const OFFLINE_REDIRECT_FLAG = 'offlineRedirectPending';
const PRE_ERROR_PATH = 'preErrorPath';

function markOfflineAndRememberPath() {
  try {
    if (!sessionStorage.getItem(PRE_ERROR_PATH)) {
      const current = window.location.pathname + window.location.search + window.location.hash;
      sessionStorage.setItem(PRE_ERROR_PATH, current);
    }
    sessionStorage.setItem(OFFLINE_REDIRECT_FLAG, '1');
  } catch {
    // EMPTY
  }
}

export function redirectFromOfflineIfNeeded() {
  try {
    const pending = sessionStorage.getItem(OFFLINE_REDIRECT_FLAG) === '1';
    if (!pending) return;

    const prev = sessionStorage.getItem(PRE_ERROR_PATH) || '/dashboard';
    sessionStorage.removeItem(OFFLINE_REDIRECT_FLAG);
    sessionStorage.removeItem(PRE_ERROR_PATH);

    window.location.replace(prev);
  } catch {
    window.location.replace('/dashboard');
  }
}

// ==========================================
// REFRESH TOKEN HANDLING
// ==========================================

interface RefreshTokenResponse {
  statusCode: number;
  message: string;
  data: {
    accessToken: string;
    refreshToken: string;
    deviceId: string;
  };
}

interface FailedRequest {
  resolve: (token: string) => void;
  reject: (error: any) => void;
}

let isRefreshing = false;
let failedQueue: FailedRequest[] = [];

const processQueue = (error: any, token: string | null = null): void => {
  failedQueue.forEach((prom) => {
    if (error) prom.reject(error);
    else if (token) prom.resolve(token);
  });
  failedQueue = [];
};

// ==========================================
// REQUEST INTERCEPTOR
// ==========================================

axiosInstance.interceptors.request.use(
  (config: InternalAxiosRequestConfig): InternalAxiosRequestConfig => {
    // Skip auth for public endpoints
    if (config.headers && config.headers['x-public'] === 'true') {
      delete config.headers['x-public'];
      return config;
    }

    const tokens = getAuthTokens();
    if (tokens?.accessToken) {
      (config.headers as AxiosHeaders).set('Authorization', `Bearer ${tokens.accessToken}`);
    }
    return config;
  },
  (error: AxiosError) => Promise.reject(error)
);

// ==========================================
// RESPONSE INTERCEPTOR
// ==========================================

axiosInstance.interceptors.response.use(
  // âœ… SUCCESS
  (response: AxiosResponse): AxiosResponse => {
    if (window.location.pathname.includes('/errors/offline')) {
      redirectFromOfflineIfNeeded();
    }
    return response;
  },

  async (error: AxiosError): Promise<any> => {
    const originalRequest = error.config as CustomAxiosRequestConfig;
    const showErrorToast = originalRequest?.showErrorToast === true; // âœ… Default true

    // ==========================================
    // NETWORK ERROR (No Internet)
    // ==========================================
    if (!error.response) {
      console.error('Network error:', error.message);

      if (showErrorToast) {
        toast.error('No internet connection', {
          description: 'Please check your network and try again',
          duration: 5000,
        });
      }

      markOfflineAndRememberPath();

      // Only redirect if not already on offline page
      if (!window.location.pathname.includes('/errors/offline')) {
        window.location.href = '/errors/offline';
      }
      return Promise.reject(error);
    }

    const status = error.response.status;
    const errorData = error.response.data as any;
    const errorMessage = errorData?.message || 'An error occurred';

    // ==========================================
    // 401 UNAUTHORIZED (Token Refresh)
    // ==========================================
    if (
      status === 401 &&
      !originalRequest._retry &&
      !originalRequest.url?.includes('/auth/login') &&
      !originalRequest.url?.includes('/auth/register') &&
      !originalRequest.url?.includes('/auth/refresh')
    ) {
      if (isRefreshing) {
        return new Promise<string>((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then((token: string) => {
            (originalRequest.headers as AxiosHeaders).set('Authorization', `Bearer ${token}`);
            return axiosInstance(originalRequest);
          })
          .catch((err) => Promise.reject(err));
      }

      originalRequest._retry = true;
      isRefreshing = true;

      const tokens = getAuthTokens();
      if (!tokens?.refreshToken) {
        clearAuthTokens();
        if (showErrorToast) {
          toast.error('Session expired', {
            description: 'Please log in again',
          });
        }
        window.location.href = '/auth/login';
        return Promise.reject(error);
      }

      try {
        const response = await axios.post<RefreshTokenResponse>(
          `${BASE_URL}/auth/refresh`,
          { deviceId: tokens.deviceId },
          {
            headers: { Authorization: `Bearer ${tokens.refreshToken}` },
            withCredentials: true,
          }
        );

        const newTokens: AuthTokens = {
          accessToken: response.data.data.accessToken,
          refreshToken: response.data.data.refreshToken,
          deviceId: tokens.deviceId,
        };

        setAuthTokens(newTokens);

        (originalRequest.headers as AxiosHeaders).set(
          'Authorization',
          `Bearer ${newTokens.accessToken}`
        );

        processQueue(null, newTokens.accessToken);

        return axiosInstance(originalRequest);
      } catch (err) {
        processQueue(err, null);
        clearAuthTokens();
        if (showErrorToast) {
          toast.error('Session expired', {
            description: 'Please log in again',
          });
        }
        window.location.href = '/auth/login';
        return Promise.reject(err);
      } finally {
        isRefreshing = false;
      }
    }

    // ==========================================
    // 403 FORBIDDEN
    // ==========================================
    if (status === 403) {
      console.error('Access forbidden:', errorData);
      if (showErrorToast) {
        toast.error('Access denied', {
          description: errorMessage || "You don't have permission to access this resource",
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 404 NOT FOUND
    // ==========================================
    if (status === 404) {
      console.error('Resource not found:', errorData);
      if (showErrorToast) {
        toast.error('Not found', {
          description: errorMessage || 'The requested resource was not found',
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 409 CONFLICT
    // ==========================================
    if (status === 409) {
      console.error('Conflict:', errorData);
      if (showErrorToast) {
        toast.error('Conflict', {
          description: errorMessage || 'A conflict occurred with existing data',
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 422 VALIDATION ERROR
    // ==========================================
    if (status === 422) {
      console.error('Validation error:', errorData);
      if (showErrorToast) {
        toast.error('Validation error', {
          description: errorMessage || 'Please check your input and try again',
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 429 TOO MANY REQUESTS
    // ==========================================
    if (status === 429) {
      console.error('Rate limit exceeded:', errorData);
      if (showErrorToast) {
        toast.error('Too many requests', {
          description: 'Please wait a moment before trying again',
          duration: 5000,
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 500 INTERNAL SERVER ERROR
    // ==========================================
    if (status === 500) {
      console.error('Server error:', errorData);
      if (showErrorToast) {
        toast.error('Server error', {
          description: errorMessage || 'Something went wrong on our end. Please try again later',
          duration: 5000,
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 502 BAD GATEWAY
    // ==========================================
    if (status === 502) {
      console.error('Bad gateway:', errorData);
      if (showErrorToast) {
        toast.error('Service temporarily unavailable', {
          description: 'Our servers are having issues. Please try again in a few moments',
          duration: 5000,
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // 503 SERVICE UNAVAILABLE
    // ==========================================
    if (status === 503) {
      console.error('Service unavailable:', errorData);
      if (showErrorToast) {
        toast.error('Service unavailable', {
          description: 'The service is temporarily down for maintenance',
          duration: 5000,
        });
      }
      return Promise.reject(error);
    }

    // ==========================================
    // OTHER ERRORS (4xx, 5xx)
    // ==========================================
    if (status >= 400) {
      console.error('HTTP error:', status, errorData);
      if (showErrorToast) {
        toast.error('Request failed', {
          description: errorMessage || `An error occurred (${status})`,
        });
      }
    }

    return Promise.reject(error);
  }
);

export default axiosInstance;

```

### `apps\frontend\src\lib\query-client.ts`

```typescript
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

```

### `apps\frontend\src\lib\toast-utils.ts`

```typescript
import { toast as sonnerToast, ExternalToast } from 'sonner';

// Track active toasts to prevent duplicates
const activeToasts = new Map<string, number>();
const DEBOUNCE_TIME = 300;

const generateToastKey = (message: string, description?: string): string => {
  const descStr = description ? String(description) : '';
  return `${message}-${descStr}`;
};

const isToastActive = (key: string): boolean => {
  const timestamp = activeToasts.get(key);
  if (!timestamp) return false;

  const now = Date.now();
  const isActive = now - timestamp < DEBOUNCE_TIME;

  if (!isActive) {
    activeToasts.delete(key);
  }

  return isActive;
};

const markToastActive = (key: string): void => {
  activeToasts.set(key, Date.now());
  setTimeout(() => {
    activeToasts.delete(key);
  }, DEBOUNCE_TIME + 100);
};

// Wrapper functions
export function success(message: string, data?: ExternalToast) {
  const description = data?.description ? String(data.description) : undefined;
  const key = generateToastKey(message, description);
  if (isToastActive(key)) return;

  markToastActive(key);
  return sonnerToast.success(message, data);
}

export function error(message: string, data?: ExternalToast) {
  const description = data?.description ? String(data.description) : undefined;
  const key = generateToastKey(message, description);
  if (isToastActive(key)) return;

  markToastActive(key);
  return sonnerToast.error(message, data);
}

export function info(message: string, data?: ExternalToast) {
  const description = data?.description ? String(data.description) : undefined;
  const key = generateToastKey(message, description);
  if (isToastActive(key)) return;

  markToastActive(key);
  return sonnerToast.info(message, data);
}

export function warning(message: string, data?: ExternalToast) {
  const description = data?.description ? String(data.description) : undefined;
  const key = generateToastKey(message, description);
  if (isToastActive(key)) return;

  markToastActive(key);
  return sonnerToast.warning(message, data);
}

export function loading(message: string, data?: ExternalToast) {
  const description = data?.description ? String(data.description) : undefined;
  const key = generateToastKey(message, description);
  if (isToastActive(key)) return;

  markToastActive(key);
  return sonnerToast.loading(message, data);
}

// âœ… Use wrapper function instead of direct export
export function promise<T>(promiseToRun: Promise<T> | (() => Promise<T>), data?: any) {
  return sonnerToast.promise(promiseToRun, data);
}

// Direct exports for other methods
export const custom = sonnerToast.custom;
export const dismiss = sonnerToast.dismiss;
export const message = sonnerToast.message;

// Default export as object
export const toast = {
  success,
  error,
  info,
  warning,
  loading,
  promise,
  custom,
  dismiss,
  message,
};

export default toast;

```

### `apps\frontend\src\lib\utils.ts`

```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

### `apps\frontend\src\main.tsx`

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import { QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { Toaster } from 'sonner';
import { ThemeProvider } from './components/shared/theme/theme-provider';
import { queryClient } from './lib/query-client';
import { router } from './router';
import './index.css';
import { BreadcrumbProvider } from './context/breadcrumb-context';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider defaultTheme="dark">
      <BreadcrumbProvider>
        <QueryClientProvider client={queryClient}>
          <RouterProvider router={router} />
          <Toaster position="top-right" richColors closeButton />
          <ReactQueryDevtools />
        </QueryClientProvider>
      </BreadcrumbProvider>
    </ThemeProvider>
  </React.StrictMode>
);

```

### `apps\frontend\src\pages\auth\callback.tsx`

```typescript
import { useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { toast } from '@/lib/toast-utils';
import { setAuthTokens, setDeviceName } from '@/utils/token-utils';
import { useAuth } from '@/hooks/use-auth';
import { Loader2 } from 'lucide-react';

export default function AuthCallbackPage() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { setUser } = useAuth();

  useEffect(() => {
    const handleCallback = async () => {
      const accessToken = searchParams.get('accessToken');
      const refreshToken = searchParams.get('refreshToken');
      const userId = searchParams.get('userId');
      const deviceId = searchParams.get('deviceId');
      const deviceName = searchParams.get('deviceName');
      const error = searchParams.get('error');

      if (error) {
        toast.error(`Authentication failed: ${error}`);
        navigate('/auth/login');
        return;
      }

      if (!accessToken || !refreshToken || !userId || !deviceId) {
        toast.error('Invalid authentication response');
        navigate('/auth/login');
        return;
      }

      try {
        // Save tokens to encrypted cookies
        setAuthTokens({
          accessToken,
          refreshToken,
          deviceId,
        });

        // Save device name if provided
        if (deviceName) {
          setDeviceName(deviceName);
        }

        // Fetch user data
        const { axiosInstance } = await import('@/lib/axios-instance');
        const response = await axiosInstance.get('/users/me');

        setUser(response.data.data);

        toast.success('Logged in successfully!');
        navigate('/dashboard');
      } catch (error) {
        console.error('OAuth callback error:', error);
        toast.error('Failed to complete authentication');
        navigate('/auth/login');
      }
    };

    handleCallback();
  }, [searchParams, navigate, setUser]);

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <Loader2 className="text-primary mx-auto h-8 w-8 animate-spin" />
        <p className="text-muted-foreground mt-4 text-sm">Completing sign in...</p>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\auth\components\login-form.tsx`

```typescript
import { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { cn } from '@/lib/utils';
import { useAuth } from '@/hooks/use-auth';
import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Github, Mail, Loader2 } from 'lucide-react';
import { toast } from '@/lib/toast-utils';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api/v1';

export function LoginForm({ className, ...props }: React.ComponentProps<'div'>) {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleEmailLogin = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!email || !password) {
      toast.error('Please fill in all fields');
      return;
    }

    setLoading(true);
    try {
      await login({ email, password });
      toast.success('Welcome back!');
      navigate('/dashboard');
    } catch (error: any) {
      console.error('Login error:', error);
      const message = error.response?.data?.message || 'Login failed';
      toast.error(message);
    } finally {
      setLoading(false);
    }
  };

  const handleGithubLogin = () => {
    window.location.href = `${API_URL}/auth/github`;
  };

  const handleGoogleLogin = () => {
    window.location.href = `${API_URL}/auth/google`;
  };

  return (
    <Card className={cn('w-full max-w-sm', className)} {...props}>
      <CardHeader className="space-y-1 text-center">
        <CardTitle className="text-2xl font-bold">Welcome Back</CardTitle>
        <CardDescription>Sign in or create an account to continue.</CardDescription>
      </CardHeader>

      <CardContent className="grid gap-4">
        {/* Social Login Buttons */}
        <div className="grid grid-cols-2 gap-4">
          <Button
            variant="outline"
            className="flex items-center gap-2"
            onClick={handleGithubLogin}
            type="button"
            disabled={loading}
          >
            <Github className="h-4 w-4" />
            GitHub
          </Button>
          <Button
            variant="outline"
            className="flex items-center gap-2"
            onClick={handleGoogleLogin}
            type="button"
            disabled={loading}
          >
            <svg
              className="h-4 w-4"
              viewBox="0 0 30 30"
              aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                fill="currentColor"
                d="M 15.003906 3 C 8.3749062 3 3 8.373 3 15 C 3 21.627 8.3749062 27 15.003906 27 C 25.013906 27 27.269078 17.707 26.330078 13 L 25 13 L 22.732422 13 L 15 13 L 15 17 L 22.738281 17 C 21.848702 20.448251 18.725955 23 15 23 C 10.582 23 7 19.418 7 15 C 7 10.582 10.582 7 15 7 C 17.009 7 18.839141 7.74575 20.244141 8.96875 L 23.085938 6.1289062 C 20.951937 4.1849063 18.116906 3 15.003906 3 z"
              />
            </svg>
            Google
          </Button>
        </div>

        {/* Separator */}
        <div className="relative">
          <Separator />
          <span className="bg-card text-muted-foreground absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 px-2 text-xs">
            OR
          </span>
        </div>

        {/* Email/Password Form */}
        <form onSubmit={handleEmailLogin} className="grid gap-4">
          <div className="grid gap-2">
            <Label htmlFor="email">Email Address</Label>
            <Input
              id="email"
              type="email"
              placeholder="you@example.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              disabled={loading}
            />
          </div>

          <div className="grid gap-2">
            <div className="flex items-center justify-between">
              <Label htmlFor="password">Password</Label>
              <Link
                to="/auth/forgot-password"
                className="text-primary text-sm font-medium hover:underline"
              >
                Forgot Password?
              </Link>
            </div>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              disabled={loading}
            />
          </div>

          <Button type="submit" className="mt-2 w-full" disabled={loading}>
            {loading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Signing in...
              </>
            ) : (
              <>
                <Mail className="mr-2 h-4 w-4" />
                Login with Email
              </>
            )}
          </Button>
        </form>
      </CardContent>

      <CardFooter className="justify-center">
        <p className="text-muted-foreground text-sm">
          Don&apos;t have an account?{' '}
          <Link to="/auth/register" className="text-primary font-medium hover:underline">
            Sign up
          </Link>
        </p>
      </CardFooter>
    </Card>
  );
}

export default LoginForm;

```

### `apps\frontend\src\pages\auth\components\register-form.tsx`

```typescript
import { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { cn } from '@/lib/utils';
import { useAuth } from '@/hooks/use-auth';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Github, Loader2 } from 'lucide-react';
import { toast } from '@/lib/toast-utils';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api/v1';

export function RegisterForm({ className, ...props }: React.ComponentProps<'div'>) {
  const { register } = useAuth();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData((prev) => ({
      ...prev,
      [e.target.id]: e.target.value,
    }));
  };

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name || !formData.email || !formData.password || !formData.confirmPassword) {
      toast.error('Please fill in all fields');
      return;
    }

    if (formData.password !== formData.confirmPassword) {
      toast.error('Passwords do not match');
      return;
    }

    if (formData.password.length < 8) {
      toast.error('Password must be at least 8 characters');
      return;
    }

    setLoading(true);
    try {
      // Pass name, email, and password
      await register({
        name: formData.name,
        email: formData.email,
        password: formData.password,
      });
      toast.success('Account created successfully!');
      navigate('/dashboard');
    } catch (error: any) {
      console.error('Register error:', error);
      const message = error.response?.data?.message || 'Registration failed';
      toast.error(message);
    } finally {
      setLoading(false);
    }
  };

  const handleGithubSignup = () => {
    window.location.href = `${API_URL}/auth/github`;
  };

  const handleGoogleSignup = () => {
    window.location.href = `${API_URL}/auth/google`;
  };

  return (
    <Card className={cn('w-full max-w-md', className)} {...props}>
      <CardHeader>
        <CardTitle className="text-2xl">Create an account</CardTitle>
        <CardDescription>Enter your information below to create your account</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleRegister} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="name">Full Name</Label>
            <Input
              id="name"
              type="text"
              placeholder="John Doe"
              value={formData.name}
              onChange={handleChange}
              required
              disabled={loading}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              placeholder="m@example.com"
              value={formData.email}
              onChange={handleChange}
              required
              disabled={loading}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={formData.password}
              onChange={handleChange}
              required
              disabled={loading}
            />
            <p className="text-muted-foreground text-xs">Must be at least 8 characters long.</p>
          </div>

          <div className="space-y-2">
            <Label htmlFor="confirmPassword">Confirm Password</Label>
            <Input
              id="confirmPassword"
              type="password"
              value={formData.confirmPassword}
              onChange={handleChange}
              required
              disabled={loading}
            />
            <p className="text-muted-foreground text-xs">Please confirm your password.</p>
          </div>

          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Creating account...
              </>
            ) : (
              'Create Account'
            )}
          </Button>

          <div className="relative">
            <Separator />
            <span className="bg-card text-muted-foreground absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 px-2 text-xs">
              OR
            </span>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <Button variant="outline" type="button" onClick={handleGoogleSignup} disabled={loading}>
              <svg
                className="mr-2 h-4 w-4"
                viewBox="0 0 30 30"
                fill="currentColor"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path d="M 15.003906 3 C 8.3749062 3 3 8.373 3 15 C 3 21.627 8.3749062 27 15.003906 27 C 25.013906 27 27.269078 17.707 26.330078 13 L 25 13 L 22.732422 13 L 15 13 L 15 17 L 22.738281 17 C 21.848702 20.448251 18.725955 23 15 23 C 10.582 23 7 19.418 7 15 C 7 10.582 10.582 7 15 7 C 17.009 7 18.839141 7.74575 20.244141 8.96875 L 23.085938 6.1289062 C 20.951937 4.1849063 18.116906 3 15.003906 3 z" />
              </svg>
              Google
            </Button>
            <Button variant="outline" type="button" onClick={handleGithubSignup} disabled={loading}>
              <Github className="mr-2 h-4 w-4" />
              GitHub
            </Button>
          </div>

          <p className="text-muted-foreground px-6 text-center text-sm">
            Already have an account?{' '}
            <Link to="/auth/login" className="text-primary font-medium hover:underline">
              Sign in
            </Link>
          </p>
        </form>
      </CardContent>
    </Card>
  );
}

export default RegisterForm;

```

### `apps\frontend\src\pages\auth\login.tsx`

```typescript
import { LoginForm } from './components/login-form';

export default function Page() {
  return (
    <div className="flex min-h-svh w-full items-center justify-center p-6 md:p-10">
      <div className="w-full max-w-sm">
        <LoginForm />
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\auth\register.tsx`

```typescript
import RegisterForm from './components/register-form';

export default function Page() {
  return (
    <div className="flex min-h-svh w-full items-center justify-center p-6 md:p-10">
      <div className="w-full max-w-sm">
        <RegisterForm />
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\canvas\canvas-background.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\edges\animated-edge.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\panels\config-panel\index.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\panels\execution-panel\execution-list-item.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\panels\execution-panel\index.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\panels\pod-library\index.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\panels\pod-library\pod-library-item.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\pod-components\pod-execution-indicator.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\pod-components\pod-handle.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\pod-components\pod-header.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\pods\base-pod-node.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\pods\llm-pod-node.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\pods\source-pod-node.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\components\toolbar\save-toolbar.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\context\canvas-context.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\context\models-context.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\hooks\use-executions.ts`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\hooks\use-flow-socket.ts`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\hooks\use-pods.ts`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\index.tsx`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\[id]\types\index.ts`

```typescript
// Error reading file
```

### `apps\frontend\src\pages\dashboard\flows\components\create-flow-dialog.tsx`

```typescript
// File: apps/frontend/src/pages/dashboard/flows/components/create-flow-dialog.tsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { useFlows } from '../hooks/use-flows';
import { FlowVisibility } from '../types';

interface CreateFlowDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function CreateFlowDialog({ open, onOpenChange }: CreateFlowDialogProps) {
  const navigate = useNavigate();
  const { createFlow } = useFlows();
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    visibility: FlowVisibility.PRIVATE,
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim()) {
      return; // âœ… Guard clause
    }

    setIsLoading(true);

    try {
      const flow = await createFlow(formData);

      if (flow) {
        onOpenChange(false);
        setFormData({ name: '', description: '', visibility: FlowVisibility.PRIVATE });
        navigate(`/dashboard/flows/${flow.id}`);
      }
    } catch (error) {
      console.error('Failed to create flow:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent
        className="sm:max-w-[500px]"
        onPointerDownOutside={(e) => {
          // âœ… Prevent closing when clicking outside
          if (isLoading) e.preventDefault();
        }}
      >
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Flow</DialogTitle>
            <DialogDescription>Create a new AI workflow canvas to start building</DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="name">Name *</Label>
              <Input
                id="name"
                placeholder="My AI Workflow"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                disabled={isLoading}
                required
                autoFocus
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                placeholder="Describe what this workflow does..."
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                disabled={isLoading}
                rows={3}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="visibility">Visibility</Label>
              <Select
                value={formData.visibility}
                onValueChange={(value) =>
                  setFormData({ ...formData, visibility: value as FlowVisibility })
                }
                disabled={isLoading}
              >
                <SelectTrigger id="visibility">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={FlowVisibility.PRIVATE}>Private</SelectItem>
                  <SelectItem value={FlowVisibility.WORKSPACE}>Workspace</SelectItem>
                  <SelectItem value={FlowVisibility.PUBLIC}>Public</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          <DialogFooter>
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading || !formData.name.trim()}>
              {isLoading ? 'Creating...' : 'Create Flow'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

```

### `apps\frontend\src\pages\dashboard\flows\hooks\use-flow.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { axiosInstance } from '@/lib/axios-instance';
import { toast } from '@/lib/toast-utils';
import { useWorkspaces } from '@/hooks/use-workspaces';
import { Flow, ApiResponse } from '../types';

export function useFlow(flowId: string | undefined) {
  const { currentWorkspace } = useWorkspaces();
  const [flow, setFlow] = useState<Flow | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const fetchFlow = useCallback(async () => {
    if (!currentWorkspace?.id || !flowId) return;

    try {
      setIsLoading(true);
      const response = await axiosInstance.get<ApiResponse<Flow>>(
        `/workspaces/${currentWorkspace.id}/flows/${flowId}`
      );

      setFlow(response.data.data);
    } catch (error) {
      console.error('Failed to fetch flow:', error);
      toast.error('Failed to load flow');
    } finally {
      setIsLoading(false);
    }
  }, [currentWorkspace?.id, flowId]);

  useEffect(() => {
    fetchFlow();
  }, [fetchFlow]);

  return {
    flow,
    isLoading,
    refetch: fetchFlow,
  };
}

```

### `apps\frontend\src\pages\dashboard\flows\hooks\use-flows.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { axiosInstance } from '@/lib/axios-instance';
import { toast } from '@/lib/toast-utils';
import { useWorkspaces } from '@/hooks/use-workspaces';
import { Flow, FlowVisibility } from '../types';

interface UseFlowsOptions {
  page?: number;
  limit?: number;
  search?: string;
  visibility?: FlowVisibility;
  spaceId?: string;
}

// âœ… Match your backend's interceptor structure
interface BackendResponse<T> {
  statusCode: number;
  message: string;
  data: T;
  errors?: string[];
  timestamp: string;
  pagination?: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
  };
}

export function useFlows(options: UseFlowsOptions = {}) {
  const { currentWorkspace } = useWorkspaces();
  const [flows, setFlows] = useState<Flow[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [pagination, setPagination] = useState({
    totalItems: 0,
    totalPages: 0,
    currentPage: 1,
    pageSize: 0,
  });

  const fetchFlows = useCallback(async () => {
    if (!currentWorkspace?.id) return;

    try {
      setIsLoading(true);
      const response = await axiosInstance.get<BackendResponse<Flow[]>>(
        `/workspaces/${currentWorkspace.id}/flows`,
        {
          params: {
            page: options.page || 1,
            limit: options.limit || 20,
            search: options.search,
            visibility: options.visibility,
            spaceId: options.spaceId,
          },
        }
      );

      // âœ… Your interceptor returns: { statusCode, message, data: [], pagination: {}, errors, timestamp }
      setFlows(response.data.data || []);
      setPagination(
        response.data.pagination || {
          totalItems: 0,
          totalPages: 0,
          currentPage: 1,
          pageSize: 0,
        }
      );
    } catch (error) {
      console.error('Failed to fetch flows:', error);
      toast.error('Failed to load flows');
      setFlows([]);
    } finally {
      setIsLoading(false);
    }
  }, [
    currentWorkspace?.id,
    options.page,
    options.limit,
    options.search,
    options.visibility,
    options.spaceId,
  ]);

  useEffect(() => {
    fetchFlows();
  }, [fetchFlows]);

  const createFlow = useCallback(
    async (data: {
      name: string;
      description?: string;
      visibility?: FlowVisibility;
      spaceId?: string;
    }) => {
      if (!currentWorkspace?.id) return null;

      try {
        const response = await axiosInstance.post<BackendResponse<Flow>>(
          `/workspaces/${currentWorkspace.id}/flows`,
          data
        );

        const newFlow = response.data.data;
        setFlows((prev) => [newFlow, ...prev]);
        toast.success('Flow created successfully');
        return newFlow;
      } catch (error) {
        console.error('Failed to create flow:', error);
        toast.error('Failed to create flow');
        return null;
      }
    },
    [currentWorkspace?.id]
  );

  const updateFlow = useCallback(
    async (
      flowId: string,
      data: { name?: string; description?: string; visibility?: FlowVisibility; spaceId?: string }
    ) => {
      if (!currentWorkspace?.id) return null;

      try {
        const response = await axiosInstance.patch<BackendResponse<Flow>>(
          `/workspaces/${currentWorkspace.id}/flows/${flowId}`,
          data
        );

        const updatedFlow = response.data.data;
        setFlows((prev) => prev.map((f) => (f.id === flowId ? updatedFlow : f)));
        toast.success('Flow updated successfully');
        return updatedFlow;
      } catch (error) {
        console.error('Failed to update flow:', error);
        toast.error('Failed to update flow');
        return null;
      }
    },
    [currentWorkspace?.id]
  );

  const deleteFlow = useCallback(
    async (flowId: string) => {
      if (!currentWorkspace?.id) return false;

      try {
        await axiosInstance.delete(`/workspaces/${currentWorkspace.id}/flows/${flowId}`);
        setFlows((prev) => prev.filter((f) => f.id !== flowId));
        toast.success('Flow deleted successfully');
        return true;
      } catch (error) {
        console.error('Failed to delete flow:', error);
        toast.error('Failed to delete flow');
        return false;
      }
    },
    [currentWorkspace?.id]
  );

  return {
    flows,
    isLoading,
    pagination,
    fetchFlows,
    createFlow,
    updateFlow,
    deleteFlow,
  };
}

```

### `apps\frontend\src\pages\dashboard\flows\index.tsx`

```typescript
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Plus,
  Search,
  MoreVertical,
  Edit,
  Trash2,
  Copy,
  Eye,
  Users,
  Grid3x3,
  Workflow,
} from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { useFlows } from './hooks/use-flows';
import { CreateFlowDialog } from './components/create-flow-dialog';

export default function FlowsPage() {
  const navigate = useNavigate();
  const [search, setSearch] = useState('');
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const { flows, isLoading, deleteFlow } = useFlows({ search });

  const handleDeleteFlow = async (flowId: string) => {
    if (confirm('Are you sure you want to delete this flow? This action cannot be undone.')) {
      await deleteFlow(flowId);
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Flows</h1>
          <p className="text-muted-foreground">Create and manage AI-powered workflows</p>
        </div>
        <Button onClick={() => setCreateDialogOpen(true)}>
          <Plus className="mr-2 h-4 w-4" />
          New Flow
        </Button>
      </div>

      {/* Search Bar */}
      <div className="flex items-center gap-4">
        <div className="relative flex-1">
          <Search className="text-muted-foreground absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2" />
          <Input
            placeholder="Search flows..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="pl-9"
          />
        </div>
      </div>

      {/* Flows Grid */}
      {isLoading ? (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 6 }).map((_, i) => (
            <Card key={i}>
              <CardHeader>
                <Skeleton className="h-4 w-3/4" />
                <Skeleton className="h-3 w-full" />
              </CardHeader>
              <CardContent>
                <Skeleton className="h-20 w-full" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : flows.length === 0 ? (
        <Card className="flex flex-col items-center justify-center py-12">
          <Workflow className="text-muted-foreground mb-4 h-12 w-12" />
          <h3 className="mb-2 text-lg font-semibold">No flows yet</h3>
          <p className="text-muted-foreground mb-4 text-center text-sm">
            Create your first AI workflow to get started
          </p>
          <Button onClick={() => setCreateDialogOpen(true)}>
            <Plus className="mr-2 h-4 w-4" />
            Create Flow
          </Button>
        </Card>
      ) : (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {flows.map((flow) => (
            <Card
              key={flow.id}
              className="group cursor-pointer transition-all hover:shadow-lg"
              onClick={() => navigate(`/dashboard/flows/${flow.id}`)}
            >
              <CardHeader>
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <CardTitle className="line-clamp-1">{flow.name}</CardTitle>
                    <CardDescription className="line-clamp-2">
                      {flow.description || 'No description'}
                    </CardDescription>
                  </div>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="opacity-0 group-hover:opacity-100"
                      >
                        <MoreVertical className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem
                        onClick={(e) => {
                          e.stopPropagation();
                          navigate(`/dashboard/flows/${flow.id}`);
                        }}
                      >
                        <Edit className="mr-2 h-4 w-4" />
                        Edit
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={(e) => e.stopPropagation()}>
                        <Copy className="mr-2 h-4 w-4" />
                        Duplicate
                      </DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <DropdownMenuItem
                        className="text-destructive"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleDeleteFlow(flow.id);
                        }}
                      >
                        <Trash2 className="mr-2 h-4 w-4" />
                        Delete
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </CardHeader>
              <CardContent>
                <div className="text-muted-foreground flex items-center gap-4 text-sm">
                  <div className="flex items-center gap-1">
                    <Grid3x3 className="h-4 w-4" />
                    <span>{flow.podCount || 0} pods</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <Users className="h-4 w-4" />
                    <span>{flow.collaboratorCount || 0}</span>
                  </div>
                </div>
              </CardContent>
              <CardFooter className="flex items-center justify-between">
                <Badge variant={flow.visibility === 'PRIVATE' ? 'secondary' : 'default'}>
                  <Eye className="mr-1 h-3 w-3" />
                  {flow.visibility}
                </Badge>
                <span className="text-muted-foreground text-xs">
                  {formatDistanceToNow(new Date(flow.updatedAt), { addSuffix: true })}
                </span>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}

      <CreateFlowDialog open={createDialogOpen} onOpenChange={setCreateDialogOpen} />
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\flows\types\index.ts`

```typescript
export enum FlowVisibility {
  PRIVATE = 'PRIVATE',
  WORKSPACE = 'WORKSPACE',
  PUBLIC = 'PUBLIC',
}

export interface Flow {
  id: string;
  workspaceId: string;
  spaceId: string | null;
  name: string;
  description: string | null;
  version: number;
  visibility: FlowVisibility;
  createdBy: string;
  thumbnailS3Key: string | null;
  thumbnailGeneratedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  podCount?: number;
  collaboratorCount?: number;
}

export interface FlowPagination {
  totalItems: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
}

export interface FlowsResponse {
  data: Flow[];
  pagination: FlowPagination;
}

// âœ… Backend response wrapper
export interface ApiResponse<T> {
  statusCode: number;
  message: string;
  data: T;
  timestamp: string;
}

```

### `apps\frontend\src\pages\dashboard\index.tsx`

```typescript
import { useAuth } from '@/hooks/use-auth';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

export default function DashboardPage() {
  const { user } = useAuth();

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Welcome back, {user?.name || user?.email}!</h1>
        <p className="text-muted-foreground">
          Here&apos;s what&apos;s happening with your workspace
        </p>
      </div>

      <div className="grid gap-4 md:grid-cols-3">
        <Card>
          <CardHeader>
            <CardTitle>Profile</CardTitle>
            <CardDescription>Your account information</CardDescription>
          </CardHeader>
          <CardContent className="space-y-2">
            <div>
              <p className="text-sm font-medium">Email</p>
              <p className="text-muted-foreground text-sm">{user?.email}</p>
            </div>
            <div>
              <p className="text-sm font-medium">Name</p>
              <p className="text-muted-foreground text-sm">{user?.name || 'Not set'}</p>
            </div>
            <div>
              <p className="text-sm font-medium">Member since</p>
              <p className="text-muted-foreground text-sm">
                {user?.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A'}
              </p>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Workspaces</CardTitle>
            <CardDescription>Your active workspaces</CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-2xl font-bold">0</p>
            <p className="text-muted-foreground text-sm">No workspaces yet</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Canvases</CardTitle>
            <CardDescription>Your AI workflows</CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-2xl font-bold">0</p>
            <p className="text-muted-foreground text-sm">No canvases yet</p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\add-api-key-dialog.tsx`

```typescript
import { useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Loader2, Eye, EyeOff } from 'lucide-react';
import { useWorkspaceApiKeys } from '../hooks/use-workspace-api-keys';
import { AddApiKeyDto } from '../types/settings.types';

interface AddApiKeyDialogProps {
  workspaceId: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void; // âœ… Add this
}

const LLM_PROVIDERS = [
  { value: 'OPENAI', label: 'OpenAI' },
  { value: 'ANTHROPIC', label: 'Anthropic' },
  { value: 'GOOGLE_GEMINI', label: 'Google Gemini' },
  { value: 'PERPLEXITY', label: 'Perplexity' },
  { value: 'MISTRAL', label: 'Mistral' },
  { value: 'COHERE', label: 'Cohere' },
  { value: 'GROQ', label: 'Groq' },
  { value: 'XAI', label: 'xAI (Grok)' },
  { value: 'DEEPSEEK', label: 'DeepSeek' },
  { value: 'CUSTOM', label: 'Custom' },
];

const DEFAULT_FORM_DATA = {
  provider: 'OPENAI',
  displayName: '',
  apiKey: '',
};

export function AddApiKeyDialog({
  workspaceId,
  open,
  onOpenChange,
  onSuccess, // âœ… Add this
}: AddApiKeyDialogProps) {
  const { addApiKey } = useWorkspaceApiKeys(workspaceId);
  const [isLoading, setIsLoading] = useState(false);
  const [showApiKey, setShowApiKey] = useState(false);
  const [formData, setFormData] = useState<AddApiKeyDto>(DEFAULT_FORM_DATA);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      await addApiKey(formData);
      onOpenChange(false);
      setFormData(DEFAULT_FORM_DATA);
      setShowApiKey(false);
      onSuccess?.(); // âœ… Call onSuccess to refresh data
    } catch {
      // Error handled in hook
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Add API Key</DialogTitle>
            <DialogDescription>Connect an LLM provider to use in your workflows</DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="provider">Provider *</Label>
              <Select
                value={formData.provider}
                onValueChange={(value) => setFormData({ ...formData, provider: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {LLM_PROVIDERS.map((provider) => (
                    <SelectItem key={provider.value} value={provider.value}>
                      {provider.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="displayName">Display Name *</Label>
              <Input
                id="displayName"
                placeholder="e.g., Production Key, Development Key"
                value={formData.displayName}
                onChange={(e) => setFormData({ ...formData, displayName: e.target.value })}
                required
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="apiKey">API Key *</Label>
              <div className="relative">
                <Input
                  id="apiKey"
                  type={showApiKey ? 'text' : 'password'}
                  placeholder="sk-..."
                  value={formData.apiKey}
                  onChange={(e) => setFormData({ ...formData, apiKey: e.target.value })}
                  required
                  className="pr-10"
                />
                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  className="absolute top-0 right-0 h-full"
                  onClick={() => setShowApiKey(!showApiKey)}
                >
                  {showApiKey ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </Button>
              </div>
              <p className="text-muted-foreground text-xs">
                Your API key will be encrypted and stored securely
              </p>
            </div>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Add API Key
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\api-keys-settings.tsx`

```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Key, Trash2, Plus, Zap, Clock, DollarSign, Activity } from 'lucide-react';
import { useWorkspaceApiKeys } from '../hooks/use-workspace-api-keys';
import { Skeleton } from '@/components/ui/skeleton';
import { AddApiKeyDialog } from './add-api-key-dialog';
import { toast } from '@/lib/toast-utils';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';

export function ApiKeysSettings({ workspaceId }: { workspaceId: string }) {
  const { apiKeys, stats, isLoading, deleteApiKey, refetch } = useWorkspaceApiKeys(workspaceId);
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [deleteId, setDeleteId] = useState<string | null>(null);

  const handleDelete = async () => {
    if (!deleteId) return;

    try {
      await deleteApiKey(deleteId);
      toast.success('API key deleted');
    } catch {
      // Error handled in hook
    }
    setDeleteId(null);
  };

  const handleAddSuccess = () => {
    setIsAddDialogOpen(false);
    refetch(); // âœ… Refresh data after adding
  };

  if (isLoading) {
    return (
      <div className="space-y-8">
        <Skeleton className="h-6 w-48" />
        <Skeleton className="h-4 w-64" />
        <Separator />
        <div className="space-y-4">
          {[1, 2].map((i) => (
            <Skeleton key={i} className="h-28 w-full" />
          ))}
        </div>
      </div>
    );
  }

  const apiKeysList = Array.isArray(apiKeys) ? apiKeys : [];

  return (
    <>
      <div className="space-y-8">
        {/* Header with Stats */}
        <div className="flex items-start justify-between">
          <div>
            <h3 className="text-lg font-semibold">API Keys</h3>
            <p className="text-muted-foreground mt-1 text-sm">
              Manage your LLM provider API keys ({apiKeysList.length}{' '}
              {apiKeysList.length === 1 ? 'key' : 'keys'})
            </p>

            {/* Usage Stats */}
            {stats && apiKeysList.length > 0 && (
              <div className="mt-4 flex flex-wrap gap-4">
                <div className="flex items-center gap-2 text-sm">
                  <Activity className="text-muted-foreground h-4 w-4" />
                  <span className="text-muted-foreground">Total Usage:</span>
                  <span className="font-semibold">{stats.totalUsageCount.toLocaleString()}</span>
                </div>
                <div className="flex items-center gap-2 text-sm">
                  <DollarSign className="text-muted-foreground h-4 w-4" />
                  <span className="text-muted-foreground">Total Cost:</span>
                  <span className="font-semibold">${stats.totalCostIncurred.toFixed(2)}</span>
                </div>
                <div className="flex items-center gap-2 text-sm">
                  <Zap className="text-muted-foreground h-4 w-4" />
                  <span className="text-muted-foreground">Active:</span>
                  <span className="font-semibold">
                    {stats.activeKeys} / {stats.totalKeys}
                  </span>
                </div>
              </div>
            )}
          </div>
          <Button onClick={() => setIsAddDialogOpen(true)}>
            <Plus className="mr-2 h-4 w-4" />
            Add API Key
          </Button>
        </div>

        <Separator />

        {/* API Keys List or Empty State */}
        {apiKeysList.length === 0 ? (
          <div className="flex flex-col items-center justify-center rounded-lg border-2 border-dashed p-16 text-center">
            <div className="bg-muted rounded-full p-4">
              <Key className="text-muted-foreground h-10 w-10" />
            </div>
            <h3 className="mt-6 text-lg font-semibold">No API keys configured</h3>
            <p className="text-muted-foreground mt-2 max-w-sm text-sm">
              Connect LLM providers like OpenAI, Anthropic, or Google AI to power your workflows
            </p>
            <Button className="mt-6" onClick={() => setIsAddDialogOpen(true)}>
              <Plus className="mr-2 h-4 w-4" />
              Add Your First API Key
            </Button>
          </div>
        ) : (
          <div className="space-y-3">
            {apiKeysList.map((apiKey) => (
              <div
                key={apiKey.id}
                className="group bg-card hover:border-primary/50 flex items-start justify-between rounded-lg border p-4 transition-all hover:shadow-sm"
              >
                <div className="flex items-start gap-4">
                  <div className="from-primary/20 to-primary/10 rounded-full bg-gradient-to-br p-3">
                    <Zap className="text-primary h-5 w-5" />
                  </div>
                  <div className="flex-1 space-y-2">
                    {/* Title Row */}
                    <div className="flex items-center gap-2">
                      <p className="font-semibold">{apiKey.displayName || 'Unnamed Key'}</p>
                      <Badge
                        variant={apiKey.isActive ? 'default' : 'secondary'}
                        className="font-medium"
                      >
                        {apiKey.isActive ? 'Active' : 'Inactive'}
                      </Badge>
                    </div>

                    {/* Provider & Last Used */}
                    <div className="text-muted-foreground flex items-center gap-4 text-sm">
                      <span className="flex items-center gap-1">
                        <span className="font-medium">Provider:</span>{' '}
                        {apiKey.provider || 'Unknown'}
                      </span>
                      {apiKey.lastUsedAt ? (
                        <>
                          <span>â€¢</span>
                          <span className="flex items-center gap-1">
                            <Clock className="h-3 w-3" />
                            Last used:{' '}
                            {new Date(apiKey.lastUsedAt).toLocaleDateString('en-US', {
                              month: 'short',
                              day: 'numeric',
                              year: 'numeric',
                            })}
                          </span>
                        </>
                      ) : (
                        <>
                          <span>â€¢</span>
                          <span className="text-muted-foreground/60">Never used</span>
                        </>
                      )}
                    </div>

                    {/* Usage Stats */}
                    {apiKey.usageCount > 0 && (
                      <div className="text-muted-foreground flex items-center gap-4 text-xs">
                        <span className="flex items-center gap-1">
                          <Activity className="h-3 w-3" />
                          {apiKey.usageCount.toLocaleString()} uses
                        </span>
                        {apiKey.totalCost > 0 && (
                          <>
                            <span>â€¢</span>
                            <span className="flex items-center gap-1">
                              <DollarSign className="h-3 w-3" />${apiKey.totalCost.toFixed(2)}
                            </span>
                          </>
                        )}
                        {apiKey.totalTokens && (
                          <>
                            <span>â€¢</span>
                            <span>{parseInt(apiKey.totalTokens).toLocaleString()} tokens</span>
                          </>
                        )}
                      </div>
                    )}

                    {/* Creator Info */}
                    {apiKey.createdBy && (
                      <div className="text-muted-foreground text-xs">
                        Added by {apiKey.createdBy.name || apiKey.createdBy.email}
                      </div>
                    )}
                  </div>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setDeleteId(apiKey.id)}
                  className="text-destructive hover:bg-destructive/10 opacity-0 group-hover:opacity-100"
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete
                </Button>
              </div>
            ))}
          </div>
        )}
      </div>

      <AddApiKeyDialog
        workspaceId={workspaceId}
        open={isAddDialogOpen}
        onOpenChange={(open) => {
          if (!open) {
            setIsAddDialogOpen(false);
          }
        }}
        onSuccess={handleAddSuccess} // âœ… Pass success handler
      />

      <AlertDialog open={!!deleteId} onOpenChange={() => setDeleteId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete API Key</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this API key? This action cannot be undone and any
              workflows or flows using this key will stop working immediately.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleDelete} className="bg-destructive">
              Delete API Key
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\delete-workspace-dialog.tsx`

```typescript
import { useState } from 'react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Loader2 } from 'lucide-react';
import { toast } from '@/lib/toast-utils';
import axiosInstance from '@/lib/axios-instance';

interface DeleteWorkspaceDialogProps {
  workspace: any;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function DeleteWorkspaceDialog({
  workspace,
  open,
  onOpenChange,
}: DeleteWorkspaceDialogProps) {
  const [confirmText, setConfirmText] = useState('');
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    if (confirmText !== workspace.name) {
      toast.error('Workspace name does not match');
      return;
    }

    setIsDeleting(true);
    try {
      await axiosInstance.delete(`/workspaces/${workspace.id}`);
      toast.success('Workspace deleted successfully');
      setTimeout(() => {
        window.location.href = '/dashboard';
      }, 1000);
    } catch (error: any) {
      toast.error('Failed to delete workspace', {
        description: error.response?.data?.message || 'Please try again',
      });
      setIsDeleting(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete Workspace</AlertDialogTitle>
          <AlertDialogDescription className="space-y-3">
            <p>
              This action <strong>cannot be undone</strong>. This will permanently delete the
              workspace <strong>&quot;{workspace.name}&quot;</strong> and remove all associated data
              including:
            </p>
            <ul className="list-inside list-disc space-y-1">
              <li>All workspace members</li>
              <li>All flows and spaces</li>
              <li>All documents and sources</li>
              <li>All API keys and integrations</li>
            </ul>
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="space-y-2 py-4">
          <Label htmlFor="confirm">
            Type <strong>{workspace.name}</strong> to confirm
          </Label>
          <Input
            id="confirm"
            value={confirmText}
            onChange={(e) => setConfirmText(e.target.value)}
            placeholder={workspace.name}
          />
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={handleDelete}
            disabled={confirmText !== workspace.name || isDeleting}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isDeleting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Delete Workspace
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\general-settings.tsx`

```typescript
import { useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Trash2, Save, Loader2, Copy, Check, Calendar, Building2, AlertCircle } from 'lucide-react';
import { toast } from '@/lib/toast-utils';
import { axiosInstance } from '@/lib/axios-instance';
import { DeleteWorkspaceDialog } from './delete-workspace-dialog';
import { useWorkspaces } from '@/hooks/use-workspaces';

interface GeneralSettingsProps {
  workspace: any;
}

export function GeneralSettings({ workspace }: GeneralSettingsProps) {
  const { workspaces } = useWorkspaces();
  const [workspaceName, setWorkspaceName] = useState(workspace.name);
  const [isUpdating, setIsUpdating] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [copied, setCopied] = useState(false);

  // âœ… Handle both workspace list format (role) and workspace details format (currentUserRole)
  const userRole = workspace.currentUserRole || workspace.role;
  const isOwner = userRole === 'OWNER';

  const totalWorkspaces = Array.isArray(workspaces) ? workspaces.length : 0;
  const isLastWorkspace = totalWorkspaces <= 1;
  const canDelete = isOwner && workspace.type === 'TEAM' && !isLastWorkspace;

  const handleUpdateName = async () => {
    if (!workspaceName.trim()) {
      toast.error('Workspace name cannot be empty');
      return;
    }

    if (workspaceName === workspace.name) {
      toast.info('No changes to save');
      return;
    }

    setIsUpdating(true);
    try {
      await axiosInstance.patch(`/workspaces/${workspace.id}`, { name: workspaceName });
      toast.success('Workspace name updated');
      setTimeout(() => window.location.reload(), 1000);
    } catch (error: any) {
      toast.error('Failed to update workspace', {
        description: error.response?.data?.message || 'Please try again',
      });
    } finally {
      setIsUpdating(false);
    }
  };

  const copyWorkspaceId = () => {
    navigator.clipboard.writeText(workspace.id);
    setCopied(true);
    toast.success('Copied to clipboard');
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="space-y-8">
      {/* Header Section */}
      <div>
        <h3 className="text-lg font-semibold">General Settings</h3>
        <p className="text-muted-foreground mt-1 text-sm">
          Manage your workspace information and settings
        </p>
      </div>

      <Separator />

      {/* Workspace Name Section */}
      <div className="space-y-4">
        <div>
          <Label htmlFor="workspace-name" className="text-base font-medium">
            Workspace Name
          </Label>
          <p className="text-muted-foreground mt-0.5 text-sm">
            Update the display name for your workspace
          </p>
        </div>
        <div className="flex max-w-2xl gap-3">
          <Input
            id="workspace-name"
            value={workspaceName}
            onChange={(e) => setWorkspaceName(e.target.value)}
            placeholder="Enter workspace name"
            className="h-10"
            disabled={!isOwner}
          />
          <Button
            onClick={handleUpdateName}
            disabled={isUpdating || workspaceName === workspace.name || !isOwner}
            size="default"
          >
            {isUpdating ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Saving
              </>
            ) : (
              <>
                <Save className="mr-2 h-4 w-4" />
                Save
              </>
            )}
          </Button>
        </div>
        {!isOwner && (
          <Alert>
            <AlertCircle className="h-4 w-4" />
            <AlertDescription className="text-xs">
              Only workspace owners can update the workspace name
            </AlertDescription>
          </Alert>
        )}
      </div>

      <Separator />

      {/* Workspace Details Section */}
      <div className="space-y-6">
        <div>
          <h4 className="text-base font-medium">Workspace Details</h4>
          <p className="text-muted-foreground mt-0.5 text-sm">
            View information about your workspace
          </p>
        </div>

        <div className="grid gap-6 sm:grid-cols-2">
          {/* Workspace Type */}
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-sm font-medium">
              <Building2 className="text-muted-foreground h-4 w-4" />
              <span>Workspace Type</span>
            </div>
            <Badge
              variant={workspace.type === 'PERSONAL' ? 'default' : 'secondary'}
              className="text-xs"
            >
              {workspace.type}
            </Badge>
          </div>

          {/* Created Date */}
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-sm font-medium">
              <Calendar className="text-muted-foreground h-4 w-4" />
              <span>Created</span>
            </div>
            <p className="text-muted-foreground text-sm">
              {new Date(workspace.createdAt).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
              })}
            </p>
          </div>
        </div>

        {/* Workspace ID */}
        <div className="space-y-2">
          <Label className="text-sm font-medium">Workspace ID</Label>
          <div className="flex max-w-2xl items-center gap-2">
            <Input
              value={workspace.id}
              readOnly
              className="h-9 flex-1 font-mono text-xs"
              disabled
            />
            <Button variant="outline" size="sm" onClick={copyWorkspaceId} className="h-9 shrink-0">
              {copied ? <Check className="h-3.5 w-3.5" /> : <Copy className="h-3.5 w-3.5" />}
            </Button>
          </div>
          <p className="text-muted-foreground text-xs">Your unique workspace identifier</p>
        </div>
      </div>

      {/* âœ… DANGER ZONE - ONLY SHOWS FOR OWNER OF TEAM WORKSPACES */}
      {isOwner && workspace.type === 'TEAM' && (
        <>
          <Separator />
          <Card className="border-destructive/50 bg-destructive/5">
            <CardHeader className="pb-3">
              <CardTitle className="text-destructive text-base">Danger Zone</CardTitle>
              <CardDescription>
                Irreversible actions that will permanently affect your workspace
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="border-destructive/20 bg-background flex items-start justify-between rounded-lg border p-4">
                <div className="space-y-1">
                  <p className="text-sm font-medium">Delete this workspace</p>
                  <p className="text-muted-foreground text-sm">
                    {isLastWorkspace
                      ? 'Cannot delete your last workspace'
                      : 'Once deleted, all data will be permanently removed'}
                  </p>
                </div>
                <Button
                  variant="destructive"
                  size="sm"
                  onClick={() => setIsDeleteDialogOpen(true)}
                  disabled={!canDelete}
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete
                </Button>
              </div>

              {/* Last Workspace Warning */}
              {isLastWorkspace && (
                <Alert className="mt-4">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription className="text-xs">
                    You must have at least one workspace. Create another workspace before deleting
                    this one.
                  </AlertDescription>
                </Alert>
              )}
            </CardContent>
          </Card>
        </>
      )}

      {/* Personal Workspace Note */}
      {workspace.type === 'PERSONAL' && (
        <>
          <Separator />
          <Alert>
            <AlertCircle className="h-4 w-4" />
            <AlertDescription className="text-sm">
              Personal workspaces cannot be deleted. They are automatically managed for each user.
            </AlertDescription>
          </Alert>
        </>
      )}

      <DeleteWorkspaceDialog
        workspace={workspace}
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
      />
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\invitations-settings.tsx`

```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Mail, Trash2, Clock, CheckCircle2, XCircle, Copy, Check, UserPlus } from 'lucide-react';
import { useWorkspaceInvitations } from '../hooks/use-workspace-invitations';
import { Skeleton } from '@/components/ui/skeleton';
import { toast } from '@/lib/toast-utils';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { SendInvitationDialog } from './send-invitation-dialog';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

export function InvitationsSettings({ workspaceId }: { workspaceId: string }) {
  const { invitations, isLoading, revokeInvitation, refetch } =
    useWorkspaceInvitations(workspaceId);
  const [isInviteDialogOpen, setIsInviteDialogOpen] = useState(false);
  const [revokeId, setRevokeId] = useState<string | null>(null);
  const [copiedToken, setCopiedToken] = useState<string | null>(null);

  const handleRevoke = async () => {
    if (!revokeId) return;

    toast.promise(revokeInvitation(revokeId), {
      loading: 'Revoking invitation...',
      success: 'Invitation revoked',
      error: 'Failed to revoke invitation',
    });

    setRevokeId(null);
  };

  const handleSendSuccess = () => {
    setIsInviteDialogOpen(false);
    refetch(); // âœ… Refresh invitations list
  };

  const copyInvitationLink = (token: string) => {
    const inviteUrl = `${window.location.origin}/workspace/invite/${token}`;
    navigator.clipboard.writeText(inviteUrl);
    setCopiedToken(token);
    toast.success('Link copied');
    setTimeout(() => setCopiedToken(null), 2000);
  };

  const getStatusConfig = (status: string) => {
    switch (status) {
      case 'PENDING':
        return {
          variant: 'default' as const,
          icon: Clock,
          color: 'text-blue-600',
          label: 'Pending',
        };
      case 'ACCEPTED':
        return {
          variant: 'secondary' as const,
          icon: CheckCircle2,
          color: 'text-green-600',
          label: 'Accepted',
        };
      case 'EXPIRED':
        return {
          variant: 'destructive' as const,
          icon: XCircle,
          color: 'text-red-600',
          label: 'Expired',
        };
      case 'REVOKED':
        return {
          variant: 'outline' as const,
          icon: XCircle,
          color: 'text-gray-600',
          label: 'Revoked',
        };
      default:
        return {
          variant: 'secondary' as const,
          icon: null,
          color: 'text-gray-600',
          label: status,
        };
    }
  };

  const isExpired = (expiresAt: string) => {
    return new Date(expiresAt) < new Date();
  };

  if (isLoading) {
    return (
      <div className="space-y-8">
        <Skeleton className="h-6 w-48" />
        <Skeleton className="h-4 w-64" />
        <Separator />
        <div className="space-y-4">
          {[1, 2].map((i) => (
            <Skeleton key={i} className="h-32 w-full" />
          ))}
        </div>
      </div>
    );
  }

  const invitationsList = Array.isArray(invitations) ? invitations : [];
  const pendingInvitations = invitationsList.filter((inv) => inv.status === 'PENDING');

  const stats = {
    total: invitationsList.length,
    pending: pendingInvitations.length,
    accepted: invitationsList.filter((inv) => inv.status === 'ACCEPTED').length,
    expired: invitationsList.filter((inv) => inv.status === 'EXPIRED' || isExpired(inv.expiresAt))
      .length,
  };

  return (
    <div className="space-y-8">
      {/* Header with Stats */}
      <div className="flex items-start justify-between">
        <div>
          <h3 className="text-lg font-semibold">Workspace Invitations</h3>
          <p className="text-muted-foreground mt-1 text-sm">
            Send and manage workspace invitations
          </p>

          <div className="mt-3 flex items-center gap-4 text-sm">
            <div className="flex items-center gap-1.5">
              <Badge variant="default" className="h-5">
                {stats.pending}
              </Badge>
              <span className="text-muted-foreground">Pending</span>
            </div>
            <div className="flex items-center gap-1.5">
              <Badge variant="secondary" className="h-5">
                {stats.accepted}
              </Badge>
              <span className="text-muted-foreground">Accepted</span>
            </div>
            <div className="flex items-center gap-1.5">
              <Badge variant="outline" className="h-5">
                {stats.expired}
              </Badge>
              <span className="text-muted-foreground">Expired</span>
            </div>
          </div>
        </div>

        <Button onClick={() => setIsInviteDialogOpen(true)}>
          <UserPlus className="mr-2 h-4 w-4" />
          Send Invitation
        </Button>
      </div>

      <Separator />

      {/* Invitations List or Empty State */}
      {invitationsList.length === 0 ? (
        <div className="flex flex-col items-center justify-center rounded-lg border-2 border-dashed p-16 text-center">
          <div className="bg-muted rounded-full p-4">
            <Mail className="text-muted-foreground h-10 w-10" />
          </div>
          <h3 className="mt-6 text-lg font-semibold">No invitations sent</h3>
          <p className="text-muted-foreground mt-2 max-w-sm text-sm">
            Invite team members to join your workspace via email
          </p>
          <Button className="mt-6" onClick={() => setIsInviteDialogOpen(true)}>
            <UserPlus className="mr-2 h-4 w-4" />
            Send Your First Invitation
          </Button>
        </div>
      ) : (
        <div className="space-y-3">
          {invitationsList.map((invitation) => {
            const statusConfig = getStatusConfig(invitation.status);
            const expired = isExpired(invitation.expiresAt);
            const StatusIcon = statusConfig.icon;

            return (
              <div
                key={invitation.id}
                className="group bg-card hover:border-primary/50 flex items-start justify-between rounded-lg border p-4 transition-all hover:shadow-sm"
              >
                <div className="flex flex-1 items-start gap-3">
                  <div className="bg-muted rounded-full p-2.5">
                    <Mail className="text-muted-foreground h-4 w-4" />
                  </div>

                  <div className="flex-1 space-y-2">
                    {/* Email and Status */}
                    <div className="flex items-center gap-2">
                      <p className="font-semibold">{invitation.email}</p>
                      <Badge variant={statusConfig.variant} className="gap-1">
                        {StatusIcon && <StatusIcon className="h-3 w-3" />}
                        {statusConfig.label}
                      </Badge>
                    </div>

                    {/* Role and Permissions */}
                    <div className="text-muted-foreground flex flex-wrap items-center gap-2 text-sm">
                      <Badge variant="outline" className="font-normal">
                        {invitation.role}
                      </Badge>

                      {invitation.permissions && (
                        <>
                          {invitation.permissions.canManageMembers && (
                            <Badge variant="outline" className="font-normal">
                              Can manage members
                            </Badge>
                          )}
                          {invitation.permissions.canManageApiKeys && (
                            <Badge variant="outline" className="font-normal">
                              Can manage API keys
                            </Badge>
                          )}
                          {invitation.permissions.canCreateCanvas && (
                            <Badge variant="outline" className="font-normal">
                              Can create canvas
                            </Badge>
                          )}
                          {invitation.permissions.canDeleteCanvas && (
                            <Badge variant="outline" className="font-normal">
                              Can delete canvas
                            </Badge>
                          )}
                        </>
                      )}
                    </div>

                    {/* Dates */}
                    <div className="text-muted-foreground flex items-center gap-4 text-xs">
                      <span>
                        Sent{' '}
                        {new Date(invitation.createdAt).toLocaleDateString('en-US', {
                          month: 'short',
                          day: 'numeric',
                          year: 'numeric',
                        })}
                      </span>
                      <span>â€¢</span>
                      <span className={expired ? 'text-destructive' : ''}>
                        {expired ? 'Expired' : 'Expires'}{' '}
                        {new Date(invitation.expiresAt).toLocaleDateString('en-US', {
                          month: 'short',
                          day: 'numeric',
                          year: 'numeric',
                        })}
                      </span>
                    </div>
                  </div>
                </div>

                {/* Actions */}
                <div className="flex items-center gap-2">
                  {invitation.status === 'PENDING' && (
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => copyInvitationLink(invitation.token)}
                            className="h-8 w-8 opacity-0 group-hover:opacity-100"
                          >
                            {copiedToken === invitation.token ? (
                              <Check className="h-4 w-4 text-green-600" />
                            ) : (
                              <Copy className="h-4 w-4" />
                            )}
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>
                          <p>Copy invitation link</p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                  )}

                  {invitation.status === 'PENDING' && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setRevokeId(invitation.id)}
                      className="text-destructive hover:bg-destructive/10 opacity-0 group-hover:opacity-100"
                    >
                      <Trash2 className="mr-2 h-4 w-4" />
                      Revoke
                    </Button>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}

      <SendInvitationDialog
        workspaceId={workspaceId}
        open={isInviteDialogOpen}
        onOpenChange={(open) => {
          if (!open) {
            setIsInviteDialogOpen(false);
          }
        }}
        onSuccess={handleSendSuccess} // âœ… Pass success handler
      />

      <AlertDialog open={!!revokeId} onOpenChange={() => setRevokeId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Revoke Invitation</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to revoke this invitation? The recipient will no longer be able
              to use the invitation link to join the workspace.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleRevoke} className="bg-destructive">
              Revoke Invitation
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\members-settings.tsx`

```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Users, Trash2, Settings2, Mail } from 'lucide-react';
import { useWorkspaceMembers } from '../hooks/use-workspace-members';
import { Skeleton } from '@/components/ui/skeleton';
import { toast } from '@/lib/toast-utils';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { UpdateMemberDialog } from './update-member-dialog';

export function MembersSettings({ workspaceId }: { workspaceId: string }) {
  const { members, isLoading, removeMember, refetch } = useWorkspaceMembers(workspaceId);
  const [removeId, setRemoveId] = useState<string | null>(null);
  const [editMember, setEditMember] = useState<any | null>(null);

  const handleRemove = async () => {
    if (!removeId) return;

    toast.promise(removeMember(removeId), {
      loading: 'Removing member...',
      success: 'Member removed successfully',
      error: 'Failed to remove member',
    });

    setRemoveId(null);
  };

  const handleUpdateSuccess = () => {
    setEditMember(null);
    refetch();
  };

  const getRoleBadgeVariant = (role: string) => {
    switch (role) {
      case 'OWNER':
        return 'default' as const;
      case 'ADMIN':
        return 'secondary' as const;
      case 'MEMBER':
        return 'outline' as const;
      default:
        return 'outline' as const;
    }
  };

  const getInitials = (name?: string | null, email?: string | null) => {
    if (name) {
      return name
        .split(' ')
        .map((n) => n[0])
        .join('')
        .toUpperCase()
        .slice(0, 2);
    }
    if (email) {
      return email.slice(0, 2).toUpperCase();
    }
    return 'U';
  };

  if (isLoading) {
    return (
      <div className="space-y-8">
        <Skeleton className="h-6 w-48" />
        <Skeleton className="h-4 w-64" />
        <Separator />
        <div className="space-y-4">
          {[1, 2].map((i) => (
            <Skeleton key={i} className="h-24 w-full" />
          ))}
        </div>
      </div>
    );
  }

  const membersList = Array.isArray(members) ? members : [];

  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h3 className="text-lg font-semibold">Team Members</h3>
          <p className="text-muted-foreground mt-1 text-sm">
            Manage workspace members, their roles, and permissions
          </p>
          <p className="text-muted-foreground mt-2 flex items-center gap-2 text-sm">
            <Mail className="h-4 w-4" />
            <span>Use invitations to add new members to your workspace</span>
          </p>
        </div>
      </div>

      <Separator />

      {/* Members List */}
      {membersList.length === 0 ? (
        <div className="flex flex-col items-center justify-center rounded-lg border-2 border-dashed p-16 text-center">
          <div className="bg-muted rounded-full p-4">
            <Users className="text-muted-foreground h-10 w-10" />
          </div>
          <h3 className="mt-6 text-lg font-semibold">No members yet</h3>
          <p className="text-muted-foreground mt-2 max-w-sm text-sm">
            Send invitations to add team members to this workspace
          </p>
        </div>
      ) : (
        <div className="space-y-3">
          {membersList.map((member) => {
            const isOwner = member.role === 'OWNER';

            return (
              <div
                key={member.userId}
                className="group bg-card hover:border-primary/50 flex items-start justify-between rounded-lg border p-4 transition-all hover:shadow-sm"
              >
                <div className="flex flex-1 items-start gap-3">
                  {/* Avatar */}
                  <Avatar className="h-10 w-10">
                    <AvatarImage
                      src={member.user.image || undefined}
                      alt={member.user.name || member.user.email || 'User'}
                    />
                    <AvatarFallback className="bg-primary/10 text-primary">
                      {getInitials(member.user.name, member.user.email)}
                    </AvatarFallback>
                  </Avatar>

                  {/* Member Info */}
                  <div className="min-w-0 flex-1 space-y-2">
                    {/* Name & Email */}
                    <div>
                      <p className="font-semibold">{member.user.name || 'Unnamed User'}</p>
                      <p className="text-muted-foreground text-sm">{member.user.email}</p>
                    </div>

                    {/* Role & Permissions */}
                    <div className="flex flex-wrap items-center gap-2">
                      <Badge variant={getRoleBadgeVariant(member.role)} className="font-medium">
                        {member.role}
                      </Badge>

                      {member.canManageMembers && (
                        <Badge variant="outline" className="text-xs font-normal">
                          Can manage members
                        </Badge>
                      )}
                      {member.canManageApiKeys && (
                        <Badge variant="outline" className="text-xs font-normal">
                          Can manage API keys
                        </Badge>
                      )}
                      {member.canCreateCanvas && (
                        <Badge variant="outline" className="text-xs font-normal">
                          Can create canvas
                        </Badge>
                      )}
                      {member.canDeleteCanvas && (
                        <Badge variant="outline" className="text-xs font-normal">
                          Can delete canvas
                        </Badge>
                      )}
                    </div>

                    {/* Join Date */}
                    <p className="text-muted-foreground text-xs">
                      Joined{' '}
                      {new Date(member.joinedAt).toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric',
                      })}
                    </p>
                  </div>
                </div>

                {/* Actions */}
                {!isOwner && (
                  <div className="flex items-center gap-2">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setEditMember(member)}
                      className="opacity-0 group-hover:opacity-100"
                    >
                      <Settings2 className="mr-2 h-4 w-4" />
                      Edit
                    </Button>

                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setRemoveId(member.userId)}
                      className="text-destructive hover:bg-destructive/10 opacity-0 group-hover:opacity-100"
                    >
                      <Trash2 className="mr-2 h-4 w-4" />
                      Remove
                    </Button>
                  </div>
                )}

                {isOwner && (
                  <Badge variant="default" className="ml-4 shrink-0">
                    Owner
                  </Badge>
                )}
              </div>
            );
          })}
        </div>
      )}

      {/* Update Member Dialog */}
      {editMember && (
        <UpdateMemberDialog
          workspaceId={workspaceId}
          member={editMember}
          open={!!editMember}
          onOpenChange={(open) => {
            if (!open) {
              setEditMember(null);
            }
          }}
          onSuccess={handleUpdateSuccess}
        />
      )}

      {/* Remove Confirmation Dialog */}
      <AlertDialog open={!!removeId} onOpenChange={() => setRemoveId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Remove Member</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to remove this member from the workspace? They will lose access
              to all workspace resources.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleRemove} className="bg-destructive">
              Remove Member
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\send-invitation-dialog.tsx`

```typescript
import { useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { Loader2 } from 'lucide-react';
import { useWorkspaceInvitations } from '../hooks/use-workspace-invitations';
import { SendInvitationDto } from '../types/settings.types';

interface SendInvitationDialogProps {
  workspaceId: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void; // âœ… Add this
}

const DEFAULT_FORM_DATA = {
  email: '',
  role: 'MEMBER' as const,
  permissions: {
    canCreateCanvas: true,
    canDeleteCanvas: false,
    canInviteMembers: false,
    canManageMembers: false,
    canManageApiKeys: false,
  },
};

export function SendInvitationDialog({
  workspaceId,
  open,
  onOpenChange,
  onSuccess, // âœ… Add this
}: SendInvitationDialogProps) {
  const { sendInvitation } = useWorkspaceInvitations(workspaceId);
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState<SendInvitationDto & { permissions: any }>(
    DEFAULT_FORM_DATA
  );

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      await sendInvitation(formData);
      onOpenChange(false);
      setFormData(DEFAULT_FORM_DATA);
      onSuccess?.(); // âœ… Call onSuccess to refresh
    } catch {
      // Error handled in hook
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-h-[90vh] max-w-md overflow-hidden">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Send Invitation</DialogTitle>
            <DialogDescription>Invite someone to join this workspace via email</DialogDescription>
          </DialogHeader>

          <div className="max-h-[calc(90vh-200px)] space-y-4 overflow-y-auto px-1 py-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email Address *</Label>
              <Input
                id="email"
                type="email"
                placeholder="user@example.com"
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                required
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="role">Role *</Label>
              <Select
                value={formData.role}
                onValueChange={(value: any) => setFormData({ ...formData, role: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="MEMBER">Member</SelectItem>
                  <SelectItem value="ADMIN">Admin</SelectItem>
                  <SelectItem value="VIEWER">Viewer</SelectItem>
                </SelectContent>
              </Select>
              <p className="text-muted-foreground text-xs">Expires in 7 days</p>
            </div>

            <div className="space-y-3 rounded-lg border p-3">
              <p className="text-sm font-medium">Permissions</p>
              <div className="space-y-2.5">
                <div className="flex items-center justify-between">
                  <Label htmlFor="canCreateCanvas" className="text-sm font-normal">
                    Create Flows
                  </Label>
                  <Switch
                    id="canCreateCanvas"
                    checked={formData.permissions.canCreateCanvas}
                    onCheckedChange={(checked) =>
                      setFormData({
                        ...formData,
                        permissions: { ...formData.permissions, canCreateCanvas: checked },
                      })
                    }
                  />
                </div>
                <div className="flex items-center justify-between">
                  <Label htmlFor="canDeleteCanvas" className="text-sm font-normal">
                    Delete Flows
                  </Label>
                  <Switch
                    id="canDeleteCanvas"
                    checked={formData.permissions.canDeleteCanvas}
                    onCheckedChange={(checked) =>
                      setFormData({
                        ...formData,
                        permissions: { ...formData.permissions, canDeleteCanvas: checked },
                      })
                    }
                  />
                </div>
                <div className="flex items-center justify-between">
                  <Label htmlFor="canInviteMembers" className="text-sm font-normal">
                    Invite Members
                  </Label>
                  <Switch
                    id="canInviteMembers"
                    checked={formData.permissions.canInviteMembers}
                    onCheckedChange={(checked) =>
                      setFormData({
                        ...formData,
                        permissions: { ...formData.permissions, canInviteMembers: checked },
                      })
                    }
                  />
                </div>
                <div className="flex items-center justify-between">
                  <Label htmlFor="canManageMembers" className="text-sm font-normal">
                    Manage Members
                  </Label>
                  <Switch
                    id="canManageMembers"
                    checked={formData.permissions.canManageMembers}
                    onCheckedChange={(checked) =>
                      setFormData({
                        ...formData,
                        permissions: { ...formData.permissions, canManageMembers: checked },
                      })
                    }
                  />
                </div>
                <div className="flex items-center justify-between">
                  <Label htmlFor="canManageApiKeys" className="text-sm font-normal">
                    Manage API Keys
                  </Label>
                  <Switch
                    id="canManageApiKeys"
                    checked={formData.permissions.canManageApiKeys}
                    onCheckedChange={(checked) =>
                      setFormData({
                        ...formData,
                        permissions: { ...formData.permissions, canManageApiKeys: checked },
                      })
                    }
                  />
                </div>
              </div>
            </div>
          </div>

          <DialogFooter className="mt-4">
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Send Invitation
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\components\update-member-dialog.tsx`

```typescript
import { useState, useEffect } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { Separator } from '@/components/ui/separator';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { useWorkspaceMembers } from '../hooks/use-workspace-members';
import { toast } from '@/lib/toast-utils';
import { Loader2, AlertCircle } from 'lucide-react';
import { Alert, AlertDescription } from '@/components/ui/alert';

interface UpdateMemberDialogProps {
  workspaceId: string;
  member: any;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void;
}

export function UpdateMemberDialog({
  workspaceId,
  member,
  open,
  onOpenChange,
  onSuccess,
}: UpdateMemberDialogProps) {
  const { updateMember } = useWorkspaceMembers(workspaceId);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form state - REMOVED canManageBilling
  const [role, setRole] = useState<string>(member?.role || 'MEMBER');
  const [permissions, setPermissions] = useState({
    canCreateCanvas: member?.canCreateCanvas ?? true,
    canDeleteCanvas: member?.canDeleteCanvas ?? false,
    canInviteMembers: member?.canInviteMembers ?? false,
    canManageMembers: member?.canManageMembers ?? false,
    canManageApiKeys: member?.canManageApiKeys ?? false,
  });

  // Reset form when member changes
  useEffect(() => {
    if (member) {
      setRole(member.role);
      setPermissions({
        canCreateCanvas: member.canCreateCanvas ?? true,
        canDeleteCanvas: member.canDeleteCanvas ?? false,
        canInviteMembers: member.canInviteMembers ?? false,
        canManageMembers: member.canManageMembers ?? false,
        canManageApiKeys: member.canManageApiKeys ?? false,
      });
    }
  }, [member]);

  // Auto-set permissions based on role
  useEffect(() => {
    if (role === 'ADMIN') {
      setPermissions({
        canCreateCanvas: true,
        canDeleteCanvas: true,
        canInviteMembers: true,
        canManageMembers: true,
        canManageApiKeys: true,
      });
    } else if (role === 'VIEWER') {
      setPermissions({
        canCreateCanvas: false,
        canDeleteCanvas: false,
        canInviteMembers: false,
        canManageMembers: false,
        canManageApiKeys: false,
      });
    }
  }, [role]);

  const handleSubmit = async () => {
    if (!member) return;

    setIsSubmitting(true);

    try {
      await updateMember(member.userId, {
        role,
        ...permissions,
      });

      toast.success('Member updated', {
        description: `Updated ${member.user.name || member.user.email}`,
      });

      onOpenChange(false);
      onSuccess?.(); // âœ… Call onSuccess to reload data
    } catch (error: any) {
      console.error('Update member error:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const togglePermission = (key: keyof typeof permissions) => {
    setPermissions((prev) => ({
      ...prev,
      [key]: !prev[key],
    }));
  };

  const getRoleBadgeVariant = (roleValue: string) => {
    switch (roleValue) {
      case 'ADMIN':
        return 'default' as const;
      case 'MEMBER':
        return 'secondary' as const;
      case 'VIEWER':
        return 'outline' as const;
      default:
        return 'outline' as const;
    }
  };

  const getInitials = (name?: string, email?: string) => {
    if (name) {
      return name
        .split(' ')
        .map((n) => n[0])
        .join('')
        .toUpperCase()
        .slice(0, 2);
    }
    if (email) {
      return email.slice(0, 2).toUpperCase();
    }
    return 'U';
  };

  if (!member) return null;

  const isRoleDisabled = role === 'ADMIN' || role === 'VIEWER';

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-h-[90vh] max-w-lg overflow-hidden p-0">
        <DialogHeader className="p-4 pb-0 sm:p-6 sm:pb-0">
          <DialogTitle className="text-lg sm:text-xl">Update Member</DialogTitle>
          <DialogDescription className="text-sm">
            Manage role and permissions for {member.user.name || member.user.email}
          </DialogDescription>
        </DialogHeader>

        {/* Scrollable Content */}
        <div className="max-h-[calc(90vh-180px)] space-y-4 overflow-y-auto px-4 py-4 sm:px-6">
          {/* Member Info */}
          <div className="bg-muted flex items-center gap-3 rounded-lg p-3">
            <Avatar className="h-10 w-10">
              <AvatarImage src={member.user.image} alt={member.user.name || member.user.email} />
              <AvatarFallback className="bg-primary/10 text-primary">
                {getInitials(member.user.name, member.user.email)}
              </AvatarFallback>
            </Avatar>
            <div className="min-w-0 flex-1">
              <p className="truncate font-semibold">{member.user.name || 'Unnamed User'}</p>
              <p className="text-muted-foreground truncate text-sm">{member.user.email}</p>
            </div>
            <Badge variant={getRoleBadgeVariant(member.role)} className="shrink-0">
              {member.role}
            </Badge>
          </div>

          <Separator />

          {/* Role Selection */}
          <div className="space-y-3">
            <Label htmlFor="role" className="text-sm font-semibold sm:text-base">
              Role
            </Label>
            <Select value={role} onValueChange={setRole}>
              <SelectTrigger id="role">
                <SelectValue placeholder="Select role" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="ADMIN">
                  <div className="flex items-center gap-2">
                    <Badge variant="default" className="h-5">
                      ADMIN
                    </Badge>
                    <span className="text-muted-foreground text-xs">Full access</span>
                  </div>
                </SelectItem>
                <SelectItem value="MEMBER">
                  <div className="flex items-center gap-2">
                    <Badge variant="secondary" className="h-5">
                      MEMBER
                    </Badge>
                    <span className="text-muted-foreground text-xs">Custom permissions</span>
                  </div>
                </SelectItem>
                <SelectItem value="VIEWER">
                  <div className="flex items-center gap-2">
                    <Badge variant="outline" className="h-5">
                      VIEWER
                    </Badge>
                    <span className="text-muted-foreground text-xs">Read-only</span>
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>

            {isRoleDisabled && (
              <Alert>
                <AlertCircle className="h-4 w-4" />
                <AlertDescription className="text-xs">
                  {role === 'ADMIN'
                    ? 'Admins have all permissions'
                    : 'Viewers have read-only access'}
                </AlertDescription>
              </Alert>
            )}
          </div>

          <Separator />

          {/* Permissions */}
          <div className="space-y-4">
            <Label className="text-sm font-semibold sm:text-base">Permissions</Label>

            {/* Canvas Permissions */}
            <div className="space-y-2">
              <p className="text-muted-foreground text-xs font-medium sm:text-sm">Canvas</p>
              <div className="space-y-3">
                <div className="flex items-start justify-between gap-3">
                  <div className="min-w-0 flex-1">
                    <Label htmlFor="canCreateCanvas" className="cursor-pointer text-sm font-normal">
                      Can create canvas
                    </Label>
                    <p className="text-muted-foreground text-xs">Create new flows</p>
                  </div>
                  <Switch
                    id="canCreateCanvas"
                    checked={permissions.canCreateCanvas}
                    onCheckedChange={() => togglePermission('canCreateCanvas')}
                    disabled={isRoleDisabled}
                  />
                </div>

                <div className="flex items-start justify-between gap-3">
                  <div className="min-w-0 flex-1">
                    <Label htmlFor="canDeleteCanvas" className="cursor-pointer text-sm font-normal">
                      Can delete canvas
                    </Label>
                    <p className="text-muted-foreground text-xs">Delete flows</p>
                  </div>
                  <Switch
                    id="canDeleteCanvas"
                    checked={permissions.canDeleteCanvas}
                    onCheckedChange={() => togglePermission('canDeleteCanvas')}
                    disabled={isRoleDisabled}
                  />
                </div>
              </div>
            </div>

            <Separator />

            {/* Workspace Permissions */}
            <div className="space-y-2">
              <p className="text-muted-foreground text-xs font-medium sm:text-sm">Workspace</p>
              <div className="space-y-3">
                <div className="flex items-start justify-between gap-3">
                  <div className="min-w-0 flex-1">
                    <Label
                      htmlFor="canInviteMembers"
                      className="cursor-pointer text-sm font-normal"
                    >
                      Can invite members
                    </Label>
                    <p className="text-muted-foreground text-xs">Send invitations</p>
                  </div>
                  <Switch
                    id="canInviteMembers"
                    checked={permissions.canInviteMembers}
                    onCheckedChange={() => togglePermission('canInviteMembers')}
                    disabled={isRoleDisabled}
                  />
                </div>

                <div className="flex items-start justify-between gap-3">
                  <div className="min-w-0 flex-1">
                    <Label
                      htmlFor="canManageMembers"
                      className="cursor-pointer text-sm font-normal"
                    >
                      Can manage members
                    </Label>
                    <p className="text-muted-foreground text-xs">Edit/remove members</p>
                  </div>
                  <Switch
                    id="canManageMembers"
                    checked={permissions.canManageMembers}
                    onCheckedChange={() => togglePermission('canManageMembers')}
                    disabled={isRoleDisabled}
                  />
                </div>

                <div className="flex items-start justify-between gap-3">
                  <div className="min-w-0 flex-1">
                    <Label
                      htmlFor="canManageApiKeys"
                      className="cursor-pointer text-sm font-normal"
                    >
                      Can manage API keys
                    </Label>
                    <p className="text-muted-foreground text-xs">Add/edit API keys</p>
                  </div>
                  <Switch
                    id="canManageApiKeys"
                    checked={permissions.canManageApiKeys}
                    onCheckedChange={() => togglePermission('canManageApiKeys')}
                    disabled={isRoleDisabled}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>

        <DialogFooter className="flex-row gap-2 border-t p-4 sm:p-6">
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isSubmitting}
            className="flex-1 sm:flex-none"
          >
            Cancel
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting} className="flex-1 sm:flex-none">
            {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {isSubmitting ? 'Updating...' : 'Update'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\hooks\use-workspace-api-keys.ts`

```typescript
// hooks/useWorkspaceApiKeys.ts

import { useState, useEffect, useCallback, useMemo } from 'react';
import { toast } from '@/lib/toast-utils';
import axiosInstance from '@/lib/axios-instance';
import {
  WorkspaceApiKey,
  AddApiKeyDto,
  UpdateApiKeyDto,
  ApiKeyUsageStats,
  UsageMetric,
} from '../types/settings.types';

interface UseWorkspaceApiKeysOptions {
  autoRefresh?: boolean;
  refreshInterval?: number;
  enableOptimisticUpdates?: boolean;
}

export function useWorkspaceApiKeys(workspaceId: string, options: UseWorkspaceApiKeysOptions = {}) {
  const { autoRefresh = false, refreshInterval = 30000, enableOptimisticUpdates = true } = options;

  const [apiKeys, setApiKeys] = useState<WorkspaceApiKey[]>([]);
  const [stats, setStats] = useState<ApiKeyUsageStats | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchApiKeys = useCallback(
    async (showLoading: boolean = true) => {
      if (!workspaceId) return;

      try {
        if (showLoading) {
          setIsLoading(true);
        } else {
          setIsRefreshing(true);
        }
        setError(null);

        const response = await axiosInstance.get(`/workspaces/${workspaceId}/api-keys`);

        // âœ… HANDLE WRAPPED RESPONSE (response.data.data) OR DIRECT RESPONSE
        const apiKeysData = response.data?.data || response.data;
        setApiKeys(Array.isArray(apiKeysData) ? apiKeysData : []);
      } catch (error: any) {
        const errorMessage = error.response?.data?.message || 'Failed to load API keys';
        setError(errorMessage);
        toast.error('Failed to load API keys', {
          description: errorMessage,
        });
        setApiKeys([]);
      } finally {
        setIsLoading(false);
        setIsRefreshing(false);
      }
    },
    [workspaceId]
  );

  const fetchStats = useCallback(async () => {
    if (!workspaceId) return;

    try {
      const response = await axiosInstance.get(`/workspaces/${workspaceId}/api-keys/stats`);

      // âœ… HANDLE WRAPPED RESPONSE
      const statsData = response.data?.data || response.data;
      setStats(statsData);
    } catch (error: any) {
      console.error('Failed to fetch API key stats:', error);
    }
  }, [workspaceId]);

  const fetchUsageMetrics = useCallback(
    async (keyId: string, startDate?: string, endDate?: string): Promise<UsageMetric[]> => {
      try {
        const params = new URLSearchParams();
        if (startDate) params.append('startDate', startDate);
        if (endDate) params.append('endDate', endDate);

        const response = await axiosInstance.get(
          `/workspaces/${workspaceId}/api-keys/${keyId}/metrics?${params.toString()}`
        );

        // âœ… HANDLE WRAPPED RESPONSE
        const metricsData = response.data?.data || response.data;
        return Array.isArray(metricsData) ? metricsData : [];
      } catch (error: any) {
        toast.error('Failed to fetch usage metrics', {
          description: error.response?.data?.message || 'Please try again',
        });
        return [];
      }
    },
    [workspaceId]
  );

  const addApiKey = useCallback(
    async (data: AddApiKeyDto) => {
      try {
        const response = await axiosInstance.post(`/workspaces/${workspaceId}/api-keys`, data);

        // âœ… HANDLE WRAPPED RESPONSE
        const newApiKey = response.data?.data || response.data;

        toast.success('API key added successfully', {
          description: `${data.displayName} is ready to use`,
        });

        if (enableOptimisticUpdates) {
          setApiKeys((prev) => [newApiKey, ...prev]);
        } else {
          await fetchApiKeys(false);
        }

        fetchStats();
        return newApiKey;
      } catch (error: any) {
        toast.error('Failed to add API key', {
          description: error.response?.data?.message || 'Please try again',
        });
        throw error;
      }
    },
    [workspaceId, enableOptimisticUpdates, fetchApiKeys, fetchStats]
  );

  const updateApiKey = useCallback(
    async (keyId: string, data: UpdateApiKeyDto) => {
      try {
        if (enableOptimisticUpdates) {
          setApiKeys((prev) => prev.map((key) => (key.id === keyId ? { ...key, ...data } : key)));
        }

        const response = await axiosInstance.patch(
          `/workspaces/${workspaceId}/api-keys/${keyId}`,
          data
        );

        // âœ… HANDLE WRAPPED RESPONSE
        const updatedKey = response.data?.data || response.data;

        toast.success('API key updated successfully');

        if (!enableOptimisticUpdates) {
          await fetchApiKeys(false);
        }

        return updatedKey;
      } catch (error: any) {
        if (enableOptimisticUpdates) {
          await fetchApiKeys(false);
        }

        toast.error('Failed to update API key', {
          description: error.response?.data?.message || 'Please try again',
        });
        throw error;
      }
    },
    [workspaceId, enableOptimisticUpdates, fetchApiKeys]
  );

  const toggleApiKeyStatus = useCallback(
    async (keyId: string, isActive: boolean) => {
      return updateApiKey(keyId, { isActive });
    },
    [updateApiKey]
  );

  const deleteApiKey = useCallback(
    async (keyId: string) => {
      try {
        if (enableOptimisticUpdates) {
          setApiKeys((prev) => prev.filter((key) => key.id !== keyId));
        }

        await axiosInstance.delete(`/workspaces/${workspaceId}/api-keys/${keyId}`);

        toast.success('API key deleted successfully');

        if (!enableOptimisticUpdates) {
          await fetchApiKeys(false);
        }

        fetchStats();
      } catch (error: any) {
        if (enableOptimisticUpdates) {
          await fetchApiKeys(false);
        }

        toast.error('Failed to delete API key', {
          description: error.response?.data?.message || 'Please try again',
        });
        throw error;
      }
    },
    [workspaceId, enableOptimisticUpdates, fetchApiKeys, fetchStats]
  );

  const groupedByProvider = useMemo(() => {
    return apiKeys.reduce(
      (acc, key) => {
        if (!acc[key.provider]) {
          acc[key.provider] = [];
        }
        acc[key.provider].push(key);
        return acc;
      },
      {} as Record<string, WorkspaceApiKey[]>
    );
  }, [apiKeys]);

  const activeKeysCount = useMemo(() => apiKeys.filter((key) => key.isActive).length, [apiKeys]);

  useEffect(() => {
    if (autoRefresh && refreshInterval > 0) {
      const interval = setInterval(() => {
        fetchApiKeys(false);
        fetchStats();
      }, refreshInterval);

      return () => clearInterval(interval);
    }
  }, [autoRefresh, refreshInterval, fetchApiKeys, fetchStats]);

  useEffect(() => {
    fetchApiKeys();
    fetchStats();
  }, [fetchApiKeys, fetchStats]);

  return {
    apiKeys,
    groupedByProvider,
    stats,
    isLoading,
    isRefreshing,
    error,
    totalCount: apiKeys.length,
    activeKeysCount,
    addApiKey,
    updateApiKey,
    deleteApiKey,
    toggleApiKeyStatus,
    fetchUsageMetrics,
    refetch: fetchApiKeys,
    refetchStats: fetchStats,
  };
}

```

### `apps\frontend\src\pages\dashboard\settings\hooks\use-workspace-invitations.ts`

```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';
import { toast } from '@/lib/toast-utils';
import { axiosInstance } from '@/lib/axios-instance';
import { WorkspaceInvitation, SendInvitationDto } from '../types/settings.types';

interface UseWorkspaceInvitationsOptions {
  autoRefresh?: boolean;
  refreshInterval?: number;
}

export function useWorkspaceInvitations(
  workspaceId: string,
  options: UseWorkspaceInvitationsOptions = {}
) {
  const { autoRefresh = false, refreshInterval = 30000 } = options;

  const [invitations, setInvitations] = useState<WorkspaceInvitation[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchInvitations = useCallback(
    async (showLoading: boolean = true) => {
      if (!workspaceId) return;

      try {
        if (showLoading) {
          setIsLoading(true);
        } else {
          setIsRefreshing(true);
        }
        setError(null);

        const response = await axiosInstance.get(`/workspaces/${workspaceId}/invitations`);

        // âœ… FIXED: Handle both wrapped and direct responses
        const data = response.data?.data || response.data;
        setInvitations(Array.isArray(data) ? data : []);
      } catch (error: any) {
        const errorMessage = error.response?.data?.message || 'Failed to load invitations';
        setError(errorMessage);
        toast.error('Failed to load invitations', {
          description: errorMessage,
        });
        setInvitations([]);
      } finally {
        setIsLoading(false);
        setIsRefreshing(false);
      }
    },
    [workspaceId]
  );

  const sendInvitation = useCallback(
    async (data: SendInvitationDto) => {
      try {
        const response = await axiosInstance.post(`/workspaces/${workspaceId}/invitations`, data);

        toast.success('Invitation sent', {
          description: `Invite sent to ${data.email}`,
        });

        await fetchInvitations(false);
        return response.data;
      } catch (error: any) {
        toast.error('Failed to send invitation', {
          description: error.response?.data?.message || 'Please try again',
        });
        throw error;
      }
    },
    [workspaceId, fetchInvitations]
  );

  const revokeInvitation = useCallback(
    async (invitationId: string) => {
      try {
        await axiosInstance.delete(`/workspaces/${workspaceId}/invitations/${invitationId}`);

        toast.success('Invitation revoked');

        // Optimistic update
        setInvitations((prev) => prev.filter((inv) => inv.id !== invitationId));
      } catch (error: any) {
        toast.error('Failed to revoke invitation', {
          description: error.response?.data?.message || 'Please try again',
        });
        // Refetch on error
        fetchInvitations(false);
        throw error;
      }
    },
    [workspaceId, fetchInvitations]
  );

  const pendingInvitations = useMemo(
    () => invitations.filter((inv) => inv.status === 'PENDING'),
    [invitations]
  );

  useEffect(() => {
    if (autoRefresh && refreshInterval > 0) {
      const interval = setInterval(() => {
        fetchInvitations(false);
      }, refreshInterval);

      return () => clearInterval(interval);
    }
  }, [autoRefresh, refreshInterval, fetchInvitations]);

  useEffect(() => {
    fetchInvitations();
  }, [fetchInvitations]);

  return {
    invitations,
    pendingInvitations,
    isLoading,
    isRefreshing,
    error,
    totalInvitations: invitations.length,
    pendingCount: pendingInvitations.length,
    sendInvitation,
    revokeInvitation,
    refetch: fetchInvitations,
  };
}

```

### `apps\frontend\src\pages\dashboard\settings\hooks\use-workspace-members.ts`

```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';
import { toast } from '@/lib/toast-utils';
import { axiosInstance } from '@/lib/axios-instance';
import { WorkspaceMember } from '../types/settings.types';

interface UseWorkspaceMembersOptions {
  autoRefresh?: boolean;
  refreshInterval?: number;
  enableOptimisticUpdates?: boolean;
}

export function useWorkspaceMembers(workspaceId: string, options: UseWorkspaceMembersOptions = {}) {
  const { autoRefresh = false, refreshInterval = 30000, enableOptimisticUpdates = true } = options;

  const [members, setMembers] = useState<WorkspaceMember[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchMembers = useCallback(
    async (showLoading: boolean = true) => {
      if (!workspaceId) return;

      try {
        if (showLoading) {
          setIsLoading(true);
        } else {
          setIsRefreshing(true);
        }

        setError(null);
        const response = await axiosInstance.get(`/workspaces/${workspaceId}/members`);

        // Handle both wrapped and direct responses
        const membersData = response.data?.data || response.data;
        setMembers(Array.isArray(membersData) ? membersData : []);
      } catch (error: any) {
        const errorMessage = error.response?.data?.message || 'Failed to load members';
        setError(errorMessage);
        toast.error('Failed to load members', {
          description: errorMessage,
        });
        setMembers([]);
      } finally {
        setIsLoading(false);
        setIsRefreshing(false);
      }
    },
    [workspaceId]
  );

  // âŒ REMOVED: addMember function - Use invitations instead

  const updateMember = useCallback(
    async (userId: string, data: Partial<any>) => {
      try {
        if (enableOptimisticUpdates) {
          setMembers((prev) =>
            prev.map((member) => (member.userId === userId ? { ...member, ...data } : member))
          );
        }

        const response = await axiosInstance.patch(
          `/workspaces/${workspaceId}/members/${userId}`,
          data
        );

        toast.success('Member updated successfully');

        if (!enableOptimisticUpdates) {
          await fetchMembers(false);
        }

        return response.data;
      } catch (error: any) {
        if (enableOptimisticUpdates) {
          await fetchMembers(false);
        }

        toast.error('Failed to update member', {
          description: error.response?.data?.message || 'Please try again',
        });
        throw error;
      }
    },
    [workspaceId, enableOptimisticUpdates, fetchMembers]
  );

  const removeMember = useCallback(
    async (userId: string) => {
      try {
        if (enableOptimisticUpdates) {
          setMembers((prev) => prev.filter((member) => member.userId !== userId));
        }

        await axiosInstance.delete(`/workspaces/${workspaceId}/members/${userId}`);

        toast.success('Member removed successfully');

        if (!enableOptimisticUpdates) {
          await fetchMembers(false);
        }
      } catch (error: any) {
        if (enableOptimisticUpdates) {
          await fetchMembers(false);
        }

        toast.error('Failed to remove member', {
          description: error.response?.data?.message || 'Please try again',
        });
        throw error;
      }
    },
    [workspaceId, enableOptimisticUpdates, fetchMembers]
  );

  const membersByRole = useMemo(() => {
    return members.reduce(
      (acc, member) => {
        if (!acc[member.role]) {
          acc[member.role] = [];
        }
        acc[member.role].push(member);
        return acc;
      },
      {} as Record<string, WorkspaceMember[]>
    );
  }, [members]);

  const ownerCount = useMemo(() => members.filter((m) => m.role === 'OWNER').length, [members]);
  const adminCount = useMemo(() => members.filter((m) => m.role === 'ADMIN').length, [members]);
  const memberCount = useMemo(() => members.filter((m) => m.role === 'MEMBER').length, [members]);

  useEffect(() => {
    if (autoRefresh && refreshInterval > 0) {
      const interval = setInterval(() => {
        fetchMembers(false);
      }, refreshInterval);

      return () => clearInterval(interval);
    }
  }, [autoRefresh, refreshInterval, fetchMembers]);

  useEffect(() => {
    fetchMembers();
  }, [fetchMembers]);

  return {
    members,
    membersByRole,
    isLoading,
    isRefreshing,
    error,
    totalMembers: members.length,
    ownerCount,
    adminCount,
    memberCount,
    // âŒ REMOVED: addMember
    updateMember,
    removeMember,
    refetch: fetchMembers,
  };
}

```

### `apps\frontend\src\pages\dashboard\settings\index.tsx`

```typescript
import { useMemo } from 'react';
import { useSearchParams } from 'react-router-dom';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card, CardContent } from '@/components/ui/card';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Settings, Users, Mail, Key } from 'lucide-react';
import { GeneralSettings } from './components/general-settings';
import { MembersSettings } from './components/members-settings';
import { InvitationsSettings } from './components/invitations-settings';
import { ApiKeysSettings } from './components/api-keys-settings';
import { useWorkspaces } from '@/hooks/use-workspaces';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { AlertCircle } from 'lucide-react';

const tabs = [
  { value: 'general', label: 'General', icon: Settings },
  { value: 'members', label: 'Members', icon: Users },
  { value: 'invitations', label: 'Invitations', icon: Mail },
  { value: 'api-keys', label: 'API Keys', icon: Key },
];

export default function WorkspaceSettingsPage() {
  const { currentWorkspace, isLoading } = useWorkspaces();
  const [searchParams, setSearchParams] = useSearchParams();

  // âœ… Derive active tab from URL - no state needed!
  const activeTab = useMemo(() => {
    const urlTab = searchParams.get('tab') || 'general';
    // Validate tab exists
    return tabs.some((tab) => tab.value === urlTab) ? urlTab : 'general';
  }, [searchParams]);

  // âœ… Update URL when tab changes
  const handleTabChange = (newTab: string) => {
    setSearchParams({ tab: newTab });
  };

  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <p className="text-muted-foreground">Loading workspace...</p>
      </div>
    );
  }

  if (!currentWorkspace) {
    return (
      <div className="flex h-full items-center justify-center p-4">
        <Alert variant="destructive" className="max-w-md">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            No workspace selected. Please select a workspace from the sidebar.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="space-y-4 md:space-y-6">
      {/* Header */}
      <div>
        <h1 className="text-2xl font-bold tracking-tight md:text-3xl">Workspace Settings</h1>
        <p className="text-muted-foreground mt-1 text-sm md:mt-2">
          Manage your workspace settings, members, and integrations
        </p>
      </div>

      <Card>
        <CardContent className="px-6 py-1 md:px-6 md:py-4">
          <Tabs value={activeTab} onValueChange={handleTabChange}>
            {/* Mobile: Dropdown Selector */}
            <div className="mb-6 md:hidden">
              <Select value={activeTab} onValueChange={handleTabChange}>
                <SelectTrigger className="w-full">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {tabs.map((tab) => {
                    const Icon = tab.icon;
                    return (
                      <SelectItem key={tab.value} value={tab.value}>
                        <div className="flex items-center gap-2">
                          <Icon className="h-4 w-4" />
                          <span>{tab.label}</span>
                        </div>
                      </SelectItem>
                    );
                  })}
                </SelectContent>
              </Select>
            </div>

            {/* Desktop: Side Navigation */}
            <div className="hidden md:flex md:gap-6">
              {/* TABS ON LEFT (Desktop) */}
              <TabsList className="flex h-fit w-48 shrink-0 flex-col items-stretch justify-start space-y-1 bg-transparent p-0">
                {tabs.map((tab) => {
                  const Icon = tab.icon;
                  return (
                    <TabsTrigger
                      key={tab.value}
                      value={tab.value}
                      className="data-[state=active]:bg-accent justify-start gap-3 rounded-lg px-3 py-2.5 data-[state=active]:shadow-sm"
                    >
                      <Icon className="h-4 w-4 shrink-0" />
                      <span>{tab.label}</span>
                    </TabsTrigger>
                  );
                })}
              </TabsList>

              {/* CONTENT ON RIGHT (Desktop) */}
              <div className="min-w-0 flex-1">
                <TabsContent value="general" className="m-0">
                  <GeneralSettings workspace={currentWorkspace} />
                </TabsContent>

                <TabsContent value="members" className="m-0">
                  <MembersSettings workspaceId={currentWorkspace.id} />
                </TabsContent>

                <TabsContent value="invitations" className="m-0">
                  <InvitationsSettings workspaceId={currentWorkspace.id} />
                </TabsContent>

                <TabsContent value="api-keys" className="m-0">
                  <ApiKeysSettings workspaceId={currentWorkspace.id} />
                </TabsContent>
              </div>
            </div>

            {/* Mobile: Full Width Content */}
            <div className="md:hidden">
              <TabsContent value="general" className="m-0">
                <GeneralSettings workspace={currentWorkspace} />
              </TabsContent>

              <TabsContent value="members" className="m-0">
                <MembersSettings workspaceId={currentWorkspace.id} />
              </TabsContent>

              <TabsContent value="invitations" className="m-0">
                <InvitationsSettings workspaceId={currentWorkspace.id} />
              </TabsContent>

              <TabsContent value="api-keys" className="m-0">
                <ApiKeysSettings workspaceId={currentWorkspace.id} />
              </TabsContent>
            </div>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  );
}

```

### `apps\frontend\src\pages\dashboard\settings\types\settings.types.ts`

```typescript
// types/settings.types.ts

/**
 * Workspace member
 */
export interface WorkspaceMember {
  userId: string;
  workspaceId: string;
  role: 'OWNER' | 'ADMIN' | 'MEMBER' | 'VIEWER';
  canCreateCanvas: boolean;
  canDeleteCanvas: boolean;
  canManageBilling: boolean;
  canInviteMembers: boolean;
  canManageMembers: boolean;
  canManageApiKeys: boolean;
  joinedAt: string;
  invitedBy: string | null;
  user: {
    id: string;
    email: string;
    name: string | null;
    image: string | null;
  };
}

/**
 * Workspace invitation
 */
export interface WorkspaceInvitation {
  id: string;
  workspaceId: string;
  email: string;
  role: 'OWNER' | 'ADMIN' | 'MEMBER' | 'VIEWER';
  permissions: Record<string, boolean> | null;
  token: string;
  status: 'PENDING' | 'ACCEPTED' | 'DECLINED' | 'EXPIRED' | 'REVOKED';
  expiresAt: string;
  createdAt: string;
  invitedBy: string;
  invitedUserId: string | null;
  acceptedAt: string | null;
}

/**
 * Workspace API key with usage tracking
 */
export interface WorkspaceApiKey {
  id: string;
  provider: string;
  displayName: string;
  isActive: boolean;
  lastUsedAt: string | null;
  createdAt: string;

  // Usage metrics
  usageCount: number;
  totalTokens: string;
  totalCost: number;

  // Error tracking
  lastErrorAt: string | null;

  // Creator
  createdBy: {
    id: string;
    name: string | null;
    email: string;
  };
}

/**
 * API key usage statistics
 */
export interface ApiKeyUsageStats {
  totalKeys: number;
  activeKeys: number;
  inactiveKeys: number;
  providerBreakdown: Record<string, number>;
  totalUsageCount: number;
  totalTokensConsumed: string;
  totalCostIncurred: number;
}

/**
 * Daily usage metric
 */
export interface UsageMetric {
  id: string;
  date: string;
  requestCount: number;
  successCount: number;
  errorCount: number;
  promptTokens: string;
  completionTokens: string;
  totalTokens: string;
  estimatedCost: number;
}

/**
 * Add API key DTO
 */
export interface AddApiKeyDto {
  provider: string;
  displayName: string;
  apiKey: string;
}

/**
 * Update API key DTO
 */
export interface UpdateApiKeyDto {
  displayName?: string;
  apiKey?: string;
  isActive?: boolean;
}

/**
 * Add member DTO
 */
export interface AddMemberDto {
  email: string;
  role?: 'ADMIN' | 'MEMBER' | 'VIEWER';
  canCreateCanvas?: boolean;
  canDeleteCanvas?: boolean;
  canManageBilling?: boolean;
  canInviteMembers?: boolean;
  canManageMembers?: boolean;
  canManageApiKeys?: boolean;
}

/**
 * Send invitation DTO
 */
export interface SendInvitationDto {
  email: string;
  role?: 'MEMBER' | 'ADMIN' | 'VIEWER';
  permissions?: Record<string, boolean> | null;
}

```

### `apps\frontend\src\pages\errors\403.tsx`

```typescript
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Home, ArrowLeft, ShieldAlert } from 'lucide-react';
import { motion } from 'framer-motion';

export default function ForbiddenPage() {
  const navigate = useNavigate();

  return (
    <div className="bg-background flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-2xl text-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
          className="mb-8 flex justify-center"
        >
          <div className="relative">
            <h1 className="text-destructive text-9xl font-bold">403</h1>
            <motion.div
              animate={{ scale: [1, 1.1, 1] }}
              transition={{ repeat: Infinity, duration: 2 }}
              className="absolute -top-4 -right-12"
            >
              <ShieldAlert className="text-destructive h-20 w-20" />
            </motion.div>
          </div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2, duration: 0.5 }}
          className="space-y-4"
        >
          <h2 className="text-foreground text-3xl font-semibold">Access Forbidden</h2>
          <p className="text-muted-foreground text-lg">
            You don&apos;t have permission to access this resource.
          </p>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4, duration: 0.5 }}
          className="mt-8 flex flex-col items-center justify-center gap-4 sm:flex-row"
        >
          <Button onClick={() => navigate(-1)} variant="outline" size="lg">
            <ArrowLeft className="mr-2 h-4 w-4" />
            Go Back
          </Button>
          <Button onClick={() => navigate('/dashboard')} size="lg">
            <Home className="mr-2 h-4 w-4" />
            Go to Dashboard
          </Button>
        </motion.div>

        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.6, duration: 0.5 }}
          className="mt-12"
        >
          <p className="text-muted-foreground text-sm">
            Need access?{' '}
            <a href="mailto:support@flopods.com" className="text-primary hover:underline">
              Request Permissions
            </a>
          </p>
        </motion.div>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\errors\404.tsx`

```typescript
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Home, ArrowLeft } from 'lucide-react';
import { motion } from 'framer-motion';

export default function NotFoundPage() {
  const navigate = useNavigate();

  return (
    <div className="bg-background flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-2xl text-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
          className="mb-8"
        >
          <h1 className="text-primary text-9xl font-bold">404</h1>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2, duration: 0.5 }}
          className="space-y-4"
        >
          <h2 className="text-foreground text-3xl font-semibold">Page Not Found</h2>
          <p className="text-muted-foreground text-lg">
            The page you&apos;re looking for doesn&apos;t exist or has been moved.
          </p>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4, duration: 0.5 }}
          className="mt-8 flex flex-col items-center justify-center gap-4 sm:flex-row"
        >
          <Button onClick={() => navigate(-1)} variant="outline" size="lg">
            <ArrowLeft className="mr-2 h-4 w-4" />
            Go Back
          </Button>
          <Button onClick={() => navigate('/dashboard')} size="lg">
            <Home className="mr-2 h-4 w-4" />
            Go to Dashboard
          </Button>
        </motion.div>

        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.6, duration: 0.5 }}
          className="mt-12"
        >
          <p className="text-muted-foreground text-sm">
            Need help?{' '}
            <a href="mailto:support@flopods.com" className="text-primary hover:underline">
              Contact Support
            </a>
          </p>
        </motion.div>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\errors\500.tsx`

```typescript
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Home, RefreshCw, AlertTriangle } from 'lucide-react';
import { motion } from 'framer-motion';

export default function ServerErrorPage() {
  const navigate = useNavigate();

  const handleRefresh = () => {
    window.location.reload();
  };

  return (
    <div className="bg-background flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-2xl text-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
          className="mb-8 flex justify-center"
        >
          <div className="relative">
            <h1 className="text-destructive text-9xl font-bold">500</h1>
            <motion.div
              animate={{ rotate: [0, 10, -10, 10, 0] }}
              transition={{ repeat: Infinity, duration: 2, repeatDelay: 1 }}
              className="absolute -top-8 -right-8"
            >
              <AlertTriangle className="text-destructive h-16 w-16" />
            </motion.div>
          </div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2, duration: 0.5 }}
          className="space-y-4"
        >
          <h2 className="text-foreground text-3xl font-semibold">Internal Server Error</h2>
          <p className="text-muted-foreground text-lg">
            Something went wrong on our end. We&apos;re working to fix it.
          </p>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4, duration: 0.5 }}
          className="mt-8 flex flex-col items-center justify-center gap-4 sm:flex-row"
        >
          <Button onClick={handleRefresh} variant="outline" size="lg">
            <RefreshCw className="mr-2 h-4 w-4" />
            Try Again
          </Button>
          <Button onClick={() => navigate('/dashboard')} size="lg">
            <Home className="mr-2 h-4 w-4" />
            Go to Dashboard
          </Button>
        </motion.div>

        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.6, duration: 0.5 }}
          className="mt-12 space-y-4"
        >
          <p className="text-muted-foreground text-sm">
            If this problem persists, please{' '}
            <a href="mailto:support@flopods.com" className="text-primary hover:underline">
              contact our support team
            </a>
          </p>
        </motion.div>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\errors\maintenance.tsx`

```typescript
import { Button } from '@/components/ui/button';
import { RefreshCw, Wrench } from 'lucide-react';
import { motion } from 'framer-motion';

export default function MaintenancePage() {
  const handleRefresh = () => {
    window.location.reload();
  };

  return (
    <div className="bg-background flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-2xl text-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
          className="mb-8 flex justify-center"
        >
          <motion.div
            animate={{ rotate: [0, 360] }}
            transition={{ repeat: Infinity, duration: 3, ease: 'linear' }}
          >
            <Wrench className="text-primary h-32 w-32" />
          </motion.div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2, duration: 0.5 }}
          className="space-y-4"
        >
          <h2 className="text-foreground text-3xl font-semibold">Under Maintenance</h2>
          <p className="text-muted-foreground text-lg">
            We&apos;re currently performing scheduled maintenance. We&apos;ll be back soon!
          </p>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4, duration: 0.5 }}
          className="mt-8"
        >
          <Button onClick={handleRefresh} size="lg">
            <RefreshCw className="mr-2 h-4 w-4" />
            Check Status
          </Button>
        </motion.div>

        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.6, duration: 0.5 }}
          className="mt-12"
        >
          <div className="border-border bg-card rounded-lg border p-6">
            <p className="text-muted-foreground text-sm">
              Expected downtime: <strong>30 minutes</strong>
            </p>
            <p className="text-muted-foreground mt-2 text-xs">
              Follow us on{' '}
              <a href="https://twitter.com/flopods" className="text-primary hover:underline">
                Twitter
              </a>{' '}
              for live updates
            </p>
          </div>
        </motion.div>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\errors\offline.tsx`

```typescript
// pages/errors/OfflinePage.tsx
import { Button } from '@/components/ui/button';
import { RefreshCw, WifiOff } from 'lucide-react';
import { motion } from 'framer-motion';
import { useCallback, useState } from 'react';
import { axiosInstance } from '@/lib/axios-instance';

const OFFLINE_REDIRECT_FLAG = 'offlineRedirectPending';
const PRE_ERROR_PATH = 'preErrorPath';

export default function OfflinePage() {
  const [loading, setLoading] = useState(false);

  const redirectBack = useCallback(() => {
    try {
      const prev = sessionStorage.getItem(PRE_ERROR_PATH) || '/dashboard';
      sessionStorage.removeItem(PRE_ERROR_PATH);
      sessionStorage.removeItem(OFFLINE_REDIRECT_FLAG);
      // Replace so /errors/offline isn't left in history
      window.location.replace(prev);
    } catch {
      window.location.replace('/dashboard');
    }
  }, []);

  const handleRefresh = useCallback(async () => {
    if (loading) return;
    setLoading(true);
    try {
      // Call the user endpoint as the connectivity/session probe
      const res = await axiosInstance.get('/users/me');
      // Your backend shape shows statusCode/message/data; just check it responded
      if (res?.status === 200) {
        redirectBack();
        return;
      }
      // If your API wraps with {statusCode:200,...}, you could also check:
      // if ((res.data?.statusCode ?? 200) === 200) redirectBack();
    } catch (err: any) {
      // If unauthorized after recovery, kick to login
      if (err?.response?.status === 401) {
        sessionStorage.removeItem(PRE_ERROR_PATH);
        sessionStorage.removeItem(OFFLINE_REDIRECT_FLAG);
        window.location.replace('/auth/login');
        return;
      }
      // Still offline or other errors â€” stay on this page
    } finally {
      setLoading(false);
    }
  }, [loading, redirectBack]);

  return (
    <div className="bg-background flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-2xl text-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
          className="mb-8 flex justify-center"
        >
          <motion.div animate={{ y: [0, -10, 0] }} transition={{ repeat: Infinity, duration: 2 }}>
            <WifiOff className="text-muted-foreground h-32 w-32" />
          </motion.div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2, duration: 0.5 }}
          className="space-y-4"
        >
          <h2 className="text-foreground text-3xl font-semibold">No Internet Connection</h2>
          <p className="text-muted-foreground text-lg">
            Please check your network connection and try again.
          </p>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4, duration: 0.5 }}
          className="mt-8"
        >
          <Button onClick={handleRefresh} size="lg" disabled={loading}>
            <RefreshCw className="mr-2 h-4 w-4" />
            {loading ? 'Checkingâ€¦' : 'Retry Connection'}
          </Button>
        </motion.div>

        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.6, duration: 0.5 }}
          className="mt-12"
        >
          <div className="border-border bg-card rounded-lg border p-4">
            <p className="text-muted-foreground text-sm">
              <strong>Troubleshooting tips:</strong>
            </p>
            <ul className="text-muted-foreground mt-2 space-y-1 text-left text-sm">
              <li>â€¢ Check if your Wi-Fi or mobile data is turned on</li>
              <li>â€¢ Try restarting your router</li>
              <li>â€¢ Check if other websites are loading</li>
            </ul>
          </div>
        </motion.div>
      </div>
    </div>
  );
}

```

### `apps\frontend\src\pages\workspace\invite\index.tsx`

```typescript
import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Skeleton } from '@/components/ui/skeleton';
import {
  CheckCircle2,
  XCircle,
  Loader2,
  Building2,
  Shield,
  AlertCircle,
  ArrowRight,
} from 'lucide-react';
import { axiosInstance } from '@/lib/axios-instance';
import { toast } from '@/lib/toast-utils';
import { useAuth } from '@/hooks/use-auth';
import { motion } from 'framer-motion';

interface InvitationDetails {
  workspace: {
    id: string;
    name: string;
    type: string;
  };
  email: string;
  role: string;
  expiresAt: string;
}

export default function AcceptInvitationPage() {
  const { token } = useParams<{ token: string }>();
  const navigate = useNavigate();
  const { user, isAuthenticated, isLoading: authLoading } = useAuth();

  const [invitation, setInvitation] = useState<InvitationDetails | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAccepting, setIsAccepting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const fetchInvitationDetails = async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await axiosInstance.get(`/workspaces/invitations/${token}/details`);
      const data = response.data?.data || response.data;

      setInvitation(data);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Invalid invitation');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (authLoading) return;

    if (!isAuthenticated) {
      sessionStorage.setItem('pendingInvitation', token || '');
      const returnUrl = `/workspace/invite/${token}`; // âœ… Fixed path
      navigate(`/auth/login?returnUrl=${encodeURIComponent(returnUrl)}`);
      return;
    }

    fetchInvitationDetails();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [token, isAuthenticated, authLoading]);

  const handleAccept = async () => {
    if (!token) return;

    try {
      setIsAccepting(true);
      await axiosInstance.post(`/workspaces/invitations/${token}/accept`);

      toast.success('Welcome!', {
        description: `Joined ${invitation?.workspace.name}`,
      });

      setSuccess(true);

      setTimeout(() => {
        navigate('/dashboard');
      }, 1500);
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'Failed to accept';
      toast.error('Failed', {
        description: errorMessage,
      });
      setError(errorMessage);
    } finally {
      setIsAccepting(false);
    }
  };

  const getRoleBadgeVariant = (role: string) => {
    if (role === 'ADMIN') return 'default' as const;
    if (role === 'MEMBER') return 'secondary' as const;
    return 'outline' as const;
  };

  // Loading State
  if (authLoading || isLoading) {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardHeader className="space-y-3">
            <Skeleton className="h-6 w-2/3" />
            <Skeleton className="h-4 w-full" />
          </CardHeader>
          <CardContent className="space-y-3">
            <Skeleton className="h-20 w-full" />
            <Skeleton className="h-10 w-full" />
          </CardContent>
        </Card>
      </div>
    );
  }

  // Error State
  if (error && !invitation) {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className="w-full max-w-md"
        >
          <Card className="border-destructive/50">
            <CardHeader className="text-center">
              <div className="bg-destructive/10 mx-auto mb-3 flex h-12 w-12 items-center justify-center rounded-full">
                <XCircle className="text-destructive h-6 w-6" />
              </div>
              <CardTitle>Invalid Invitation</CardTitle>
              <CardDescription>{error}</CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full" onClick={() => navigate('/dashboard')}>
                Go to Dashboard
              </Button>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    );
  }

  // Success State
  if (success) {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          className="w-full max-w-md"
        >
          <Card className="border-green-500/50">
            <CardHeader className="text-center">
              <div className="mx-auto mb-3 flex h-12 w-12 items-center justify-center rounded-full bg-green-100 dark:bg-green-900/20">
                <CheckCircle2 className="h-6 w-6 text-green-600 dark:text-green-500" />
              </div>
              <CardTitle>Welcome! ðŸŽ‰</CardTitle>
              <CardDescription>Joined {invitation?.workspace.name}</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="bg-muted flex items-center justify-center gap-2 rounded-lg p-3">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span className="text-muted-foreground text-sm">Redirecting...</span>
              </div>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    );
  }

  const isExpired = invitation && new Date(invitation.expiresAt) < new Date();
  const emailMismatch = user?.email !== invitation?.email;

  // Main Invitation Card
  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        className="w-full max-w-md"
      >
        <Card>
          <CardHeader className="text-center">
            <div className="bg-primary/10 mx-auto mb-3 flex h-12 w-12 items-center justify-center rounded-full">
              <Building2 className="text-primary h-6 w-6" />
            </div>
            <CardTitle className="text-xl">{invitation?.workspace.name}</CardTitle>
            <CardDescription>
              {invitation?.workspace.type === 'TEAM' ? 'Team Workspace' : 'Workspace'}
            </CardDescription>
          </CardHeader>

          <CardContent className="space-y-4">
            {/* Role Badge */}
            <div className="bg-muted flex items-center justify-between rounded-lg p-3">
              <div className="flex items-center gap-2">
                <Shield className="text-muted-foreground h-4 w-4" />
                <span className="text-muted-foreground text-sm">Your Role</span>
              </div>
              <Badge variant={getRoleBadgeVariant(invitation?.role || '')}>
                {invitation?.role}
              </Badge>
            </div>

            {/* Warnings */}
            {isExpired && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription className="text-sm">Invitation expired</AlertDescription>
              </Alert>
            )}

            {emailMismatch && (
              <Alert>
                <AlertCircle className="h-4 w-4" />
                <AlertDescription className="text-sm">
                  Sent to <strong>{invitation?.email}</strong>
                  <br />
                  You&apos;re signed in as <strong>{user?.email}</strong>
                </AlertDescription>
              </Alert>
            )}

            {/* Actions */}
            <div className="space-y-2 pt-2">
              <Button
                className="w-full"
                size="lg"
                onClick={handleAccept}
                disabled={isExpired || isAccepting || emailMismatch}
              >
                {isAccepting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Accepting...
                  </>
                ) : (
                  <>
                    Accept Invitation
                    <ArrowRight className="ml-2 h-4 w-4" />
                  </>
                )}
              </Button>

              <Button
                variant="ghost"
                className="w-full"
                onClick={() => navigate('/dashboard')}
                disabled={isAccepting}
              >
                Decline
              </Button>
            </div>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  );
}

```

### `apps\frontend\src\router.tsx`

```typescript
import { createBrowserRouter, Navigate } from 'react-router-dom';
import { ErrorBoundary } from './components/shared/error-boundary';
import LoginPage from './pages/auth/login';
import RegisterPage from './pages/auth/register';
import AuthCallbackPage from './pages/auth/callback';
import DashboardPage from './pages/dashboard';
import WorkspaceSettingsPage from './pages/dashboard/settings';
import { DashboardLayout } from './layout/dashboard-layout';
import { AuthLayout } from './layout/auth-layout';
import { ProtectedRoute } from './components/shared/protected-route';
import { RootLayout } from './layout/root-layout';

// Error Pages
import NotFoundPage from './pages/errors/404';
import ServerErrorPage from './pages/errors/500';
import ForbiddenPage from './pages/errors/403';
import OfflinePage from './pages/errors/offline';
import MaintenancePage from './pages/errors/maintenance';
import AcceptInvitationPage from './pages/workspace/invite';
import FlowsPage from './pages/dashboard/flows';
import FlowIdPage from './pages/dashboard/flows/[id]';

export const router = createBrowserRouter([
  {
    element: <RootLayout />,
    errorElement: <ErrorBoundary />,
    children: [
      {
        path: '/',
        element: <Navigate to="/auth/login" replace />,
      },
      {
        path: 'auth',
        element: <AuthLayout />,
        children: [
          {
            path: 'login',
            element: <LoginPage />,
          },
          {
            path: 'register',
            element: <RegisterPage />,
          },
          {
            path: 'callback',
            element: <AuthCallbackPage />,
          },
        ],
      },
      {
        path: 'workspace/invite/:token',
        element: <AcceptInvitationPage />,
      },
      {
        path: 'dashboard',
        element: (
          <ProtectedRoute>
            <DashboardLayout />
          </ProtectedRoute>
        ),
        children: [
          {
            index: true,
            element: <DashboardPage />,
          },
          {
            path: 'settings',
            element: <WorkspaceSettingsPage />,
          },

          {
            path: 'flows',
            element: <FlowsPage />,
          },

          {
            path: 'flows/:id',
            element: <FlowIdPage />,
          },
          {
            path: 'spaces',
            element: <div>Spaces Page (Coming Soon)</div>,
          },
          {
            path: 'documents',
            element: <div>Documents Page (Coming Soon)</div>,
          },
          {
            path: 'sources',
            element: <div>Sources Page (Coming Soon)</div>,
          },
          {
            path: 'api-keys',
            element: <div>API Keys Page (Coming Soon)</div>,
          },
          {
            path: 'profile',
            element: <div>Profile Page (Coming Soon)</div>,
          },
        ],
      },
      // Error Pages
      {
        path: 'errors',
        children: [
          {
            path: '404',
            element: <NotFoundPage />,
          },
          {
            path: '500',
            element: <ServerErrorPage />,
          },
          {
            path: '403',
            element: <ForbiddenPage />,
          },
          {
            path: 'offline',
            element: <OfflinePage />,
          },
          {
            path: 'maintenance',
            element: <MaintenancePage />,
          },
        ],
      },
      {
        path: '*',
        element: <NotFoundPage />,
      },
    ],
  },
]);

```

### `apps\frontend\src\store\workspace-store.ts`

```typescript
// src/store/workspace-store.ts
import { create } from 'zustand';
import { persist, createJSONStorage, StateStorage } from 'zustand/middleware';

interface WorkspaceState {
  currentWorkspaceId: string | null;
  setCurrentWorkspaceId: (id: string) => void;
  clearWorkspace: () => void;
}

const encodeWorkspaceId = (id: string): string => {
  return btoa(id);
};

const decodeWorkspaceId = (encoded: string): string => {
  try {
    return atob(encoded);
  } catch {
    return '';
  }
};

const customStorage: StateStorage = {
  getItem: (name: string): string | null => {
    const str = localStorage.getItem(name);
    if (!str) return null;

    try {
      const parsed = JSON.parse(str);
      if (parsed.state?.currentWorkspaceId) {
        parsed.state.currentWorkspaceId = decodeWorkspaceId(parsed.state.currentWorkspaceId);
      }
      return JSON.stringify(parsed);
    } catch {
      return null;
    }
  },
  setItem: (name: string, value: string): void => {
    try {
      const parsed = JSON.parse(value);
      if (parsed.state?.currentWorkspaceId) {
        parsed.state.currentWorkspaceId = encodeWorkspaceId(parsed.state.currentWorkspaceId);
      }
      localStorage.setItem(name, JSON.stringify(parsed));
    } catch (error) {
      console.error('Error saving to storage:', error);
    }
  },
  removeItem: (name: string): void => {
    localStorage.removeItem(name);
  },
};

export const useWorkspaceStore = create<WorkspaceState>()(
  persist(
    (set) => ({
      currentWorkspaceId: null,
      setCurrentWorkspaceId: (id: string) => {
        console.log('ðŸ“Œ Workspace set to:', id);
        set({ currentWorkspaceId: id });
      },
      clearWorkspace: () => set({ currentWorkspaceId: null }),
    }),
    {
      name: 'actopod-workspace',
      storage: createJSONStorage(() => customStorage),
    }
  )
);

```

### `apps\frontend\src\types\auth.ts`

```typescript
export interface User {
  userId: string;
  email: string;
  name: string | null;
  image: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  deviceId: string;
}

export interface LoginData {
  email: string;
  password: string;
}

export interface RegisterData {
  name: string;
  email: string;
  password: string;
}

export interface LoginResponse {
  statusCode: number;
  message: string;
  data: {
    userId: string;
    email: string;
    accessToken: string;
    refreshToken: string;
    deviceId: string;
    deviceName: string;
  };
  errors: any[];
  timestamp: string;
}

export interface UserMeResponse {
  statusCode: number;
  message: string;
  data: {
    userId: string;
    email: string;
    name: string | null;
    image: string | null;
    createdAt: string;
    updatedAt: string;
  };
  errors: any[];
  timestamp: string;
}

```

### `apps\frontend\src\utils\token-utils.ts`

```typescript
import Cookies from 'js-cookie';
import CryptoJS from 'crypto-js';
import { AuthTokens } from '@/types/auth';

// Encryption secret key (secure it in environment variables)
const ENCRYPTION_KEY =
  import.meta.env.VITE_TOKEN_ENCRYPTION_KEY || 'actopod_secure_key_2025_change_in_production';

// Detect environment
const hostname = window.location.hostname;
const isProdHost = hostname !== 'localhost' && !hostname.startsWith('127.0.0.1');

// Shared cookie options
const COOKIE_OPTIONS: Cookies.CookieAttributes = isProdHost
  ? {
      domain: window.location.hostname,
      path: '/',
      secure: true, // HTTPS only
      sameSite: 'None', // cross-site
    }
  : {
      path: '/', // localhost
      secure: false, // allow HTTP in dev
      sameSite: 'Lax', // sane default
    };

// Utility to encrypt data
const encrypt = (data: string): string => CryptoJS.AES.encrypt(data, ENCRYPTION_KEY).toString();

// Utility to decrypt data
const decrypt = (encryptedData: string): string | undefined => {
  try {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    const decrypted = bytes.toString(CryptoJS.enc.Utf8);
    return decrypted || undefined;
  } catch (error) {
    console.error('Failed to decrypt data:', error);
    return undefined;
  }
};

// Utility to set a cookie with encryption
const setCookie = (key: string, value: string, expiresInDays: number): void => {
  const encryptedValue = encrypt(value);
  Cookies.set(key, encryptedValue, {
    expires: expiresInDays,
    ...COOKIE_OPTIONS,
  });
};

// Utility to get a decrypted cookie
const getCookie = (key: string): string | undefined => {
  const encryptedValue = Cookies.get(key);
  if (!encryptedValue) return undefined;
  return decrypt(encryptedValue);
};

// Utility to remove a cookie
const removeCookie = (key: string): void => {
  Cookies.remove(key, COOKIE_OPTIONS);
};

// Keys for our auth cookies
const ACCESS_TOKEN_KEY = 'access_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const DEVICE_ID_KEY = 'device_id';
const DEVICE_NAME_KEY = 'device_name';

/** Store all auth tokens with encryption. */
export const setAuthTokens = (tokens: AuthTokens): void => {
  setCookie(ACCESS_TOKEN_KEY, tokens.accessToken, 1); // 1 day
  setCookie(REFRESH_TOKEN_KEY, tokens.refreshToken, 7); // 7 days
  setCookie(DEVICE_ID_KEY, tokens.deviceId, 7); // 7 days
};

/** Store device name (persists longer). */
export const setDeviceName = (deviceName: string): void => {
  setCookie(DEVICE_NAME_KEY, deviceName, 365); // 1 year
};

/** Get device name. */
export const getDeviceName = (): string | undefined => {
  return getCookie(DEVICE_NAME_KEY);
};

/** Read tokens back out of cookies. */
export const getAuthTokens = (): AuthTokens | null => {
  const accessToken = getCookie(ACCESS_TOKEN_KEY);
  const refreshToken = getCookie(REFRESH_TOKEN_KEY);
  const deviceId = getCookie(DEVICE_ID_KEY);

  if (accessToken && refreshToken && deviceId) {
    return { accessToken, refreshToken, deviceId };
  }
  return null;
};

/** Clear all auth-related cookies. */
export const clearAuthTokens = (): void => {
  removeCookie(ACCESS_TOKEN_KEY);
  removeCookie(REFRESH_TOKEN_KEY);
  removeCookie(DEVICE_ID_KEY);
  // Keep device name even after logout
};

```

---

## Frontend Styles

### `apps\frontend\src\index.css`

```css
@import 'tailwindcss';
@import 'tw-animate-css';

/* Light theme for highlight.js */
@import 'highlight.js/styles/github.css' layer(hljs-light);

/* Dark theme for highlight.js */
@import 'highlight.js/styles/github-dark.css' layer(hljs-dark);

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root:not(.dark) [data-theme='hljs-dark'] {
  display: none;
}

.dark [data-theme='hljs-light'] {
  display: none;
}

:root {
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --radius: 0.65rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.606 0.25 292.717);
  --primary-foreground: oklch(0.969 0.016 293.756);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.606 0.25 292.717);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
}

.dark {
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.439 0 0);
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.541 0.281 293.009);
  --primary-foreground: oklch(0.969 0.016 293.756);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.541 0.281 293.009);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Hide scrollbar utility class */
@layer utilities {
  .no-scrollbar::-webkit-scrollbar {
    display: none;
  }

  .no-scrollbar {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  [data-sidebar]::-webkit-scrollbar {
    display: none;
  }

  [data-sidebar] {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
}

/* ========================================
   âœ… REACT FLOW - NODE & HANDLE STYLES
   ======================================== */

.react-flow__node {
  user-select: none;
  cursor: grab;
}

.react-flow__node:active {
  cursor: grabbing;
}

/* âœ… CRITICAL: Make handles ALWAYS visible */
.react-flow__handle {
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: all !important;
  transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1) !important;
  z-index: 100 !important;
}

.react-flow__handle-connecting {
  background: white !important;
  box-shadow: 0 0 25px hsl(var(--primary)) !important;
  border: 3px solid hsl(var(--primary)) !important;
  transform: scale(1.5) !important;
}

/* âœ… Make handles pop on node hover */
.react-flow__node:hover .react-flow__handle {
  opacity: 1 !important;
  transform: scale(1.2) !important;
  box-shadow: 0 0 15px hsl(var(--primary)) !important;
}

/* ========================================
   âœ… EDGE STYLES
   ======================================== */

.react-flow__edge-path {
  stroke: oklch(0.606 0.25 292.717 / 0.6);
  stroke-width: 2px;
  transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
}

.react-flow__edge.selected .react-flow__edge-path {
  stroke: oklch(0.606 0.25 292.717);
  stroke-width: 3px;
  filter: drop-shadow(0 0 6px oklch(0.606 0.25 292.717 / 0.4));
}

@keyframes dash {
  to {
    stroke-dashoffset: -12;
  }
}

.react-flow__connectionline {
  stroke: oklch(0.606 0.25 292.717) !important;
  stroke-width: 2px !important;
  stroke-dasharray: 6 6;
  animation: dash 1s linear infinite;
}

/* ========================================
   âœ… CONTROLS & MINIMAP
   ======================================== */

.react-flow__controls {
  background: hsl(var(--card) / 0.8) !important;
  backdrop-filter: blur(12px) !important;
  border: 1px solid hsl(var(--border) / 0.5) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 40px -10px oklch(0 0 0 / 0.1) !important;
}

.react-flow__controls-button {
  background: transparent !important;
  border: none !important;
  color: hsl(var(--foreground)) !important;
}

.react-flow__controls-button:hover {
  background: hsl(var(--accent)) !important;
}

.react-flow__minimap {
  background: hsl(var(--card) / 0.6) !important;
  backdrop-filter: blur(12px) !important;
  border: 1px solid hsl(var(--border) / 0.5) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 40px -10px oklch(0 0 0 / 0.1) !important;
}

.react-flow__minimap-mask {
  fill: oklch(0.606 0.25 292.717 / 0.1) !important;
  stroke: oklch(0.606 0.25 292.717 / 0.5) !important;
}

.react-flow__selection {
  background: oklch(0.606 0.25 292.717 / 0.05) !important;
  border: 1px solid oklch(0.606 0.25 292.717 / 0.3) !important;
}

.react-flow__node,
.react-flow__edge {
  transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
}

/* ========================================
   âœ… CODE HIGHLIGHTING
   ======================================== */

pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  background: hsl(var(--muted)) !important;
  color: hsl(var(--foreground)) !important;
}

:root:not(.dark) pre code.hljs {
  --hljs-keyword: #d73a49;
  --hljs-string: #032f62;
  --hljs-comment: #6a737d;
  --hljs-function: #6f42c1;
  --hljs-variable: #e36209;
  --hljs-number: #005cc5;
  --hljs-literal: #0086b3;
}

.dark pre code.hljs {
  --hljs-keyword: #ff7b72;
  --hljs-string: #a5d6ff;
  --hljs-comment: #8b949e;
  --hljs-function: #d2a8ff;
  --hljs-variable: #ffa657;
  --hljs-number: #79c0ff;
  --hljs-literal: #79c0ff;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-built_in {
  color: var(--hljs-keyword) !important;
}
.hljs-string,
.hljs-doctag {
  color: var(--hljs-string) !important;
}
.hljs-comment,
.hljs-quote {
  color: var(--hljs-comment) !important;
  font-style: italic;
}
.hljs-title,
.hljs-section,
.hljs-function {
  color: var(--hljs-function) !important;
  font-weight: 600;
}
.hljs-variable,
.hljs-template-variable,
.hljs-attr {
  color: var(--hljs-variable) !important;
}
.hljs-number,
.hljs-literal {
  color: var(--hljs-number) !important;
}
.hljs-regexp,
.hljs-link {
  color: var(--hljs-string) !important;
}
.hljs-meta {
  color: var(--hljs-comment) !important;
}
.hljs-tag {
  color: var(--hljs-keyword) !important;
}
.hljs-name {
  color: var(--hljs-function) !important;
  font-weight: 600;
}
.hljs-attribute {
  color: var(--hljs-variable) !important;
}
.hljs-symbol,
.hljs-bullet {
  color: var(--hljs-literal) !important;
}
.hljs-addition {
  color: #22863a !important;
  background-color: #f0fff4 !important;
}
.hljs-deletion {
  color: #b31d28 !important;
  background-color: #ffeef0 !important;
}

.dark .hljs-addition {
  color: #aff5b4 !important;
  background-color: #033a16 !important;
}
.dark .hljs-deletion {
  color: #ffdcd7 !important;
  background-color: #67060c !important;
}

/* ========================================
   âœ… TEXT SELECTION & CURSOR CONTROL
   ======================================== */

.select-text,
.select-text * {
  user-select: text !important;
  cursor: text !important;
}

input,
textarea,
[contenteditable] {
  user-select: text;
  cursor: text;
}

.react-flow__node .drag-handle {
  cursor: move !important;
}

.react-flow__node .nodrag {
  cursor: default !important;
  user-select: text !important;
}

.react-flow__node .nodrag * {
  cursor: inherit !important;
}

/* âœ… Allow buttons inside nodes to be clickable */
.react-flow__node .nodrag button {
  cursor: pointer !important;
}

.react-flow__node .nodrag input,
.react-flow__node .nodrag textarea,
.react-flow__node .nodrag [role='button'],
.react-flow__node .nodrag [role='combobox'] {
  cursor: pointer !important;
}

```

---

## Packages - Prisma Schema

### `packages\schema\package.json`

```json
{
  "name": "@actopod/schema",
  "version": "0.0.1",
  "private": true,
  "main": "./index.js",
  "types": "./index.d.ts",
  "exports": {
    ".": {
      "import": "./index.js",
      "require": "./index.js",
      "types": "./index.d.ts"
    }
  },
  "scripts": {
    "build": "prisma generate",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "db:seed:pricing": "ts-node prisma/seed-data/model-pricing.ts",
    "clean": "rimraf node_modules .turbo client"
  },
  "dependencies": {
    "@prisma/client": "^6.17.1",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "prisma": "^6.17.1",
    "rimraf": "^6.0.1",
    "typescript": "^5.9.3"
  }
}

```

### `packages\schema\prisma.config.ts`

```typescript
import 'dotenv/config';
import { defineConfig } from 'prisma/config';

export default defineConfig({
  schema: './prisma',
});

```

### `packages\schema\prisma\admin\admin.prisma`

```prisma
// ==========================================
// ADMIN SCHEMA - Admin Panel & Security
// ==========================================

model Admin {
  id           String @id @default(cuid())
  email        String @unique
  username     String @unique @db.VarChar(50)
  passwordHash String @db.VarChar(255)

  role         AdminRole   @default(SUPPORT)
  status       AdminStatus @default(PENDING)
  isSuperAdmin Boolean     @default(false)

  // MFA
  requiresMfa    Boolean   @default(true)
  mfaSecret      String?   @db.VarChar(255)
  mfaBackupCodes Json?
  mfaVerifiedAt  DateTime? @db.Timestamptz(6)

  // IP whitelisting
  allowedIpAddresses Json?

  // Session tracking
  lastLoginAt         DateTime? @db.Timestamptz(6)
  lastLoginIp         String?   @db.VarChar(45)
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime? @db.Timestamptz(6)

  // Password management
  passwordChangedAt   DateTime? @db.Timestamptz(6)
  passwordResetToken  String?   @unique @db.VarChar(255)
  passwordResetExpiry DateTime? @db.Timestamptz(6)

  createdAt     DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime  @updatedAt @db.Timestamptz(6)
  createdBy     String?
  deactivatedAt DateTime? @db.Timestamptz(6)
  deactivatedBy String?

  sessions    AdminSession[]
  auditLogs   AdminAuditLog[]
  permissions AdminPermission[]
  apiKeys     AdminAPIKey[]
  invitations AdminInvitation[] @relation("InvitedBy")

  @@index([email, status])
  @@index([username])
  @@index([status, role])
  @@index([lastLoginAt])
  @@schema("admin")
}

model AdminSession {
  id                String  @id @default(cuid())
  adminId           String
  token             String  @unique @db.VarChar(255)
  refreshToken      String? @unique @db.VarChar(255)
  ipAddress         String  @db.VarChar(45)
  userAgent         String  @db.VarChar(500)
  deviceFingerprint String? @db.VarChar(255)

  createdAt      DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt      DateTime  @db.Timestamptz(6)
  lastActivityAt DateTime  @default(now()) @db.Timestamptz(6)
  revokedAt      DateTime? @db.Timestamptz(6)
  revokedReason  String?   @db.VarChar(255)

  admin Admin @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId, revokedAt, expiresAt])
  @@index([token])
  @@index([expiresAt])
  @@index([ipAddress, createdAt])
  @@schema("admin")
}

model AdminAuditLog {
  id              String        @id @default(cuid())
  adminId         String?
  action          AdminAction
  resource        AdminResource
  resourceId      String?       @db.VarChar(255)
  method          String        @db.VarChar(10)
  endpoint        String        @db.VarChar(500)
  ipAddress       String        @db.VarChar(45)
  userAgent       String?       @db.VarChar(500)
  changesBefore   Json?
  changesAfter    Json?
  status          Int
  errorMessage    String?       @db.Text
  metadata        Json?
  executionTimeMs Int?
  createdAt       DateTime      @default(now()) @db.Timestamptz(6)

  admin Admin? @relation(fields: [adminId], references: [id], onDelete: SetNull)

  @@index([adminId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
  @@index([resource, resourceId])
  @@index([ipAddress, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@schema("admin")
}

model AdminPermission {
  id         String             @id @default(cuid())
  adminId    String
  permission SpecificPermission
  resource   AdminResource?
  grantedAt  DateTime           @default(now()) @db.Timestamptz(6)
  grantedBy  String?
  expiresAt  DateTime?          @db.Timestamptz(6)

  admin Admin @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@unique([adminId, permission, resource])
  @@index([adminId])
  @@index([permission, resource])
  @@index([expiresAt])
  @@schema("admin")
}

model AdminAPIKey {
  id         String @id @default(cuid())
  adminId    String
  name       String @db.VarChar(100)
  keyHash    String @unique @db.VarChar(255)
  keyPrefix  String @db.VarChar(20)
  scopes     Json
  rateLimit  Int?
  allowedIps Json?

  createdAt  DateTime  @default(now()) @db.Timestamptz(6)
  lastUsedAt DateTime? @db.Timestamptz(6)
  expiresAt  DateTime? @db.Timestamptz(6)
  revokedAt  DateTime? @db.Timestamptz(6)

  admin Admin @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([keyHash])
  @@index([expiresAt, revokedAt])
  @@schema("admin")
}

model AdminInvitation {
  id         String    @id @default(cuid())
  email      String    @db.VarChar(255)
  role       AdminRole
  token      String    @unique @db.VarChar(255)
  invitedBy  String
  createdAt  DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt  DateTime  @db.Timestamptz(6)
  acceptedAt DateTime? @db.Timestamptz(6)

  inviter Admin @relation("InvitedBy", fields: [invitedBy], references: [id])

  @@index([token, expiresAt])
  @@index([email])
  @@schema("admin")
}

model AdminSecurityEvent {
  id          String            @id @default(cuid())
  eventType   SecurityEventType
  severity    SecuritySeverity
  adminId     String?
  ipAddress   String            @db.VarChar(45)
  userAgent   String?           @db.VarChar(500)
  description String            @db.Text
  metadata    Json?
  resolved    Boolean           @default(false)
  resolvedAt  DateTime?         @db.Timestamptz(6)
  resolvedBy  String?
  createdAt   DateTime          @default(now()) @db.Timestamptz(6)

  @@index([eventType, severity, createdAt(sort: Desc)])
  @@index([adminId, createdAt(sort: Desc)])
  @@index([resolved, severity])
  @@index([ipAddress, createdAt(sort: Desc)])
  @@schema("admin")
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  FINANCE
  SUPPORT
  DEVELOPER
  ANALYST

  @@schema("admin")
}

enum AdminStatus {
  PENDING
  ACTIVE
  SUSPENDED
  DEACTIVATED
  LOCKED

  @@schema("admin")
}

enum AdminAction {
  USER_CREATED
  USER_UPDATED
  USER_DELETED
  USER_SUSPENDED
  WORKSPACE_DELETED
  SUBSCRIPTION_UPDATED
  SUBSCRIPTION_CANCELLED
  CREDITS_ADDED
  CREDITS_REMOVED
  REFUND_ISSUED
  MODEL_ADDED
  MODEL_UPDATED
  PRICING_CHANGED
  ADMIN_INVITED
  ADMIN_CREATED
  ADMIN_ROLE_CHANGED
  PERMISSION_GRANTED
  SESSION_REVOKED
  CONFIG_CHANGED
  DATA_EXPORTED

  @@schema("admin")
}

enum AdminResource {
  USER
  WORKSPACE
  SUBSCRIPTION
  CREDIT
  MODEL
  ADMIN
  PERMISSION
  SESSION
  API_KEY
  CANVAS
  ACTION_POD
  DOCUMENT
  AUDIT_LOG
  SYSTEM_CONFIG

  @@schema("admin")
}

enum SpecificPermission {
  USER_VIEW
  USER_UPDATE
  USER_DELETE
  USER_SUSPEND
  WORKSPACE_VIEW
  WORKSPACE_DELETE
  BILLING_VIEW
  BILLING_MANAGE
  CREDITS_MANAGE
  REFUND_ISSUE
  MODEL_VIEW
  MODEL_MANAGE
  PRICING_MANAGE
  ADMIN_VIEW
  ADMIN_INVITE
  ADMIN_MANAGE
  SYSTEM_CONFIG_VIEW
  SYSTEM_CONFIG_MANAGE
  AUDIT_LOG_VIEW
  AUDIT_LOG_EXPORT
  DATA_EXPORT
  DATA_DELETE

  @@schema("admin")
}

enum SecurityEventType {
  FAILED_LOGIN
  MULTIPLE_FAILED_LOGINS
  SUSPICIOUS_IP
  ACCOUNT_LOCKED
  MFA_FAILED
  UNAUTHORIZED_ACCESS_ATTEMPT

  @@schema("admin")
}

enum SecuritySeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL

  @@schema("admin")
}

```

### `packages\schema\prisma\billing\billing.prisma`

```prisma
// ==========================================
// BILLING SCHEMA - Subscriptions & Pricing
// ==========================================

model Subscription {
  id          String             @id @default(cuid())
  workspaceId String             @unique
  tier        SubscriptionTier   @default(HOBBYIST)
  status      SubscriptionStatus @default(ACTIVE)

  stripeCustomerId     String? @unique
  stripeSubscriptionId String? @unique

  credits            Int       @default(0)
  monthlyCreditQuota Int       @default(0)
  creditResetDate    DateTime? @db.Timestamptz(6)

  maxCanvases               Int @default(3)
  maxActionPodsPerCanvas    Int @default(50)
  maxDocumentSizeInMB       Int @default(10)
  maxCollaboratorsPerCanvas Int @default(0)

  canInviteToWorkspace Boolean @default(false)
  canInviteToCanvas    Boolean @default(false)
  canCreatePublicLinks Boolean @default(true)
  canUseAdvancedModels Boolean @default(false)
  canAccessAnalytics   Boolean @default(false)
  canExportData        Boolean @default(false)

  nextBillingDate    DateTime? @db.Timestamptz(6)
  currentPeriodStart DateTime? @db.Timestamptz(6)
  currentPeriodEnd   DateTime? @db.Timestamptz(6)
  cancelAtPeriodEnd  Boolean   @default(false)

  isByokMode Boolean @default(false)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  workspace              Workspace                @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  usageLogs              PodUsageLog[]
  creditPurchases        CreditPurchase[]
  creditUsage            CreditUsageLog[]
  documentProcessingCost DocumentProcessingCost[]

  @@index([status, nextBillingDate])
  @@index([tier, status])
  @@index([creditResetDate])
  @@schema("billing")
}

model CreditPurchase {
  id               String   @id @default(cuid())
  subscriptionId   String
  creditsPurchased Int
  amountPaid       Decimal  @db.Decimal(10, 2)
  currency         String   @default("USD") @db.VarChar(3)
  stripeChargeId   String   @unique
  status           String   @default("succeeded") @db.VarChar(50)
  purchasedAt      DateTime @default(now()) @db.Timestamptz(6)

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId, purchasedAt(sort: Desc)])
  @@index([stripeChargeId])
  @@schema("billing")
}

model CreditUsageLog {
  id             String @id @default(cuid())
  subscriptionId String
  workspaceId    String
  canvasId       String
  podId          String
  executionId    String

  creditsUsed   Int @default(0)
  balanceBefore Int
  balanceAfter  Int

  provider  LLMProvider
  modelId   String      @db.VarChar(255)
  modelName String?     @db.VarChar(255)

  createdAt DateTime @default(now()) @db.Timestamptz(6)

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId, createdAt(sort: Desc)])
  @@index([workspaceId, createdAt(sort: Desc)])
  @@index([executionId])
  @@index([provider, modelId, createdAt(sort: Desc)])
  @@schema("billing")
}

model ModelPricingTier {
  id       String        @id @default(cuid())
  provider LLMProvider
  modelId  String        @db.VarChar(255)
  category ModelCategory

  displayName String  @db.VarChar(255)
  description String? @db.VarChar(500)

  inputTokenCost     Decimal @db.Decimal(12, 8)
  outputTokenCost    Decimal @db.Decimal(12, 8)
  reasoningTokenCost Decimal @default(0) @db.Decimal(12, 8)

  creditsPerMillionInputTokens     Int
  creditsPerMillionOutputTokens    Int
  creditsPerMillionReasoningTokens Int @default(0)

  maxTokens            Int?
  maxOutputTokens      Int?
  supportsStreaming    Boolean @default(true)
  supportsVision       Boolean @default(false)
  supportsAudio        Boolean @default(false)
  supportsVideo        Boolean @default(false)
  supportsFunctions    Boolean @default(false)
  supportsJsonMode     Boolean @default(false)
  supportsSystemPrompt Boolean @default(true)

  providerConfig Json?

  isActive       Boolean   @default(true)
  effectiveFrom  DateTime  @db.Timestamptz(6)
  effectiveUntil DateTime? @db.Timestamptz(6)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  @@unique([provider, modelId, effectiveFrom])
  @@index([provider, modelId, isActive, effectiveFrom])
  @@index([provider, category, isActive])
  @@index([isActive, effectiveFrom])
  @@index([category, isActive])
  @@schema("billing")
}

enum SubscriptionTier {
  HOBBYIST // FREE
  PRO // $20/month
  TEAM // $50/user/month

  @@schema("billing")
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
  INCOMPLETE
  PAUSED

  @@schema("billing")
}

enum ModelCategory {
  WORKHORSE
  POWERHOUSE
  REASONING
  SPECIALIST
  IMAGE_GEN
  VIDEO_GEN
  AUDIO_GEN
  EMBEDDING
  RERANKING
  MODERATION
  SEARCH
  TRANSLATION

  @@schema("billing")
}

```

### `packages\schema\prisma\canvas\canvas.prisma`

```prisma
// /prisma/schemas/canvas.prisma

// ==========================================
// CANVAS SCHEMA - WITH API KEY TRACKING
// ==========================================

model Space {
  id          String  @id @default(cuid())
  workspaceId String
  name        String  @db.VarChar(255)
  description String? @db.VarChar(1000)

  customInstructions String? @db.Text

  icon  String? @db.VarChar(50)
  color String? @db.VarChar(7)

  createdBy String
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  flows     Flow[]

  @@unique([workspaceId, name])
  @@index([workspaceId, updatedAt(sort: Desc)])
  @@index([workspaceId, createdAt(sort: Desc)])
  @@schema("canvas")
}

model Flow {
  id          String         @id @default(cuid())
  workspaceId String
  spaceId     String?
  name        String         @db.VarChar(255)
  description String?        @db.VarChar(500)
  version     Int            @default(1)
  visibility  FlowVisibility @default(PRIVATE)

  createdBy String

  thumbnailS3Key       String?   @db.VarChar(512)
  thumbnailGeneratedAt DateTime? @db.Timestamptz(6)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  workspace      Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  space          Space?             @relation(fields: [spaceId], references: [id], onDelete: SetNull)
  pods           Pod[]
  edges          Edge[]
  contextualPods Pod[]              @relation("FlowAsContext")
  contextModules ContextModule[]    @relation("FlowOriginal")
  collaborators  FlowCollaborator[]
  invitations    FlowInvitation[]
  sessions       FlowSession[]
  activityLog    FlowActivityLog[]
  comments       FlowComment[]

  @@index([spaceId, updatedAt(sort: Desc)])
  @@index([spaceId, createdAt(sort: Desc)])
  @@index([workspaceId, updatedAt(sort: Desc)])
  @@index([workspaceId, createdAt(sort: Desc)])
  @@index([workspaceId, visibility])
  @@index([createdBy, createdAt(sort: Desc)])
  @@schema("canvas")
}

model FlowInvitation {
  id     String @id @default(cuid())
  flowId String
  email  String @db.VarChar(255)

  accessLevel FlowAccessLevel @default(EDITOR)
  permissions Json?

  invitedBy     String
  invitedUserId String?

  token  String           @unique @db.VarChar(255)
  status InvitationStatus @default(PENDING)

  createdAt  DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt  DateTime  @db.Timestamptz(6)
  acceptedAt DateTime? @db.Timestamptz(6)

  flow        Flow  @relation(fields: [flowId], references: [id], onDelete: Cascade)
  inviter     User  @relation("FlowInvitedBy", fields: [invitedBy], references: [id], onDelete: Cascade)
  invitedUser User? @relation("FlowInvitedUser", fields: [invitedUserId], references: [id], onDelete: SetNull)

  @@index([flowId, status])
  @@index([email, status])
  @@index([token, expiresAt])
  @@schema("canvas")
}

model FlowCollaborator {
  id     String @id @default(cuid())
  flowId String
  userId String

  accessLevel FlowAccessLevel @default(EDITOR)

  canEdit    Boolean @default(true)
  canExecute Boolean @default(true)
  canDelete  Boolean @default(false)
  canShare   Boolean @default(false)
  canInvite  Boolean @default(false)

  invitedBy    String?
  invitedAt    DateTime  @default(now()) @db.Timestamptz(6)
  lastViewedAt DateTime? @db.Timestamptz(6)

  flow Flow @relation(fields: [flowId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([flowId, userId])
  @@index([userId])
  @@index([flowId, accessLevel])
  @@schema("canvas")
}

model FlowSession {
  id     String  @id @default(cuid())
  flowId String
  userId String?

  anonymousName String? @db.VarChar(100)
  sessionToken  String? @unique @db.VarChar(255)

  socketId       String? @db.VarChar(255)
  cursorPosition Json?
  selectedPodIds Json?
  viewportState  Json?

  userColor String? @db.VarChar(7)

  userAgent String? @db.VarChar(500)
  ipAddress String? @db.VarChar(45)

  connectedAt     DateTime  @default(now()) @db.Timestamptz(6)
  lastHeartbeatAt DateTime  @default(now()) @db.Timestamptz(6)
  disconnectedAt  DateTime? @db.Timestamptz(6)

  flow Flow @relation(fields: [flowId], references: [id], onDelete: Cascade)

  @@index([flowId, disconnectedAt])
  @@index([socketId])
  @@index([flowId, userId, disconnectedAt])
  @@index([lastHeartbeatAt])
  @@index([sessionToken])
  @@schema("canvas")
}

model FlowActivityLog {
  id     String  @id @default(cuid())
  flowId String
  userId String?

  action FlowActivityAction

  entityType String? @db.VarChar(50)
  entityId   String? @db.VarChar(255)

  changeData Json?

  createdAt DateTime @default(now()) @db.Timestamptz(6)

  flow Flow @relation(fields: [flowId], references: [id], onDelete: Cascade)

  @@index([flowId, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
  @@schema("canvas")
}

model FlowComment {
  id     String  @id @default(cuid())
  flowId String
  userId String?

  content  String  @db.Text
  position Json?
  podId    String?

  parentId String?

  isResolved Boolean   @default(false)
  resolvedBy String?
  resolvedAt DateTime? @db.Timestamptz(6)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  flow Flow @relation(fields: [flowId], references: [id], onDelete: Cascade)

  @@index([flowId, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([podId])
  @@index([parentId])
  @@index([isResolved])
  @@schema("canvas")
}

model Pod {
  id              String             @id @default(cuid())
  flowId          String
  type            PodType
  position        Json
  executionStatus PodExecutionStatus @default(IDLE)
  lastExecutionId String?
  contextFlowId   String?
  documentId      String?

  lockedBy String?
  lockedAt DateTime? @db.Timestamptz(6)

  dynamoPartitionKey String @db.VarChar(255)
  dynamoSortKey      String @db.VarChar(255)

  s3VectorBucket String? @db.VarChar(255)
  s3VectorKey    String? @db.VarChar(512)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  flow        Flow           @relation(fields: [flowId], references: [id], onDelete: Cascade)
  contextFlow Flow?          @relation("FlowAsContext", fields: [contextFlowId], references: [id], onDelete: SetNull)
  document    Document?      @relation(fields: [documentId], references: [id], onDelete: SetNull)
  sourceEdges Edge[]         @relation("SourcePod")
  targetEdges Edge[]         @relation("TargetPod")
  executions  PodExecution[]
  usageLogs   PodUsageLog[]

  @@unique([dynamoPartitionKey, dynamoSortKey])
  @@index([flowId, type, executionStatus])
  @@index([contextFlowId])
  @@index([documentId])
  @@index([executionStatus, updatedAt])
  @@index([s3VectorBucket, s3VectorKey])
  @@index([lockedBy, lockedAt])
  @@schema("canvas")
}

model Edge {
  id           String   @id @default(cuid())
  flowId       String
  sourcePodId  String
  targetPodId  String
  sourceHandle String?  @db.VarChar(100)
  targetHandle String?  @db.VarChar(100)
  animated     Boolean  @default(false)
  createdAt    DateTime @default(now()) @db.Timestamptz(6)

  flow      Flow @relation(fields: [flowId], references: [id], onDelete: Cascade)
  sourcePod Pod  @relation("SourcePod", fields: [sourcePodId], references: [id], onDelete: Cascade)
  targetPod Pod  @relation("TargetPod", fields: [targetPodId], references: [id], onDelete: Cascade)

  @@unique([flowId, sourcePodId, sourceHandle, targetPodId, targetHandle])
  @@index([flowId])
  @@index([sourcePodId])
  @@index([targetPodId])
  @@schema("canvas")
}

// ==========================================
// POD EXECUTION - NOW TRACKS WHICH API KEY WAS USED
// ==========================================

model PodExecution {
  id          String             @id @default(cuid())
  podId       String
  flowId      String
  workspaceId String
  status      PodExecutionStatus @default(RUNNING)
  startedAt   DateTime           @default(now()) @db.Timestamptz(6)
  finishedAt  DateTime?          @db.Timestamptz(6)
  runtimeInMs Int?

  // âœ… NEW: Track which API key was used
  apiKeyId String? // Which workspace API key was used

  provider  LLMProvider
  modelId   String      @db.VarChar(255)
  modelName String?     @db.VarChar(255)

  providerMetadata Json?
  requestMetadata  Json?
  responseMetadata Json?

  errorMessage String? @db.Text
  errorCode    String? @db.VarChar(100)

  inputTokens     Int @default(0)
  outputTokens    Int @default(0)
  reasoningTokens Int @default(0)

  creditsConsumed Int @default(0)

  costInUsd Decimal? @db.Decimal(12, 8)

  pod    Pod             @relation(fields: [podId], references: [id], onDelete: Cascade)
  apiKey ProviderAPIKey? @relation(fields: [apiKeyId], references: [id], onDelete: SetNull) // âœ… NEW relation

  @@index([podId, startedAt(sort: Desc)])
  @@index([workspaceId, status, startedAt(sort: Desc)])
  @@index([flowId, status, startedAt(sort: Desc)])
  @@index([status, startedAt])
  @@index([provider, modelId, startedAt(sort: Desc)])
  @@index([provider, status])
  @@index([apiKeyId, startedAt(sort: Desc)]) // âœ… NEW: Query by API key
  @@schema("canvas")
}

// ==========================================
// POD USAGE LOG - NOW TRACKS WHICH API KEY WAS USED
// ==========================================

model PodUsageLog {
  id             String @id @default(cuid())
  podId          String
  executionId    String
  flowId         String
  workspaceId    String
  subscriptionId String

  // âœ… NEW: Track which API key was used
  apiKeyId String? // Which workspace API key was used

  provider  LLMProvider
  modelId   String      @db.VarChar(255)
  modelName String?     @db.VarChar(255)

  providerMetadata Json?

  inputTokens     Int  @default(0)
  outputTokens    Int  @default(0)
  reasoningTokens Int  @default(0)
  creditsConsumed Int  @default(0)
  runtimeInMs     Int?

  inputTokenCost     Decimal @db.Decimal(12, 8)
  outputTokenCost    Decimal @db.Decimal(12, 8)
  reasoningTokenCost Decimal @db.Decimal(12, 8)
  totalCostInUsd     Decimal @db.Decimal(12, 8)

  executedAt DateTime @default(now()) @db.Timestamptz(6)

  pod          Pod             @relation(fields: [podId], references: [id], onDelete: Cascade)
  subscription Subscription    @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  apiKey       ProviderAPIKey? @relation(fields: [apiKeyId], references: [id], onDelete: SetNull) // âœ… NEW relation

  @@index([workspaceId, executedAt(sort: Desc)])
  @@index([subscriptionId, executedAt(sort: Desc)])
  @@index([executionId])
  @@index([podId, executedAt(sort: Desc)])
  @@index([flowId, executedAt(sort: Desc)])
  @@index([provider, modelId, executedAt(sort: Desc)])
  @@index([provider, executedAt(sort: Desc)])
  @@index([apiKeyId, executedAt(sort: Desc)]) // âœ… NEW: Query by API key
  @@schema("canvas")
}

model ContextModule {
  id             String   @id @default(cuid())
  workspaceId    String
  name           String   @db.VarChar(255)
  description    String?  @db.VarChar(1000)
  definitionJson Json
  originalFlowId String?
  version        Int      @default(1)
  createdAt      DateTime @default(now()) @db.Timestamptz(6)
  updatedAt      DateTime @updatedAt @db.Timestamptz(6)

  workspace    Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  originalFlow Flow?     @relation("FlowOriginal", fields: [originalFlowId], references: [id], onDelete: SetNull)

  @@index([workspaceId, updatedAt(sort: Desc)])
  @@index([originalFlowId])
  @@schema("canvas")
}

enum PodType {
  TEXT_INPUT
  DOCUMENT_INPUT
  URL_INPUT
  IMAGE_INPUT
  VIDEO_INPUT
  AUDIO_INPUT
  LLM_PROMPT
  EMBEDDING_POD
  TOOL_POD
  TEXT_OUTPUT
  IMAGE_OUTPUT
  VIDEO_OUTPUT
  AUDIO_OUTPUT
  CONTEXT_MODULE
  FLOW_CONTEXT_INPUT
  CODE_EXECUTION

  @@schema("canvas")
}

enum PodExecutionStatus {
  IDLE
  QUEUED
  RUNNING
  PAUSED
  COMPLETED
  ERROR
  CANCELLED

  @@schema("canvas")
}

enum FlowVisibility {
  PRIVATE
  WORKSPACE
  PUBLIC

  @@schema("canvas")
}

enum FlowAccessLevel {
  VIEWER
  COMMENTER
  EDITOR
  OWNER

  @@schema("canvas")
}

enum FlowActivityAction {
  FLOW_CREATED
  FLOW_UPDATED
  FLOW_DELETED
  FLOW_SHARED
  FLOW_VISIBILITY_CHANGED
  POD_CREATED
  POD_UPDATED
  POD_DELETED
  POD_MOVED
  POD_EXECUTED
  POD_LOCKED
  POD_UNLOCKED
  EDGE_CREATED
  EDGE_DELETED
  COLLABORATOR_ADDED
  COLLABORATOR_REMOVED
  COLLABORATOR_PERMISSIONS_CHANGED
  COMMENT_ADDED
  COMMENT_RESOLVED
  USER_JOINED
  USER_LEFT

  @@schema("canvas")
}

```

### `packages\schema\prisma\core\core.prisma`

```prisma
// /prisma/schemas/core.prisma

// ==========================================
// CORE SCHEMA - MINIMAL WITH USAGE TRACKING
// ==========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  hash      String?  @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  accounts                 Account[]
  workspaces               WorkspaceUser[]
  refreshTokens            RefreshToken[]
  notifications            Notification[]
  flowCollaborations       FlowCollaborator[]
  sentWorkspaceInvites     WorkspaceInvitation[] @relation("InvitedBy")
  receivedWorkspaceInvites WorkspaceInvitation[] @relation("InvitedUser")
  sentFlowInvites          FlowInvitation[]      @relation("FlowInvitedBy")
  receivedFlowInvites      FlowInvitation[]      @relation("FlowInvitedUser")
  createdApiKeys           ProviderAPIKey[]

  @@index([email])
  @@schema("core")
}

model RefreshToken {
  id         String   @id @default(cuid())
  token      String   @unique
  deviceName String   @db.VarChar(255)
  userId     String
  expiresAt  DateTime @db.Timestamptz(6)
  createdAt  DateTime @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime @updatedAt @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceName])
  @@index([userId, expiresAt])
  @@index([token, expiresAt])
  @@schema("core")
}

model Account {
  id                String       @id @default(cuid())
  userId            String
  provider          AuthProvider
  providerAccountId String
  accessToken       String?      @db.Text
  refreshToken      String?      @db.Text
  expiresAt         DateTime?    @db.Timestamptz(6)
  createdAt         DateTime     @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@schema("core")
}

model Workspace {
  id        String        @id @default(cuid())
  name      String        @db.VarChar(255)
  type      WorkspaceType @default(PERSONAL)
  createdAt DateTime      @default(now()) @db.Timestamptz(6)
  updatedAt DateTime      @updatedAt @db.Timestamptz(6)

  members         WorkspaceUser[]
  spaces          Space[]
  flows           Flow[]
  documents       Document[]
  documentFolders DocumentFolder[]
  subscription    Subscription?
  contextModules  ContextModule[]
  shareLinks      ShareLink[]
  apiKeys         ProviderAPIKey[]
  invitations     WorkspaceInvitation[]
  usageMetrics    UsageMetric[]

  @@index([type, createdAt])
  @@schema("core")
}

model WorkspaceUser {
  id          String        @id @default(cuid())
  userId      String
  workspaceId String
  role        WorkspaceRole @default(MEMBER)

  canCreateCanvas  Boolean @default(true)
  canDeleteCanvas  Boolean @default(false)
  canManageBilling Boolean @default(false)
  canInviteMembers Boolean @default(false)
  canManageMembers Boolean @default(false)
  canManageApiKeys Boolean @default(false)

  joinedAt  DateTime @default(now()) @db.Timestamptz(6)
  invitedBy String?

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([userId, workspaceId])
  @@index([workspaceId, role])
  @@index([userId])
  @@schema("core")
}

model WorkspaceInvitation {
  id          String        @id @default(cuid())
  workspaceId String
  email       String        @db.VarChar(255)
  role        WorkspaceRole @default(MEMBER)
  permissions Json?

  invitedBy     String
  invitedUserId String?

  token  String           @unique @db.VarChar(255)
  status InvitationStatus @default(PENDING)

  createdAt  DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt  DateTime  @db.Timestamptz(6)
  acceptedAt DateTime? @db.Timestamptz(6)

  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  inviter     User      @relation("InvitedBy", fields: [invitedBy], references: [id], onDelete: Cascade)
  invitedUser User?     @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: SetNull)

  @@index([workspaceId, status])
  @@index([email, status])
  @@index([token, expiresAt])
  @@schema("core")
}

// ==========================================
// API KEY WITH USAGE TRACKING
// ==========================================

model ProviderAPIKey {
  id          String      @id @default(cuid())
  workspaceId String
  provider    LLMProvider
  displayName String      @db.VarChar(100)

  // Encrypted storage (format: iv:authTag:encrypted)
  keyHash String @db.VarChar(500)

  // Status
  isActive Boolean @default(true)

  // Usage tracking
  lastUsedAt  DateTime? @db.Timestamptz(6)
  usageCount  Int       @default(0)
  totalTokens BigInt    @default(0)
  totalCost   Decimal   @default(0) @db.Decimal(12, 6)

  // Error tracking
  lastErrorAt DateTime? @db.Timestamptz(6)

  // Timestamps
  createdById String
  createdAt   DateTime @default(now()) @db.Timestamptz(6)

  // Relations
  workspace     Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdBy     User           @relation(fields: [createdById], references: [id], onDelete: Restrict)
  usageMetrics  UsageMetric[]
  podExecutions PodExecution[]
  podUsageLogs  PodUsageLog[]

  @@unique([workspaceId, provider, displayName])
  @@index([workspaceId, isActive])
  @@schema("core")
}

// ==========================================
// USAGE METRICS - DAILY BREAKDOWN
// ==========================================

model UsageMetric {
  id          String   @id @default(cuid())
  workspaceId String
  keyId       String
  date        DateTime @db.Date

  // Request counts
  requestCount Int @default(0)
  successCount Int @default(0)
  errorCount   Int @default(0)

  // Token usage
  promptTokens     BigInt @default(0)
  completionTokens BigInt @default(0)
  totalTokens      BigInt @default(0)

  // Cost tracking
  estimatedCost Decimal @default(0) @db.Decimal(12, 6)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  workspace Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  apiKey    ProviderAPIKey @relation(fields: [keyId], references: [id], onDelete: Cascade)

  @@unique([keyId, date])
  @@index([workspaceId, date])
  @@index([keyId, date])
  @@schema("core")
}

model ShareLink {
  id          String             @id @default(cuid())
  publicToken String             @unique @default(cuid())
  assetType   ShareableAssetType
  assetId     String
  workspaceId String
  createdBy   String

  accessLevel ShareAccessLevel @default(VIEW_ONLY)
  password    String?          @db.VarChar(255)

  viewCount    Int       @default(0)
  lastViewedAt DateTime? @db.Timestamptz(6)

  createdAt DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt DateTime? @db.Timestamptz(6)

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([assetType, assetId])
  @@index([publicToken, expiresAt])
  @@index([workspaceId, assetType])
  @@index([createdBy, createdAt])
  @@schema("core")
}


model Notification {
  id     String           @id @default(cuid())
  userId String
  type   NotificationType
  title  String           @db.VarChar(255)
  body   String           @db.Text

  // Reference to related entity
  entityType String?        @db.VarChar(50)
  entityId   String?

  // Metadata (invitation IDs, workspace IDs, etc.)
  metadata Json?

  isRead     Boolean  @default(false)
  readAt     DateTime? @db.Timestamptz(6)
  actionUrl  String?   @db.VarChar(500)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  expiresAt DateTime? @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead, createdAt])
  @@index([userId, type, isRead])
  @@schema("core")
}


// ==========================================
// ENUMS
// ==========================================

enum AuthProvider {
  GOOGLE
  GITHUB
  EMAIL

  @@schema("core")
}



enum NotificationType {
  WORKSPACE_INVITATION
  WORKSPACE_MEMBER_JOINED
  WORKSPACE_MEMBER_LEFT
  WORKSPACE_ROLE_CHANGED
  FLOW_INVITATION
  FLOW_SHARED
  MENTION
  COMMENT
  SYSTEM

  @@schema("core")
}


enum WorkspaceType {
  PERSONAL
  TEAM

  @@schema("core")
}

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER

  @@schema("core")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  REVOKED

  @@schema("core")
}

enum ShareAccessLevel {
  VIEW_ONLY
  COMMENT
  EDIT

  @@schema("core")
}

enum LLMProvider {
  OPENAI
  ANTHROPIC
  GOOGLE_GEMINI
  PERPLEXITY
  MISTRAL
  COHERE
  GROQ
  XAI
  DEEPSEEK
  CUSTOM

  @@schema("core")
}

enum ShareableAssetType {
  FLOW
  CONTEXT_MODULE

  @@schema("core")
}

```

### `packages\schema\prisma\documents\documents.prisma`

```prisma
// /prisma/schemas/documents.prisma

// ==========================================
// DOCUMENTS SCHEMA - File Storage, Embeddings & Processing
// ==========================================

// Document Folders (like Google Drive folders)
model DocumentFolder {
  id          String @id @default(cuid())
  workspaceId String
  name        String @db.VarChar(255)

  // Self-referential for nested folders (folder within folder)
  parentId String?
  parent   DocumentFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children DocumentFolder[] @relation("FolderHierarchy")

  icon  String? @db.VarChar(50)
  color String? @db.VarChar(7)

  sortOrder Int @default(0)

  createdBy String
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  workspace Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  documents Document[] // Documents in this folder

  @@unique([workspaceId, parentId, name])
  @@index([workspaceId, parentId, sortOrder])
  @@index([parentId, sortOrder])
  @@schema("documents")
}

model Document {
  id          String  @id @default(cuid())
  workspaceId String
  folderId    String? // Optional folder location
  name        String  @db.VarChar(255)

  sourceType DocumentSourceType @default(INTERNAL)

  // For INTERNAL (uploaded files)
  storageKey String? @unique @db.VarChar(512)
  s3Bucket   String? @db.VarChar(255)

  // For EXTERNAL (YouTube, Google Drive, URLs, etc.)
  externalUrl      String? @db.VarChar(2048)
  externalProvider String? @db.VarChar(50)
  externalFileId   String? @db.VarChar(512)

  fileType    String         @db.VarChar(100)
  mimeType    String?        @db.VarChar(255)
  sizeInBytes BigInt?
  status      DocumentStatus @default(UPLOADING)
  uploadedBy  String?

  metadata Json? // Store thumbnails, duration, channel info, etc.

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  workspace             Workspace                @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  folder                DocumentFolder?          @relation(fields: [folderId], references: [id], onDelete: SetNull)
  embeddings            Embedding[]
  pods                  Pod[]
  processingCostRecords DocumentProcessingCost[]

  @@index([workspaceId, folderId, status, createdAt(sort: Desc)])
  @@index([workspaceId, status, createdAt(sort: Desc)])
  @@index([workspaceId, sourceType, createdAt(sort: Desc)])
  @@index([folderId, createdAt(sort: Desc)])
  @@index([storageKey])
  @@index([status, updatedAt])
  @@index([fileType, workspaceId])
  @@index([externalProvider, externalFileId])
  @@schema("documents")
}

model Embedding {
  id         String @id @default(cuid())
  documentId String
  model      String @db.VarChar(100)
  chunkIndex Int
  chunkText  String @db.Text

  // S3 Vectors - AWS S3 storage (NOT pgvector)
  s3VectorBucket  String @db.VarChar(255)
  s3VectorKey     String @db.VarChar(512)
  vectorDimension Int    @default(1536)

  metadata Json?

  createdAt DateTime @default(now()) @db.Timestamptz(6)

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@unique([s3VectorBucket, s3VectorKey])
  @@index([documentId, createdAt(sort: Desc)])
  @@index([model, createdAt(sort: Desc)])
  @@index([s3VectorBucket])
  @@schema("documents")
}

model DocumentProcessingCost {
  id             String @id @default(cuid())
  documentId     String
  workspaceId    String
  subscriptionId String

  processingType DocumentProcessingType

  creditsConsumed Int @default(0)

  // Cost breakdown
  extractionCost Decimal @default(0) @db.Decimal(12, 8) // YouTube transcript, OCR, etc.
  embeddingCost  Decimal @default(0) @db.Decimal(12, 8) // Embedding generation cost
  totalCostInUsd Decimal @db.Decimal(12, 8)

  // Processing stats
  chunkCount       Int?
  embeddingModel   String? @db.VarChar(100)
  processingTimeMs Int?
  tokensProcessed  Int     @default(0)

  processedAt DateTime @default(now()) @db.Timestamptz(6)

  document     Document     @relation(fields: [documentId], references: [id], onDelete: Cascade)
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([documentId, processedAt(sort: Desc)])
  @@index([workspaceId, processedAt(sort: Desc)])
  @@index([subscriptionId, processedAt(sort: Desc)])
  @@index([processingType, processedAt(sort: Desc)])
  @@schema("documents")
}

enum DocumentStatus {
  UPLOADING
  PROCESSING
  READY
  ERROR
  ARCHIVED

  @@schema("documents")
}

enum DocumentSourceType {
  INTERNAL
  GOOGLE_DRIVE
  YOUTUBE
  VIMEO
  LOOM
  URL

  @@schema("documents")
}

enum DocumentProcessingType {
  PDF_TEXT_EXTRACTION
  IMAGE_OCR
  VIDEO_TRANSCRIPT // YouTube, Vimeo, Loom
  AUDIO_TRANSCRIPT
  DOCUMENT_EMBEDDING // General embedding generation
  URL_SCRAPING
  VISION_EXTRACTION // Image description via GPT-4V/Claude Vision

  @@schema("documents")
}

```

### `packages\schema\prisma\migrations\20251016141950_init\migration.sql`

```sql
-- CreateSchema
CREATE SCHEMA IF NOT EXISTS "admin";

-- CreateSchema
CREATE SCHEMA IF NOT EXISTS "billing";

-- CreateSchema
CREATE SCHEMA IF NOT EXISTS "canvas";

-- CreateSchema
CREATE SCHEMA IF NOT EXISTS "core";

-- CreateSchema
CREATE SCHEMA IF NOT EXISTS "documents";

-- CreateEnum
CREATE TYPE "admin"."AdminRole" AS ENUM ('SUPER_ADMIN', 'ADMIN', 'FINANCE', 'SUPPORT', 'DEVELOPER', 'ANALYST');

-- CreateEnum
CREATE TYPE "admin"."AdminStatus" AS ENUM ('PENDING', 'ACTIVE', 'SUSPENDED', 'DEACTIVATED', 'LOCKED');

-- CreateEnum
CREATE TYPE "admin"."AdminAction" AS ENUM ('USER_CREATED', 'USER_UPDATED', 'USER_DELETED', 'USER_SUSPENDED', 'WORKSPACE_DELETED', 'SUBSCRIPTION_UPDATED', 'SUBSCRIPTION_CANCELLED', 'CREDITS_ADDED', 'CREDITS_REMOVED', 'REFUND_ISSUED', 'MODEL_ADDED', 'MODEL_UPDATED', 'PRICING_CHANGED', 'ADMIN_INVITED', 'ADMIN_CREATED', 'ADMIN_ROLE_CHANGED', 'PERMISSION_GRANTED', 'SESSION_REVOKED', 'CONFIG_CHANGED', 'DATA_EXPORTED');

-- CreateEnum
CREATE TYPE "admin"."AdminResource" AS ENUM ('USER', 'WORKSPACE', 'SUBSCRIPTION', 'CREDIT', 'MODEL', 'ADMIN', 'PERMISSION', 'SESSION', 'API_KEY', 'CANVAS', 'ACTION_POD', 'DOCUMENT', 'AUDIT_LOG', 'SYSTEM_CONFIG');

-- CreateEnum
CREATE TYPE "admin"."SpecificPermission" AS ENUM ('USER_VIEW', 'USER_UPDATE', 'USER_DELETE', 'USER_SUSPEND', 'WORKSPACE_VIEW', 'WORKSPACE_DELETE', 'BILLING_VIEW', 'BILLING_MANAGE', 'CREDITS_MANAGE', 'REFUND_ISSUE', 'MODEL_VIEW', 'MODEL_MANAGE', 'PRICING_MANAGE', 'ADMIN_VIEW', 'ADMIN_INVITE', 'ADMIN_MANAGE', 'SYSTEM_CONFIG_VIEW', 'SYSTEM_CONFIG_MANAGE', 'AUDIT_LOG_VIEW', 'AUDIT_LOG_EXPORT', 'DATA_EXPORT', 'DATA_DELETE');

-- CreateEnum
CREATE TYPE "admin"."SecurityEventType" AS ENUM ('FAILED_LOGIN', 'MULTIPLE_FAILED_LOGINS', 'SUSPICIOUS_IP', 'ACCOUNT_LOCKED', 'MFA_FAILED', 'UNAUTHORIZED_ACCESS_ATTEMPT');

-- CreateEnum
CREATE TYPE "admin"."SecuritySeverity" AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL');

-- CreateEnum
CREATE TYPE "billing"."SubscriptionTier" AS ENUM ('HOBBYIST', 'PRO', 'TEAM');

-- CreateEnum
CREATE TYPE "billing"."SubscriptionStatus" AS ENUM ('ACTIVE', 'CANCELED', 'PAST_DUE', 'TRIALING', 'INCOMPLETE', 'PAUSED');

-- CreateEnum
CREATE TYPE "billing"."ModelCategory" AS ENUM ('WORKHORSE', 'POWERHOUSE', 'REASONING', 'SPECIALIST', 'IMAGE_GEN', 'VIDEO_GEN', 'AUDIO_GEN', 'EMBEDDING', 'RERANKING', 'MODERATION', 'SEARCH', 'TRANSLATION');

-- CreateEnum
CREATE TYPE "canvas"."PodType" AS ENUM ('TEXT_INPUT', 'DOCUMENT_INPUT', 'URL_INPUT', 'IMAGE_INPUT', 'VIDEO_INPUT', 'AUDIO_INPUT', 'LLM_PROMPT', 'EMBEDDING_POD', 'TOOL_POD', 'TEXT_OUTPUT', 'IMAGE_OUTPUT', 'VIDEO_OUTPUT', 'AUDIO_OUTPUT', 'CONTEXT_MODULE', 'FLOW_CONTEXT_INPUT', 'CODE_EXECUTION');

-- CreateEnum
CREATE TYPE "canvas"."PodExecutionStatus" AS ENUM ('IDLE', 'QUEUED', 'RUNNING', 'PAUSED', 'COMPLETED', 'ERROR', 'CANCELLED');

-- CreateEnum
CREATE TYPE "canvas"."FlowVisibility" AS ENUM ('PRIVATE', 'WORKSPACE', 'PUBLIC');

-- CreateEnum
CREATE TYPE "canvas"."FlowAccessLevel" AS ENUM ('VIEWER', 'COMMENTER', 'EDITOR', 'OWNER');

-- CreateEnum
CREATE TYPE "canvas"."FlowActivityAction" AS ENUM ('FLOW_CREATED', 'FLOW_UPDATED', 'FLOW_DELETED', 'FLOW_SHARED', 'FLOW_VISIBILITY_CHANGED', 'POD_CREATED', 'POD_UPDATED', 'POD_DELETED', 'POD_MOVED', 'POD_EXECUTED', 'POD_LOCKED', 'POD_UNLOCKED', 'EDGE_CREATED', 'EDGE_DELETED', 'COLLABORATOR_ADDED', 'COLLABORATOR_REMOVED', 'COLLABORATOR_PERMISSIONS_CHANGED', 'COMMENT_ADDED', 'COMMENT_RESOLVED', 'USER_JOINED', 'USER_LEFT');

-- CreateEnum
CREATE TYPE "core"."AuthProvider" AS ENUM ('GOOGLE', 'GITHUB', 'EMAIL');

-- CreateEnum
CREATE TYPE "core"."NotificationType" AS ENUM ('WORKSPACE_INVITATION', 'WORKSPACE_MEMBER_JOINED', 'WORKSPACE_MEMBER_LEFT', 'WORKSPACE_ROLE_CHANGED', 'FLOW_INVITATION', 'FLOW_SHARED', 'MENTION', 'COMMENT', 'SYSTEM');

-- CreateEnum
CREATE TYPE "core"."WorkspaceType" AS ENUM ('PERSONAL', 'TEAM');

-- CreateEnum
CREATE TYPE "core"."WorkspaceRole" AS ENUM ('OWNER', 'ADMIN', 'MEMBER', 'VIEWER');

-- CreateEnum
CREATE TYPE "core"."InvitationStatus" AS ENUM ('PENDING', 'ACCEPTED', 'DECLINED', 'EXPIRED', 'REVOKED');

-- CreateEnum
CREATE TYPE "core"."ShareAccessLevel" AS ENUM ('VIEW_ONLY', 'COMMENT', 'EDIT');

-- CreateEnum
CREATE TYPE "core"."LLMProvider" AS ENUM ('OPENAI', 'ANTHROPIC', 'GOOGLE_GEMINI', 'PERPLEXITY', 'MISTRAL', 'COHERE', 'GROQ', 'XAI', 'DEEPSEEK', 'CUSTOM');

-- CreateEnum
CREATE TYPE "core"."ShareableAssetType" AS ENUM ('FLOW', 'CONTEXT_MODULE');

-- CreateEnum
CREATE TYPE "documents"."DocumentStatus" AS ENUM ('UPLOADING', 'PROCESSING', 'READY', 'ERROR', 'ARCHIVED');

-- CreateEnum
CREATE TYPE "documents"."DocumentSourceType" AS ENUM ('INTERNAL', 'GOOGLE_DRIVE', 'YOUTUBE', 'VIMEO', 'LOOM', 'URL');

-- CreateEnum
CREATE TYPE "documents"."DocumentProcessingType" AS ENUM ('PDF_TEXT_EXTRACTION', 'IMAGE_OCR', 'VIDEO_TRANSCRIPT', 'AUDIO_TRANSCRIPT', 'DOCUMENT_EMBEDDING', 'URL_SCRAPING', 'VISION_EXTRACTION');

-- CreateTable
CREATE TABLE "admin"."Admin" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "username" VARCHAR(50) NOT NULL,
    "passwordHash" VARCHAR(255) NOT NULL,
    "role" "admin"."AdminRole" NOT NULL DEFAULT 'SUPPORT',
    "status" "admin"."AdminStatus" NOT NULL DEFAULT 'PENDING',
    "isSuperAdmin" BOOLEAN NOT NULL DEFAULT false,
    "requiresMfa" BOOLEAN NOT NULL DEFAULT true,
    "mfaSecret" VARCHAR(255),
    "mfaBackupCodes" JSONB,
    "mfaVerifiedAt" TIMESTAMPTZ(6),
    "allowedIpAddresses" JSONB,
    "lastLoginAt" TIMESTAMPTZ(6),
    "lastLoginIp" VARCHAR(45),
    "failedLoginAttempts" INTEGER NOT NULL DEFAULT 0,
    "lockedUntil" TIMESTAMPTZ(6),
    "passwordChangedAt" TIMESTAMPTZ(6),
    "passwordResetToken" VARCHAR(255),
    "passwordResetExpiry" TIMESTAMPTZ(6),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,
    "createdBy" TEXT,
    "deactivatedAt" TIMESTAMPTZ(6),
    "deactivatedBy" TEXT,

    CONSTRAINT "Admin_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "admin"."AdminSession" (
    "id" TEXT NOT NULL,
    "adminId" TEXT NOT NULL,
    "token" VARCHAR(255) NOT NULL,
    "refreshToken" VARCHAR(255),
    "ipAddress" VARCHAR(45) NOT NULL,
    "userAgent" VARCHAR(500) NOT NULL,
    "deviceFingerprint" VARCHAR(255),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMPTZ(6) NOT NULL,
    "lastActivityAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "revokedAt" TIMESTAMPTZ(6),
    "revokedReason" VARCHAR(255),

    CONSTRAINT "AdminSession_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "admin"."AdminAuditLog" (
    "id" TEXT NOT NULL,
    "adminId" TEXT,
    "action" "admin"."AdminAction" NOT NULL,
    "resource" "admin"."AdminResource" NOT NULL,
    "resourceId" VARCHAR(255),
    "method" VARCHAR(10) NOT NULL,
    "endpoint" VARCHAR(500) NOT NULL,
    "ipAddress" VARCHAR(45) NOT NULL,
    "userAgent" VARCHAR(500),
    "changesBefore" JSONB,
    "changesAfter" JSONB,
    "status" INTEGER NOT NULL,
    "errorMessage" TEXT,
    "metadata" JSONB,
    "executionTimeMs" INTEGER,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AdminAuditLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "admin"."AdminPermission" (
    "id" TEXT NOT NULL,
    "adminId" TEXT NOT NULL,
    "permission" "admin"."SpecificPermission" NOT NULL,
    "resource" "admin"."AdminResource",
    "grantedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "grantedBy" TEXT,
    "expiresAt" TIMESTAMPTZ(6),

    CONSTRAINT "AdminPermission_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "admin"."AdminAPIKey" (
    "id" TEXT NOT NULL,
    "adminId" TEXT NOT NULL,
    "name" VARCHAR(100) NOT NULL,
    "keyHash" VARCHAR(255) NOT NULL,
    "keyPrefix" VARCHAR(20) NOT NULL,
    "scopes" JSONB NOT NULL,
    "rateLimit" INTEGER,
    "allowedIps" JSONB,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastUsedAt" TIMESTAMPTZ(6),
    "expiresAt" TIMESTAMPTZ(6),
    "revokedAt" TIMESTAMPTZ(6),

    CONSTRAINT "AdminAPIKey_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "admin"."AdminInvitation" (
    "id" TEXT NOT NULL,
    "email" VARCHAR(255) NOT NULL,
    "role" "admin"."AdminRole" NOT NULL,
    "token" VARCHAR(255) NOT NULL,
    "invitedBy" TEXT NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMPTZ(6) NOT NULL,
    "acceptedAt" TIMESTAMPTZ(6),

    CONSTRAINT "AdminInvitation_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "admin"."AdminSecurityEvent" (
    "id" TEXT NOT NULL,
    "eventType" "admin"."SecurityEventType" NOT NULL,
    "severity" "admin"."SecuritySeverity" NOT NULL,
    "adminId" TEXT,
    "ipAddress" VARCHAR(45) NOT NULL,
    "userAgent" VARCHAR(500),
    "description" TEXT NOT NULL,
    "metadata" JSONB,
    "resolved" BOOLEAN NOT NULL DEFAULT false,
    "resolvedAt" TIMESTAMPTZ(6),
    "resolvedBy" TEXT,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AdminSecurityEvent_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "billing"."Subscription" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "tier" "billing"."SubscriptionTier" NOT NULL DEFAULT 'HOBBYIST',
    "status" "billing"."SubscriptionStatus" NOT NULL DEFAULT 'ACTIVE',
    "stripeCustomerId" TEXT,
    "stripeSubscriptionId" TEXT,
    "credits" INTEGER NOT NULL DEFAULT 0,
    "monthlyCreditQuota" INTEGER NOT NULL DEFAULT 0,
    "creditResetDate" TIMESTAMPTZ(6),
    "maxCanvases" INTEGER NOT NULL DEFAULT 3,
    "maxActionPodsPerCanvas" INTEGER NOT NULL DEFAULT 50,
    "maxDocumentSizeInMB" INTEGER NOT NULL DEFAULT 10,
    "maxCollaboratorsPerCanvas" INTEGER NOT NULL DEFAULT 0,
    "canInviteToWorkspace" BOOLEAN NOT NULL DEFAULT false,
    "canInviteToCanvas" BOOLEAN NOT NULL DEFAULT false,
    "canCreatePublicLinks" BOOLEAN NOT NULL DEFAULT true,
    "canUseAdvancedModels" BOOLEAN NOT NULL DEFAULT false,
    "canAccessAnalytics" BOOLEAN NOT NULL DEFAULT false,
    "canExportData" BOOLEAN NOT NULL DEFAULT false,
    "nextBillingDate" TIMESTAMPTZ(6),
    "currentPeriodStart" TIMESTAMPTZ(6),
    "currentPeriodEnd" TIMESTAMPTZ(6),
    "cancelAtPeriodEnd" BOOLEAN NOT NULL DEFAULT false,
    "isByokMode" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "Subscription_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "billing"."CreditPurchase" (
    "id" TEXT NOT NULL,
    "subscriptionId" TEXT NOT NULL,
    "creditsPurchased" INTEGER NOT NULL,
    "amountPaid" DECIMAL(10,2) NOT NULL,
    "currency" VARCHAR(3) NOT NULL DEFAULT 'USD',
    "stripeChargeId" TEXT NOT NULL,
    "status" VARCHAR(50) NOT NULL DEFAULT 'succeeded',
    "purchasedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "CreditPurchase_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "billing"."CreditUsageLog" (
    "id" TEXT NOT NULL,
    "subscriptionId" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "canvasId" TEXT NOT NULL,
    "podId" TEXT NOT NULL,
    "executionId" TEXT NOT NULL,
    "creditsUsed" INTEGER NOT NULL DEFAULT 0,
    "balanceBefore" INTEGER NOT NULL,
    "balanceAfter" INTEGER NOT NULL,
    "provider" "core"."LLMProvider" NOT NULL,
    "modelId" VARCHAR(255) NOT NULL,
    "modelName" VARCHAR(255),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "CreditUsageLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "billing"."ModelPricingTier" (
    "id" TEXT NOT NULL,
    "provider" "core"."LLMProvider" NOT NULL,
    "modelId" VARCHAR(255) NOT NULL,
    "category" "billing"."ModelCategory" NOT NULL,
    "displayName" VARCHAR(255) NOT NULL,
    "description" VARCHAR(500),
    "inputTokenCost" DECIMAL(12,8) NOT NULL,
    "outputTokenCost" DECIMAL(12,8) NOT NULL,
    "reasoningTokenCost" DECIMAL(12,8) NOT NULL DEFAULT 0,
    "creditsPerMillionInputTokens" INTEGER NOT NULL,
    "creditsPerMillionOutputTokens" INTEGER NOT NULL,
    "creditsPerMillionReasoningTokens" INTEGER NOT NULL DEFAULT 0,
    "maxTokens" INTEGER,
    "maxOutputTokens" INTEGER,
    "supportsStreaming" BOOLEAN NOT NULL DEFAULT true,
    "supportsVision" BOOLEAN NOT NULL DEFAULT false,
    "supportsAudio" BOOLEAN NOT NULL DEFAULT false,
    "supportsVideo" BOOLEAN NOT NULL DEFAULT false,
    "supportsFunctions" BOOLEAN NOT NULL DEFAULT false,
    "supportsJsonMode" BOOLEAN NOT NULL DEFAULT false,
    "supportsSystemPrompt" BOOLEAN NOT NULL DEFAULT true,
    "providerConfig" JSONB,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "effectiveFrom" TIMESTAMPTZ(6) NOT NULL,
    "effectiveUntil" TIMESTAMPTZ(6),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "ModelPricingTier_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."Space" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "description" VARCHAR(1000),
    "customInstructions" TEXT,
    "icon" VARCHAR(50),
    "color" VARCHAR(7),
    "createdBy" TEXT NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "Space_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."Flow" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "spaceId" TEXT,
    "name" VARCHAR(255) NOT NULL,
    "description" VARCHAR(500),
    "version" INTEGER NOT NULL DEFAULT 1,
    "visibility" "canvas"."FlowVisibility" NOT NULL DEFAULT 'PRIVATE',
    "createdBy" TEXT NOT NULL,
    "thumbnailS3Key" VARCHAR(512),
    "thumbnailGeneratedAt" TIMESTAMPTZ(6),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "Flow_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."FlowInvitation" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "email" VARCHAR(255) NOT NULL,
    "accessLevel" "canvas"."FlowAccessLevel" NOT NULL DEFAULT 'EDITOR',
    "permissions" JSONB,
    "invitedBy" TEXT NOT NULL,
    "invitedUserId" TEXT,
    "token" VARCHAR(255) NOT NULL,
    "status" "core"."InvitationStatus" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMPTZ(6) NOT NULL,
    "acceptedAt" TIMESTAMPTZ(6),

    CONSTRAINT "FlowInvitation_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."FlowCollaborator" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "accessLevel" "canvas"."FlowAccessLevel" NOT NULL DEFAULT 'EDITOR',
    "canEdit" BOOLEAN NOT NULL DEFAULT true,
    "canExecute" BOOLEAN NOT NULL DEFAULT true,
    "canDelete" BOOLEAN NOT NULL DEFAULT false,
    "canShare" BOOLEAN NOT NULL DEFAULT false,
    "canInvite" BOOLEAN NOT NULL DEFAULT false,
    "invitedBy" TEXT,
    "invitedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastViewedAt" TIMESTAMPTZ(6),

    CONSTRAINT "FlowCollaborator_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."FlowSession" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "userId" TEXT,
    "anonymousName" VARCHAR(100),
    "sessionToken" VARCHAR(255),
    "socketId" VARCHAR(255),
    "cursorPosition" JSONB,
    "selectedPodIds" JSONB,
    "viewportState" JSONB,
    "userColor" VARCHAR(7),
    "userAgent" VARCHAR(500),
    "ipAddress" VARCHAR(45),
    "connectedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastHeartbeatAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "disconnectedAt" TIMESTAMPTZ(6),

    CONSTRAINT "FlowSession_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."FlowActivityLog" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "userId" TEXT,
    "action" "canvas"."FlowActivityAction" NOT NULL,
    "entityType" VARCHAR(50),
    "entityId" VARCHAR(255),
    "changeData" JSONB,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "FlowActivityLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."FlowComment" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "userId" TEXT,
    "content" TEXT NOT NULL,
    "position" JSONB,
    "podId" TEXT,
    "parentId" TEXT,
    "isResolved" BOOLEAN NOT NULL DEFAULT false,
    "resolvedBy" TEXT,
    "resolvedAt" TIMESTAMPTZ(6),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "FlowComment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."Pod" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "type" "canvas"."PodType" NOT NULL,
    "position" JSONB NOT NULL,
    "executionStatus" "canvas"."PodExecutionStatus" NOT NULL DEFAULT 'IDLE',
    "lastExecutionId" TEXT,
    "contextFlowId" TEXT,
    "documentId" TEXT,
    "lockedBy" TEXT,
    "lockedAt" TIMESTAMPTZ(6),
    "dynamoPartitionKey" VARCHAR(255) NOT NULL,
    "dynamoSortKey" VARCHAR(255) NOT NULL,
    "s3VectorBucket" VARCHAR(255),
    "s3VectorKey" VARCHAR(512),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "Pod_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."Edge" (
    "id" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "sourcePodId" TEXT NOT NULL,
    "targetPodId" TEXT NOT NULL,
    "sourceHandle" VARCHAR(100),
    "targetHandle" VARCHAR(100),
    "animated" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Edge_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."PodExecution" (
    "id" TEXT NOT NULL,
    "podId" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "status" "canvas"."PodExecutionStatus" NOT NULL DEFAULT 'RUNNING',
    "startedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "finishedAt" TIMESTAMPTZ(6),
    "runtimeInMs" INTEGER,
    "apiKeyId" TEXT,
    "provider" "core"."LLMProvider" NOT NULL,
    "modelId" VARCHAR(255) NOT NULL,
    "modelName" VARCHAR(255),
    "providerMetadata" JSONB,
    "requestMetadata" JSONB,
    "responseMetadata" JSONB,
    "errorMessage" TEXT,
    "errorCode" VARCHAR(100),
    "inputTokens" INTEGER NOT NULL DEFAULT 0,
    "outputTokens" INTEGER NOT NULL DEFAULT 0,
    "reasoningTokens" INTEGER NOT NULL DEFAULT 0,
    "creditsConsumed" INTEGER NOT NULL DEFAULT 0,
    "costInUsd" DECIMAL(12,8),

    CONSTRAINT "PodExecution_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."PodUsageLog" (
    "id" TEXT NOT NULL,
    "podId" TEXT NOT NULL,
    "executionId" TEXT NOT NULL,
    "flowId" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "subscriptionId" TEXT NOT NULL,
    "apiKeyId" TEXT,
    "provider" "core"."LLMProvider" NOT NULL,
    "modelId" VARCHAR(255) NOT NULL,
    "modelName" VARCHAR(255),
    "providerMetadata" JSONB,
    "inputTokens" INTEGER NOT NULL DEFAULT 0,
    "outputTokens" INTEGER NOT NULL DEFAULT 0,
    "reasoningTokens" INTEGER NOT NULL DEFAULT 0,
    "creditsConsumed" INTEGER NOT NULL DEFAULT 0,
    "runtimeInMs" INTEGER,
    "inputTokenCost" DECIMAL(12,8) NOT NULL,
    "outputTokenCost" DECIMAL(12,8) NOT NULL,
    "reasoningTokenCost" DECIMAL(12,8) NOT NULL,
    "totalCostInUsd" DECIMAL(12,8) NOT NULL,
    "executedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "PodUsageLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "canvas"."ContextModule" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "description" VARCHAR(1000),
    "definitionJson" JSONB NOT NULL,
    "originalFlowId" TEXT,
    "version" INTEGER NOT NULL DEFAULT 1,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "ContextModule_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "image" TEXT,
    "hash" VARCHAR(255),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."RefreshToken" (
    "id" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "deviceName" VARCHAR(255) NOT NULL,
    "userId" TEXT NOT NULL,
    "expiresAt" TIMESTAMPTZ(6) NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "RefreshToken_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "provider" "core"."AuthProvider" NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "accessToken" TEXT,
    "refreshToken" TEXT,
    "expiresAt" TIMESTAMPTZ(6),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."Workspace" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "type" "core"."WorkspaceType" NOT NULL DEFAULT 'PERSONAL',
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "Workspace_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."WorkspaceUser" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "role" "core"."WorkspaceRole" NOT NULL DEFAULT 'MEMBER',
    "canCreateCanvas" BOOLEAN NOT NULL DEFAULT true,
    "canDeleteCanvas" BOOLEAN NOT NULL DEFAULT false,
    "canManageBilling" BOOLEAN NOT NULL DEFAULT false,
    "canInviteMembers" BOOLEAN NOT NULL DEFAULT false,
    "canManageMembers" BOOLEAN NOT NULL DEFAULT false,
    "canManageApiKeys" BOOLEAN NOT NULL DEFAULT false,
    "joinedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "invitedBy" TEXT,

    CONSTRAINT "WorkspaceUser_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."WorkspaceInvitation" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "email" VARCHAR(255) NOT NULL,
    "role" "core"."WorkspaceRole" NOT NULL DEFAULT 'MEMBER',
    "permissions" JSONB,
    "invitedBy" TEXT NOT NULL,
    "invitedUserId" TEXT,
    "token" VARCHAR(255) NOT NULL,
    "status" "core"."InvitationStatus" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMPTZ(6) NOT NULL,
    "acceptedAt" TIMESTAMPTZ(6),

    CONSTRAINT "WorkspaceInvitation_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."ProviderAPIKey" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "provider" "core"."LLMProvider" NOT NULL,
    "displayName" VARCHAR(100) NOT NULL,
    "keyHash" VARCHAR(500) NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "lastUsedAt" TIMESTAMPTZ(6),
    "usageCount" INTEGER NOT NULL DEFAULT 0,
    "totalTokens" BIGINT NOT NULL DEFAULT 0,
    "totalCost" DECIMAL(12,6) NOT NULL DEFAULT 0,
    "lastErrorAt" TIMESTAMPTZ(6),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ProviderAPIKey_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."UsageMetric" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "keyId" TEXT NOT NULL,
    "date" DATE NOT NULL,
    "requestCount" INTEGER NOT NULL DEFAULT 0,
    "successCount" INTEGER NOT NULL DEFAULT 0,
    "errorCount" INTEGER NOT NULL DEFAULT 0,
    "promptTokens" BIGINT NOT NULL DEFAULT 0,
    "completionTokens" BIGINT NOT NULL DEFAULT 0,
    "totalTokens" BIGINT NOT NULL DEFAULT 0,
    "estimatedCost" DECIMAL(12,6) NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "UsageMetric_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."ShareLink" (
    "id" TEXT NOT NULL,
    "publicToken" TEXT NOT NULL,
    "assetType" "core"."ShareableAssetType" NOT NULL,
    "assetId" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "createdBy" TEXT NOT NULL,
    "accessLevel" "core"."ShareAccessLevel" NOT NULL DEFAULT 'VIEW_ONLY',
    "password" VARCHAR(255),
    "viewCount" INTEGER NOT NULL DEFAULT 0,
    "lastViewedAt" TIMESTAMPTZ(6),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMPTZ(6),

    CONSTRAINT "ShareLink_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "core"."Notification" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" "core"."NotificationType" NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "body" TEXT NOT NULL,
    "entityType" VARCHAR(50),
    "entityId" TEXT,
    "metadata" JSONB,
    "isRead" BOOLEAN NOT NULL DEFAULT false,
    "readAt" TIMESTAMPTZ(6),
    "actionUrl" VARCHAR(500),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMPTZ(6),

    CONSTRAINT "Notification_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "documents"."DocumentFolder" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "parentId" TEXT,
    "icon" VARCHAR(50),
    "color" VARCHAR(7),
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdBy" TEXT NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "DocumentFolder_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "documents"."Document" (
    "id" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "folderId" TEXT,
    "name" VARCHAR(255) NOT NULL,
    "sourceType" "documents"."DocumentSourceType" NOT NULL DEFAULT 'INTERNAL',
    "storageKey" VARCHAR(512),
    "s3Bucket" VARCHAR(255),
    "externalUrl" VARCHAR(2048),
    "externalProvider" VARCHAR(50),
    "externalFileId" VARCHAR(512),
    "fileType" VARCHAR(100) NOT NULL,
    "mimeType" VARCHAR(255),
    "sizeInBytes" BIGINT,
    "status" "documents"."DocumentStatus" NOT NULL DEFAULT 'UPLOADING',
    "uploadedBy" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "Document_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "documents"."Embedding" (
    "id" TEXT NOT NULL,
    "documentId" TEXT NOT NULL,
    "model" VARCHAR(100) NOT NULL,
    "chunkIndex" INTEGER NOT NULL,
    "chunkText" TEXT NOT NULL,
    "s3VectorBucket" VARCHAR(255) NOT NULL,
    "s3VectorKey" VARCHAR(512) NOT NULL,
    "vectorDimension" INTEGER NOT NULL DEFAULT 1536,
    "metadata" JSONB,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Embedding_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "documents"."DocumentProcessingCost" (
    "id" TEXT NOT NULL,
    "documentId" TEXT NOT NULL,
    "workspaceId" TEXT NOT NULL,
    "subscriptionId" TEXT NOT NULL,
    "processingType" "documents"."DocumentProcessingType" NOT NULL,
    "creditsConsumed" INTEGER NOT NULL DEFAULT 0,
    "extractionCost" DECIMAL(12,8) NOT NULL DEFAULT 0,
    "embeddingCost" DECIMAL(12,8) NOT NULL DEFAULT 0,
    "totalCostInUsd" DECIMAL(12,8) NOT NULL,
    "chunkCount" INTEGER,
    "embeddingModel" VARCHAR(100),
    "processingTimeMs" INTEGER,
    "tokensProcessed" INTEGER NOT NULL DEFAULT 0,
    "processedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "DocumentProcessingCost_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Admin_email_key" ON "admin"."Admin"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Admin_username_key" ON "admin"."Admin"("username");

-- CreateIndex
CREATE UNIQUE INDEX "Admin_passwordResetToken_key" ON "admin"."Admin"("passwordResetToken");

-- CreateIndex
CREATE INDEX "Admin_email_status_idx" ON "admin"."Admin"("email", "status");

-- CreateIndex
CREATE INDEX "Admin_username_idx" ON "admin"."Admin"("username");

-- CreateIndex
CREATE INDEX "Admin_status_role_idx" ON "admin"."Admin"("status", "role");

-- CreateIndex
CREATE INDEX "Admin_lastLoginAt_idx" ON "admin"."Admin"("lastLoginAt");

-- CreateIndex
CREATE UNIQUE INDEX "AdminSession_token_key" ON "admin"."AdminSession"("token");

-- CreateIndex
CREATE UNIQUE INDEX "AdminSession_refreshToken_key" ON "admin"."AdminSession"("refreshToken");

-- CreateIndex
CREATE INDEX "AdminSession_adminId_revokedAt_expiresAt_idx" ON "admin"."AdminSession"("adminId", "revokedAt", "expiresAt");

-- CreateIndex
CREATE INDEX "AdminSession_token_idx" ON "admin"."AdminSession"("token");

-- CreateIndex
CREATE INDEX "AdminSession_expiresAt_idx" ON "admin"."AdminSession"("expiresAt");

-- CreateIndex
CREATE INDEX "AdminSession_ipAddress_createdAt_idx" ON "admin"."AdminSession"("ipAddress", "createdAt");

-- CreateIndex
CREATE INDEX "AdminAuditLog_adminId_createdAt_idx" ON "admin"."AdminAuditLog"("adminId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "AdminAuditLog_action_createdAt_idx" ON "admin"."AdminAuditLog"("action", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "AdminAuditLog_resource_resourceId_idx" ON "admin"."AdminAuditLog"("resource", "resourceId");

-- CreateIndex
CREATE INDEX "AdminAuditLog_ipAddress_createdAt_idx" ON "admin"."AdminAuditLog"("ipAddress", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "AdminAuditLog_createdAt_idx" ON "admin"."AdminAuditLog"("createdAt" DESC);

-- CreateIndex
CREATE INDEX "AdminPermission_adminId_idx" ON "admin"."AdminPermission"("adminId");

-- CreateIndex
CREATE INDEX "AdminPermission_permission_resource_idx" ON "admin"."AdminPermission"("permission", "resource");

-- CreateIndex
CREATE INDEX "AdminPermission_expiresAt_idx" ON "admin"."AdminPermission"("expiresAt");

-- CreateIndex
CREATE UNIQUE INDEX "AdminPermission_adminId_permission_resource_key" ON "admin"."AdminPermission"("adminId", "permission", "resource");

-- CreateIndex
CREATE UNIQUE INDEX "AdminAPIKey_keyHash_key" ON "admin"."AdminAPIKey"("keyHash");

-- CreateIndex
CREATE INDEX "AdminAPIKey_adminId_idx" ON "admin"."AdminAPIKey"("adminId");

-- CreateIndex
CREATE INDEX "AdminAPIKey_keyHash_idx" ON "admin"."AdminAPIKey"("keyHash");

-- CreateIndex
CREATE INDEX "AdminAPIKey_expiresAt_revokedAt_idx" ON "admin"."AdminAPIKey"("expiresAt", "revokedAt");

-- CreateIndex
CREATE UNIQUE INDEX "AdminInvitation_token_key" ON "admin"."AdminInvitation"("token");

-- CreateIndex
CREATE INDEX "AdminInvitation_token_expiresAt_idx" ON "admin"."AdminInvitation"("token", "expiresAt");

-- CreateIndex
CREATE INDEX "AdminInvitation_email_idx" ON "admin"."AdminInvitation"("email");

-- CreateIndex
CREATE INDEX "AdminSecurityEvent_eventType_severity_createdAt_idx" ON "admin"."AdminSecurityEvent"("eventType", "severity", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "AdminSecurityEvent_adminId_createdAt_idx" ON "admin"."AdminSecurityEvent"("adminId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "AdminSecurityEvent_resolved_severity_idx" ON "admin"."AdminSecurityEvent"("resolved", "severity");

-- CreateIndex
CREATE INDEX "AdminSecurityEvent_ipAddress_createdAt_idx" ON "admin"."AdminSecurityEvent"("ipAddress", "createdAt" DESC);

-- CreateIndex
CREATE UNIQUE INDEX "Subscription_workspaceId_key" ON "billing"."Subscription"("workspaceId");

-- CreateIndex
CREATE UNIQUE INDEX "Subscription_stripeCustomerId_key" ON "billing"."Subscription"("stripeCustomerId");

-- CreateIndex
CREATE UNIQUE INDEX "Subscription_stripeSubscriptionId_key" ON "billing"."Subscription"("stripeSubscriptionId");

-- CreateIndex
CREATE INDEX "Subscription_status_nextBillingDate_idx" ON "billing"."Subscription"("status", "nextBillingDate");

-- CreateIndex
CREATE INDEX "Subscription_tier_status_idx" ON "billing"."Subscription"("tier", "status");

-- CreateIndex
CREATE INDEX "Subscription_creditResetDate_idx" ON "billing"."Subscription"("creditResetDate");

-- CreateIndex
CREATE UNIQUE INDEX "CreditPurchase_stripeChargeId_key" ON "billing"."CreditPurchase"("stripeChargeId");

-- CreateIndex
CREATE INDEX "CreditPurchase_subscriptionId_purchasedAt_idx" ON "billing"."CreditPurchase"("subscriptionId", "purchasedAt" DESC);

-- CreateIndex
CREATE INDEX "CreditPurchase_stripeChargeId_idx" ON "billing"."CreditPurchase"("stripeChargeId");

-- CreateIndex
CREATE INDEX "CreditUsageLog_subscriptionId_createdAt_idx" ON "billing"."CreditUsageLog"("subscriptionId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "CreditUsageLog_workspaceId_createdAt_idx" ON "billing"."CreditUsageLog"("workspaceId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "CreditUsageLog_executionId_idx" ON "billing"."CreditUsageLog"("executionId");

-- CreateIndex
CREATE INDEX "CreditUsageLog_provider_modelId_createdAt_idx" ON "billing"."CreditUsageLog"("provider", "modelId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "ModelPricingTier_provider_modelId_isActive_effectiveFrom_idx" ON "billing"."ModelPricingTier"("provider", "modelId", "isActive", "effectiveFrom");

-- CreateIndex
CREATE INDEX "ModelPricingTier_provider_category_isActive_idx" ON "billing"."ModelPricingTier"("provider", "category", "isActive");

-- CreateIndex
CREATE INDEX "ModelPricingTier_isActive_effectiveFrom_idx" ON "billing"."ModelPricingTier"("isActive", "effectiveFrom");

-- CreateIndex
CREATE INDEX "ModelPricingTier_category_isActive_idx" ON "billing"."ModelPricingTier"("category", "isActive");

-- CreateIndex
CREATE UNIQUE INDEX "ModelPricingTier_provider_modelId_effectiveFrom_key" ON "billing"."ModelPricingTier"("provider", "modelId", "effectiveFrom");

-- CreateIndex
CREATE INDEX "Space_workspaceId_updatedAt_idx" ON "canvas"."Space"("workspaceId", "updatedAt" DESC);

-- CreateIndex
CREATE INDEX "Space_workspaceId_createdAt_idx" ON "canvas"."Space"("workspaceId", "createdAt" DESC);

-- CreateIndex
CREATE UNIQUE INDEX "Space_workspaceId_name_key" ON "canvas"."Space"("workspaceId", "name");

-- CreateIndex
CREATE INDEX "Flow_spaceId_updatedAt_idx" ON "canvas"."Flow"("spaceId", "updatedAt" DESC);

-- CreateIndex
CREATE INDEX "Flow_spaceId_createdAt_idx" ON "canvas"."Flow"("spaceId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Flow_workspaceId_updatedAt_idx" ON "canvas"."Flow"("workspaceId", "updatedAt" DESC);

-- CreateIndex
CREATE INDEX "Flow_workspaceId_createdAt_idx" ON "canvas"."Flow"("workspaceId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Flow_workspaceId_visibility_idx" ON "canvas"."Flow"("workspaceId", "visibility");

-- CreateIndex
CREATE INDEX "Flow_createdBy_createdAt_idx" ON "canvas"."Flow"("createdBy", "createdAt" DESC);

-- CreateIndex
CREATE UNIQUE INDEX "FlowInvitation_token_key" ON "canvas"."FlowInvitation"("token");

-- CreateIndex
CREATE INDEX "FlowInvitation_flowId_status_idx" ON "canvas"."FlowInvitation"("flowId", "status");

-- CreateIndex
CREATE INDEX "FlowInvitation_email_status_idx" ON "canvas"."FlowInvitation"("email", "status");

-- CreateIndex
CREATE INDEX "FlowInvitation_token_expiresAt_idx" ON "canvas"."FlowInvitation"("token", "expiresAt");

-- CreateIndex
CREATE INDEX "FlowCollaborator_userId_idx" ON "canvas"."FlowCollaborator"("userId");

-- CreateIndex
CREATE INDEX "FlowCollaborator_flowId_accessLevel_idx" ON "canvas"."FlowCollaborator"("flowId", "accessLevel");

-- CreateIndex
CREATE UNIQUE INDEX "FlowCollaborator_flowId_userId_key" ON "canvas"."FlowCollaborator"("flowId", "userId");

-- CreateIndex
CREATE UNIQUE INDEX "FlowSession_sessionToken_key" ON "canvas"."FlowSession"("sessionToken");

-- CreateIndex
CREATE INDEX "FlowSession_flowId_disconnectedAt_idx" ON "canvas"."FlowSession"("flowId", "disconnectedAt");

-- CreateIndex
CREATE INDEX "FlowSession_socketId_idx" ON "canvas"."FlowSession"("socketId");

-- CreateIndex
CREATE INDEX "FlowSession_flowId_userId_disconnectedAt_idx" ON "canvas"."FlowSession"("flowId", "userId", "disconnectedAt");

-- CreateIndex
CREATE INDEX "FlowSession_lastHeartbeatAt_idx" ON "canvas"."FlowSession"("lastHeartbeatAt");

-- CreateIndex
CREATE INDEX "FlowSession_sessionToken_idx" ON "canvas"."FlowSession"("sessionToken");

-- CreateIndex
CREATE INDEX "FlowActivityLog_flowId_createdAt_idx" ON "canvas"."FlowActivityLog"("flowId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "FlowActivityLog_userId_createdAt_idx" ON "canvas"."FlowActivityLog"("userId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "FlowActivityLog_action_createdAt_idx" ON "canvas"."FlowActivityLog"("action", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "FlowComment_flowId_createdAt_idx" ON "canvas"."FlowComment"("flowId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "FlowComment_userId_createdAt_idx" ON "canvas"."FlowComment"("userId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "FlowComment_podId_idx" ON "canvas"."FlowComment"("podId");

-- CreateIndex
CREATE INDEX "FlowComment_parentId_idx" ON "canvas"."FlowComment"("parentId");

-- CreateIndex
CREATE INDEX "FlowComment_isResolved_idx" ON "canvas"."FlowComment"("isResolved");

-- CreateIndex
CREATE INDEX "Pod_flowId_type_executionStatus_idx" ON "canvas"."Pod"("flowId", "type", "executionStatus");

-- CreateIndex
CREATE INDEX "Pod_contextFlowId_idx" ON "canvas"."Pod"("contextFlowId");

-- CreateIndex
CREATE INDEX "Pod_documentId_idx" ON "canvas"."Pod"("documentId");

-- CreateIndex
CREATE INDEX "Pod_executionStatus_updatedAt_idx" ON "canvas"."Pod"("executionStatus", "updatedAt");

-- CreateIndex
CREATE INDEX "Pod_s3VectorBucket_s3VectorKey_idx" ON "canvas"."Pod"("s3VectorBucket", "s3VectorKey");

-- CreateIndex
CREATE INDEX "Pod_lockedBy_lockedAt_idx" ON "canvas"."Pod"("lockedBy", "lockedAt");

-- CreateIndex
CREATE UNIQUE INDEX "Pod_dynamoPartitionKey_dynamoSortKey_key" ON "canvas"."Pod"("dynamoPartitionKey", "dynamoSortKey");

-- CreateIndex
CREATE INDEX "Edge_flowId_idx" ON "canvas"."Edge"("flowId");

-- CreateIndex
CREATE INDEX "Edge_sourcePodId_idx" ON "canvas"."Edge"("sourcePodId");

-- CreateIndex
CREATE INDEX "Edge_targetPodId_idx" ON "canvas"."Edge"("targetPodId");

-- CreateIndex
CREATE UNIQUE INDEX "Edge_flowId_sourcePodId_sourceHandle_targetPodId_targetHand_key" ON "canvas"."Edge"("flowId", "sourcePodId", "sourceHandle", "targetPodId", "targetHandle");

-- CreateIndex
CREATE INDEX "PodExecution_podId_startedAt_idx" ON "canvas"."PodExecution"("podId", "startedAt" DESC);

-- CreateIndex
CREATE INDEX "PodExecution_workspaceId_status_startedAt_idx" ON "canvas"."PodExecution"("workspaceId", "status", "startedAt" DESC);

-- CreateIndex
CREATE INDEX "PodExecution_flowId_status_startedAt_idx" ON "canvas"."PodExecution"("flowId", "status", "startedAt" DESC);

-- CreateIndex
CREATE INDEX "PodExecution_status_startedAt_idx" ON "canvas"."PodExecution"("status", "startedAt");

-- CreateIndex
CREATE INDEX "PodExecution_provider_modelId_startedAt_idx" ON "canvas"."PodExecution"("provider", "modelId", "startedAt" DESC);

-- CreateIndex
CREATE INDEX "PodExecution_provider_status_idx" ON "canvas"."PodExecution"("provider", "status");

-- CreateIndex
CREATE INDEX "PodExecution_apiKeyId_startedAt_idx" ON "canvas"."PodExecution"("apiKeyId", "startedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_workspaceId_executedAt_idx" ON "canvas"."PodUsageLog"("workspaceId", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_subscriptionId_executedAt_idx" ON "canvas"."PodUsageLog"("subscriptionId", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_executionId_idx" ON "canvas"."PodUsageLog"("executionId");

-- CreateIndex
CREATE INDEX "PodUsageLog_podId_executedAt_idx" ON "canvas"."PodUsageLog"("podId", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_flowId_executedAt_idx" ON "canvas"."PodUsageLog"("flowId", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_provider_modelId_executedAt_idx" ON "canvas"."PodUsageLog"("provider", "modelId", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_provider_executedAt_idx" ON "canvas"."PodUsageLog"("provider", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "PodUsageLog_apiKeyId_executedAt_idx" ON "canvas"."PodUsageLog"("apiKeyId", "executedAt" DESC);

-- CreateIndex
CREATE INDEX "ContextModule_workspaceId_updatedAt_idx" ON "canvas"."ContextModule"("workspaceId", "updatedAt" DESC);

-- CreateIndex
CREATE INDEX "ContextModule_originalFlowId_idx" ON "canvas"."ContextModule"("originalFlowId");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "core"."User"("email");

-- CreateIndex
CREATE INDEX "User_email_idx" ON "core"."User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "RefreshToken_token_key" ON "core"."RefreshToken"("token");

-- CreateIndex
CREATE INDEX "RefreshToken_userId_expiresAt_idx" ON "core"."RefreshToken"("userId", "expiresAt");

-- CreateIndex
CREATE INDEX "RefreshToken_token_expiresAt_idx" ON "core"."RefreshToken"("token", "expiresAt");

-- CreateIndex
CREATE UNIQUE INDEX "RefreshToken_userId_deviceName_key" ON "core"."RefreshToken"("userId", "deviceName");

-- CreateIndex
CREATE INDEX "Account_userId_idx" ON "core"."Account"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "core"."Account"("provider", "providerAccountId");

-- CreateIndex
CREATE INDEX "Workspace_type_createdAt_idx" ON "core"."Workspace"("type", "createdAt");

-- CreateIndex
CREATE INDEX "WorkspaceUser_workspaceId_role_idx" ON "core"."WorkspaceUser"("workspaceId", "role");

-- CreateIndex
CREATE INDEX "WorkspaceUser_userId_idx" ON "core"."WorkspaceUser"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "WorkspaceUser_userId_workspaceId_key" ON "core"."WorkspaceUser"("userId", "workspaceId");

-- CreateIndex
CREATE UNIQUE INDEX "WorkspaceInvitation_token_key" ON "core"."WorkspaceInvitation"("token");

-- CreateIndex
CREATE INDEX "WorkspaceInvitation_workspaceId_status_idx" ON "core"."WorkspaceInvitation"("workspaceId", "status");

-- CreateIndex
CREATE INDEX "WorkspaceInvitation_email_status_idx" ON "core"."WorkspaceInvitation"("email", "status");

-- CreateIndex
CREATE INDEX "WorkspaceInvitation_token_expiresAt_idx" ON "core"."WorkspaceInvitation"("token", "expiresAt");

-- CreateIndex
CREATE INDEX "ProviderAPIKey_workspaceId_isActive_idx" ON "core"."ProviderAPIKey"("workspaceId", "isActive");

-- CreateIndex
CREATE UNIQUE INDEX "ProviderAPIKey_workspaceId_provider_displayName_key" ON "core"."ProviderAPIKey"("workspaceId", "provider", "displayName");

-- CreateIndex
CREATE INDEX "UsageMetric_workspaceId_date_idx" ON "core"."UsageMetric"("workspaceId", "date");

-- CreateIndex
CREATE INDEX "UsageMetric_keyId_date_idx" ON "core"."UsageMetric"("keyId", "date");

-- CreateIndex
CREATE UNIQUE INDEX "UsageMetric_keyId_date_key" ON "core"."UsageMetric"("keyId", "date");

-- CreateIndex
CREATE UNIQUE INDEX "ShareLink_publicToken_key" ON "core"."ShareLink"("publicToken");

-- CreateIndex
CREATE INDEX "ShareLink_publicToken_expiresAt_idx" ON "core"."ShareLink"("publicToken", "expiresAt");

-- CreateIndex
CREATE INDEX "ShareLink_workspaceId_assetType_idx" ON "core"."ShareLink"("workspaceId", "assetType");

-- CreateIndex
CREATE INDEX "ShareLink_createdBy_createdAt_idx" ON "core"."ShareLink"("createdBy", "createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "ShareLink_assetType_assetId_key" ON "core"."ShareLink"("assetType", "assetId");

-- CreateIndex
CREATE INDEX "Notification_userId_isRead_createdAt_idx" ON "core"."Notification"("userId", "isRead", "createdAt");

-- CreateIndex
CREATE INDEX "Notification_userId_type_isRead_idx" ON "core"."Notification"("userId", "type", "isRead");

-- CreateIndex
CREATE INDEX "DocumentFolder_workspaceId_parentId_sortOrder_idx" ON "documents"."DocumentFolder"("workspaceId", "parentId", "sortOrder");

-- CreateIndex
CREATE INDEX "DocumentFolder_parentId_sortOrder_idx" ON "documents"."DocumentFolder"("parentId", "sortOrder");

-- CreateIndex
CREATE UNIQUE INDEX "DocumentFolder_workspaceId_parentId_name_key" ON "documents"."DocumentFolder"("workspaceId", "parentId", "name");

-- CreateIndex
CREATE UNIQUE INDEX "Document_storageKey_key" ON "documents"."Document"("storageKey");

-- CreateIndex
CREATE INDEX "Document_workspaceId_folderId_status_createdAt_idx" ON "documents"."Document"("workspaceId", "folderId", "status", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Document_workspaceId_status_createdAt_idx" ON "documents"."Document"("workspaceId", "status", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Document_workspaceId_sourceType_createdAt_idx" ON "documents"."Document"("workspaceId", "sourceType", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Document_folderId_createdAt_idx" ON "documents"."Document"("folderId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Document_storageKey_idx" ON "documents"."Document"("storageKey");

-- CreateIndex
CREATE INDEX "Document_status_updatedAt_idx" ON "documents"."Document"("status", "updatedAt");

-- CreateIndex
CREATE INDEX "Document_fileType_workspaceId_idx" ON "documents"."Document"("fileType", "workspaceId");

-- CreateIndex
CREATE INDEX "Document_externalProvider_externalFileId_idx" ON "documents"."Document"("externalProvider", "externalFileId");

-- CreateIndex
CREATE INDEX "Embedding_documentId_createdAt_idx" ON "documents"."Embedding"("documentId", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Embedding_model_createdAt_idx" ON "documents"."Embedding"("model", "createdAt" DESC);

-- CreateIndex
CREATE INDEX "Embedding_s3VectorBucket_idx" ON "documents"."Embedding"("s3VectorBucket");

-- CreateIndex
CREATE UNIQUE INDEX "Embedding_documentId_chunkIndex_key" ON "documents"."Embedding"("documentId", "chunkIndex");

-- CreateIndex
CREATE UNIQUE INDEX "Embedding_s3VectorBucket_s3VectorKey_key" ON "documents"."Embedding"("s3VectorBucket", "s3VectorKey");

-- CreateIndex
CREATE INDEX "DocumentProcessingCost_documentId_processedAt_idx" ON "documents"."DocumentProcessingCost"("documentId", "processedAt" DESC);

-- CreateIndex
CREATE INDEX "DocumentProcessingCost_workspaceId_processedAt_idx" ON "documents"."DocumentProcessingCost"("workspaceId", "processedAt" DESC);

-- CreateIndex
CREATE INDEX "DocumentProcessingCost_subscriptionId_processedAt_idx" ON "documents"."DocumentProcessingCost"("subscriptionId", "processedAt" DESC);

-- CreateIndex
CREATE INDEX "DocumentProcessingCost_processingType_processedAt_idx" ON "documents"."DocumentProcessingCost"("processingType", "processedAt" DESC);

-- AddForeignKey
ALTER TABLE "admin"."AdminSession" ADD CONSTRAINT "AdminSession_adminId_fkey" FOREIGN KEY ("adminId") REFERENCES "admin"."Admin"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "admin"."AdminAuditLog" ADD CONSTRAINT "AdminAuditLog_adminId_fkey" FOREIGN KEY ("adminId") REFERENCES "admin"."Admin"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "admin"."AdminPermission" ADD CONSTRAINT "AdminPermission_adminId_fkey" FOREIGN KEY ("adminId") REFERENCES "admin"."Admin"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "admin"."AdminAPIKey" ADD CONSTRAINT "AdminAPIKey_adminId_fkey" FOREIGN KEY ("adminId") REFERENCES "admin"."Admin"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "admin"."AdminInvitation" ADD CONSTRAINT "AdminInvitation_invitedBy_fkey" FOREIGN KEY ("invitedBy") REFERENCES "admin"."Admin"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "billing"."Subscription" ADD CONSTRAINT "Subscription_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "billing"."CreditPurchase" ADD CONSTRAINT "CreditPurchase_subscriptionId_fkey" FOREIGN KEY ("subscriptionId") REFERENCES "billing"."Subscription"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "billing"."CreditUsageLog" ADD CONSTRAINT "CreditUsageLog_subscriptionId_fkey" FOREIGN KEY ("subscriptionId") REFERENCES "billing"."Subscription"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Space" ADD CONSTRAINT "Space_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Flow" ADD CONSTRAINT "Flow_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Flow" ADD CONSTRAINT "Flow_spaceId_fkey" FOREIGN KEY ("spaceId") REFERENCES "canvas"."Space"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowInvitation" ADD CONSTRAINT "FlowInvitation_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowInvitation" ADD CONSTRAINT "FlowInvitation_invitedBy_fkey" FOREIGN KEY ("invitedBy") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowInvitation" ADD CONSTRAINT "FlowInvitation_invitedUserId_fkey" FOREIGN KEY ("invitedUserId") REFERENCES "core"."User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowCollaborator" ADD CONSTRAINT "FlowCollaborator_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowCollaborator" ADD CONSTRAINT "FlowCollaborator_userId_fkey" FOREIGN KEY ("userId") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowSession" ADD CONSTRAINT "FlowSession_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowActivityLog" ADD CONSTRAINT "FlowActivityLog_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."FlowComment" ADD CONSTRAINT "FlowComment_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Pod" ADD CONSTRAINT "Pod_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Pod" ADD CONSTRAINT "Pod_contextFlowId_fkey" FOREIGN KEY ("contextFlowId") REFERENCES "canvas"."Flow"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Pod" ADD CONSTRAINT "Pod_documentId_fkey" FOREIGN KEY ("documentId") REFERENCES "documents"."Document"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Edge" ADD CONSTRAINT "Edge_flowId_fkey" FOREIGN KEY ("flowId") REFERENCES "canvas"."Flow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Edge" ADD CONSTRAINT "Edge_sourcePodId_fkey" FOREIGN KEY ("sourcePodId") REFERENCES "canvas"."Pod"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."Edge" ADD CONSTRAINT "Edge_targetPodId_fkey" FOREIGN KEY ("targetPodId") REFERENCES "canvas"."Pod"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."PodExecution" ADD CONSTRAINT "PodExecution_podId_fkey" FOREIGN KEY ("podId") REFERENCES "canvas"."Pod"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."PodExecution" ADD CONSTRAINT "PodExecution_apiKeyId_fkey" FOREIGN KEY ("apiKeyId") REFERENCES "core"."ProviderAPIKey"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."PodUsageLog" ADD CONSTRAINT "PodUsageLog_podId_fkey" FOREIGN KEY ("podId") REFERENCES "canvas"."Pod"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."PodUsageLog" ADD CONSTRAINT "PodUsageLog_subscriptionId_fkey" FOREIGN KEY ("subscriptionId") REFERENCES "billing"."Subscription"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."PodUsageLog" ADD CONSTRAINT "PodUsageLog_apiKeyId_fkey" FOREIGN KEY ("apiKeyId") REFERENCES "core"."ProviderAPIKey"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."ContextModule" ADD CONSTRAINT "ContextModule_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "canvas"."ContextModule" ADD CONSTRAINT "ContextModule_originalFlowId_fkey" FOREIGN KEY ("originalFlowId") REFERENCES "canvas"."Flow"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."RefreshToken" ADD CONSTRAINT "RefreshToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."Account" ADD CONSTRAINT "Account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."WorkspaceUser" ADD CONSTRAINT "WorkspaceUser_userId_fkey" FOREIGN KEY ("userId") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."WorkspaceUser" ADD CONSTRAINT "WorkspaceUser_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."WorkspaceInvitation" ADD CONSTRAINT "WorkspaceInvitation_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."WorkspaceInvitation" ADD CONSTRAINT "WorkspaceInvitation_invitedBy_fkey" FOREIGN KEY ("invitedBy") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."WorkspaceInvitation" ADD CONSTRAINT "WorkspaceInvitation_invitedUserId_fkey" FOREIGN KEY ("invitedUserId") REFERENCES "core"."User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."ProviderAPIKey" ADD CONSTRAINT "ProviderAPIKey_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."ProviderAPIKey" ADD CONSTRAINT "ProviderAPIKey_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "core"."User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."UsageMetric" ADD CONSTRAINT "UsageMetric_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."UsageMetric" ADD CONSTRAINT "UsageMetric_keyId_fkey" FOREIGN KEY ("keyId") REFERENCES "core"."ProviderAPIKey"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."ShareLink" ADD CONSTRAINT "ShareLink_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "core"."Notification" ADD CONSTRAINT "Notification_userId_fkey" FOREIGN KEY ("userId") REFERENCES "core"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."DocumentFolder" ADD CONSTRAINT "DocumentFolder_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "documents"."DocumentFolder"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."DocumentFolder" ADD CONSTRAINT "DocumentFolder_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."Document" ADD CONSTRAINT "Document_workspaceId_fkey" FOREIGN KEY ("workspaceId") REFERENCES "core"."Workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."Document" ADD CONSTRAINT "Document_folderId_fkey" FOREIGN KEY ("folderId") REFERENCES "documents"."DocumentFolder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."Embedding" ADD CONSTRAINT "Embedding_documentId_fkey" FOREIGN KEY ("documentId") REFERENCES "documents"."Document"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."DocumentProcessingCost" ADD CONSTRAINT "DocumentProcessingCost_documentId_fkey" FOREIGN KEY ("documentId") REFERENCES "documents"."Document"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents"."DocumentProcessingCost" ADD CONSTRAINT "DocumentProcessingCost_subscriptionId_fkey" FOREIGN KEY ("subscriptionId") REFERENCES "billing"."Subscription"("id") ON DELETE CASCADE ON UPDATE CASCADE;

```

### `packages\schema\prisma\schema.prisma`

```prisma
// /prisma/schema.prisma

// This is your main Prisma schema file.
// It defines the database connection and the Prisma Client generator.
// Models are organized into separate files for better maintainability.

generator client {
  provider        = "prisma-client-js"
  output          = "../client"
  binaryTargets   = ["native", "debian-openssl-3.0.x", "rhel-openssl-3.0.x"]
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["core", "canvas", "billing", "documents", "admin"]
}

```

---

## Packages - ESLint Config

### `packages\eslint-config\base.js`

```javascript
import eslintJs from '@eslint/js';
import eslintConfigPrettier from 'eslint-config-prettier';
import turboPlugin from 'eslint-plugin-turbo';
import tseslint from 'typescript-eslint';

export default [
  eslintJs.configs.recommended,
  ...tseslint.configs.recommended,
  eslintConfigPrettier,
  {
    plugins: {
      turbo: turboPlugin,
    },
    rules: {
      'turbo/no-undeclared-env-vars': 'warn',
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_', varsIgnorePattern: '^_' },
      ],
      '@typescript-eslint/no-explicit-any': 'off',
      'no-console': ['warn', { allow: ['warn', 'error'] }],
    },
  },
  {
    ignores: ['dist/**', 'node_modules/**', '.turbo/**', 'coverage/**'],
  },
];

```

### `packages\eslint-config\nestjs.js`

```javascript
import baseConfig from './base.js';

export default [
  ...baseConfig,
  {
    rules: {
      '@typescript-eslint/interface-name-prefix': 'off',
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
    },
  },
];

```

### `packages\eslint-config\package.json`

```json
{
	"name": "@actopod/eslint-config",
	"version": "0.0.1",
	"private": true,
	"main": "index.js",
	"files": [
		"*.js"
	],
	"devDependencies": {
		"@eslint/js": "^9.37.0",
		"@typescript-eslint/eslint-plugin": "^8.46.0",
		"@typescript-eslint/parser": "^8.46.0",
		"eslint": "^9.37.0",
		"eslint-config-prettier": "^10.1.8",
		"eslint-plugin-react": "^7.37.5",
		"eslint-plugin-react-hooks": "^7.0.0",
		"eslint-plugin-react-refresh": "^0.4.23",
		"eslint-plugin-turbo": "^2.5.8",
		"typescript-eslint": "^8.46.0"
	},
	"Transform": "AWS::Serverless-2016-10-31",
	"Resources": {
		"Api": {
			"Type": "AWS::Serverless::Api",
			"Properties": {
				"Name": {
					"Fn::Sub": [
						"${ResourceName} From Stack ${AWS::StackName}",
						{
							"ResourceName": "Api"
						}
					]
				},
				"StageName": "Prod",
				"DefinitionBody": {
					"openapi": "3.0",
					"info": {},
					"paths": {
						"/": {
							"get": {
								"responses": {}
							}
						}
					}
				},
				"EndpointConfiguration": "REGIONAL",
				"TracingEnabled": true
			}
		}
	}
}

```

### `packages\eslint-config\react.js`

```javascript
import baseConfig from './base.js';
import reactPlugin from 'eslint-plugin-react';
import reactHooksPlugin from 'eslint-plugin-react-hooks';
import reactRefreshPlugin from 'eslint-plugin-react-refresh';

export default [
  ...baseConfig,
  {
    files: ['**/*.{ts,tsx}'],
    plugins: {
      react: reactPlugin,
      'react-hooks': reactHooksPlugin,
      'react-refresh': reactRefreshPlugin,
    },
    rules: {
      ...reactPlugin.configs.recommended.rules,
      ...reactHooksPlugin.configs.recommended.rules,
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
      'react-refresh/only-export-components': ['warn', { allowConstantExport: true }],
    },
    settings: {
      react: {
        version: 'detect',
      },
    },
  },
];

```

---

## Packages - TypeScript Config

### `packages\tsconfig\base.json`

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "esnext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  }
}

```

### `packages\tsconfig\nestjs.json`

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true
  }
}

```

### `packages\tsconfig\package.json`

```json
{
  "name": "@actopod/tsconfig",
  "version": "0.0.1",
  "private": true
}

```

### `packages\tsconfig\react.json`

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "./base.json",
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "noEmit": true,
    "isolatedModules": true
  }
}

```

---

## Root Configuration

### `.editorconfig`

```text
# EditorConfig is awesome: https://EditorConfig.org

root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true
max_line_length = 100

[*.md]
trim_trailing_whitespace = false
max_line_length = 0

[*.{yml,yaml}]
indent_size = 2

[{package.json,*.json}]
indent_size = 2

[*.{ts,tsx,js,jsx}]
indent_size = 2

```

### `.gitignore`

```text
# Dependencies
node_modules
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Build outputs
dist
build
out
.next
.turbo
*.tsbuildinfo

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.env*.local

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
desktop.ini

# IDE and editor files
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.swp
*.swo
*~
.idea
*.sublime-project
*.sublime-workspace

# Testing
coverage
*.lcov
.nyc_output
.jest-cache

# Prisma
*.db
*.db-journal
prisma/migrations/**/*.sql
packages/schema/client
**/prisma/client

# Temporary files
*.tmp
*.temp
.cache
.parcel-cache
.eslintcache

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Debug
.vscode-test

# Misc
.vercel
.netlify
.serverless

```

### `.prettierignore`

```text
node_modules
dist
build
.turbo
.next
coverage
*.log
.env
.env.*
pnpm-lock.yaml
yarn.lock
package-lock.json

```

### `.prettierrc`

```text
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "always",
  "endOfLine": "lf"
}

```

### `package.json`

```json
{
  "name": "actopod",
  "version": "0.0.1",
  "private": true,
  "license": "MIT",
  "description": "AI Workflow Canvas - Multi-LLM Node-Based Platform",
  "author": "Zahid Khan",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev": "turbo run dev",
    "dev:backend": "turbo run dev --filter=@actopod/backend",
    "dev:frontend": "turbo run dev --filter=@actopod/frontend",
    "build": "turbo run build",
    "build:schema": "turbo run build --filter=@actopod/schema",
    "build:backend": "turbo run build --filter=@actopod/backend",
    "build:frontend": "turbo run build --filter=@actopod/frontend",
    "start": "turbo run start",
    "start:backend": "yarn workspace @actopod/backend start",
    "start:frontend": "yarn workspace @actopod/frontend start",
    "lint": "turbo run lint",
    "lint:fix": "turbo run lint:fix",
    "lint:backend": "turbo run lint --filter=@actopod/backend",
    "lint:frontend": "turbo run lint --filter=@actopod/frontend",
    "type-check": "turbo run type-check",
    "test": "turbo run test",
    "test:watch": "turbo run test:watch",
    "test:cov": "turbo run test:cov",
    "test:backend": "yarn workspace @actopod/backend test",
    "test:e2e": "yarn workspace @actopod/backend test:e2e",
    "clean": "turbo run clean && rimraf node_modules .turbo",
    "clean:all": "yarn clean && rimraf **/node_modules **/.turbo **/dist",
    "clean:turbo": "rimraf .turbo",
    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,css,md,yaml,yml}\"",
    "format:check": "prettier --check \"**/*.{ts,tsx,js,jsx,json,css,md,yaml,yml}\"",
    "db:generate": "turbo run db:generate",
    "db:migrate": "yarn workspace @actopod/schema db:migrate",
    "db:migrate:create": "yarn workspace @actopod/schema prisma migrate dev --create-only",
    "db:migrate:deploy": "yarn workspace @actopod/schema prisma migrate deploy",
    "db:push": "yarn workspace @actopod/schema db:push",
    "db:pull": "yarn workspace @actopod/schema prisma db pull",
    "db:studio": "yarn workspace @actopod/schema db:studio",
    "db:seed:pricing": "yarn workspace @actopod/schema db:seed:pricing",
    "db:reset": "yarn workspace @actopod/schema prisma migrate reset",
    "db:validate": "yarn workspace @actopod/schema prisma validate",
    "db:format": "yarn workspace @actopod/schema prisma format",
    "docker:db:up": "docker compose -f docker/db-docker-compose.yaml up -d",
    "docker:db:down": "docker compose -f docker/db-docker-compose.yaml down",
    "docker:db:restart": "yarn docker:db:down && yarn docker:db:up",
    "docker:db:logs": "docker compose -f docker/db-docker-compose.yaml logs -f",
    "docker:db:clean": "docker compose -f docker/db-docker-compose.yaml down -v",
    "docker:db:ps": "docker compose -f docker/db-docker-compose.yaml ps",
    "docker:dynamodb:up": "docker compose -f docker/dynamodb-docker-compose.yaml up -d",
    "docker:dynamodb:down": "docker compose -f docker/dynamodb-docker-compose.yaml down",
    "docker:dynamodb:restart": "yarn docker:dynamodb:down && yarn docker:dynamodb:up",
    "docker:dynamodb:logs": "docker compose -f docker/dynamodb-docker-compose.yaml logs -f",
    "docker:dynamodb:clean": "docker compose -f docker/dynamodb-docker-compose.yaml down -v",
    "docker:redis:up": "docker compose -f docker/redis-docker-compose.yaml up -d",
    "docker:redis:down": "docker compose -f docker/redis-docker-compose.yaml down",
    "docker:redis:logs": "docker compose -f docker/redis-docker-compose.yaml logs -f",
    "docker:dev": "yarn docker:db:up && yarn docker:dynamodb:up",
    "install:all": "yarn install",
    "reinstall": "yarn clean:all && yarn install",
    "prepare": "husky install || true",
    "check": "yarn type-check && yarn lint && yarn format:check",
    "fix": "yarn lint:fix && yarn format"
  },
  "devDependencies": {
    "@actopod/eslint-config": "*",
    "@types/node": "^24.7.2",
    "prettier": "^3.4.2",
    "rimraf": "^6.0.1",
    "turbo": "^2.5.8",
    "typescript": "^5.7.2"
  },
  "packageManager": "yarn@4.10.3",
  "engines": {
    "node": ">=20.0.0",
    "yarn": ">=4.0.0"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.14",
    "tailwindcss": "^4.1.14"
  }
}

```

### `README.md`

```markdown
# Actopod: The AI Workflow Canvas

âœ¨ **Welcome to Actopod** - A next-generation, multi-LLM, node-based workflow platform built with modern web technologies. âœ¨

## ðŸŽ¯ The Vision

Actopod empowers AI power users, developers, and researchers by providing an infinite, node-based canvas for building, managing, and executing complex AI workflows. It eliminates subscription overload, context fragmentation, and workflow inefficiencies by unifying multiple Large Language Models (LLMs) into a single, visual interface.

## ðŸ› ï¸ Core Technologies

This project is built with a cutting-edge, production-ready stack:

- **Monorepo**: Turborepo for intelligent caching and parallel execution
- **Backend**: NestJS (TypeScript) for robust, scalable APIs
- **Frontend**: React + Vite for blazing-fast development
- **Canvas UI**: React Flow for node-based workflow visualization
- **Database ORM**: Prisma with PostgreSQL for type-safe data access
- **Code Quality**: ESLint, Prettier, and EditorConfig for consistent code style

## ðŸ“ Workspace Structure

```
actopod/
â”‚
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ backend/          # NestJS API server
â”‚   â”‚   â”œâ”€â”€ src/          # Source code
â”‚   â”‚   â””â”€â”€ dist/         # Production build output
â”‚   â”‚
â”‚   â””â”€â”€ frontend/         # React + Vite application
â”‚       â”œâ”€â”€ src/          # Source code
â”‚       â””â”€â”€ dist/         # Production build output
â”‚
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ schema/           # Prisma schema and database client
â”‚   â”œâ”€â”€ tsconfig/         # Shared TypeScript configurations
â”‚   â””â”€â”€ eslint-config/    # Shared ESLint configurations
â”‚
â”œâ”€â”€ docker/
â”‚   â””â”€â”€ db-docker-compose.yaml  # PostgreSQL database setup
â”‚
â””â”€â”€ turbo.json           # Turborepo configuration
```

## ðŸš€ Getting Started: Local Development

### Prerequisites

- **Node.js**: >= 20.0.0
- **Yarn**: >= 4.0.0
- **Docker**: For running PostgreSQL locally

### 1. Install Dependencies

```
yarn install
```

This automatically runs `prisma generate` via the `postinstall` hook.

### 2. Set Up Environment Variables

Create a `.env` file in the root directory:

```
# Database
DATABASE_URL="postgresql://postgres:123@localhost:5434/actopod?schema=public"

# Node Environment
NODE_ENV="development"

# Backend
BACKEND_PORT=3001

# Frontend
VITE_API_URL="http://localhost:3001"
```

### 3. Start Database

```
yarn docker:db:up
```

This starts a PostgreSQL database in Docker on port `5434`.

### 4. Run Database Migrations

```
yarn db:migrate
```

### 5. Seed Database (Optional)

```
yarn db:seed
```

### 6. Start Development Servers

```
yarn dev
```

This starts both frontend and backend concurrently:

- **Frontend**: http://localhost:3000
- **Backend**: http://localhost:3001

## ðŸ“‹ Key Commands

### Development

| Command             | Description                                 |
| ------------------- | ------------------------------------------- |
| `yarn dev`          | Start both frontend and backend in dev mode |
| `yarn build`        | Build all packages for production           |
| `yarn lint`         | Lint all code                               |
| `yarn lint:fix`     | Fix linting issues automatically            |
| `yarn type-check`   | Run TypeScript type checking                |
| `yarn format`       | Format all code with Prettier               |
| `yarn format:check` | Check code formatting                       |

### Database (Prisma)

| Command            | Description                                 |
| ------------------ | ------------------------------------------- |
| `yarn db:generate` | Generate Prisma Client after schema changes |
| `yarn db:migrate`  | Create and apply database migrations        |
| `yarn db:push`     | Push schema changes to database (dev)       |
| `yarn db:studio`   | Open Prisma Studio (database GUI)           |
| `yarn db:seed`     | Populate database with initial data         |

### Docker

| Command               | Description               |
| --------------------- | ------------------------- |
| `yarn docker:db:up`   | Start PostgreSQL database |
| `yarn docker:db:down` | Stop PostgreSQL database  |
| `yarn docker:db:logs` | View database logs        |

### Maintenance

| Command      | Description                                 |
| ------------ | ------------------------------------------- |
| `yarn clean` | Remove all build artifacts and dependencies |
| `yarn test`  | Run all tests                               |

## ðŸ—ï¸ Building for Production

### Build All Packages

```
yarn build
```

Output locations:

- **Backend**: `apps/backend/dist/`
- **Frontend**: `apps/frontend/dist/`
- **Schema**: `packages/schema/dist/`

### Build Individual Packages

```
# Backend only
turbo build --filter=@actopod/backend

# Frontend only
turbo build --filter=@actopod/frontend
```

## ðŸš¢ Deployment

### Frontend (`apps/frontend`)

Deploy the `apps/frontend/dist/` folder to any static hosting provider:

- **Vercel**: `vercel deploy`
- **Netlify**: Upload `dist/` folder
- **AWS S3 + CloudFront**: Sync `dist/` to S3 bucket

### Backend (`apps/backend`)

Deploy the `apps/backend/dist/` folder to a Node.js runtime:

- **AWS EC2**: Copy `dist/` and run `node main.js`
- **Docker**: Build container with `dist/` and NestJS runtime
- **Render/Railway**: Deploy directly from repository

**Environment Variables**: Configure `DATABASE_URL` and other secrets in your hosting provider's dashboard.

### Database

Run migrations in production:

```
yarn workspace @actopod/schema db:migrate:deploy
```

## ðŸŽ¨ Project Features

- âœ… **Monorepo Architecture**: Turborepo with intelligent caching
- âœ… **Type Safety**: Full TypeScript coverage across frontend and backend
- âœ… **Modern Stack**: React 18, NestJS 11, Prisma 6
- âœ… **Visual Workflow Builder**: React Flow for node-based canvas
- âœ… **Production-Ready**: ESLint, Prettier, EditorConfig configured
- âœ… **Database Migrations**: Prisma for schema management
- âœ… **Hot Reload**: Fast development with Vite and NestJS watch mode

## ðŸ§ª Testing

```
# Run all tests
yarn test

# Run tests in watch mode
yarn test:watch

# Generate coverage report
yarn test:cov
```

## ðŸ“š Useful Resources

- [Turborepo Documentation](https://turbo.build/repo/docs)
- [NestJS Documentation](https://docs.nestjs.com/)
- [React Flow Documentation](https://reactflow.dev/)
- [Prisma Documentation](https://www.prisma.io/docs)
- [Vite Documentation](https://vitejs.dev/)

## ðŸ¤ Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Commit your changes: `git commit -m 'Add amazing feature'`
4. Push to branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

## ðŸ“„ License

MIT License - see [LICENSE](LICENSE) file for details

## ðŸ‘¨â€ðŸ’» Author

**Zahid Khan** ([@zahidkhandev](https://github.com/zahidkhandev))

---

Built with â¤ï¸ using Turborepo, NestJS, React, and Prisma

```

This README is:
- **Professional** and well-structured
- **Action-oriented** with clear commands
- **Production-ready** with deployment instructions
- **Visually organized** with emojis and tables
- **Similar to your old repo** but updated for Turborepo stack

Save this as `README.md` in your root directory.[1][2]

[1](https://blog.nashtechglobal.com/monorepo-setup-with-turborepo-the-complete-guide-to-consistent-code-quality/)
[2](https://www.prisma.io/blog/nestjs-prisma-rest-api-7D056s1BmOL0)
[3](https://github.com)
[4](https://github.com/zahidkhandev)
```

```

### `turbo.json`

```json
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [
        "dist/**",
        ".next/**",
        "build/**",
        "node_modules/.prisma/**",
        "node_modules/@prisma/**",
        "tsconfig.tsbuildinfo"
      ],
      "env": [
        "DATABASE_URL",
        "NODE_ENV",
        "JWT_ACCESS_TOKEN_SECRET",
        "JWT_REFRESH_TOKEN_SECRET",
        "JWT_ACCESS_TOKEN_EXPIRATION",
        "JWT_REFRESH_TOKEN_EXPIRATION",
        "GOOGLE_CLIENT_ID",
        "GOOGLE_CLIENT_SECRET",
        "GOOGLE_CALLBACK_URL",
        "GITHUB_CLIENT_ID",
        "GITHUB_CLIENT_SECRET",
        "GITHUB_CALLBACK_URL",
        "AWS_REGION",
        "AWS_SES_ACCESS_KEY_ID",
        "AWS_SES_SECRET_ACCESS_KEY",
        "AWS_SES_NO_REPLY_EMAIL",
        "AWS_SES_SUPPORT_EMAIL",
        "AWS_S3_ACCESS_KEY_ID",
        "AWS_S3_SECRET_ACCESS_KEY",
        "AWS_S3_BUCKET_NAME",
        "AWS_SNS_ACCESS_KEY_ID",
        "AWS_SNS_SECRET_ACCESS_KEY",
        "AWS_DYNAMODB_ACCESS_KEY_ID",
        "AWS_DYNAMODB_SECRET_ACCESS_KEY",
        "AWS_DYNAMODB_ENDPOINT",
        "AWS_DYNAMODB_REGION",
        "AWS_DYNAMODB_POD_TABLE",
        "AWS_DYNAMODB_EXECUTION_TABLE",
        "AWS_DYNAMODB_CACHE_TABLE",
        "API_KEY_ENCRYPTION_SECRET",
        "VITE_*"
      ]
    },
    "dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": ["^db:generate"],
      "env": [
        "API_KEY_ENCRYPTION_SECRET",
        "DATABASE_URL",
        "NODE_ENV",
        "BACKEND_PORT",
        "FRONTEND_PORT",
        "FRONTEND_URL",
        "JWT_ACCESS_TOKEN_SECRET",
        "JWT_REFRESH_TOKEN_SECRET",
        "JWT_ACCESS_TOKEN_EXPIRATION",
        "JWT_REFRESH_TOKEN_EXPIRATION",
        "GOOGLE_CLIENT_ID",
        "GOOGLE_CLIENT_SECRET",
        "GOOGLE_CALLBACK_URL",
        "GITHUB_CLIENT_ID",
        "GITHUB_CLIENT_SECRET",
        "GITHUB_CALLBACK_URL",
        "AWS_REGION",
        "AWS_SES_ACCESS_KEY_ID",
        "AWS_SES_SECRET_ACCESS_KEY",
        "AWS_SES_NO_REPLY_EMAIL",
        "AWS_SES_SUPPORT_EMAIL",
        "AWS_S3_ACCESS_KEY_ID",
        "AWS_S3_SECRET_ACCESS_KEY",
        "AWS_S3_BUCKET_NAME",
        "AWS_SNS_ACCESS_KEY_ID",
        "AWS_SNS_SECRET_ACCESS_KEY",
        "AWS_DYNAMODB_ACCESS_KEY_ID",
        "AWS_DYNAMODB_SECRET_ACCESS_KEY",
        "AWS_DYNAMODB_ENDPOINT",
        "AWS_DYNAMODB_REGION",
        "AWS_DYNAMODB_POD_TABLE",
        "AWS_DYNAMODB_SESSION_TABLE",
        "AWS_DYNAMODB_EXECUTION_TABLE",
        "AWS_DYNAMODB_CACHE_TABLE",
        "API_KEY_ENCRYPTION_SECRET",
        "QUEUE_BACKEND",
        "REDIS_HOST",
        "REDIS_PORT",
        "REDIS_PASSWORD",
        "REDIS_TLS_ENABLED",
        "AWS_SQS_ACCESS_KEY_ID",
        "AWS_SQS_SECRET_ACCESS_KEY",
        "AWS_SQS_QUEUE_URL",
        "AWS_SQS_REGION",
        "VITE_*"
      ]
    },
    "db:generate": {
      "cache": true,
      "outputs": ["node_modules/.prisma/**", "node_modules/@prisma/**"],
      "env": ["DATABASE_URL"],
      "persistent": false
    },
    "db:migrate": {
      "cache": false,
      "dependsOn": ["^db:generate"],
      "env": ["DATABASE_URL"]
    },
    "db:push": {
      "cache": false,
      "env": ["DATABASE_URL"]
    },
    "db:studio": {
      "cache": false,
      "persistent": true,
      "env": ["DATABASE_URL"]
    },
    "lint": {
      "dependsOn": ["^build"]
    },
    "lint:fix": {
      "dependsOn": ["^build"],
      "cache": false
    },
    "type-check": {
      "dependsOn": ["^build"],
      "env": ["NODE_ENV"]
    },
    "format": {
      "cache": false
    },
    "format:check": {
      "outputs": []
    },
    "test": {
      "dependsOn": ["^build"],
      "outputs": ["coverage/**"],
      "env": [
        "DATABASE_URL",
        "NODE_ENV",
        "JWT_ACCESS_TOKEN_SECRET",
        "JWT_REFRESH_TOKEN_SECRET",
        "AWS_DYNAMODB_ACCESS_KEY_ID",
        "AWS_DYNAMODB_SECRET_ACCESS_KEY",
        "AWS_DYNAMODB_ENDPOINT",
        "AWS_DYNAMODB_REGION",
        "AWS_DYNAMODB_POD_TABLE"
      ]
    },
    "clean": {
      "cache": false
    }
  },
  "globalEnv": ["NODE_ENV", "DATABASE_URL", "CI"],
  "globalPassThroughEnv": ["CI", "VERCEL", "VERCEL_ENV", "VERCEL_URL"]
}

```

---

## Backend Configuration

### `apps\backend\src\app.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { ScheduleModule } from '@nestjs/schedule';

import { AccessTokenGuard } from './common/guards/auth';
import { PrismaModule } from './prisma/prisma.module';
import { WebSocketModule } from './common/websocket/websocket.module';
import { V1AppModule } from './v1/app.module';
import { QueueModule } from './common/queue/queue.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: ['.env'],
    }),
    QueueModule,
    PrismaModule,
    ScheduleModule.forRoot(),
    WebSocketModule,
    V1AppModule,
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: AccessTokenGuard,
    },
  ],
})
export class AppModule {}

```

### `apps\backend\src\common\aws\aws.module.ts`

```typescript
import { Module, Global } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AwsSesEmailService } from './ses/ses-email.service';
import { S3Service } from './s3/s3.service';
import { DynamoDbService } from './dynamodb/dynamodb.service';
import { SnsService } from './sns/sns.service';

@Global()
@Module({
  imports: [ConfigModule],
  providers: [AwsSesEmailService, S3Service, SnsService, DynamoDbService],
  exports: [AwsSesEmailService, S3Service, SnsService, DynamoDbService],
})
export class AwsModule {}

```

### `apps\backend\src\common\aws\dynamodb\dynamodb.service.ts`

```typescript
import { Injectable, Logger, InternalServerErrorException, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  DynamoDBClient,
  PutItemCommand,
  GetItemCommand,
  UpdateItemCommand,
  DeleteItemCommand,
  QueryCommand,
  ScanCommand,
  BatchWriteItemCommand,
  BatchGetItemCommand,
  CreateTableCommand,
  DescribeTableCommand,
  UpdateTimeToLiveCommand,
  ResourceNotFoundException,
} from '@aws-sdk/client-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';

export interface QueryOptions {
  tableName: string;
  keyConditionExpression: string;
  expressionAttributeValues: Record<string, any>;
  expressionAttributeNames?: Record<string, string>;
  indexName?: string;
  limit?: number;
  exclusiveStartKey?: Record<string, any>;
  scanIndexForward?: boolean;
}

export interface ScanOptions {
  tableName: string;
  filterExpression?: string;
  expressionAttributeValues?: Record<string, any>;
  expressionAttributeNames?: Record<string, string>;
  limit?: number;
  exclusiveStartKey?: Record<string, any>;
}

@Injectable()
export class DynamoDbService implements OnModuleInit {
  private readonly logger = new Logger(DynamoDbService.name);
  private readonly dynamoClient: DynamoDBClient | null = null;
  private readonly isEnabled: boolean;
  private readonly region: string;
  private readonly isProduction: boolean;

  // Table names
  private readonly podTableName: string;
  private readonly executionTableName: string;
  private readonly contextTableName: string;

  constructor(private readonly configService: ConfigService) {
    this.region =
      this.configService.get<string>('AWS_DYNAMODB_REGION') ||
      this.configService.get<string>('AWS_REGION') ||
      'ap-south-1';

    const accessKeyId = this.configService.get<string>('AWS_DYNAMODB_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_DYNAMODB_SECRET_ACCESS_KEY');
    const endpoint = this.configService.get<string>('AWS_DYNAMODB_ENDPOINT');

    this.isProduction = this.configService.get('NODE_ENV') === 'production';

    // Get table names from environment
    this.podTableName = this.configService.get<string>(
      'AWS_DYNAMODB_POD_TABLE',
      'flopods-pods-dev',
    );
    this.executionTableName = this.configService.get<string>(
      'AWS_DYNAMODB_EXECUTION_TABLE',
      'flopods-executions-dev',
    );
    this.contextTableName = this.configService.get<string>(
      'AWS_DYNAMODB_CONTEXT_TABLE',
      'flopods-context-dev',
    );

    this.isEnabled = !!(accessKeyId && secretAccessKey);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      const clientConfig: any = {
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      };

      if (endpoint) {
        clientConfig.endpoint = endpoint;
        this.logger.log(`ðŸ”§ DynamoDB Local endpoint: ${endpoint}`);
      }

      this.dynamoClient = new DynamoDBClient(clientConfig);
      this.logger.log('âœ… AWS DynamoDB initialized successfully');
      this.logger.log(`ðŸ“‹ Pod Table: ${this.podTableName}`);
      this.logger.log(`ðŸ“‹ Execution Table: ${this.executionTableName}`);
      this.logger.log(`ðŸ“‹ Context Table: ${this.contextTableName}`);
    } else {
      this.logger.warn('âš ï¸  AWS DynamoDB not configured');
    }
  }

  async onModuleInit() {
    if (this.isEnabled && this.dynamoClient) {
      // Only auto-create tables in development
      if (!this.isProduction) {
        this.logger.log('ðŸ”§ Development mode: Ensuring tables exist...');
        await Promise.all([
          this.ensureTableExists(this.podTableName, this.createPodTableSchema()),
          this.ensureTableExists(this.executionTableName, this.createExecutionTableSchema()),
          this.ensureTableExists(this.contextTableName, this.createContextTableSchema()),
        ]);
        // this.logger.log('ðŸ”§ Development mode: Active');
      } else {
        this.logger.log('ðŸ­ Production mode: Skipping auto table creation');
      }
    }
  }

  /**
   * Ensure table exists (development only)
   */
  private async ensureTableExists(tableName: string, schema: CreateTableCommand['input']) {
    try {
      await this.dynamoClient!.send(new DescribeTableCommand({ TableName: tableName }));
      this.logger.log(`âœ… DynamoDB table "${tableName}" exists`);
    } catch (error: any) {
      if (error instanceof ResourceNotFoundException) {
        await this.createTable(schema);
        // Enable TTL after table creation
        await this.enableTTL(tableName);
      } else {
        this.logger.error(`âŒ Error checking table ${tableName}: ${error.message}`);
      }
    }
  }

  /**
   * Create table with schema
   */
  private async createTable(schema: CreateTableCommand['input']) {
    try {
      await this.dynamoClient!.send(new CreateTableCommand(schema));
      this.logger.log(`âœ… Created DynamoDB table "${schema.TableName}"`);

      // Wait for table to be active
      await this.waitForTableActive(schema.TableName!);
    } catch (error: any) {
      this.logger.error(`âŒ Error creating table ${schema.TableName}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Wait for table to become active
   */
  private async waitForTableActive(tableName: string, maxAttempts = 30) {
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const { Table } = await this.dynamoClient!.send(
          new DescribeTableCommand({ TableName: tableName }),
        );

        if (Table?.TableStatus === 'ACTIVE') {
          this.logger.log(`âœ… Table "${tableName}" is active`);
          return;
        }

        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch {
        this.logger.warn(`â³ Waiting for table "${tableName}" to be active...`);
      }
    }

    throw new Error(`Table "${tableName}" did not become active in time`);
  }

  /**
   * Enable TTL on a table
   */
  private async enableTTL(tableName: string) {
    try {
      await this.dynamoClient!.send(
        new UpdateTimeToLiveCommand({
          TableName: tableName,
          TimeToLiveSpecification: {
            Enabled: true,
            AttributeName: 'ttl',
          },
        }),
      );
      this.logger.log(`âœ… Enabled TTL for table "${tableName}"`);
    } catch (error: any) {
      this.logger.warn(`âš ï¸ Could not enable TTL for "${tableName}": ${error.message}`);
    }
  }

  /**
   * Pod Table Schema
   * Stores: Pod content, configuration, visual properties, connections, context
   */
  private createPodTableSchema(): CreateTableCommand['input'] {
    return {
      TableName: this.podTableName,
      KeySchema: [
        { AttributeName: 'pk', KeyType: 'HASH' }, // WORKSPACE#<id>
        { AttributeName: 'sk', KeyType: 'RANGE' }, // FLOW#<flowId>#POD#<podId>
      ],
      AttributeDefinitions: [
        { AttributeName: 'pk', AttributeType: 'S' },
        { AttributeName: 'sk', AttributeType: 'S' },
        { AttributeName: 'gsi1pk', AttributeType: 'S' }, // FLOW#<flowId>
        { AttributeName: 'gsi1sk', AttributeType: 'S' }, // POD#<podId>
        { AttributeName: 'gsi2pk', AttributeType: 'S' }, // POD#<podId>
        { AttributeName: 'gsi2sk', AttributeType: 'S' }, // VERSION#<timestamp>
      ],
      GlobalSecondaryIndexes: [
        {
          IndexName: 'GSI1-FlowPods',
          KeySchema: [
            { AttributeName: 'gsi1pk', KeyType: 'HASH' },
            { AttributeName: 'gsi1sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
        {
          IndexName: 'GSI2-PodVersions',
          KeySchema: [
            { AttributeName: 'gsi2pk', KeyType: 'HASH' },
            { AttributeName: 'gsi2sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
      ],
      BillingMode: 'PAY_PER_REQUEST',
    };
  }

  /**
   * Execution Table Schema
   * Stores: Execution results, inputs, outputs, context used, caching
   */
  private createExecutionTableSchema(): CreateTableCommand['input'] {
    return {
      TableName: this.executionTableName,
      KeySchema: [
        { AttributeName: 'pk', KeyType: 'HASH' }, // POD#<podId>
        { AttributeName: 'sk', KeyType: 'RANGE' }, // EXECUTION#<timestamp>
      ],
      AttributeDefinitions: [
        { AttributeName: 'pk', AttributeType: 'S' },
        { AttributeName: 'sk', AttributeType: 'S' },
        { AttributeName: 'gsi1pk', AttributeType: 'S' }, // FLOW#<flowId>
        { AttributeName: 'gsi1sk', AttributeType: 'S' }, // EXECUTION#<timestamp>
        { AttributeName: 'gsi2pk', AttributeType: 'S' }, // WORKSPACE#<id>#STATUS#<status>
        { AttributeName: 'gsi2sk', AttributeType: 'S' }, // TIMESTAMP#<timestamp>
      ],
      GlobalSecondaryIndexes: [
        {
          IndexName: 'GSI1-FlowExecutions',
          KeySchema: [
            { AttributeName: 'gsi1pk', KeyType: 'HASH' },
            { AttributeName: 'gsi1sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
        {
          IndexName: 'GSI2-WorkspaceExecutions',
          KeySchema: [
            { AttributeName: 'gsi2pk', KeyType: 'HASH' },
            { AttributeName: 'gsi2sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
      ],
      BillingMode: 'PAY_PER_REQUEST',
    };
  }

  /**
   * Context Table Schema
   * Stores: Context chains, pod relationships, execution context snapshots
   */
  private createContextTableSchema(): CreateTableCommand['input'] {
    return {
      TableName: this.contextTableName,
      KeySchema: [
        { AttributeName: 'pk', KeyType: 'HASH' }, // EXECUTION#<execId> or FLOW#<flowId>
        { AttributeName: 'sk', KeyType: 'RANGE' }, // CONTEXT#<timestamp> or POD#<podId>
      ],
      AttributeDefinitions: [
        { AttributeName: 'pk', AttributeType: 'S' },
        { AttributeName: 'sk', AttributeType: 'S' },
        { AttributeName: 'gsi1pk', AttributeType: 'S' }, // POD#<podId>
        { AttributeName: 'gsi1sk', AttributeType: 'S' }, // USED_IN#<flowId>#<timestamp>
      ],
      GlobalSecondaryIndexes: [
        {
          IndexName: 'GSI1-PodContextUsage',
          KeySchema: [
            { AttributeName: 'gsi1pk', KeyType: 'HASH' },
            { AttributeName: 'gsi1sk', KeyType: 'RANGE' },
          ],
          Projection: { ProjectionType: 'ALL' },
        },
      ],
      BillingMode: 'PAY_PER_REQUEST',
    };
  }

  /**
   * Put item into table
   */
  async putItem(tableName: string, item: Record<string, any>): Promise<void> {
    if (!this.isEnabled || !this.dynamoClient) {
      this.logger.debug(`[DynamoDB LOG] Put item in ${tableName}`);
      return;
    }

    try {
      const command = new PutItemCommand({
        TableName: tableName,
        Item: marshall(item, { removeUndefinedValues: true }),
      });

      await this.dynamoClient.send(command);
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB put item error:', error);
      throw new InternalServerErrorException(`Failed to put item in DynamoDB: ${error.message}`);
    }
  }

  /**
   * Get item from table
   */
  async getItem(tableName: string, key: Record<string, any>): Promise<Record<string, any> | null> {
    if (!this.isEnabled || !this.dynamoClient) {
      return null;
    }

    try {
      const command = new GetItemCommand({
        TableName: tableName,
        Key: marshall(key),
      });

      const response = await this.dynamoClient.send(command);
      return response.Item ? unmarshall(response.Item) : null;
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB get item error:', error);
      throw new InternalServerErrorException(`Failed to get item from DynamoDB: ${error.message}`);
    }
  }

  /**
   * Update item in table
   */
  async updateItem(
    tableName: string,
    key: Record<string, any>,
    updates: Record<string, any>,
  ): Promise<Record<string, any>> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const updateExpression =
        'SET ' +
        Object.keys(updates)
          .map((k, i) => `#attr${i} = :val${i}`)
          .join(', ');
      const expressionAttributeNames = Object.keys(updates).reduce(
        (acc, k, i) => {
          acc[`#attr${i}`] = k;
          return acc;
        },
        {} as Record<string, string>,
      );
      const expressionAttributeValues = marshall(
        Object.values(updates).reduce(
          (acc, v, i) => {
            acc[`:val${i}`] = v;
            return acc;
          },
          {} as Record<string, any>,
        ),
      );

      const command = new UpdateItemCommand({
        TableName: tableName,
        Key: marshall(key),
        UpdateExpression: updateExpression,
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ReturnValues: 'ALL_NEW',
      });

      const response = await this.dynamoClient.send(command);
      return response.Attributes ? unmarshall(response.Attributes) : {};
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB update item error:', error);
      throw new InternalServerErrorException(`Failed to update item: ${error.message}`);
    }
  }

  /**
   * Delete item from table
   */
  async deleteItem(tableName: string, key: Record<string, any>): Promise<void> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new DeleteItemCommand({
        TableName: tableName,
        Key: marshall(key),
      });

      await this.dynamoClient.send(command);
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB delete item error:', error);
      throw new InternalServerErrorException(`Failed to delete item: ${error.message}`);
    }
  }

  /**
   * Query items from table (supports GSI)
   */
  async query(options: QueryOptions): Promise<{
    items: Record<string, any>[];
    lastEvaluatedKey?: Record<string, any>;
  }> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new QueryCommand({
        TableName: options.tableName,
        IndexName: options.indexName,
        KeyConditionExpression: options.keyConditionExpression,
        ExpressionAttributeValues: marshall(options.expressionAttributeValues),
        ExpressionAttributeNames: options.expressionAttributeNames,
        Limit: options.limit,
        ScanIndexForward: options.scanIndexForward !== false,
        ExclusiveStartKey: options.exclusiveStartKey
          ? marshall(options.exclusiveStartKey)
          : undefined,
      });

      const response = await this.dynamoClient.send(command);

      return {
        items: (response.Items || []).map((item) => unmarshall(item)),
        lastEvaluatedKey: response.LastEvaluatedKey
          ? unmarshall(response.LastEvaluatedKey)
          : undefined,
      };
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB query error:', error);
      throw new InternalServerErrorException(`Failed to query items: ${error.message}`);
    }
  }

  /**
   * Scan table
   */
  async scan(options: ScanOptions): Promise<{
    items: Record<string, any>[];
    lastEvaluatedKey?: Record<string, any>;
  }> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new ScanCommand({
        TableName: options.tableName,
        FilterExpression: options.filterExpression,
        ExpressionAttributeValues: options.expressionAttributeValues
          ? marshall(options.expressionAttributeValues)
          : undefined,
        ExpressionAttributeNames: options.expressionAttributeNames,
        Limit: options.limit,
        ExclusiveStartKey: options.exclusiveStartKey
          ? marshall(options.exclusiveStartKey)
          : undefined,
      });

      const response = await this.dynamoClient.send(command);

      return {
        items: (response.Items || []).map((item) => unmarshall(item)),
        lastEvaluatedKey: response.LastEvaluatedKey
          ? unmarshall(response.LastEvaluatedKey)
          : undefined,
      };
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB scan error:', error);
      throw new InternalServerErrorException(`Failed to scan table: ${error.message}`);
    }
  }

  /**
   * Batch write items
   */
  async batchWrite(tableName: string, items: Record<string, any>[]): Promise<void> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    const batches = [];
    for (let i = 0; i < items.length; i += 25) {
      batches.push(items.slice(i, i + 25));
    }

    try {
      for (const batch of batches) {
        const command = new BatchWriteItemCommand({
          RequestItems: {
            [tableName]: batch.map((item) => ({
              PutRequest: { Item: marshall(item, { removeUndefinedValues: true }) },
            })),
          },
        });

        await this.dynamoClient.send(command);
      }

      this.logger.log(`âœ… ${items.length} items batch written to table`);
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB batch write error:', error);
      throw new InternalServerErrorException(`Failed to batch write items: ${error.message}`);
    }
  }

  /**
   * Batch get items
   */
  async batchGet(tableName: string, keys: Record<string, any>[]): Promise<Record<string, any>[]> {
    if (!this.isEnabled || !this.dynamoClient) {
      throw new InternalServerErrorException('DynamoDB not configured');
    }

    try {
      const command = new BatchGetItemCommand({
        RequestItems: {
          [tableName]: {
            Keys: keys.map((key) => marshall(key)),
          },
        },
      });

      const response = await this.dynamoClient.send(command);
      const items = response.Responses?.[tableName] || [];

      return items.map((item) => unmarshall(item));
    } catch (error: any) {
      this.logger.error('âŒ DynamoDB batch get error:', error);
      throw new InternalServerErrorException(`Failed to batch get items: ${error.message}`);
    }
  }

  /**
   * Helper: Get all pods in a flow with their context
   */
  async queryPodsByFlow(flowId: string): Promise<Record<string, any>[]> {
    const { items } = await this.query({
      tableName: this.podTableName,
      indexName: 'GSI1-FlowPods',
      keyConditionExpression: 'gsi1pk = :flowId',
      expressionAttributeValues: {
        ':flowId': `FLOW#${flowId}`,
      },
      scanIndexForward: true,
    });

    return items;
  }

  /**
   * Helper: Get pod content with all context
   */
  async getPodWithContext(workspaceId: string, flowId: string, podId: string) {
    return this.getItem(this.podTableName, {
      pk: `WORKSPACE#${workspaceId}`,
      sk: `FLOW#${flowId}#POD#${podId}`,
    });
  }

  /**
   * Check if DynamoDB is configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get DynamoDB configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
      isProduction: this.isProduction,
      podTableName: this.podTableName,
      executionTableName: this.executionTableName,
      contextTableName: this.contextTableName,
      endpoint: this.configService.get<string>('AWS_DYNAMODB_ENDPOINT'),
    };
  }

  /**
   * Get table names
   */
  getTableNames() {
    return {
      pods: this.podTableName,
      executions: this.executionTableName,
      context: this.contextTableName,
    };
  }
}

```

### `apps\backend\src\common\aws\s3\s3.service.ts`

```typescript
import {
  Injectable,
  Logger,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  DeleteObjectsCommand,
  HeadObjectCommand,
  ListObjectsV2Command,
  CopyObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export interface UploadOptions {
  key: string;
  body: Buffer;
  contentType?: string;
  metadata?: Record<string, string>;
  acl?: 'private' | 'public-read' | 'public-read-write';
}

export interface ListObjectsOptions {
  prefix?: string;
  maxKeys?: number;
  continuationToken?: string;
}

@Injectable()
export class S3Service {
  private readonly logger = new Logger(S3Service.name);
  private readonly s3Client: S3Client | null = null;
  private readonly bucketName: string;
  private readonly isEnabled: boolean;
  private readonly region: string;

  constructor(private readonly configService: ConfigService) {
    this.region = this.configService.get<string>('AWS_REGION') || 'us-east-1';
    const accessKeyId = this.configService.get<string>('AWS_S3_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_S3_SECRET_ACCESS_KEY');
    this.bucketName = this.configService.get<string>('AWS_S3_BUCKET_NAME') || '';

    this.isEnabled = !!(this.region && accessKeyId && secretAccessKey && this.bucketName);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      this.s3Client = new S3Client({
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      });
      this.logger.log('âœ… AWS S3 initialized successfully');
    } else {
      this.logger.warn('âš ï¸  AWS S3 not configured');
    }
  }

  /**
   * Upload file to S3
   */
  async uploadFile(options: UploadOptions): Promise<string> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    const { key, body, contentType, metadata, acl } = options;

    try {
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: key,
        Body: body,
        ContentType: contentType,
        Metadata: metadata,
        ACL: acl || 'private',
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ“ File uploaded to S3: ${key}`);

      return acl === 'public-read'
        ? `https://${this.bucketName}.s3.${this.region}.amazonaws.com/${key}`
        : key;
    } catch (error: any) {
      this.logger.error('âŒ S3 upload error:', error);
      throw new InternalServerErrorException(`Failed to upload file: ${error.message}`);
    }
  }

  /**
   * Get signed URL for secure file access
   */
  async getSignedUrl(key: string, expiresIn: number = 3600): Promise<string> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new GetObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      // Type assertion to fix AWS SDK version mismatch
      const url = await getSignedUrl(this.s3Client as any, command as any, { expiresIn });
      this.logger.log(`ðŸ”— Generated signed URL for: ${key} (expires in ${expiresIn}s)`);
      return url;
    } catch (error: any) {
      this.logger.error('âŒ S3 get signed URL error:', error);
      throw new InternalServerErrorException(`Failed to generate signed URL: ${error.message}`);
    }
  }

  /**
   * Get signed URL for file upload (client-side upload)
   */

  async getUploadSignedUrl(
    key: string,
    contentType: string,
    expiresIn: number = 3600,
  ): Promise<string> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: key,
        ContentType: contentType,
      });

      // Type assertion to fix AWS SDK version mismatch
      const url = await getSignedUrl(this.s3Client as any, command as any, { expiresIn });
      this.logger.log(`ðŸ”— Generated upload signed URL for: ${key}`);
      return url;
    } catch (error: any) {
      this.logger.error('âŒ S3 get upload signed URL error:', error);
      throw new InternalServerErrorException(`Failed to generate upload URL: ${error.message}`);
    }
  }

  /**
   * Delete single file
   */
  async deleteFile(key: string): Promise<void> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new DeleteObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ—‘ï¸  File deleted from S3: ${key}`);
    } catch (error: any) {
      this.logger.error('âŒ S3 delete error:', error);
      throw new InternalServerErrorException(`Failed to delete file: ${error.message}`);
    }
  }

  /**
   * Delete multiple files
   */
  async deleteFiles(keys: string[]): Promise<void> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    if (keys.length === 0) return;

    try {
      const command = new DeleteObjectsCommand({
        Bucket: this.bucketName,
        Delete: {
          Objects: keys.map((key) => ({ Key: key })),
        },
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ—‘ï¸  ${keys.length} files deleted from S3`);
    } catch (error: any) {
      this.logger.error('âŒ S3 batch delete error:', error);
      throw new InternalServerErrorException(`Failed to delete files: ${error.message}`);
    }
  }

  /**
   * Check if file exists
   */
  async fileExists(key: string): Promise<boolean> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new HeadObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      await this.s3Client.send(command);
      return true;
    } catch (error: any) {
      if (error.name === 'NotFound') {
        return false;
      }
      throw error;
    }
  }

  /**
   * Get file metadata
   */
  async getFileMetadata(key: string): Promise<Record<string, any>> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new HeadObjectCommand({
        Bucket: this.bucketName,
        Key: key,
      });

      const response = await this.s3Client.send(command);
      return {
        contentType: response.ContentType,
        contentLength: response.ContentLength,
        lastModified: response.LastModified,
        metadata: response.Metadata,
      };
    } catch (error: any) {
      this.logger.error('âŒ S3 get metadata error:', error);
      throw new NotFoundException(`File not found: ${key}`);
    }
  }

  /**
   * List objects in bucket
   */
  async listObjects(options: ListObjectsOptions = {}): Promise<{
    files: Array<{ key: string; size: number; lastModified: Date }>;
    nextToken?: string;
  }> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new ListObjectsV2Command({
        Bucket: this.bucketName,
        Prefix: options.prefix,
        MaxKeys: options.maxKeys || 1000,
        ContinuationToken: options.continuationToken,
      });

      const response = await this.s3Client.send(command);

      return {
        files: (response.Contents || []).map((item) => ({
          key: item.Key || '',
          size: item.Size || 0,
          lastModified: item.LastModified || new Date(),
        })),
        nextToken: response.NextContinuationToken,
      };
    } catch (error: any) {
      this.logger.error('âŒ S3 list objects error:', error);
      throw new InternalServerErrorException(`Failed to list objects: ${error.message}`);
    }
  }

  /**
   * Copy file within S3
   */
  async copyFile(sourceKey: string, destinationKey: string): Promise<void> {
    if (!this.isEnabled || !this.s3Client) {
      throw new InternalServerErrorException('S3 not configured');
    }

    try {
      const command = new CopyObjectCommand({
        Bucket: this.bucketName,
        CopySource: `${this.bucketName}/${sourceKey}`,
        Key: destinationKey,
      });

      await this.s3Client.send(command);
      this.logger.log(`ðŸ“‹ File copied: ${sourceKey} â†’ ${destinationKey}`);
    } catch (error: any) {
      this.logger.error('âŒ S3 copy error:', error);
      throw new InternalServerErrorException(`Failed to copy file: ${error.message}`);
    }
  }

  /**
   * Check if S3 is configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get S3 configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
      bucket: this.bucketName,
    };
  }
}

```

### `apps\backend\src\common\aws\ses\ses-email.service.ts`

```typescript
import { Injectable, InternalServerErrorException, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  SESClient,
  SendEmailCommand,
  SendEmailCommandInput,
  VerifyEmailIdentityCommand,
  GetSendQuotaCommand,
  ListVerifiedEmailAddressesCommand,
} from '@aws-sdk/client-ses';

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  bodyHtml: string;
  bodyText?: string;
  from?: string;
  replyTo?: string[];
  cc?: string[];
  bcc?: string[];
}

@Injectable()
export class AwsSesEmailService {
  private readonly logger = new Logger(AwsSesEmailService.name);
  private readonly sesClient: SESClient | null = null;
  private readonly defaultFromEmail: string;
  private readonly isEnabled: boolean;
  private readonly region: string;

  constructor(private readonly configService: ConfigService) {
    this.region = this.configService.get<string>('AWS_REGION') || 'us-east-1';
    const accessKeyId = this.configService.get<string>('AWS_SES_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_SES_SECRET_ACCESS_KEY');
    this.defaultFromEmail = this.configService.get<string>('AWS_SES_NO_REPLY_EMAIL') || '';

    this.isEnabled = !!(this.region && accessKeyId && secretAccessKey);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      this.sesClient = new SESClient({
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      });
      this.logger.log('âœ… AWS SES initialized successfully');
    } else {
      this.logger.warn('âš ï¸  AWS SES not configured - emails will be logged only');
    }
  }

  /**
   * Send a single email
   */
  async sendEmail(options: SendEmailOptions): Promise<{ messageId: string }> {
    const { to, subject, bodyHtml, bodyText, from, replyTo, cc, bcc } = options;

    if (!this.defaultFromEmail && !from) {
      throw new InternalServerErrorException('SES "from" email is not configured.');
    }

    const source = from || `Actopod <${this.defaultFromEmail}>`;
    const toAddresses = Array.isArray(to) ? to : [to];

    // Development mode - log only
    if (!this.isEnabled || !this.sesClient) {
      this.logger.log('=== EMAIL LOG (Development Mode) ===');
      this.logger.log(`From: ${source}`);
      this.logger.log(`To: ${toAddresses.join(', ')}`);
      this.logger.log(`Subject: ${subject}`);
      this.logger.log(`Body: ${bodyText || 'HTML content'}`);
      if (cc) this.logger.log(`CC: ${cc.join(', ')}`);
      if (bcc) this.logger.log(`BCC: ${bcc.join(', ')}`);
      this.logger.log('===================================');
      return { messageId: `dev-mode-${Date.now()}` };
    }

    const params: SendEmailCommandInput = {
      Source: source,
      Destination: {
        ToAddresses: toAddresses,
        ...(cc && cc.length > 0 && { CcAddresses: cc }),
        ...(bcc && bcc.length > 0 && { BccAddresses: bcc }),
      },
      ...(replyTo && replyTo.length > 0 && { ReplyToAddresses: replyTo }),
      Message: {
        Subject: { Data: subject, Charset: 'UTF-8' },
        Body: {
          Html: { Data: bodyHtml, Charset: 'UTF-8' },
          ...(bodyText && { Text: { Data: bodyText, Charset: 'UTF-8' } }),
        },
      },
    };

    try {
      this.logger.log(`ðŸ“§ Sending email to: ${toAddresses.join(', ')}`);
      const command = new SendEmailCommand(params);
      const response = await this.sesClient.send(command);
      this.logger.log(`âœ… Email sent successfully. Message ID: ${response.MessageId}`);
      return { messageId: response.MessageId || '' };
    } catch (error: any) {
      this.logger.error('âŒ SES send email error:', error);
      throw new InternalServerErrorException(`Failed to send email: ${error.message}`);
    }
  }

  /**
   * Send bulk emails by sending individual emails (simple approach)
   * For production with high volume, use SES SendBulkTemplatedEmail with pre-created templates
   */
  async sendBulkEmails(
    recipients: string[],
    subject: string,
    bodyHtml: string,
    bodyText?: string,
  ): Promise<{ successCount: number; failureCount: number; errors: string[] }> {
    if (!this.isEnabled || !this.sesClient) {
      this.logger.warn('Bulk email skipped - SES not configured');
      return { successCount: 0, failureCount: recipients.length, errors: [] };
    }

    let successCount = 0;
    let failureCount = 0;
    const errors: string[] = [];

    // Send emails in batches to avoid rate limiting
    const batchSize = 10;
    for (let i = 0; i < recipients.length; i += batchSize) {
      const batch = recipients.slice(i, i + batchSize);

      const promises = batch.map(async (recipient) => {
        try {
          await this.sendEmail({
            to: recipient,
            subject,
            bodyHtml,
            bodyText,
          });
          successCount++;
        } catch (error: any) {
          failureCount++;
          errors.push(`${recipient}: ${error.message}`);
        }
      });

      await Promise.all(promises);

      // Rate limiting - wait between batches
      if (i + batchSize < recipients.length) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }

    this.logger.log(`ðŸ“§ Bulk email completed: ${successCount} success, ${failureCount} failures`);
    return { successCount, failureCount, errors };
  }

  /**
   * Verify email identity (required before sending from that address)
   */
  async verifyEmailIdentity(email: string): Promise<void> {
    if (!this.isEnabled || !this.sesClient) {
      this.logger.warn(`Email verification skipped - SES not configured: ${email}`);
      return;
    }

    try {
      const command = new VerifyEmailIdentityCommand({ EmailAddress: email });
      await this.sesClient.send(command);
      this.logger.log(`âœ… Verification email sent to: ${email}`);
    } catch (error: any) {
      this.logger.error('âŒ SES verify email error:', error);
      throw new InternalServerErrorException(`Failed to verify email: ${error.message}`);
    }
  }

  /**
   * Get SES send quota (how many emails can be sent)
   */
  async getSendQuota(): Promise<{
    max24HourSend: number;
    maxSendRate: number;
    sentLast24Hours: number;
  }> {
    if (!this.isEnabled || !this.sesClient) {
      throw new InternalServerErrorException('SES not configured');
    }

    try {
      const command = new GetSendQuotaCommand({});
      const response = await this.sesClient.send(command);

      return {
        max24HourSend: response.Max24HourSend || 0,
        maxSendRate: response.MaxSendRate || 0,
        sentLast24Hours: response.SentLast24Hours || 0,
      };
    } catch (error: any) {
      this.logger.error('âŒ SES get send quota error:', error);
      throw new InternalServerErrorException(`Failed to get send quota: ${error.message}`);
    }
  }

  /**
   * List verified email addresses
   */
  async listVerifiedEmails(): Promise<string[]> {
    if (!this.isEnabled || !this.sesClient) {
      throw new InternalServerErrorException('SES not configured');
    }

    try {
      const command = new ListVerifiedEmailAddressesCommand({});
      const response = await this.sesClient.send(command);
      return response.VerifiedEmailAddresses || [];
    } catch (error: any) {
      this.logger.error('âŒ SES list verified emails error:', error);
      throw new InternalServerErrorException(`Failed to list verified emails: ${error.message}`);
    }
  }

  /**
   * Send email with retry logic
   */
  async sendEmailWithRetry(
    options: SendEmailOptions,
    maxRetries: number = 3,
  ): Promise<{ messageId: string }> {
    let lastError: any;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.sendEmail(options);
      } catch (error: any) {
        lastError = error;
        this.logger.warn(`Email send attempt ${attempt}/${maxRetries} failed: ${error.message}`);

        if (attempt < maxRetries) {
          // Exponential backoff
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  /**
   * Validate email format
   */
  validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Sanitize email list (remove invalid emails)
   */
  sanitizeEmailList(emails: string[]): string[] {
    return emails.filter((email) => this.validateEmail(email));
  }

  /**
   * Check if SES is properly configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get SES configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
      defaultFrom: this.defaultFromEmail,
    };
  }
}

```

### `apps\backend\src\common\aws\ses\templates\auth\magic-link.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const magicLinkTemplate = (
  name: string,
  magicUrl: string,
  expiresIn: string,
  ipAddress: string,
  deviceName: string,
): string => {
  const content = `
    <h2>ðŸ” Sign in to Actopod</h2>
    <p>Hi ${name || 'there'},</p>
    <p>Click the button below to securely sign in to your Actopod account:</p>
    <p style="text-align: center;">
      <a href="${magicUrl}" class="button">Sign In to Actopod</a>
    </p>
    <p>Or copy and paste this link into your browser:</p>
    <p style="word-break: break-all; color: #6b7280; background-color: #f3f4f6; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px;">
      ${magicUrl}
    </p>

    <div style="margin-top: 30px; padding: 20px; background-color: #EEF2FF; border-left: 4px solid #4F46E5; border-radius: 6px;">
      <p style="margin: 0 0 10px 0; font-weight: 600; color: #4338CA;">ðŸ”’ Security Information</p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ This link expires in <strong>${expiresIn}</strong></p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ Device: ${deviceName}</p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ IP Address: ${ipAddress}</p>
      <p style="margin: 5px 0; font-size: 14px; color: #4338CA;">â€¢ Can only be used once</p>
    </div>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF2F2; border-left: 4px solid #EF4444; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #991B1B;">
        <strong>âš ï¸ Security Warning:</strong><br>
        If you didn't request this sign-in link, please ignore this email or contact our support team immediately at <a href="mailto:${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}">${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}</a>
      </p>
    </div>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\auth\reset-password.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const resetPasswordTemplate = (name: string, resetUrl: string): string => {
  const content = `
    <h2>Reset Your Password</h2>
    <p>Hi ${name},</p>
    <p>We received a request to reset your password for your Actopod account.</p>

    <p style="text-align: center;">
      <a href="${resetUrl}" class="button">Reset Password</a>
    </p>

    <p>Or copy and paste this link into your browser:</p>
    <p style="word-break: break-all; color: #6b7280; background-color: #f3f4f6; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px;">
      ${resetUrl}
    </p>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF3C7; border-left: 4px solid #F59E0B; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #92400E;">
        â° This password reset link will expire in <strong>1 hour</strong>.
      </p>
    </div>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF2F2; border-left: 4px solid #EF4444; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #991B1B;">
        <strong>âš ï¸ Security Warning:</strong><br>
        If you didn't request a password reset, please ignore this email. Your password will remain unchanged.
      </p>
    </div>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\auth\verify-email.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const verifyEmailTemplate = (name: string, verificationUrl: string): string => {
  const content = `
    <h2>Welcome to Actopod, ${name}!</h2>
    <p>Thank you for signing up. Please verify your email address to get started with our AI Workflow Canvas.</p>

    <p style="text-align: center;">
      <a href="${verificationUrl}" class="button">Verify Email Address</a>
    </p>

    <p>Or copy and paste this link into your browser:</p>
    <p style="word-break: break-all; color: #6b7280; background-color: #f3f4f6; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px;">
      ${verificationUrl}
    </p>

    <div style="margin-top: 20px; padding: 15px; background-color: #FEF3C7; border-left: 4px solid #F59E0B; border-radius: 6px;">
      <p style="margin: 0; font-size: 14px; color: #92400E;">
        â° This verification link will expire in <strong>24 hours</strong>.
      </p>
    </div>

    <p style="margin-top: 20px; color: #6b7280; font-size: 14px;">
      If you didn't create an account with Actopod, you can safely ignore this email.
    </p>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\auth\welcome.template.ts`

```typescript
import { baseEmailTemplate } from '../base.template';

export const welcomeEmailTemplate = (name: string): string => {
  const content = `
    <h2>Welcome to Actopod, ${name}! ðŸŽ‰</h2>
    <p>Your account has been successfully verified.</p>
    <p>You're all set to start building powerful AI workflows with our Multi-LLM Node-Based Platform.</p>

    <div style="margin: 30px 0; padding: 20px; background-color: #F0FDF4; border-radius: 8px;">
      <h3 style="margin-top: 0; color: #065F46;">ðŸš€ Quick Start Guide</h3>
      <ul style="padding-left: 20px;">
        <li style="margin: 10px 0;">Create your first canvas</li>
        <li style="margin: 10px 0;">Add AI nodes (OpenAI, Anthropic, Google Gemini, and more)</li>
        <li style="margin: 10px 0;">Connect nodes to build powerful workflows</li>
        <li style="margin: 10px 0;">Run and iterate on your AI canvas</li>
      </ul>
    </div>

    <p style="text-align: center;">
      <a href="${process.env.FRONTEND_URL}/dashboard" class="button">Get Started â†’</a>
    </p>

    <div style="margin-top: 30px; padding: 20px; background-color: #F9FAFB; border-radius: 8px;">
      <h3 style="margin-top: 0; color: #374151;">ðŸ“š Helpful Resources</h3>
      <ul style="list-style: none; padding: 0;">
        <li style="margin: 10px 0;">
          ðŸ“– <a href="${process.env.FRONTEND_URL}/docs">Documentation</a> - Learn the basics
        </li>
        <li style="margin: 10px 0;">
          ðŸŽ“ <a href="${process.env.FRONTEND_URL}/tutorials">Tutorials</a> - Step-by-step guides
        </li>
        <li style="margin: 10px 0;">
          ðŸ’¬ <a href="${process.env.FRONTEND_URL}/community">Community</a> - Connect with others
        </li>
        <li style="margin: 10px 0;">
          ðŸ†˜ <a href="${process.env.FRONTEND_URL}/support">Support</a> - Get help anytime
        </li>
      </ul>
    </div>

    <p style="margin-top: 30px;">
      Need help getting started? Our support team is here to help at
      <a href="mailto:${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}">${process.env.AWS_SES_SUPPORT_EMAIL || 'support@actopod.dev'}</a>
    </p>
  `;
  return baseEmailTemplate(content);
};

```

### `apps\backend\src\common\aws\ses\templates\base.template.ts`

```typescript
export const baseEmailTemplate = (content: string): string => `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Actopod</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9fafb;
    }
    .container {
      background-color: #ffffff;
      border-radius: 8px;
      padding: 40px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .header {
      text-align: center;
      padding-bottom: 30px;
      border-bottom: 2px solid #4F46E5;
      margin-bottom: 30px;
    }
    .logo {
      font-size: 32px;
      font-weight: bold;
      color: #4F46E5;
      text-decoration: none;
    }
    .content {
      color: #374151;
      font-size: 16px;
    }
    .content h2 {
      color: #111827;
      font-size: 24px;
      margin-top: 0;
    }
    .button {
      display: inline-block;
      padding: 14px 28px;
      background-color: #4F46E5;
      color: #ffffff !important;
      text-decoration: none;
      border-radius: 8px;
      margin: 20px 0;
      font-weight: 600;
      transition: background-color 0.3s;
    }
    .button:hover {
      background-color: #4338CA;
    }
    .footer {
      text-align: center;
      padding-top: 30px;
      margin-top: 30px;
      border-top: 1px solid #e5e7eb;
      color: #6b7280;
      font-size: 14px;
    }
    .footer a {
      color: #4F46E5;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">ðŸš€ Actopod</div>
    </div>
    <div class="content">
      ${content}
    </div>
    <div class="footer">
      <p>Â© ${new Date().getFullYear()} Actopod. All rights reserved.</p>
      <p>AI Workflow Canvas - Multi-LLM Node-Based Platform</p>
      <p>
        <a href="${process.env.FRONTEND_URL}/help">Help Center</a> â€¢
        <a href="${process.env.FRONTEND_URL}/privacy">Privacy Policy</a> â€¢
        <a href="${process.env.FRONTEND_URL}/terms">Terms of Service</a>
      </p>
    </div>
  </div>
</body>
</html>
`;

```

### `apps\backend\src\common\aws\ses\templates\workspace\invitation.template.ts`

```typescript
import { WorkspaceRole } from '@actopod/schema';

export const workspaceInvitationTemplate = (
  workspaceName: string,
  inviteLink: string,
  role: WorkspaceRole,
): string => {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Workspace Invitation</title>
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f5f5f5;">
  <div style="max-width: 600px; margin: 40px auto; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; text-align: center; border-radius: 8px 8px 0 0;">
      <h1 style="color: #ffffff; margin: 0; font-size: 28px; font-weight: 600;">Workspace Invitation</h1>
    </div>

    <div style="padding: 40px;">
      <p style="font-size: 16px; color: #333; line-height: 1.6; margin: 0 0 20px;">
        You've been invited to join <strong>${workspaceName}</strong> as a <strong>${role}</strong> on Actopod.
      </p>

      <p style="font-size: 16px; color: #333; line-height: 1.6; margin: 0 0 30px;">
        Click the button below to accept the invitation and start collaborating:
      </p>

      <div style="text-align: center; margin: 30px 0;">
        <a href="${inviteLink}" style="display: inline-block; padding: 14px 32px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #ffffff; text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 16px;">
          Accept Invitation
        </a>
      </div>

      <p style="font-size: 14px; color: #666; line-height: 1.6; margin: 30px 0 0; padding-top: 20px; border-top: 1px solid #eee;">
        This invitation will expire in <strong>7 days</strong>.
      </p>

      <p style="font-size: 14px; color: #666; line-height: 1.6; margin: 10px 0 0;">
        If you didn't expect this invitation, you can safely ignore this email.
      </p>
    </div>

    <div style="background-color: #f9f9f9; padding: 20px; text-align: center; border-radius: 0 0 8px 8px; border-top: 1px solid #eee;">
      <p style="margin: 0; font-size: 12px; color: #999;">
        Â© ${new Date().getFullYear()} Actopod. All rights reserved.
      </p>
    </div>
  </div>
</body>
</html>
  `;
};

```

### `apps\backend\src\common\aws\sns\sns.service.ts`

```typescript
import { Injectable, Logger, InternalServerErrorException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  SNSClient,
  PublishCommand,
  CreateTopicCommand,
  SubscribeCommand,
  UnsubscribeCommand,
  ListTopicsCommand,
  SetTopicAttributesCommand,
} from '@aws-sdk/client-sns';

export interface PublishOptions {
  topicArn: string;
  message: string;
  subject?: string;
  messageAttributes?: Record<string, any>;
}

export interface SubscriptionOptions {
  topicArn: string;
  protocol: 'email' | 'sms' | 'http' | 'https' | 'sqs' | 'lambda';
  endpoint: string;
}

@Injectable()
export class SnsService {
  private readonly logger = new Logger(SnsService.name);
  private readonly snsClient: SNSClient | null = null;
  private readonly isEnabled: boolean;
  private readonly region: string;

  constructor(private readonly configService: ConfigService) {
    this.region = this.configService.get<string>('AWS_REGION') || 'us-east-1';
    const accessKeyId = this.configService.get<string>('AWS_SNS_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_SNS_SECRET_ACCESS_KEY');

    this.isEnabled = !!(this.region && accessKeyId && secretAccessKey);

    if (this.isEnabled && accessKeyId && secretAccessKey) {
      this.snsClient = new SNSClient({
        region: this.region,
        credentials: {
          accessKeyId,
          secretAccessKey,
        },
        maxAttempts: 3,
      });
      this.logger.log('âœ… AWS SNS initialized successfully');
    } else {
      this.logger.warn('âš ï¸  AWS SNS not configured');
    }
  }

  /**
   * Publish message to SNS topic
   */
  async publishMessage(options: PublishOptions): Promise<string> {
    if (!this.isEnabled || !this.snsClient) {
      this.logger.log(`[SNS LOG] Topic: ${options.topicArn}, Message: ${options.message}`);
      return `dev-mode-${Date.now()}`;
    }

    try {
      const command = new PublishCommand({
        TopicArn: options.topicArn,
        Message: options.message,
        Subject: options.subject,
        MessageAttributes: options.messageAttributes,
      });

      const response = await this.snsClient.send(command);
      this.logger.log(`ðŸ“¢ SNS message published: ${response.MessageId}`);
      return response.MessageId || '';
    } catch (error: any) {
      this.logger.error('âŒ SNS publish error:', error);
      throw new InternalServerErrorException(`Failed to publish SNS message: ${error.message}`);
    }
  }

  /**
   * Create SNS topic
   */
  async createTopic(name: string): Promise<string> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new CreateTopicCommand({ Name: name });
      const response = await this.snsClient.send(command);
      this.logger.log(`âœ… SNS topic created: ${name}`);
      return response.TopicArn || '';
    } catch (error: any) {
      this.logger.error('âŒ SNS create topic error:', error);
      throw new InternalServerErrorException(`Failed to create SNS topic: ${error.message}`);
    }
  }

  /**
   * Subscribe to SNS topic
   */
  async subscribe(options: SubscriptionOptions): Promise<string> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new SubscribeCommand({
        TopicArn: options.topicArn,
        Protocol: options.protocol,
        Endpoint: options.endpoint,
      });

      const response = await this.snsClient.send(command);
      this.logger.log(`âœ… Subscribed to SNS topic: ${options.topicArn}`);
      return response.SubscriptionArn || '';
    } catch (error: any) {
      this.logger.error('âŒ SNS subscribe error:', error);
      throw new InternalServerErrorException(`Failed to subscribe to SNS topic: ${error.message}`);
    }
  }

  /**
   * Unsubscribe from SNS topic
   */
  async unsubscribe(subscriptionArn: string): Promise<void> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new UnsubscribeCommand({ SubscriptionArn: subscriptionArn });
      await this.snsClient.send(command);
      this.logger.log(`âœ… Unsubscribed from SNS topic`);
    } catch (error: any) {
      this.logger.error('âŒ SNS unsubscribe error:', error);
      throw new InternalServerErrorException(`Failed to unsubscribe: ${error.message}`);
    }
  }

  /**
   * List all SNS topics
   */
  async listTopics(): Promise<string[]> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new ListTopicsCommand({});
      const response = await this.snsClient.send(command);
      return (response.Topics || []).map((t) => t.TopicArn || '');
    } catch (error: any) {
      this.logger.error('âŒ SNS list topics error:', error);
      throw new InternalServerErrorException(`Failed to list SNS topics: ${error.message}`);
    }
  }

  /**
   * Set topic attribute
   */
  async setTopicAttribute(
    topicArn: string,
    attributeName: string,
    attributeValue: string,
  ): Promise<void> {
    if (!this.isEnabled || !this.snsClient) {
      throw new InternalServerErrorException('SNS not configured');
    }

    try {
      const command = new SetTopicAttributesCommand({
        TopicArn: topicArn,
        AttributeName: attributeName,
        AttributeValue: attributeValue,
      });

      await this.snsClient.send(command);
      this.logger.log(`âœ… SNS topic attribute set: ${attributeName}`);
    } catch (error: any) {
      this.logger.error('âŒ SNS set attribute error:', error);
      throw new InternalServerErrorException(`Failed to set topic attribute: ${error.message}`);
    }
  }

  /**
   * Check if SNS is configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Get SNS configuration info
   */
  getConfig() {
    return {
      isEnabled: this.isEnabled,
      region: this.region,
    };
  }
}

```

### `apps\backend\src\common\decorators\common\index.ts`

```typescript
export * from './public.decorator';
export * from './paginate.decorator';
export * from './is-not-empty-object.decorator';

```

### `apps\backend\src\common\decorators\common\is-not-empty-object.decorator.ts`

```typescript
// src/common/decorators/common/is-not-empty-object.decorator.ts

import type { ValidationOptions, ValidationArguments } from 'class-validator';
import { registerDecorator } from 'class-validator';

export function IsNotEmptyObject(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'isNotEmptyObject',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          // Exclude the 'data' property itself from the check
          const keys = Object.keys(args.object).filter(
            (key) => key !== propertyName,
          );
          return keys.length > 0;
        },
        defaultMessage() {
          return 'At least one field must be provided';
        },
      },
    });
  };
}

```

### `apps\backend\src\common\decorators\common\paginate.decorator.ts`

```typescript
import {
  SetMetadata,
  createParamDecorator,
  ExecutionContext,
} from '@nestjs/common';

export const PAGINATE_METADATA_KEY = 'paginate';

export interface PaginateOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  order?: 'asc' | 'desc';
  search?: string;
  filters?: { [key: string]: any };
}

/**
 * This decorator is still available if you want to set some default metadata.
 */
export const Paginate = (
  options: PaginateOptions = {
    page: 1,
    limit: 20,
    sortBy: 'createdAt',
    order: 'desc',
  },
) => SetMetadata(PAGINATE_METADATA_KEY, options);

/**
 * Extract pagination options from the request query.
 */
export const PaginationParams = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): PaginateOptions => {
    const request = ctx.switchToHttp().getRequest();
    const page = parseInt(request.query.page, 10) || 1;
    const limit = parseInt(request.query.limit, 10) || 20;
    const sortBy = request.query.sortBy || 'createdAt';
    const order = request.query.order || 'desc';
    const search = request.query.search || '';
    const filters = request.query.filters
      ? JSON.parse(request.query.filters)
      : {};
    return { page, limit, sortBy, order, search, filters };
  },
);

```

### `apps\backend\src\common\decorators\common\public.decorator.ts`

```typescript
// src/common/decorators/common.decorator.ts

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

```

### `apps\backend\src\common\decorators\user\get-current-user.decorator.ts`

```typescript
// src/common/decorators/user.decorator.ts

import type { ExecutionContext } from '@nestjs/common';
import { createParamDecorator } from '@nestjs/common';

export const GetCurrentUser = createParamDecorator(
  (data: string | undefined, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest();
    if (data) {
      return request.user[data];
    }
    return request.user;
  },
);

```

### `apps\backend\src\common\decorators\user\get-current-user-id.decorator.ts`

```typescript
// src/common/decorators/user.decorator.ts

import type { ExecutionContext } from '@nestjs/common';
import { createParamDecorator, UnauthorizedException } from '@nestjs/common';

export const GetCurrentUserId = createParamDecorator(
  (data: unknown, context: ExecutionContext): string => {
    const request = context.switchToHttp().getRequest();
    return request.user?.userId;
  },
);

```

### `apps\backend\src\common\decorators\user\index.ts`

```typescript
export * from './get-current-user.decorator';
export * from './get-current-user-id.decorator';

```

### `apps\backend\src\common\dto\pagination.dto.ts`

```typescript
// src/common/dto/pagination-query.dto.ts

import { IsOptional, IsPositive, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationQueryDto {
  @IsOptional()
  @IsPositive()
  @Type(() => Number)
  page?: number = 1;

  @IsOptional()
  @IsPositive()
  @Type(() => Number)
  limit?: number = 10;

  @IsOptional()
  @IsString()
  sortBy?: string;

  @IsOptional()
  @IsString()
  order?: 'asc' | 'desc' = 'asc';

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  filters?: { [key: string]: any }; // You can enhance this to be more specific
}

```

### `apps\backend\src\common\filters\exception.filters.ts`

```typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // CRITICAL: Don't try to send response if headers already sent
    if (response.headersSent) {
      this.logger.error('Headers already sent. Cannot send error response.');
      this.logger.error('Exception details:', exception);
      return;
    }

    let status: number;
    let message: string;
    let errors: any[] = [];

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'object') {
        message = (exceptionResponse as any).message || exception.message;
        errors = (exceptionResponse as any).errors || [];
      } else {
        message = exceptionResponse;
      }
    } else {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Internal server error';
      this.logger.error('Unhandled exception:', exception);
    }

    try {
      response.status(status).json({
        statusCode: status,
        message,
        errors,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
    } catch (error) {
      // If we still can't send response, log it
      this.logger.error('Failed to send error response:', error);
    }
  }
}

```

### `apps\backend\src\common\filters\ws-exception.filter.ts`

```typescript
// common/filters/ws-exception.filter.ts
import { Catch, ArgumentsHost } from '@nestjs/common';
import { BaseWsExceptionFilter, WsException } from '@nestjs/websockets';
import { Socket } from 'socket.io';

@Catch()
export class WsExceptionFilter extends BaseWsExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const client = host.switchToWs().getClient<Socket>();

    const error =
      exception instanceof WsException
        ? exception.getError()
        : exception instanceof Error
          ? exception.message
          : 'Unknown error';

    client.emit('error', {
      message: typeof error === 'string' ? error : 'Internal server error',
      code: 'WS_ERROR',
      timestamp: new Date().toISOString(),
    });
  }
}

```

### `apps\backend\src\common\guards\auth\access-token.guard.ts`

```typescript
import { Injectable, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { IS_PUBLIC_KEY } from '../../decorators/common';

@Injectable()
export class AccessTokenGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }
}

```

### `apps\backend\src\common\guards\auth\github-oauth.guard.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GitHubOAuthGuard extends AuthGuard('github') {}

```

### `apps\backend\src\common\guards\auth\google-oauth.guard.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GoogleOAuthGuard extends AuthGuard('google') {}

```

### `apps\backend\src\common\guards\auth\index.ts`

```typescript
export * from './access-token.guard';
export * from './refresh-token.guard';
export * from './google-oauth.guard';
export * from './github-oauth.guard';

```

### `apps\backend\src\common\guards\auth\refresh-token.guard.ts`

```typescript
// src/auth/guards/refresh-token.guard.ts

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class RefreshTokenGuard extends AuthGuard('jwt-refresh') {}

```

### `apps\backend\src\common\interceptors\response.interceptor.ts`

```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  HttpStatus,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Reflector } from '@nestjs/core';
import { PAGINATE_METADATA_KEY, PaginateOptions } from '../decorators/common';
import { Response } from 'express';

interface ApiResponse<T> {
  statusCode: number;
  message: string;
  data: T | null;
  errors?: string[];
  timestamp: string;
  pagination?: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
  };
}

interface PaginationResult {
  data: any;
  pagination?: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
  };
}

@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, ApiResponse<T>> {
  constructor(private readonly reflector: Reflector) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<ApiResponse<T> | any> {
    const ctx = context.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest();

    // CRITICAL: Skip if headers already sent (OAuth redirects)
    if (response.headersSent) {
      return next.handle();
    }

    const paginateOptions = this.reflector.get<PaginateOptions>(
      PAGINATE_METADATA_KEY,
      context.getHandler(),
    );

    return next.handle().pipe(
      map((data: any) => {
        // Double-check after handler execution
        if (response.headersSent) {
          return data;
        }

        // Don't wrap null/undefined or redirects
        if (!data || response.statusCode === 302 || response.statusCode === 301) {
          return data;
        }

        const statusCode = data.statusCode || response.statusCode || HttpStatus.OK;
        const message = data.message || response.locals.customMessage || 'Success';
        const errors = data.errors || response.locals.errors || [];
        const timestamp = data.timestamp || new Date().toISOString();

        // If data already contains pagination metadata, return as-is
        if (data && typeof data === 'object' && data.pagination) {
          return this.sanitizeResponse({
            statusCode,
            message,
            data: data.data,
            errors,
            timestamp,
            pagination: data.pagination,
          });
        }

        // Apply pagination if needed
        const responseData = data.data !== undefined ? data.data : data;
        const paginationData: PaginationResult = {
          data: responseData,
        };

        if (Array.isArray(responseData) && paginateOptions) {
          const paginated = this.applyPagination(responseData, paginateOptions, request);
          paginationData.data = paginated.data;
          paginationData.pagination = paginated.pagination;
        }

        return this.sanitizeResponse({
          statusCode,
          message,
          data: paginationData.data as T,
          errors,
          timestamp,
          ...(paginationData.pagination ? { pagination: paginationData.pagination } : {}),
        });
      }),
    );
  }

  private applyPagination(data: any[], options: PaginateOptions, request: any): PaginationResult {
    let { page, limit, sortBy, order, search, filters } = options;
    page = parseInt(request.query.page, 10) || page || 1;
    limit = parseInt(request.query.limit, 10) || limit || 20;
    sortBy = request.query.sortBy || sortBy || 'createdAt';
    order = request.query.order || order || 'desc';
    search = request.query.search || search || '';
    filters = request.query.filters ? JSON.parse(request.query.filters) : filters || {};

    let filteredData = data;

    if (search) {
      filteredData = filteredData.filter((item) =>
        Object.values(item).some((val) => String(val).toLowerCase().includes(search.toLowerCase())),
      );
    }

    if (filters) {
      for (const [key, value] of Object.entries(filters)) {
        filteredData = filteredData.filter((item: { [key: string]: any }) => item[key] === value);
      }
    }

    if (sortBy) {
      filteredData = filteredData.sort((a, b) => {
        if (a[sortBy] < b[sortBy]) {
          return order === 'asc' ? -1 : 1;
        }
        if (a[sortBy] > b[sortBy]) {
          return order === 'asc' ? 1 : -1;
        }
        return 0;
      });
    }

    const totalItems = filteredData.length;
    const totalPages = Math.ceil(totalItems / limit);
    const startIndex = (page - 1) * limit;
    const endIndex = Math.min(startIndex + limit, totalItems);
    const paginatedData = filteredData.slice(startIndex, endIndex);

    return {
      data: paginatedData,
      pagination: {
        totalItems,
        totalPages,
        currentPage: page,
        pageSize: paginatedData.length,
      },
    };
  }

  private sanitizeData(data: any): any {
    if (Array.isArray(data)) {
      return data.map((item) => this.sanitizeData(item));
    } else if (data !== null && typeof data === 'object') {
      if (typeof data.toISOString === 'function') {
        return data.toISOString();
      }
      const sanitized: any = {};
      for (const [key, value] of Object.entries(data)) {
        if (key === 'hash' || key === 'password') {
          continue;
        }
        sanitized[key] = this.sanitizeData(value);
      }
      return sanitized;
    }
    return data;
  }

  private sanitizeResponse(response: ApiResponse<T>): ApiResponse<T> {
    return this.sanitizeData(response);
  }
}

```

### `apps\backend\src\common\queue\queue.factory.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { QueueAdapter } from './queue-adapter.interface';
import { RedisQueueAdapter } from './redis-queue.adapter';
import { SqsQueueAdapter } from './sqs-queue.adapter';

@Injectable()
export class QueueFactory {
  private readonly logger = new Logger(QueueFactory.name);

  constructor(private readonly config: ConfigService) {}

  createQueue(queueName: string, concurrency: number = 10): QueueAdapter {
    const backend = this.config.get('QUEUE_BACKEND', 'redis');

    this.logger.log(`ðŸ”§ Creating queue "${queueName}" with backend: ${backend}`);

    if (backend === 'sqs') {
      return new SqsQueueAdapter(this.config);
    }

    return new RedisQueueAdapter(this.config, queueName, concurrency);
  }
}

```

### `apps\backend\src\common\queue\queue.module.ts`

```typescript
import { Module, Global } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { QueueFactory } from './queue.factory';

@Global()
@Module({
  imports: [ConfigModule],
  providers: [QueueFactory],
  exports: [QueueFactory],
})
export class QueueModule {}

```

### `apps\backend\src\common\queue\queue-adapter.interface.ts`

```typescript
import { JobState } from 'bullmq';

export interface QueueJobData<T = any> {
  id?: string;
  data: T;
  attemptsMade?: number;
}

export interface QueueMetrics {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
}

export interface QueueJobStatus {
  id?: string;
  state?: JobState | 'unknown';
  progress?: any;
  attemptsMade?: number;
  processedOn?: number;
  finishedOn?: number;
}

export interface QueueAdapter<T = any> {
  add(jobName: string, data: T, options?: any): Promise<string>;
  process(handler: (job: any) => Promise<any>): void;
  getMetrics(): Promise<QueueMetrics>;
  cancel(jobId: string): Promise<boolean>;
  getJobStatus(jobId: string): Promise<QueueJobStatus | null>;
  close(): Promise<void>;
}

```

### `apps\backend\src\common\queue\redis-queue.adapter.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Queue, Worker, Job } from 'bullmq';
import { QueueAdapter, QueueJobStatus } from './queue-adapter.interface';

@Injectable()
export class RedisQueueAdapter implements QueueAdapter {
  private readonly logger = new Logger(RedisQueueAdapter.name);
  private queue: Queue;
  private worker!: Worker;

  constructor(
    private readonly config: ConfigService,
    queueName: string,
    private readonly concurrency: number = 10,
  ) {
    const redisConfig = {
      host: this.config.get('REDIS_HOST', 'localhost'),
      port: this.config.get('REDIS_PORT', 6379),
      password: this.config.get('REDIS_PASSWORD'),
      tls: this.config.get('REDIS_TLS_ENABLED') === 'true' ? {} : undefined,
    };

    this.queue = new Queue(queueName, {
      connection: redisConfig,
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
        removeOnComplete: {
          age: 3600,
          count: 1000,
        },
        removeOnFail: {
          age: 86400,
        },
      },
    });

    this.logger.log(`âœ… Redis queue initialized: ${queueName}`);
  }

  async add(jobName: string, data: any, options?: any): Promise<string> {
    const job = await this.queue.add(jobName, data, options);
    return job.id || `${Date.now()}`;
  }

  process(handler: (job: any) => Promise<any>): void {
    this.worker = new Worker(this.queue.name, async (job: Job) => handler(job), {
      connection: this.queue.opts.connection as any,
      concurrency: this.concurrency,
    });

    this.setupEventHandlers();
  }

  async getMetrics() {
    const [waiting, active, completed, failed] = await Promise.all([
      this.queue.getWaitingCount(),
      this.queue.getActiveCount(),
      this.queue.getCompletedCount(),
      this.queue.getFailedCount(),
    ]);

    return { waiting, active, completed, failed };
  }

  async cancel(jobId: string): Promise<boolean> {
    const job = await this.queue.getJob(jobId);
    if (job) {
      await job.remove();
      return true;
    }
    return false;
  }

  async getJobStatus(jobId: string): Promise<QueueJobStatus | null> {
    const job = await this.queue.getJob(jobId);
    if (!job) return null;

    return {
      id: job.id,
      state: await job.getState(),
      progress: job.progress,
      attemptsMade: job.attemptsMade,
      processedOn: job.processedOn,
      finishedOn: job.finishedOn,
    };
  }

  private setupEventHandlers() {
    this.worker.on('completed', (job: Job) => {
      this.logger.log(`âœ… Job ${job.id} completed`);
    });

    this.worker.on('failed', (job: Job | undefined, err: Error) => {
      this.logger.error(`âŒ Job ${job?.id} failed:`, err.message);
    });

    this.worker.on('stalled', (jobId: string) => {
      this.logger.warn(`âš ï¸ Job ${jobId} stalled`);
    });
  }

  async close(): Promise<void> {
    await this.queue.close();
    if (this.worker) await this.worker.close();
  }
}

```

### `apps\backend\src\common\queue\sqs-queue.adapter.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  SQSClient,
  SendMessageCommand,
  ReceiveMessageCommand,
  DeleteMessageCommand,
  GetQueueAttributesCommand,
  Message,
} from '@aws-sdk/client-sqs';
import { QueueAdapter, QueueJobStatus } from './queue-adapter.interface';

@Injectable()
export class SqsQueueAdapter implements QueueAdapter {
  private readonly logger = new Logger(SqsQueueAdapter.name);
  private sqs: SQSClient;
  private queueUrl: string;
  private isProcessing = false;
  private processingHandler: ((job: any) => Promise<any>) | null = null;

  constructor(private readonly config: ConfigService) {
    const region = this.config.get('AWS_SQS_REGION') || this.config.get('AWS_REGION');

    this.sqs = new SQSClient({
      region,
      credentials: {
        accessKeyId: this.config.get('AWS_SQS_ACCESS_KEY_ID')!,
        secretAccessKey: this.config.get('AWS_SQS_SECRET_ACCESS_KEY')!,
      },
    });

    this.queueUrl = this.config.get('AWS_SQS_QUEUE_URL')!;
    this.logger.log(`âœ… SQS queue initialized: ${this.queueUrl}`);
  }

  async add(jobName: string, data: any, options?: any): Promise<string> {
    const jobId = options?.jobId || Date.now().toString();

    const command = new SendMessageCommand({
      QueueUrl: this.queueUrl,
      MessageBody: JSON.stringify({ jobName, data, options }),
      MessageAttributes: {
        jobName: { DataType: 'String', StringValue: jobName },
        jobId: { DataType: 'String', StringValue: jobId },
      },
    });

    const result = await this.sqs.send(command);
    return result.MessageId || jobId;
  }

  process(handler: (job: any) => Promise<any>): void {
    this.processingHandler = handler;
    this.startPolling();
  }

  private async startPolling() {
    this.isProcessing = true;

    while (this.isProcessing) {
      try {
        const command = new ReceiveMessageCommand({
          QueueUrl: this.queueUrl,
          MaxNumberOfMessages: 10,
          WaitTimeSeconds: 20,
          MessageAttributeNames: ['All'],
        });

        const result = await this.sqs.send(command);

        if (result.Messages && result.Messages.length > 0) {
          await Promise.all(
            result.Messages.map(async (message: Message) => {
              try {
                const body = JSON.parse(message.Body!);
                const job = {
                  id: message.MessageAttributes?.jobId?.StringValue || message.MessageId,
                  data: body.data,
                  attemptsMade: 0,
                };

                await this.processingHandler!(job);

                const deleteCommand = new DeleteMessageCommand({
                  QueueUrl: this.queueUrl,
                  ReceiptHandle: message.ReceiptHandle!,
                });
                await this.sqs.send(deleteCommand);

                this.logger.log(`âœ… Job ${job.id} completed`);
              } catch (error) {
                this.logger.error(
                  `âŒ Job processing failed:`,
                  error instanceof Error ? error.message : 'Unknown error',
                );
              }
            }),
          );
        }
      } catch (error) {
        this.logger.error('SQS polling error:', error);
        await new Promise((resolve) => setTimeout(resolve, 5000));
      }
    }
  }

  async getMetrics() {
    const command = new GetQueueAttributesCommand({
      QueueUrl: this.queueUrl,
      AttributeNames: [
        'ApproximateNumberOfMessages',
        'ApproximateNumberOfMessagesNotVisible',
        'ApproximateNumberOfMessagesDelayed',
      ],
    });

    const result = await this.sqs.send(command);

    return {
      waiting: parseInt(result.Attributes?.ApproximateNumberOfMessages || '0'),
      active: parseInt(result.Attributes?.ApproximateNumberOfMessagesNotVisible || '0'),
      completed: 0,
      failed: 0,
    };
  }

  async cancel(_jobId: string): Promise<boolean> {
    this.logger.warn('SQS does not support job cancellation by ID');
    return false;
  }

  async getJobStatus(_jobId: string): Promise<QueueJobStatus | null> {
    return null;
  }

  async close(): Promise<void> {
    this.isProcessing = false;
  }
}

```

### `apps\backend\src\common\websocket\websocket.module.ts`

```typescript
import { Global, Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Global()
@Module({
  imports: [
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_ACCESS_TOKEN_SECRET') || 'fallback-secret',
      }),
      inject: [ConfigService],
    }),
  ],
  exports: [JwtModule],
})
export class WebSocketModule {}

```

### `apps\backend\src\main.ts`

```typescript
import 'tsconfig-paths/register';
import { NestFactory, Reflector } from '@nestjs/core';
import {
  ClassSerializerInterceptor,
  HttpException,
  HttpStatus,
  ValidationPipe,
  VersioningType,
  Logger,
} from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { ValidationError } from 'class-validator';

import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/exception.filters';
import { ResponseInterceptor } from './common/interceptors/response.interceptor';
import { PrismaService } from './prisma/prisma.service';
import { config } from 'dotenv';
import { join } from 'path';

config({ path: join(__dirname, '../../..', '.env') });

function flattenValidationErrors(
  errors: ValidationError[],
  parentPath = '',
): { property: string; constraints: Record<string, string> }[] {
  const result: { property: string; constraints: Record<string, string> }[] = [];

  for (const error of errors) {
    const propertyPath = parentPath
      ? Array.isArray(error)
        ? `${parentPath}[${error.property}]`
        : `${parentPath}.${error.property}`
      : error.property;

    if (error.constraints) {
      result.push({
        property: propertyPath,
        constraints: error.constraints,
      });
    }

    if (error.children && error.children.length > 0) {
      const childPathPrefix = Array.isArray(error) ? `${propertyPath}` : `${propertyPath}`;
      result.push(...flattenValidationErrors(error.children, childPathPrefix));
    }
  }

  return result;
}

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule, {
    rawBody: true,
  });

  // Global API prefix
  app.setGlobalPrefix('api');

  // CORS configuration (applies to both HTTP and WebSocket)
  app.enableCors({
    origin: [
      process.env.FRONTEND_URL || 'http://localhost:5173',
      /^http:\/\/localhost:\d+$/, // Allow all localhost ports
      /^https?:\/\/.*\.actopod\.dev/, // Production subdomains
    ],
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    credentials: true,
  });

  // API Versioning
  app.enableVersioning({
    type: VersioningType.URI,
    defaultVersion: '1',
  });

  // Connect to Prisma database
  const prisma = app.get(PrismaService);
  try {
    await prisma.$connect();
    logger.log('âœ… Database connected successfully');
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('âŒ Database connection failed', errorMessage);
    throw new HttpException(
      { message: 'Unable to connect to database', error: errorMessage },
      HttpStatus.INTERNAL_SERVER_ERROR,
    );
  }

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
      forbidNonWhitelisted: true,
      exceptionFactory: (validationErrors: ValidationError[] = []) => {
        const flattened = flattenValidationErrors(validationErrors);
        return new HttpException(
          {
            message: 'Validation failed',
            errors: flattened,
          },
          HttpStatus.BAD_REQUEST,
        );
      },
    }),
  );

  // Global interceptors and filters
  const reflector = app.get(Reflector);
  app.useGlobalInterceptors(new ResponseInterceptor(reflector));
  app.useGlobalInterceptors(new ClassSerializerInterceptor(reflector));
  app.useGlobalFilters(new AllExceptionsFilter());

  // Swagger documentation
  const swaggerConfig = new DocumentBuilder()
    .setTitle('Actopod API v1')
    .setDescription('AI Workflow Canvas - Multi-LLM Node-Based Platform')
    .setVersion('1.0')
    .addBearerAuth({
      type: 'http',
      scheme: 'bearer',
      bearerFormat: 'JWT',
      name: 'Authorization',
      description: 'Enter JWT token',
      in: 'header',
    })
    .build();

  const document = SwaggerModule.createDocument(app, swaggerConfig);
  SwaggerModule.setup('api/v1/docs', app, document, {
    customSiteTitle: 'Actopod API v1 Docs',
    swaggerOptions: {
      persistAuthorization: true,
    },
  });

  // Start server
  const port = parseInt(process.env.BACKEND_PORT || '3000', 10);
  await app.listen(port, '0.0.0.0');

  logger.log(`ðŸš€ Actopod Backend running on: http://localhost:${port}`);
  logger.log(`ðŸ“š API v1 Documentation: http://localhost:${port}/api/v1/docs`);
  logger.log(`ðŸ” Health Check: http://localhost:${port}/api/v1/health`);
  logger.log(`ðŸ”Œ WebSocket: ws://localhost:${port}/notifications`);
}

bootstrap().catch((error: unknown) => {
  const logger = new Logger('Bootstrap');
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  logger.error('âŒ Failed to start application', errorMessage);
  process.exit(1);
});

```

### `apps\backend\src\prisma\prisma.module.ts`

```typescript
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

```

### `apps\backend\src\prisma\prisma.service.ts`

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@actopod/schema';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

```

### `apps\backend\src\v1\app.module.ts`

```typescript
// v1/app.module.ts
import { Module } from '@nestjs/common';
import { V1ServerModule } from './server/server.module';
import { V1AuthModule } from './auth/auth.module';
import { V1WorkspaceModule } from './workspace/workspace.module';
import { V1UserModule } from './user/user.module';
import { V1NotificationModule } from './notification/notification.module';
import { V1FlowModule } from './flow/flow.module';
import { V1ExecutionModule } from './execution/execution.module';
import { V1PodModule } from './pods/pod.module';
import { V1ModelsModule } from './models/models.module';

@Module({
  imports: [
    // ALL your V1 modules
    V1ServerModule,
    V1AuthModule,
    V1WorkspaceModule,
    V1UserModule,
    V1NotificationModule,
    V1FlowModule,
    V1ExecutionModule,
    V1PodModule,
    V1ModelsModule,
  ],
  providers: [
    // {
    //   provide: APP_GUARD,
    //   useClass: AccessTokenGuard,
    // },
  ],
  exports: [
    // export if needed by the root or other modules
    V1ServerModule,
    V1AuthModule,
    V1WorkspaceModule,
    V1UserModule,
    V1NotificationModule,
    V1FlowModule,
    V1ExecutionModule,
    V1PodModule,
    V1ModelsModule,
  ],
})
export class V1AppModule {}

```

### `apps\backend\src\v1\auth\auth.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  UseGuards,
  Req,
  Res,
  HttpCode,
  HttpStatus,
  Body,
  Ip,
  UseInterceptors,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth, ApiResponse } from '@nestjs/swagger';
import { Request, Response } from 'express';
import { V1AuthService } from './auth.service';
import { SendMagicLinkDto, VerifyMagicLinkDto } from './dto/magic-link.dto';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { ForgotPasswordDto } from './dto/forgot-password.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { UAParser } from 'ua-parser-js';
import { Public } from '../../common/decorators/common';
import { GitHubOAuthGuard, GoogleOAuthGuard, RefreshTokenGuard } from '../../common/guards/auth';
import { GetCurrentUserId } from '../../common/decorators/user';

@ApiTags('Authentication')
@Controller({ path: 'auth', version: '1' })
export class V1AuthController {
  constructor(private readonly authService: V1AuthService) {}

  // ============================================
  // EMAIL/PASSWORD AUTHENTICATION
  // ============================================

  @Public()
  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'Register new user with email and password' })
  @ApiResponse({
    status: 201,
    description: 'User registered successfully. Verification email sent.',
  })
  @ApiResponse({ status: 409, description: 'Email already exists' })
  @ApiResponse({ status: 400, description: 'Invalid input data' })
  async register(@Body() dto: RegisterDto) {
    return this.authService.register(dto.email, dto.name, dto.password);
  }

  @Public()
  @Post('verify-email')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify email address' })
  @ApiResponse({ status: 200, description: 'Email verified successfully' })
  @ApiResponse({ status: 400, description: 'Invalid or expired verification token' })
  async verifyEmail(@Body() dto: { token: string }) {
    return this.authService.verifyEmail(dto.token);
  }

  @Public()
  @Post('login')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Login with email and password' })
  @ApiResponse({ status: 200, description: 'Login successful. Returns access and refresh tokens.' })
  @ApiResponse({ status: 401, description: 'Invalid credentials or email not verified' })
  async login(@Body() dto: LoginDto, @Req() req: Request) {
    const uaString = req.headers['user-agent'] || '';
    const parser = new UAParser(uaString);
    const os = parser.getOS().name || 'Unknown OS';
    const browser = parser.getBrowser().name || 'Unknown Browser';
    const deviceName = `${os} â€“ ${browser}`;

    return this.authService.login(dto.email, dto.password, deviceName);
  }

  @Public()
  @Post('forgot-password')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Request password reset link' })
  @ApiResponse({ status: 200, description: 'If email exists, password reset link sent' })
  async forgotPassword(@Body() dto: ForgotPasswordDto) {
    return this.authService.forgotPassword(dto.email);
  }

  @Public()
  @Post('reset-password')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Reset password with token from email' })
  @ApiResponse({ status: 200, description: 'Password reset successfully' })
  @ApiResponse({ status: 400, description: 'Invalid or expired reset token' })
  async resetPassword(@Body() dto: ResetPasswordDto) {
    return this.authService.resetPassword(dto.token, dto.newPassword);
  }

  // ============================================
  // MAGIC LINK AUTHENTICATION
  // ============================================

  @Public()
  @Post('magic-link/send')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Send passwordless magic link to email' })
  @ApiResponse({ status: 200, description: 'If email exists, magic link sent' })
  @ApiResponse({ status: 429, description: 'Too many attempts. Try again later.' })
  async sendMagicLink(@Body() dto: SendMagicLinkDto, @Req() req: Request, @Ip() ipAddress: string) {
    const uaString = req.headers['user-agent'] || '';
    const parser = new UAParser(uaString);
    const os = parser.getOS().name || 'Unknown OS';
    const browser = parser.getBrowser().name || 'Unknown Browser';
    const deviceName = `${os} â€“ ${browser}`;

    return this.authService.sendMagicLink(dto.email, deviceName, ipAddress || 'unknown');
  }

  @Public()
  @Post('magic-link/verify')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Verify magic link token and get JWT tokens' })
  @ApiResponse({
    status: 200,
    description: 'Magic link verified. Returns access and refresh tokens.',
  })
  @ApiResponse({ status: 401, description: 'Invalid or expired magic link' })
  async verifyMagicLink(
    @Body() dto: VerifyMagicLinkDto & { email: string },
    @Req() req: Request,
    @Ip() ipAddress: string,
  ) {
    const uaString = req.headers['user-agent'] || '';
    const parser = new UAParser(uaString);
    const os = parser.getOS().name || 'Unknown OS';
    const browser = parser.getBrowser().name || 'Unknown Browser';
    const deviceName = `${os} â€“ ${browser}`;

    return this.authService.verifyMagicLink(
      dto.token,
      dto.email,
      deviceName,
      ipAddress || 'unknown',
    );
  }

  // ============================================
  // OAUTH AUTHENTICATION
  // ============================================

  @Public()
  @Get('google')
  @UseGuards(GoogleOAuthGuard)
  @ApiOperation({ summary: 'Initiate Google OAuth login flow' })
  @ApiResponse({ status: 302, description: 'Redirects to Google OAuth consent screen' })
  async googleAuth() {}

  @Public()
  @Get('google/callback')
  @UseGuards(GoogleOAuthGuard)
  @UseInterceptors()
  @ApiOperation({ summary: 'Google OAuth callback endpoint' })
  @ApiResponse({ status: 302, description: 'Redirects to frontend with tokens' })
  async googleAuthCallback(@Req() req: Request, @Res() res: Response) {
    const user = req.user as any;

    if (!user) {
      const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
      return res.redirect(`${frontendUrl}/auth/error?message=Authentication failed`);
    }

    const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
    const params = new URLSearchParams({
      accessToken: user.accessToken,
      refreshToken: user.refreshToken,
      userId: user.userId,
      deviceId: user.deviceId,
    });

    res.redirect(`${frontendUrl}/auth/callback?${params.toString()}`);
  }

  @Public()
  @Get('github')
  @UseGuards(GitHubOAuthGuard)
  @ApiOperation({ summary: 'Initiate GitHub OAuth login flow' })
  @ApiResponse({ status: 302, description: 'Redirects to GitHub OAuth consent screen' })
  async githubAuth() {}

  @Public()
  @Get('github/callback')
  @UseGuards(GitHubOAuthGuard)
  @UseInterceptors() // â† Clear all interceptors for this route
  @ApiOperation({ summary: 'GitHub OAuth callback endpoint' })
  @ApiResponse({ status: 302, description: 'Redirects to frontend with tokens' })
  async githubAuthCallback(@Req() req: Request, @Res() res: Response) {
    const user = req.user as any;

    if (!user) {
      const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
      return res.redirect(`${frontendUrl}/auth/error?message=Authentication failed`);
    }

    const frontendUrl = this.authService['configService'].get('FRONTEND_URL');
    const params = new URLSearchParams({
      accessToken: user.accessToken,
      refreshToken: user.refreshToken,
      userId: user.userId,
      deviceId: user.deviceId,
    });

    res.redirect(`${frontendUrl}/auth/callback?${params.toString()}`);
  }

  // ============================================
  // TOKEN MANAGEMENT
  // ============================================

  @Public()
  @Post('refresh')
  @UseGuards(RefreshTokenGuard)
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Refresh access token using refresh token' })
  @ApiResponse({ status: 200, description: 'New access and refresh tokens generated' })
  @ApiResponse({ status: 401, description: 'Invalid or expired refresh token' })
  async refreshTokens(@Req() req: any, @Body() body: { deviceId: string }) {
    return this.authService.refreshTokens(req.user.refreshToken, body.deviceId);
  }

  @Post('logout')
  @HttpCode(HttpStatus.OK)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Logout from current device' })
  @ApiResponse({ status: 200, description: 'Logged out successfully' })
  async logout(@GetCurrentUserId() userId: string, @Req() req: Request) {
    const deviceId = req.headers['x-device-id'] as string;
    return this.authService.logout(userId, deviceId);
  }

  @Post('logout-all')
  @HttpCode(HttpStatus.OK)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Logout from all devices' })
  @ApiResponse({ status: 200, description: 'Logged out from all devices' })
  async logoutAll(@GetCurrentUserId() userId: string) {
    return this.authService.logoutAllDevices(userId);
  }

  @Get('me')
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get current authenticated user info' })
  @ApiResponse({ status: 200, description: 'Returns current user ID' })
  @ApiResponse({ status: 401, description: 'Not authenticated' })
  async getCurrentUser(@GetCurrentUserId() userId: string) {
    return { userId };
  }

  @Public()
  @Post('resend-verification')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Resend email verification link' })
  @ApiResponse({ status: 200, description: 'Verification email sent if user exists' })
  @ApiResponse({ status: 429, description: 'Too many attempts' })
  async resendVerification(@Body() dto: { email: string }) {
    return this.authService.resendVerificationEmail(dto.email);
  }

  @Get('email-verified-status')
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Check if current user email is verified' })
  @ApiResponse({ status: 200, description: 'Returns verification status' })
  async checkEmailVerified(@GetCurrentUserId() userId: string) {
    return this.authService.checkEmailVerifiedStatus(userId);
  }
}

```

### `apps\backend\src\v1\auth\auth.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { V1AuthController } from './auth.controller';
import { V1AuthService } from './auth.service';
import { AccessTokenStrategy } from './strategies/access-token.strategy';
import { RefreshTokenStrategy } from './strategies/refresh-token.strategy';
import { GoogleStrategy } from './strategies/google.strategy';
import { GitHubStrategy } from './strategies/github.strategy';
import { AwsModule } from '../../common/aws/aws.module';

@Module({
  imports: [PassportModule, JwtModule.register({}), AwsModule],
  controllers: [V1AuthController],
  providers: [
    V1AuthService,
    AccessTokenStrategy,
    RefreshTokenStrategy,
    GoogleStrategy,
    GitHubStrategy,
  ],
  exports: [V1AuthService],
})
export class V1AuthModule {}

```

### `apps\backend\src\v1\auth\auth.service.ts`

```typescript
import {
  Injectable,
  UnauthorizedException,
  Logger,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../prisma/prisma.service';
import { AwsSesEmailService } from '../../common/aws/ses/ses-email.service';
import { AuthUserType, GoogleUserData, GitHubUserData, JwtPayload } from './types';
import { AuthProvider } from '@actopod/schema';
import { randomBytes, createHash } from 'crypto';
import * as bcrypt from 'bcrypt';
import { magicLinkTemplate } from '../../common/aws/ses/templates/auth/magic-link.template';
import { resetPasswordTemplate } from '../../common/aws/ses/templates/auth/reset-password.template';
import { verifyEmailTemplate } from '../../common/aws/ses/templates/auth/verify-email.template';
import { welcomeEmailTemplate } from '../../common/aws/ses/templates/auth/welcome.template';

@Injectable()
export class V1AuthService {
  private readonly logger = new Logger(V1AuthService.name);
  private readonly MAGIC_LINK_EXPIRY = 15 * 60 * 1000;
  private readonly RESET_PASSWORD_EXPIRY = 60 * 60 * 1000;
  private readonly MAX_ATTEMPTS = 3;
  private readonly ATTEMPT_WINDOW = 60 * 60 * 1000;

  constructor(
    private readonly prisma: PrismaService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly emailService: AwsSesEmailService,
  ) {}

  // ============================================
  // PASSWORD AUTHENTICATION
  // ============================================

  async register(
    email: string,
    name: string,
    password: string,
  ): Promise<{ message: string; userId: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const existingUser = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (existingUser) {
      throw new ConflictException('Email already registered');
    }

    const hash = await bcrypt.hash(password, 10);
    const verificationToken = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(verificationToken).digest('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

    const user = await this.prisma.$transaction(async (tx) => {
      const newUser = await tx.user.create({
        data: { email: normalizedEmail, name, hash },
      });

      await tx.account.create({
        data: {
          userId: newUser.id,
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
          accessToken: tokenHash,
          expiresAt,
        },
      });

      await tx.workspace.create({
        data: {
          name: `${name}'s Workspace`,
          type: 'PERSONAL',
          members: {
            create: {
              userId: newUser.id,
              role: 'OWNER',
              canCreateCanvas: true,
              canDeleteCanvas: true,
              canManageBilling: true,
              canInviteMembers: true,
              canManageMembers: true,
              canManageApiKeys: true,
            },
          },
        },
      });

      return newUser;
    });

    const verificationUrl = `${this.configService.get('FRONTEND_URL')}/auth/verify-email?token=${verificationToken}`;
    await this.emailService.sendEmail({
      to: user.email,
      subject: 'Verify your Actopod account',
      bodyHtml: verifyEmailTemplate(user.name || 'there', verificationUrl),
    });

    this.logger.log(`User registered: ${user.email}`);

    return {
      message: 'Registration successful. Please check your email to verify your account.',
      userId: user.id,
    };
  }

  async verifyEmail(token: string): Promise<{ message: string }> {
    const tokenHash = createHash('sha256').update(token).digest('hex');

    const account = await this.prisma.account.findFirst({
      where: {
        accessToken: tokenHash,
        provider: AuthProvider.EMAIL,
        expiresAt: { gte: new Date() },
      },
      include: { user: true },
    });

    if (!account) {
      throw new BadRequestException('Invalid or expired verification token');
    }

    await this.prisma.account.update({
      where: { id: account.id },
      data: { accessToken: null, expiresAt: null },
    });

    await this.emailService.sendEmail({
      to: account.user.email,
      subject: 'Welcome to Actopod!',
      bodyHtml: welcomeEmailTemplate(account.user.name || 'there'),
    });

    this.logger.log(`Email verified: ${account.user.email}`);
    return { message: 'Email verified successfully. You can now log in.' };
  }

  async resendVerificationEmail(email: string): Promise<{ message: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
      include: { accounts: { where: { provider: AuthProvider.EMAIL } } },
    });

    if (!user) {
      this.logger.warn(`Verification resend requested for non-existent user: ${normalizedEmail}`);
      return {
        message: 'If the email exists and is not verified, a verification link has been sent',
      };
    }

    const emailAccount = user.accounts[0];
    if (emailAccount && !emailAccount.accessToken) {
      return { message: 'Email is already verified' };
    }

    if (emailAccount?.expiresAt && emailAccount.expiresAt > new Date()) {
      const timeSinceLastSent = Date.now() - emailAccount.createdAt.getTime();
      if (timeSinceLastSent < 60 * 1000) {
        throw new BadRequestException('Please wait before requesting another verification email');
      }
    }

    const verificationToken = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(verificationToken).digest('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        accessToken: tokenHash,
        expiresAt,
      },
      update: { accessToken: tokenHash, expiresAt },
    });

    const verificationUrl = `${this.configService.get('FRONTEND_URL')}/auth/verify-email?token=${verificationToken}`;
    await this.emailService.sendEmail({
      to: user.email,
      subject: 'Verify your Actopod account',
      bodyHtml: verifyEmailTemplate(user.name || 'there', verificationUrl),
    });

    this.logger.log(`Verification email resent to: ${user.email}`);
    return {
      message: 'If the email exists and is not verified, a verification link has been sent',
    };
  }

  async checkEmailVerifiedStatus(userId: string): Promise<{ isVerified: boolean; email: string }> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: { accounts: { where: { provider: AuthProvider.EMAIL } } },
    });

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    const emailAccount = user.accounts[0];
    const isVerified = !emailAccount || !emailAccount.accessToken;

    return { isVerified, email: user.email };
  }

  async login(email: string, password: string, deviceName: string): Promise<AuthUserType> {
    const normalizedEmail = email.toLowerCase().trim();

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user || !user.hash) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, user.hash);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Check if user already has a token for this device
    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: user.id, deviceName: deviceName },
    });

    this.logger.log(`User logged in: ${user.email}`);

    return this.generateTokens(user.id, user.email, deviceName, existingToken?.id);
  }

  async forgotPassword(email: string): Promise<{ message: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user || !user.hash) {
      return { message: 'If the email exists, a password reset link has been sent' };
    }

    const resetToken = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(resetToken).digest('hex');
    const expiresAt = new Date(Date.now() + this.RESET_PASSWORD_EXPIRY);

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        refreshToken: tokenHash,
        expiresAt,
      },
      update: { refreshToken: tokenHash, expiresAt },
    });

    const resetUrl = `${this.configService.get('FRONTEND_URL')}/auth/reset-password?token=${resetToken}`;
    await this.emailService.sendEmail({
      to: user.email,
      subject: 'Reset your Actopod password',
      bodyHtml: resetPasswordTemplate(user.name || 'there', resetUrl),
    });

    this.logger.log(`Password reset requested: ${user.email}`);
    return { message: 'If the email exists, a password reset link has been sent' };
  }

  async resetPassword(token: string, newPassword: string): Promise<{ message: string }> {
    const tokenHash = createHash('sha256').update(token).digest('hex');

    const account = await this.prisma.account.findFirst({
      where: {
        refreshToken: tokenHash,
        provider: AuthProvider.EMAIL,
        expiresAt: { gte: new Date() },
      },
      include: { user: true },
    });

    if (!account) {
      throw new BadRequestException('Invalid or expired reset token');
    }

    const hash = await bcrypt.hash(newPassword, 10);

    await this.prisma.$transaction([
      this.prisma.user.update({
        where: { id: account.userId },
        data: { hash },
      }),
      this.prisma.account.update({
        where: { id: account.id },
        data: { refreshToken: null, expiresAt: null },
      }),
      this.prisma.refreshToken.deleteMany({
        where: { userId: account.userId },
      }),
    ]);

    this.logger.log(`Password reset: ${account.user.email}`);
    return { message: 'Password reset successfully. You can now log in with your new password.' };
  }

  // ============================================
  // MAGIC LINK AUTHENTICATION
  // ============================================

  async sendMagicLink(
    email: string,
    deviceName: string,
    ipAddress: string,
  ): Promise<{ message: string }> {
    const normalizedEmail = email.toLowerCase().trim();

    const recentAttempts = await this.prisma.account.count({
      where: {
        user: { email: normalizedEmail },
        provider: AuthProvider.EMAIL,
        createdAt: { gte: new Date(Date.now() - this.ATTEMPT_WINDOW) },
      },
    });

    if (recentAttempts >= this.MAX_ATTEMPTS) {
      throw new BadRequestException('Too many login attempts. Please try again in 1 hour.');
    }

    const user = await this.prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      this.logger.warn(`Magic link requested for non-existent user: ${normalizedEmail}`);
      return { message: 'If the email exists, a magic link has been sent' };
    }

    const token = randomBytes(32).toString('hex');
    const tokenHash = createHash('sha256').update(token).digest('hex');
    const expiresAt = new Date(Date.now() + this.MAGIC_LINK_EXPIRY);

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.EMAIL,
          providerAccountId: normalizedEmail,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        accessToken: tokenHash,
        refreshToken: JSON.stringify({ deviceName, ipAddress }),
        expiresAt,
      },
      update: {
        accessToken: tokenHash,
        refreshToken: JSON.stringify({ deviceName, ipAddress }),
        expiresAt,
      },
    });

    const magicUrl = `${this.configService.get('FRONTEND_URL')}/auth/verify-magic-link?token=${token}&email=${encodeURIComponent(normalizedEmail)}`;

    await this.emailService.sendEmail({
      to: user.email,
      subject: 'ðŸ” Sign in to Actopod',
      bodyHtml: magicLinkTemplate(
        user.name || 'there',
        magicUrl,
        '15 minutes',
        ipAddress,
        deviceName,
      ),
    });

    this.logger.log(`Magic link sent to: ${normalizedEmail}`);
    return { message: 'If the email exists, a magic link has been sent' };
  }

  async verifyMagicLink(
    token: string,
    email: string,
    deviceName: string,
    _ipAddress: string,
  ): Promise<AuthUserType> {
    const normalizedEmail = email.toLowerCase().trim();
    const tokenHash = createHash('sha256').update(token).digest('hex');

    const account = await this.prisma.account.findFirst({
      where: {
        provider: AuthProvider.EMAIL,
        providerAccountId: normalizedEmail,
        accessToken: tokenHash,
        expiresAt: { gte: new Date() },
      },
      include: { user: true },
    });

    if (!account) {
      this.logger.warn(`Invalid or expired magic link: ${normalizedEmail}`);
      throw new UnauthorizedException('Invalid or expired magic link');
    }

    try {
      const metadata = JSON.parse(account.refreshToken || '{}');
      if (metadata.ipAddress !== _ipAddress) {
        this.logger.warn(`IP mismatch for magic link: ${normalizedEmail}`);
      }
    } catch {
      /* empty */
    }

    await this.prisma.account.update({
      where: { id: account.id },
      data: { accessToken: null, refreshToken: null, expiresAt: null },
    });

    this.logger.log(`Magic link verified: ${normalizedEmail}`);

    // Check for existing device
    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: account.user.id, deviceName: deviceName },
    });

    return this.generateTokens(account.user.id, account.user.email, deviceName, existingToken?.id);
  }

  // ============================================
  // OAUTH AUTHENTICATION
  // ============================================

  async validateGoogleUser(data: GoogleUserData): Promise<AuthUserType> {
    const { email, firstName, lastName, googleId, picture, deviceName } = data;

    let user = await this.prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (!user) {
      user = await this.prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            email: email.toLowerCase(),
            name: `${firstName} ${lastName}`.trim(),
            image: picture,
            hash: null,
          },
        });

        await tx.workspace.create({
          data: {
            name: `${newUser.name}'s Workspace`,
            type: 'PERSONAL',
            members: {
              create: {
                userId: newUser.id,
                role: 'OWNER',
                canCreateCanvas: true,
                canDeleteCanvas: true,
                canManageBilling: true,
                canInviteMembers: true,
                canManageMembers: true,
                canManageApiKeys: true,
              },
            },
          },
        });

        this.logger.log(`New user created via Google: ${newUser.email}`);
        return newUser;
      });
    }

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.GOOGLE,
          providerAccountId: googleId,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.GOOGLE,
        providerAccountId: googleId,
      },
      update: {},
    });

    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: user.id, deviceName: deviceName },
    });

    return this.generateTokens(user.id, user.email, deviceName, existingToken?.id);
  }

  async validateGitHubUser(data: GitHubUserData): Promise<AuthUserType> {
    const { email, name, githubId, avatarUrl, deviceName } = data;

    let user = await this.prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (!user) {
      user = await this.prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            email: email.toLowerCase(),
            name,
            image: avatarUrl,
            hash: null,
          },
        });

        await tx.workspace.create({
          data: {
            name: `${newUser.name}'s Workspace`,
            type: 'PERSONAL',
            members: {
              create: {
                userId: newUser.id,
                role: 'OWNER',
                canCreateCanvas: true,
                canDeleteCanvas: true,
                canManageBilling: true,
                canInviteMembers: true,
                canManageMembers: true,
                canManageApiKeys: true,
              },
            },
          },
        });

        this.logger.log(`New user created via GitHub: ${newUser.email}`);
        return newUser;
      });
    }

    await this.prisma.account.upsert({
      where: {
        provider_providerAccountId: {
          provider: AuthProvider.GITHUB,
          providerAccountId: githubId,
        },
      },
      create: {
        userId: user.id,
        provider: AuthProvider.GITHUB,
        providerAccountId: githubId,
      },
      update: {},
    });

    const existingToken = await this.prisma.refreshToken.findFirst({
      where: { userId: user.id, deviceName: deviceName },
    });

    return this.generateTokens(user.id, user.email, deviceName, existingToken?.id);
  }

  // ============================================
  // TOKEN MANAGEMENT
  // ============================================

  async refreshTokens(refreshToken: string, deviceId: string): Promise<AuthUserType> {
    const storedToken = await this.prisma.refreshToken.findUnique({
      where: { token: refreshToken },
      include: { user: true },
    });

    if (!storedToken || storedToken.expiresAt < new Date() || storedToken.id !== deviceId) {
      throw new UnauthorizedException('Invalid or expired refresh token');
    }

    const deviceName = storedToken.deviceName;

    return this.generateTokens(storedToken.user.id, storedToken.user.email, deviceName, deviceId);
  }

  async logout(userId: string, deviceId: string): Promise<{ message: string }> {
    await this.prisma.refreshToken.deleteMany({
      where: { userId, id: deviceId },
    });

    this.logger.log(`User logged out: ${userId} from device: ${deviceId}`);
    return { message: 'Logged out successfully' };
  }

  async logoutAllDevices(userId: string): Promise<{ message: string }> {
    await this.prisma.refreshToken.deleteMany({
      where: { userId },
    });

    this.logger.log(`User logged out from all devices: ${userId}`);
    return { message: 'Logged out from all devices' };
  }

  // ============================================
  // PRIVATE HELPERS
  // ============================================

  private async generateTokens(
    userId: string,
    email: string,
    deviceName: string,
    existingTokenId?: string,
  ): Promise<AuthUserType> {
    const payload: JwtPayload = { userId, email };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(payload, {
        secret: this.configService.get('JWT_ACCESS_TOKEN_SECRET'),
        expiresIn: this.configService.get('JWT_ACCESS_TOKEN_EXPIRATION'),
      }),
      this.jwtService.signAsync(payload, {
        secret: this.configService.get('JWT_REFRESH_TOKEN_SECRET'),
        expiresIn: this.configService.get('JWT_REFRESH_TOKEN_EXPIRATION'),
      }),
    ]);

    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    let tokenRecord;

    if (existingTokenId) {
      // UPDATE existing record (keeps same ID)
      tokenRecord = await this.prisma.refreshToken.update({
        where: { id: existingTokenId },
        data: {
          token: refreshToken,
          expiresAt,
          deviceName: deviceName,
        },
      });
    } else {
      // CREATE new record
      tokenRecord = await this.prisma.refreshToken.create({
        data: {
          userId,
          deviceName: deviceName, // Store deviceName in deviceId column
          token: refreshToken,
          expiresAt,
        },
      });
    }

    return {
      userId,
      email,
      accessToken,
      refreshToken,
      deviceId: tokenRecord.id, // Database CUID
      deviceName: deviceName, // Human-readable name
    };
  }
}

```

### `apps\backend\src\v1\auth\dto\forgot-password.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty } from 'class-validator';

export class ForgotPasswordDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'Email address to send password reset link',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;
}

```

### `apps\backend\src\v1\auth\dto\login.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'User email address',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;

  @ApiProperty({
    example: 'Password123!',
    description: 'User password',
    required: true,
  })
  @IsString({ message: 'Password must be a string' })
  @IsNotEmpty({ message: 'Password is required' })
  password!: string;
}

```

### `apps\backend\src\v1\auth\dto\magic-link.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class SendMagicLinkDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'Email address to send magic link',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;
}

export class VerifyMagicLinkDto {
  @ApiProperty({
    description: 'Magic link token from email',
    required: true,
  })
  @IsString({ message: 'Token must be a string' })
  @IsNotEmpty({ message: 'Token is required' })
  token!: string;

  @ApiProperty({
    example: 'john@example.com',
    description: 'Email address associated with the magic link',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;
}

```

### `apps\backend\src\v1\auth\dto\refresh-token.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty, IsOptional } from 'class-validator';

export class RefreshTokenDto {
  @ApiProperty({
    description: 'Refresh token to get new access token',
    required: true,
  })
  @IsString({ message: 'Refresh token must be a string' })
  @IsNotEmpty({ message: 'Refresh token is required' })
  refreshToken!: string;

  @ApiProperty({
    description: 'Device ID for session management',
    required: false,
  })
  @IsString({ message: 'Device ID must be a string' })
  @IsOptional()
  deviceId?: string;
}

```

### `apps\backend\src\v1\auth\dto\register.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString, MinLength, Matches } from 'class-validator';

export class RegisterDto {
  @ApiProperty({
    example: 'john@example.com',
    description: 'User email address',
    required: true,
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty({ message: 'Email is required' })
  email!: string;

  @ApiProperty({
    example: 'John Doe',
    description: 'Full name',
    required: true,
  })
  @IsString({ message: 'Name must be a string' })
  @IsNotEmpty({ message: 'Name is required' })
  name!: string;

  @ApiProperty({
    example: 'Password123!',
    description:
      'Password must contain at least 8 characters, one uppercase, one lowercase, one number and one special character',
    required: true,
    minLength: 8,
  })
  @IsString({ message: 'Password must be a string' })
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message:
      'Password must contain at least one uppercase letter, one lowercase letter, one number and one special character',
  })
  @IsNotEmpty({ message: 'Password is required' })
  password!: string;
}

```

### `apps\backend\src\v1\auth\dto\reset-password.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty, MinLength, Matches } from 'class-validator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'Password reset token from email',
    required: true,
  })
  @IsString({ message: 'Token must be a string' })
  @IsNotEmpty({ message: 'Token is required' })
  token!: string;

  @ApiProperty({
    example: 'NewPassword123!',
    description:
      'New password (min 8 chars, must include uppercase, lowercase, number, special char)',
    required: true,
    minLength: 8,
  })
  @IsString({ message: 'Password must be a string' })
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message:
      'Password must contain at least one uppercase letter, one lowercase letter, one number and one special character',
  })
  @IsNotEmpty({ message: 'Password is required' })
  newPassword!: string;
}

```

### `apps\backend\src\v1\auth\dto\verify-email.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty } from 'class-validator';

export class VerifyEmailDto {
  @ApiProperty({
    description: 'Email verification token from email',
    required: true,
  })
  @IsString({ message: 'Token must be a string' })
  @IsNotEmpty({ message: 'Token is required' })
  token!: string;
}

```

### `apps\backend\src\v1\auth\strategies\access-token.strategy.ts`

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../../prisma/prisma.service';
import { JwtPayload } from '../types';

@Injectable()
export class AccessTokenStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_ACCESS_TOKEN_SECRET') || '',
    });
  }

  async validate(payload: JwtPayload) {
    const user = await this.prisma.user.findUnique({
      where: { id: payload.userId },
    });

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    return { userId: user.id, email: user.email };
  }
}

```

### `apps\backend\src\v1\auth\strategies\github.strategy.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, Profile, StrategyOptionsWithRequest } from 'passport-github2';
import { ConfigService } from '@nestjs/config';
import { V1AuthService } from '../auth.service';
import { Request } from 'express';
import { UAParser } from 'ua-parser-js';

@Injectable()
export class GitHubStrategy extends PassportStrategy(Strategy, 'github') {
  private readonly logger = new Logger(GitHubStrategy.name);

  constructor(
    private readonly configService: ConfigService,
    private readonly authService: V1AuthService,
  ) {
    const options: StrategyOptionsWithRequest = {
      clientID: configService.get<string>('GITHUB_CLIENT_ID') || '',
      clientSecret: configService.get<string>('GITHUB_CLIENT_SECRET') || '',
      callbackURL: configService.get<string>('GITHUB_CALLBACK_URL') || '',
      scope: ['user:email'],
      passReqToCallback: true,
    };
    super(options);
  }

  async validate(
    req: Request,
    accessToken: string,
    refreshToken: string,
    profile: Profile,
    done: (error: any, user?: any) => void,
  ): Promise<void> {
    try {
      const uaString = req.headers['user-agent'] || '';
      const parser = new UAParser(uaString);
      const os = parser.getOS().name || 'Unknown OS';
      const browser = parser.getBrowser().name || 'Unknown Browser';
      const deviceName = `${os} â€“ ${browser}`;

      const email = profile.emails?.[0]?.value || '';
      const name = profile.displayName || profile.username || '';
      const avatarUrl = profile.photos?.[0]?.value || '';
      const githubId = profile.id;

      this.logger.log(`GitHub OAuth: ${email}`);

      const user = await this.authService.validateGitHubUser({
        email,
        name,
        githubId,
        avatarUrl,
        deviceName,
      });

      done(null, user);
    } catch (error: any) {
      this.logger.error('Error in GitHubStrategy.validate()', error?.stack || error);
      done(error, false); // Use false instead of null
    }
  }
}

```

### `apps\backend\src\v1\auth\strategies\google.strategy.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import {
  Strategy,
  Profile,
  VerifyCallback,
  StrategyOptionsWithRequest,
} from 'passport-google-oauth20';
import { ConfigService } from '@nestjs/config';
import { V1AuthService } from '../auth.service';
import { Request } from 'express';
import { UAParser } from 'ua-parser-js';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  private readonly logger = new Logger(GoogleStrategy.name);

  constructor(
    private readonly configService: ConfigService,
    private readonly authService: V1AuthService,
  ) {
    const options: StrategyOptionsWithRequest = {
      clientID: configService.get<string>('GOOGLE_CLIENT_ID') || '',
      clientSecret: configService.get<string>('GOOGLE_CLIENT_SECRET') || '',
      callbackURL: configService.get<string>('GOOGLE_CALLBACK_URL') || '',
      scope: ['email', 'profile'],
      passReqToCallback: true,
    };
    super(options);
  }

  async validate(
    req: Request,
    accessToken: string,
    refreshToken: string,
    profile: Profile,
    done: VerifyCallback,
  ): Promise<void> {
    try {
      const uaString = req.headers['user-agent'] || '';
      const parser = new UAParser(uaString);
      const os = parser.getOS().name || 'Unknown OS';
      const browser = parser.getBrowser().name || 'Unknown Browser';
      const deviceName = `${os} â€“ ${browser}`;

      const email = profile.emails?.[0]?.value || '';
      const firstName = profile.name?.givenName || '';
      const lastName = profile.name?.familyName || '';
      const picture = profile.photos?.[0]?.value || '';
      const googleId = profile.id;

      this.logger.log(`Google OAuth: ${email}`);

      const user = await this.authService.validateGoogleUser({
        email,
        firstName,
        lastName,
        googleId,
        picture,
        deviceName,
      });

      done(null, user);
    } catch (error: any) {
      this.logger.error('Error in GoogleStrategy.validate()', error?.stack || error);
      done(error, false); // Use false instead of null
    }
  }
}

```

### `apps\backend\src\v1\auth\strategies\refresh-token.strategy.ts`

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy, StrategyOptionsWithRequest } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { JwtPayload } from '../types';
import { Request } from 'express';

@Injectable()
export class RefreshTokenStrategy extends PassportStrategy(Strategy, 'jwt-refresh') {
  constructor(configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_REFRESH_TOKEN_SECRET') || '',
      passReqToCallback: true,
    } as StrategyOptionsWithRequest);
  }

  async validate(req: Request, payload: JwtPayload) {
    const authHeader = req.headers['authorization'];
    if (!authHeader) {
      throw new UnauthorizedException('No authorization header');
    }

    const [scheme, token] = authHeader.split(' ');
    if (scheme !== 'Bearer' || !token) {
      throw new UnauthorizedException('Malformed authorization header');
    }

    const deviceId = req.body.deviceId ?? req.query.deviceId ?? req.headers['x-device-id'];
    if (!deviceId) {
      throw new UnauthorizedException('Device ID is missing');
    }

    return {
      userId: payload.userId,
      email: payload.email,
      refreshToken: token,
      deviceId: deviceId as string,
    };
  }
}

```

### `apps\backend\src\v1\auth\types\index.ts`

```typescript
export interface JwtPayload {
  userId: string;
  email: string;
}

export interface JwtPayloadWithRt extends JwtPayload {
  refreshToken: string;
  deviceId: string;
}

export interface AuthUserType {
  userId: string;
  email: string;
  accessToken: string;
  refreshToken: string;
  deviceId: string;
  deviceName: string;
}

export interface GoogleUserData {
  email: string;
  firstName: string;
  lastName: string;
  googleId: string;
  picture?: string;
  deviceName: string;
}

export interface GitHubUserData {
  email: string;
  name: string;
  githubId: string;
  avatarUrl?: string;
  deviceName: string;
}

export interface MagicLinkData {
  email: string;
  token: string;
  expiresAt: Date;
  deviceName: string;
  ipAddress: string;
}

```

### `apps\backend\src\v1\execution\context-resolution.service.ts`

```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PodType } from '@actopod/schema';
import { PrismaService } from '../../prisma/prisma.service';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';

export interface ResolvedContext {
  podId: string;
  output: string;
  executionId?: string;
  timestamp: Date;
}

export interface ContextChain {
  pod: {
    id: string;
    type: PodType;
  };
  context: ResolvedContext[];
  variables: Record<string, string>;
}

@Injectable()
export class V1ContextResolutionService {
  private readonly logger = new Logger(V1ContextResolutionService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
  ) {}

  /**
   * Resolve all context for a pod execution
   */
  async resolveContext(podId: string, flowId: string): Promise<ContextChain> {
    const pod = await this.prisma.pod.findUnique({
      where: { id: podId },
      select: {
        id: true,
        type: true,
      },
    });

    if (!pod) {
      throw new NotFoundException(`Pod ${podId} not found`);
    }

    const upstreamEdges = await this.prisma.edge.findMany({
      where: {
        flowId,
        targetPodId: podId,
      },
      select: {
        sourcePodId: true,
      },
    });

    if (upstreamEdges.length === 0) {
      this.logger.debug(`Pod ${podId} has no upstream dependencies`);
      return {
        pod,
        context: [],
        variables: {},
      };
    }

    const upstreamPodIds = upstreamEdges.map((e: { sourcePodId: string }) => e.sourcePodId);

    const contextPromises = upstreamPodIds.map((upstreamPodId: string) => {
      return this.getLatestPodOutput(upstreamPodId);
    });

    const resolvedContexts = await Promise.all(contextPromises);
    const validContexts = resolvedContexts.filter(
      (c: ResolvedContext | null): c is ResolvedContext => c !== null,
    );

    const variables: Record<string, string> = {};
    for (const ctx of validContexts) {
      variables[ctx.podId] = ctx.output;
    }

    this.logger.debug(`Resolved ${validContexts.length} context items for pod ${podId}`);

    return {
      pod,
      context: validContexts,
      variables,
    };
  }

  /**
   * Resolve context with support for pinned executions
   */
  async resolveContextWithPins(
    podId: string,
    flowId: string,
    contextMappings?: Array<{ sourcePodId: string; pinnedExecutionId: string | null }>,
  ): Promise<ContextChain> {
    const pod = await this.prisma.pod.findUnique({
      where: { id: podId },
      select: {
        id: true,
        type: true,
      },
    });

    if (!pod) {
      throw new NotFoundException(`Pod ${podId} not found`);
    }

    const upstreamEdges = await this.prisma.edge.findMany({
      where: {
        flowId,
        targetPodId: podId,
      },
      select: {
        sourcePodId: true,
      },
    });

    if (upstreamEdges.length === 0) {
      this.logger.debug(`Pod ${podId} has no upstream dependencies`);
      return {
        pod,
        context: [],
        variables: {},
      };
    }

    const upstreamPodIds = upstreamEdges.map((e: { sourcePodId: string }) => e.sourcePodId);

    // Build mapping of pod â†’ execution ID
    const executionMap = new Map<string, string | null>();
    if (contextMappings) {
      for (const mapping of contextMappings) {
        executionMap.set(mapping.sourcePodId, mapping.pinnedExecutionId);
      }
    }

    const contextPromises = upstreamPodIds.map((upstreamPodId: string) => {
      const pinnedExecutionId = executionMap.get(upstreamPodId);

      if (pinnedExecutionId) {
        // Use specific pinned execution
        return this.getPinnedPodOutput(upstreamPodId, pinnedExecutionId);
      } else {
        // Use latest execution (default behavior)
        return this.getLatestPodOutput(upstreamPodId);
      }
    });

    const resolvedContexts = await Promise.all(contextPromises);
    const validContexts = resolvedContexts.filter(
      (c: ResolvedContext | null): c is ResolvedContext => c !== null,
    );

    const variables: Record<string, string> = {};
    for (const ctx of validContexts) {
      variables[ctx.podId] = ctx.output;
    }

    this.logger.debug(
      `Resolved ${validContexts.length} context items for pod ${podId} (${contextMappings?.length || 0} pinned)`,
    );

    return {
      pod,
      context: validContexts,
      variables,
    };
  }

  /**
   * Get specific pinned execution output
   */
  private async getPinnedPodOutput(
    podId: string,
    executionId: string,
  ): Promise<ResolvedContext | null> {
    const execution = await this.prisma.podExecution.findFirst({
      where: {
        id: executionId,
        podId,
        status: 'COMPLETED',
      },
      select: {
        id: true,
        responseMetadata: true,
        finishedAt: true,
      },
    });

    if (!execution || !execution.responseMetadata) {
      this.logger.warn(`Pinned execution ${executionId} not found or incomplete for pod ${podId}`);
      return null;
    }

    const output = this.extractOutputFromResponse(execution.responseMetadata);

    if (!output) {
      this.logger.warn(`Could not extract output from pinned execution ${executionId}`);
      return null;
    }

    return {
      podId,
      output,
      executionId: execution.id,
      timestamp: execution.finishedAt!,
    };
  }

  /**
   * Get latest execution output for a pod
   */
  private async getLatestPodOutput(podId: string): Promise<ResolvedContext | null> {
    const latestExecution = await this.prisma.podExecution.findFirst({
      where: {
        podId,
        status: 'COMPLETED',
      },
      orderBy: {
        finishedAt: 'desc',
      },
      select: {
        id: true,
        responseMetadata: true,
        finishedAt: true,
      },
      take: 1,
    });

    if (!latestExecution || !latestExecution.responseMetadata) {
      this.logger.warn(`No completed execution found for pod ${podId}`);
      return null;
    }

    const output = this.extractOutputFromResponse(latestExecution.responseMetadata);

    if (!output) {
      this.logger.warn(`Could not extract output from execution ${latestExecution.id}`);
      return null;
    }

    return {
      podId,
      output,
      executionId: latestExecution.id,
      timestamp: latestExecution.finishedAt!,
    };
  }

  /**
   * Extract text output from LLM response metadata
   */
  private extractOutputFromResponse(responseMetadata: any): string | null {
    try {
      // OpenAI format
      if (responseMetadata.choices && responseMetadata.choices[0]) {
        return responseMetadata.choices[0].message.content;
      }

      // Anthropic format
      if (responseMetadata.content && Array.isArray(responseMetadata.content)) {
        const textBlocks = responseMetadata.content.filter((block: any) => block.type === 'text');
        return textBlocks.map((block: any) => block.text).join('\n');
      }

      // Gemini format
      if (responseMetadata.candidates && responseMetadata.candidates[0]) {
        const parts = responseMetadata.candidates[0].content.parts;
        return parts.map((p: any) => p.text).join('\n');
      }

      return null;
    } catch (error) {
      this.logger.error('Failed to extract output from response', error);
      return null;
    }
  }

  /**
   * Interpolate variables in a string
   */
  interpolateVariables(text: string, variables: Record<string, string>): string {
    let result = text;

    const variableRegex = /\{\{([a-zA-Z0-9_-]+)(?:\.output)?\}\}/g;

    result = result.replace(variableRegex, (match, podId) => {
      const value = variables[podId];
      if (value === undefined) {
        this.logger.warn(`Variable ${podId} not found in context`);
        return match;
      }
      return value;
    });

    return result;
  }

  /**
   * Get execution order for all pods in a flow (topological sort)
   */
  async getExecutionOrder(flowId: string): Promise<string[]> {
    const pods = await this.prisma.pod.findMany({
      where: { flowId },
      select: { id: true },
    });

    const edges = await this.prisma.edge.findMany({
      where: { flowId },
      select: {
        sourcePodId: true,
        targetPodId: true,
      },
    });

    const graph = new Map<string, string[]>();
    const inDegree = new Map<string, number>();

    for (const pod of pods) {
      graph.set(pod.id, []);
      inDegree.set(pod.id, 0);
    }

    for (const edge of edges) {
      graph.get(edge.sourcePodId)!.push(edge.targetPodId);
      inDegree.set(edge.targetPodId, (inDegree.get(edge.targetPodId) || 0) + 1);
    }

    const queue: string[] = [];
    const result: string[] = [];

    for (const [podId, degree] of inDegree.entries()) {
      if (degree === 0) {
        queue.push(podId);
      }
    }

    while (queue.length > 0) {
      const current = queue.shift()!;
      result.push(current);

      for (const neighbor of graph.get(current) || []) {
        inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
        if (inDegree.get(neighbor) === 0) {
          queue.push(neighbor);
        }
      }
    }

    if (result.length !== pods.length) {
      throw new Error(`Circular dependency detected in flow ${flowId}`);
    }

    return result;
  }
}

```

### `apps\backend\src\v1\execution\dto\execute-pod.dto.ts`

```typescript
// dto/execute-pod.dto.ts

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsString,
  IsEnum,
  IsArray,
  IsOptional,
  IsNumber,
  ValidateNested,
  IsIn,
  Min,
  Max,
} from 'class-validator';
import { Type } from 'class-transformer';
import { LLMProvider } from '@actopod/schema';

export class LLMMessageDto {
  @ApiProperty({
    description: 'Role of the message sender',
    enum: ['system', 'user', 'assistant'],
    example: 'user',
  })
  @IsIn(['system', 'user', 'assistant'])
  role!: 'system' | 'user' | 'assistant';

  @ApiProperty({
    description: 'Content of the message',
    example: 'Explain quantum computing in simple terms',
  })
  @IsString()
  content!: string;
}

export class ExecutePodDto {
  @ApiProperty({
    description: 'ID of the pod to execute',
    example: 'pod_1234567890_abc123',
  })
  @IsString()
  podId!: string;

  @ApiProperty({
    description: 'Messages to send to the LLM',
    type: [LLMMessageDto],
    example: [{ role: 'user', content: 'Hello!' }],
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => LLMMessageDto)
  messages!: LLMMessageDto[];

  // Runtime overrides (all optional)
  @ApiPropertyOptional({
    description: 'Override pod provider',
    enum: LLMProvider,
    example: LLMProvider.OPENAI,
  })
  @IsOptional()
  @IsEnum(LLMProvider)
  provider?: LLMProvider;

  @ApiPropertyOptional({
    description: 'Override pod model',
    example: 'gpt-4o',
  })
  @IsOptional()
  @IsString()
  model?: string;

  @ApiPropertyOptional({
    description: 'Override system prompt (overrides pod configuration)',
    example: 'You are an expert in quantum physics',
  })
  @IsOptional()
  @IsString()
  systemPrompt?: string;

  @ApiPropertyOptional({
    description: 'Override sampling temperature (0-2)',
    minimum: 0,
    maximum: 2,
    example: 0.7,
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(2)
  temperature?: number;

  @ApiPropertyOptional({
    description: 'Override maximum tokens to generate',
    minimum: 1,
    maximum: 128000000,
    example: 2048,
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(128000000)
  maxTokens?: number;

  @ApiPropertyOptional({
    description: 'Override top-p nucleus sampling (0-1)',
    minimum: 0,
    maximum: 1,
    example: 0.9,
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(1)
  topP?: number;

  @ApiPropertyOptional({
    description: 'Override presence penalty (-2 to 2)',
    minimum: -2,
    maximum: 2,
    example: 0,
  })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  presencePenalty?: number;

  @ApiPropertyOptional({
    description: 'Override frequency penalty (-2 to 2)',
    minimum: -2,
    maximum: 2,
    example: 0,
  })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  frequencyPenalty?: number;

  @ApiPropertyOptional({
    description: 'Override thinking budget for reasoning models',
    minimum: 1000,
    maximum: 128000000,
    example: 10000,
  })
  @IsOptional()
  @IsNumber()
  @Min(1000)
  @Max(128000000)
  thinkingBudget?: number;

  @ApiPropertyOptional({
    description: 'Override response format',
    enum: ['text', 'json_object', 'json'],
    example: 'text',
  })
  @IsOptional()
  @IsIn(['text', 'json_object', 'json'])
  responseFormat?: 'text' | 'json_object' | 'json';
}

```

### `apps\backend\src\v1\execution\dto\execution-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { Expose } from 'class-transformer';
import { PodExecutionStatus, LLMProvider } from '@actopod/schema';

export class ExecutionUsageDto {
  @ApiProperty({ description: 'Prompt (input) tokens used', example: 150 })
  @Expose()
  promptTokens!: number;

  @ApiProperty({ description: 'Completion (output) tokens generated', example: 450 })
  @Expose()
  completionTokens!: number;

  @ApiProperty({ description: 'Total tokens used', example: 600 })
  @Expose()
  totalTokens!: number;

  @ApiProperty({
    description: 'Reasoning tokens (for o-series models)',
    required: false,
    example: 200,
  })
  @Expose()
  reasoningTokens?: number;

  @ApiProperty({ description: 'Cached input tokens (cost savings)', required: false, example: 100 })
  @Expose()
  cachedTokens?: number;
}

export class ExecutionCostDto {
  @ApiProperty({ description: 'Input cost in USD', example: 0.000375 })
  @Expose()
  inputCost!: number;

  @ApiProperty({ description: 'Output cost in USD', example: 0.0045 })
  @Expose()
  outputCost!: number;

  @ApiProperty({ description: 'Reasoning cost in USD', example: 0.0012 })
  @Expose()
  reasoningCost!: number;

  @ApiProperty({ description: 'Total cost in USD', example: 0.005975 })
  @Expose()
  totalCost!: number;
}

export class ExecutionResultDto {
  @ApiProperty({ description: 'Unique execution ID', example: 'exec_cm2abc123' })
  @Expose()
  executionId!: string;

  @ApiProperty({ description: 'Generated content from LLM', example: 'Quantum computing uses...' })
  @Expose()
  content!: string;

  @ApiProperty({ description: 'Token usage breakdown', type: ExecutionUsageDto })
  @Expose()
  usage!: ExecutionUsageDto;

  @ApiProperty({ description: 'Cost breakdown in USD', type: ExecutionCostDto })
  @Expose()
  cost!: ExecutionCostDto;
}

export class ExecutionHistoryItemDto {
  @ApiProperty({ description: 'Execution ID', example: 'exec_cm2abc123' })
  @Expose()
  id!: string;

  @ApiProperty({ description: 'Pod ID', example: 'pod_1234567890_abc123' })
  @Expose()
  podId!: string;

  @ApiProperty({ description: 'Execution status', enum: PodExecutionStatus, example: 'COMPLETED' })
  @Expose()
  status!: PodExecutionStatus;

  @ApiProperty({ description: 'LLM provider used', enum: LLMProvider, example: 'OPENAI' })
  @Expose()
  provider!: LLMProvider;

  @ApiProperty({ description: 'Model ID', example: 'gpt-4o' })
  @Expose()
  modelId!: string;

  @ApiProperty({ description: 'Model name returned by provider', example: 'gpt-4o-2024-05-13' })
  @Expose()
  modelName!: string | null;

  @ApiProperty({ description: 'Input tokens used', example: 150 })
  @Expose()
  inputTokens!: number;

  @ApiProperty({ description: 'Output tokens generated', example: 450 })
  @Expose()
  outputTokens!: number;

  @ApiProperty({ description: 'Reasoning tokens (o-series)', example: 0 })
  @Expose()
  reasoningTokens!: number;

  @ApiProperty({ description: 'Total cost in USD', example: '0.005975', required: false })
  @Expose()
  costInUsd!: string | null;

  @ApiProperty({ description: 'Execution start timestamp', example: '2025-10-24T18:00:00.000Z' })
  @Expose()
  startedAt!: Date;

  @ApiProperty({ description: 'Execution finish timestamp', example: '2025-10-24T18:00:05.000Z' })
  @Expose()
  finishedAt!: Date | null;

  @ApiProperty({ description: 'Runtime in milliseconds', example: 5432 })
  @Expose()
  runtimeInMs!: number | null;

  @ApiProperty({ description: 'Error message if failed', required: false })
  @Expose()
  errorMessage!: string | null;

  @ApiProperty({ description: 'Error code if failed', required: false })
  @Expose()
  errorCode!: string | null;
}

export class ExecutionDetailDto {
  @ApiProperty({ description: 'Execution ID', example: 'exec_cm2abc123' })
  @Expose()
  id!: string;

  @ApiProperty({ description: 'Pod details' })
  @Expose()
  pod!: {
    id: string;
    type: string;
    flowId: string;
  };

  @ApiProperty({ description: 'Execution status', enum: PodExecutionStatus })
  @Expose()
  status!: PodExecutionStatus;

  @ApiProperty({ description: 'LLM provider', enum: LLMProvider })
  @Expose()
  provider!: LLMProvider;

  @ApiProperty({ description: 'Model used' })
  @Expose()
  modelId!: string;

  @ApiProperty({ description: 'Token counts' })
  @Expose()
  inputTokens!: number;

  @Expose()
  outputTokens!: number;

  @Expose()
  reasoningTokens!: number;

  @ApiProperty({ description: 'Cost in USD' })
  @Expose()
  costInUsd!: string | null;

  @ApiProperty({ description: 'Timestamps' })
  @Expose()
  startedAt!: Date;

  @Expose()
  finishedAt!: Date | null;

  @Expose()
  runtimeInMs!: number | null;

  @ApiProperty({ description: 'Raw response from LLM provider' })
  @Expose()
  responseMetadata!: any;

  @ApiProperty({ description: 'Error info if failed' })
  @Expose()
  errorMessage!: string | null;

  @Expose()
  errorCode!: string | null;
}

```

### `apps\backend\src\v1\execution\execution.controller.ts`

```typescript
// execution.controller.ts - Pure streaming, no queue

import {
  Controller,
  Post,
  Get,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
  Res,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { Response } from 'express';
import { V1ExecutionService } from './execution.service';
import { ExecutePodDto } from './dto/execute-pod.dto';
import { ExecutionHistoryItemDto, ExecutionDetailDto } from './dto/execution-response.dto';
import { GetCurrentUserId } from '../../common/decorators/user';

@ApiTags('Executions')
@Controller('workspaces/:workspaceId')
@ApiBearerAuth()
export class V1ExecutionController {
  constructor(private readonly executionService: V1ExecutionService) {}

  @Post('executions')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Execute a pod with instant streaming (BYOK optimized)',
    description:
      'Execute a pod with real-time streaming response. No queuing - instant token streaming for perfect UX with BYOK.',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', example: 'cm2abc123' })
  @ApiResponse({
    status: 200,
    description: 'Streaming execution (SSE format)',
  })
  @ApiResponse({ status: 400, description: 'Invalid request or missing API key' })
  @ApiResponse({ status: 404, description: 'Pod not found' })
  async executePod(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId('id') userId: string,
    @Body() dto: ExecutePodDto,
    @Res() res: Response,
  ): Promise<void> {
    // Validate input
    if (!dto.podId || !dto.messages || dto.messages.length === 0) {
      res.status(400).json({
        error: 'Invalid request',
        message: 'podId and messages are required',
      });
      return;
    }

    // Set up SSE headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering
    res.flushHeaders();

    try {
      // INSTANT STREAMING - No queue!
      const stream = this.executionService.executePod({
        podId: dto.podId,
        workspaceId,
        userId,
        messages: dto.messages,
        provider: dto.provider,
        model: dto.model,
        systemPrompt: dto.systemPrompt,
        temperature: dto.temperature,
        maxTokens: dto.maxTokens,
        topP: dto.topP,
        presencePenalty: dto.presencePenalty,
        frequencyPenalty: dto.frequencyPenalty,
        thinkingBudget: dto.thinkingBudget,
        responseFormat: dto.responseFormat,
      });

      // Stream chunks to client in real-time
      for await (const chunk of stream) {
        res.write(`data: ${JSON.stringify(chunk)}\n\n`);
      }

      // Send completion signal
      res.write('data: [DONE]\n\n');
      res.end();
    } catch (error) {
      // Send error through SSE
      res.write(
        `data: ${JSON.stringify({
          type: 'error',
          error: error instanceof Error ? error.message : 'Unknown error',
          timestamp: new Date().toISOString(),
        })}\n\n`,
      );
      res.end();
    }
  }

  @Get('flows/:flowId/executions/pods/:podId')
  @ApiOperation({ summary: 'Get execution history for a specific pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'podId', description: 'Pod ID', example: 'pod_1234567890_abc123' })
  @ApiQuery({ name: 'limit', required: false, example: 10, description: 'Max 100' })
  @ApiResponse({ status: 200, type: [ExecutionHistoryItemDto] })
  async getPodExecutionsByPodId(
    @Param('podId') podId: string,
    @Query('limit') limit?: string,
  ): Promise<ExecutionHistoryItemDto[]> {
    const parsedLimit = limit ? Math.min(parseInt(limit, 10), 100) : 10;
    return this.executionService.getPodExecutions(podId, parsedLimit);
  }

  @Get('executions/:executionId')
  @ApiOperation({ summary: 'Get execution details' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'executionId', description: 'Execution ID', example: 'exec_cm2abc123' })
  @ApiResponse({ status: 200, type: ExecutionDetailDto })
  @ApiResponse({ status: 404, description: 'Execution not found' })
  async getExecution(@Param('executionId') executionId: string): Promise<ExecutionDetailDto> {
    return this.executionService.getExecution(executionId);
  }
}

```

### `apps\backend\src\v1\execution\execution.module.ts`

```typescript
// execution.module.ts

import { Module } from '@nestjs/common';
import { V1ExecutionService } from './execution.service';
import { V1ExecutionController } from './execution.controller';
import { PrismaModule } from '../../prisma/prisma.module';
import { ProviderModule } from './providers/provider.module';
import { V1FlowModule } from '../flow/flow.module';
import { AwsModule } from '../../common/aws/aws.module';
import { V1ContextResolutionService } from './context-resolution.service';

@Module({
  imports: [PrismaModule, AwsModule, ProviderModule, V1FlowModule],
  controllers: [V1ExecutionController],
  providers: [V1ExecutionService, V1ContextResolutionService],
  exports: [V1ExecutionService],
})
export class V1ExecutionModule {}

```

### `apps\backend\src\v1\execution\execution.service.ts`

```typescript
// execution.service.ts - Direct streaming, no queue, instant response

import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';
import { ProviderFactory } from './providers/provider.factory';
import { V1ContextResolutionService } from './context-resolution.service';
import { LLMProvider, PodExecutionStatus } from '@actopod/schema';
import { ExecutionHistoryItemDto, ExecutionDetailDto } from './dto/execution-response.dto';
import { LLMPromptPodContent, PodContextMapping } from '../pods/types/pod-content.types';
import { LLMStreamChunk } from './types/llm-provider.types';
import { nanoid } from 'nanoid';

type LLMMessage = {
  role: 'system' | 'user' | 'assistant';
  content: string;
};

@Injectable()
export class V1ExecutionService {
  private readonly logger = new Logger(V1ExecutionService.name);

  private readonly DEFAULT_SYSTEM_PROMPTS = {
    general: 'You are a helpful AI assistant. Provide clear, accurate, and concise responses.',
    analyst: 'You are a data analyst. Analyze information objectively and provide insights.',
    coder: 'You are a coding assistant. Write clean, efficient, and well-documented code.',
    creative: 'You are a creative writing assistant. Be imaginative and engaging.',
  };

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
    private readonly providerFactory: ProviderFactory,
    private readonly contextResolution: V1ContextResolutionService,
  ) {}

  /**
   * INSTANT STREAMING - No queue, perfect for BYOK
   * Users see tokens immediately as they're generated
   */
  async *executePod(params: {
    podId: string;
    workspaceId: string;
    userId: string;
    messages: LLMMessage[];
    provider?: LLMProvider;
    model?: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
    thinkingBudget?: number;
    responseFormat?: 'text' | 'json_object' | 'json';
    contextMappings?: PodContextMapping[];
  }): AsyncGenerator<LLMStreamChunk, void, unknown> {
    const { podId, workspaceId, messages, contextMappings } = params;
    const executionId = `exec_${nanoid(16)}`;
    const startTime = Date.now();

    try {
      // Get pod info
      const pod = await this.prisma.pod.findFirst({
        where: { id: podId, flow: { workspaceId } },
        select: {
          flowId: true,
          id: true,
          type: true,
          dynamoPartitionKey: true,
          dynamoSortKey: true,
        },
      });

      if (!pod) {
        yield { type: 'error', error: `Pod ${podId} not found` };
        return;
      }

      if (pod.type !== 'LLM_PROMPT') {
        yield { type: 'error', error: 'Only LLM_PROMPT pods can be executed' };
        return;
      }

      const podConfig = await this.getPodConfig(pod.dynamoPartitionKey, pod.dynamoSortKey);
      if (!podConfig) {
        yield { type: 'error', error: 'Pod configuration not found' };
        return;
      }

      const llmConfig = podConfig.config;

      // Resolve all parameters (request â†’ pod config â†’ undefined)
      const finalProvider = params.provider ?? llmConfig.provider;
      const finalModel = params.model ?? llmConfig.model;
      const finalSystemPrompt = params.systemPrompt ?? llmConfig.systemPrompt;
      const finalTemperature = params.temperature ?? llmConfig.temperature;
      const finalMaxTokens = params.maxTokens ?? llmConfig.maxTokens;
      const finalTopP = params.topP ?? llmConfig.topP;
      const finalPresencePenalty = params.presencePenalty ?? llmConfig.presencePenalty;
      const finalFrequencyPenalty = params.frequencyPenalty ?? llmConfig.frequencyPenalty;
      const finalThinkingBudget = params.thinkingBudget ?? llmConfig.thinkingBudget;
      const finalResponseFormat = params.responseFormat ?? llmConfig.responseFormat;

      // Create execution record
      await this.prisma.podExecution.create({
        data: {
          id: executionId,
          podId,
          flowId: pod.flowId,
          workspaceId,
          status: PodExecutionStatus.RUNNING,
          provider: finalProvider,
          modelId: finalModel,
          startedAt: new Date(),
        },
      });

      // Resolve context
      const contextChain = contextMappings
        ? await this.contextResolution.resolveContextWithPins(podId, pod.flowId, contextMappings)
        : await this.contextResolution.resolveContext(podId, pod.flowId);

      // Build system prompt with variable interpolation
      let systemPrompt = finalSystemPrompt ?? this.DEFAULT_SYSTEM_PROMPTS.general;
      systemPrompt = this.contextResolution.interpolateVariables(
        systemPrompt,
        contextChain.variables,
      );

      // Interpolate messages
      const interpolatedMessages = messages.map((msg) => {
        if (msg.role === 'user' && typeof msg.content === 'string') {
          return {
            ...msg,
            content: this.contextResolution.interpolateVariables(
              msg.content,
              contextChain.variables,
            ),
          };
        }
        return msg;
      });

      const finalMessages = this.buildMessagesWithSystemPrompt(
        interpolatedMessages,
        systemPrompt,
        params.systemPrompt !== undefined,
      );

      // Get API key
      const workspaceKey = await this.providerFactory.getWorkspaceApiKey(
        workspaceId,
        finalProvider,
      );
      if (!workspaceKey) {
        yield {
          type: 'error',
          error: `No ${finalProvider} API key configured for this workspace`,
        };
        return;
      }

      const { apiKey, keyId, customEndpoint } = workspaceKey;

      // Get provider
      const llmProvider = this.providerFactory.getProvider(finalProvider);

      if (!llmProvider.executeStream) {
        yield {
          type: 'error',
          error: `Provider ${finalProvider} does not support streaming yet`,
        };
        return;
      }

      // Build request - only include defined parameters
      const llmRequest: any = {
        provider: finalProvider,
        model: finalModel,
        messages: finalMessages,
        apiKey,
        customEndpoint,
        apiKeyId: keyId,
        stream: true,
      };

      if (finalTemperature !== undefined) llmRequest.temperature = finalTemperature;
      if (finalMaxTokens !== undefined) llmRequest.maxTokens = finalMaxTokens;
      if (finalTopP !== undefined) llmRequest.topP = finalTopP;
      if (finalPresencePenalty !== undefined) llmRequest.presencePenalty = finalPresencePenalty;
      if (finalFrequencyPenalty !== undefined) llmRequest.frequencyPenalty = finalFrequencyPenalty;
      if (finalThinkingBudget !== undefined) llmRequest.thinkingBudget = finalThinkingBudget;
      if (finalResponseFormat !== undefined) llmRequest.responseFormat = finalResponseFormat;

      this.logger.debug(`ðŸŒŠ Streaming execution ${executionId}: ${finalProvider}/${finalModel}`);

      // Send start event
      yield { type: 'start', content: 'Processing started...' };

      // Stream response directly - NO QUEUE!
      let fullContent = '';
      let finalUsage: any = null;
      let finishReason = 'stop';

      for await (const chunk of llmProvider.executeStream(llmRequest)) {
        yield chunk; // Stream directly to user - INSTANT!

        if (chunk.type === 'token' && chunk.content) {
          fullContent += chunk.content;
        }

        if (chunk.type === 'done') {
          finalUsage = chunk.usage;
          finishReason = chunk.finishReason || 'stop';
        }
      }

      // Save execution results
      if (finalUsage) {
        const pricing = await this.prisma.modelPricingTier.findFirst({
          where: { provider: finalProvider, modelId: finalModel, isActive: true },
          orderBy: { effectiveFrom: 'desc' },
        });

        if (pricing) {
          const inputCost = (finalUsage.promptTokens / 1_000_000) * Number(pricing.inputTokenCost);
          const outputCost =
            (finalUsage.completionTokens / 1_000_000) * Number(pricing.outputTokenCost);
          const reasoningCost =
            ((finalUsage.reasoningTokens || 0) / 1_000_000) * Number(pricing.reasoningTokenCost);
          const totalCost = inputCost + outputCost + reasoningCost;

          await this.prisma.podExecution.update({
            where: { id: executionId },
            data: {
              status: PodExecutionStatus.COMPLETED,
              finishedAt: new Date(),
              runtimeInMs: Date.now() - startTime,
              apiKeyId: keyId,
              inputTokens: finalUsage.promptTokens,
              outputTokens: finalUsage.completionTokens,
              reasoningTokens: finalUsage.reasoningTokens || 0,
              costInUsd: totalCost,
              modelName: finalModel,
              responseMetadata: { content: fullContent, finishReason },
            },
          });

          await this.providerFactory.trackApiKeyUsage(
            keyId,
            {
              input: finalUsage.promptTokens,
              output: finalUsage.completionTokens,
              reasoning: finalUsage.reasoningTokens,
            },
            totalCost,
            true,
          );

          this.logger.log(
            `âœ… Execution ${executionId} completed - ${finalUsage.totalTokens} tokens, $${totalCost.toFixed(6)} in ${Date.now() - startTime}ms`,
          );
        }
      }

      await this.prisma.pod.update({
        where: { id: podId },
        data: {
          executionStatus: PodExecutionStatus.COMPLETED,
          lastExecutionId: executionId,
        },
      });
    } catch (error) {
      await this.prisma.podExecution.update({
        where: { id: executionId },
        data: {
          status: PodExecutionStatus.ERROR,
          finishedAt: new Date(),
          runtimeInMs: Date.now() - startTime,
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
        },
      });

      this.logger.error(`âŒ Execution ${executionId} failed:`, error);

      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  private async getPodConfig(pk: string, sk: string): Promise<LLMPromptPodContent | null> {
    try {
      const tableName = this.dynamoDb.getTableNames().pods;
      const item = (await this.dynamoDb.getItem(tableName, { pk, sk })) as any | null;
      return item?.content?.type === 'LLM_PROMPT' ? (item.content as LLMPromptPodContent) : null;
    } catch (error) {
      this.logger.error('Failed to fetch pod config from DynamoDB', error);
      return null;
    }
  }

  private buildMessagesWithSystemPrompt(
    messages: LLMMessage[],
    systemPrompt: string,
    userProvidedSystemPrompt: boolean = false,
  ): LLMMessage[] {
    const hasSystemMessage = messages.some((m) => m.role === 'system');

    if (hasSystemMessage) {
      this.logger.debug('Using system message from messages array');
      return messages;
    }

    this.logger.debug(
      `Using ${userProvidedSystemPrompt ? 'user-provided' : 'configured'} system prompt: "${systemPrompt.substring(0, 50)}..."`,
    );

    return [{ role: 'system', content: systemPrompt }, ...messages];
  }

  async getPodExecutions(podId: string, limit: number = 10): Promise<ExecutionHistoryItemDto[]> {
    const executions = await this.prisma.podExecution.findMany({
      where: { podId },
      orderBy: { startedAt: 'desc' },
      take: Math.min(limit, 100), // Max 100
      select: {
        id: true,
        podId: true,
        status: true,
        provider: true,
        modelId: true,
        modelName: true,
        inputTokens: true,
        outputTokens: true,
        reasoningTokens: true,
        costInUsd: true,
        startedAt: true,
        finishedAt: true,
        runtimeInMs: true,
        errorMessage: true,
        errorCode: true,
      },
    });

    return executions.map((exec) => ({
      id: exec.id,
      podId: exec.podId,
      status: exec.status,
      provider: exec.provider,
      modelId: exec.modelId,
      modelName: exec.modelName,
      inputTokens: exec.inputTokens,
      outputTokens: exec.outputTokens,
      reasoningTokens: exec.reasoningTokens,
      costInUsd: exec.costInUsd ? exec.costInUsd.toString() : null,
      startedAt: exec.startedAt,
      finishedAt: exec.finishedAt,
      runtimeInMs: exec.runtimeInMs,
      errorMessage: exec.errorMessage,
      errorCode: exec.errorCode,
    }));
  }

  async getExecution(executionId: string): Promise<ExecutionDetailDto> {
    const execution = await this.prisma.podExecution.findUnique({
      where: { id: executionId },
      include: {
        pod: {
          select: {
            id: true,
            type: true,
            flowId: true,
          },
        },
      },
    });

    if (!execution) {
      throw new NotFoundException(`Execution ${executionId} not found`);
    }

    return {
      ...execution,
      costInUsd: execution.costInUsd ? execution.costInUsd.toString() : null,
    } as ExecutionDetailDto;
  }
}

```

### `apps\backend\src\v1\execution\execution-queue.service.ts`

```typescript
// execution-queue.service.ts

import { Injectable, Logger, OnModuleDestroy } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { V1ExecutionService } from './execution.service';
import { V1FlowGateway } from '../flow/flow.gateway';
import { PrismaService } from '../../prisma/prisma.service';
import { LLMProvider, PodExecutionStatus } from '@actopod/schema';
import { QueueFactory } from '../../common/queue/queue.factory';
import { QueueAdapter } from '../../common/queue/queue-adapter.interface';

export type ExecutionJobData = {
  executionId: string;
  podId: string;
  workspaceId: string;
  userId: string;
  flowId: string;
  messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }>;
  provider?: LLMProvider;
  model?: string;
  systemPrompt?: string; // ADD THIS
  temperature?: number;
  maxTokens?: number;
  topP?: number; // ADD THIS
  presencePenalty?: number; // ADD THIS
  frequencyPenalty?: number; // ADD THIS
  thinkingBudget?: number;
  responseFormat?: 'text' | 'json_object' | 'json'; // ADD THIS
};

@Injectable()
export class V1ExecutionQueueService implements OnModuleDestroy {
  private readonly logger = new Logger(V1ExecutionQueueService.name);
  private executionQueue: QueueAdapter;

  constructor(
    private readonly config: ConfigService,
    private readonly queueFactory: QueueFactory,
    private readonly executionService: V1ExecutionService,
    private readonly flowGateway: V1FlowGateway,
    private readonly prisma: PrismaService,
  ) {
    this.executionQueue = this.queueFactory.createQueue('pod-executions', 10);

    this.executionQueue.process(async (job: any) => {
      return this.processExecution(job);
    });

    this.logger.log('âœ… Execution queue service initialized with streaming support');
  }

  async queueExecution(data: ExecutionJobData): Promise<string> {
    try {
      const jobId = await this.executionQueue.add('execute-pod', data, {
        jobId: data.executionId,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
      });

      this.logger.log(
        `ðŸ“‹ Queued execution ${data.executionId} for pod ${data.podId} (provider: ${data.provider || 'default'})`,
      );

      this.flowGateway.broadcastToFlow(data.flowId, 'execution:queued', {
        executionId: data.executionId,
        podId: data.podId,
        status: PodExecutionStatus.QUEUED,
        timestamp: new Date(),
      });

      return jobId;
    } catch (error) {
      this.logger.error(
        `Failed to queue execution ${data.executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
      throw error;
    }
  }

  private async processExecution(job: any) {
    const { executionId, podId, workspaceId, userId, flowId, ...params } = job.data;

    this.logger.log(
      `ðŸš€ Processing execution ${executionId} (attempt ${job.attemptsMade || 1}/${job.opts?.attempts || 3})`,
    );

    try {
      await this.updateExecutionStatus(executionId, PodExecutionStatus.RUNNING);

      this.flowGateway.broadcastToFlow(flowId, 'execution:running', {
        executionId,
        podId,
        status: PodExecutionStatus.RUNNING,
        timestamp: new Date(),
      });

      // Execute with ALL parameters passed through
      const result = await this.executionService.executePod({
        podId,
        workspaceId,
        userId,
        messages: params.messages,
        provider: params.provider,
        model: params.model,
        systemPrompt: params.systemPrompt, // PASS THIS
        temperature: params.temperature,
        maxTokens: params.maxTokens,
        topP: params.topP, // PASS THIS
        presencePenalty: params.presencePenalty, // PASS THIS
        frequencyPenalty: params.frequencyPenalty, // PASS THIS
        thinkingBudget: params.thinkingBudget,
        responseFormat: params.responseFormat, // PASS THIS
      });

      this.logger.log(`âœ… Execution ${executionId} completed successfully`);

      this.flowGateway.broadcastToFlow(flowId, 'execution:completed', {
        executionId,
        podId,
        status: PodExecutionStatus.COMPLETED,
        result,
        timestamp: new Date(),
      });

      return result;
    } catch (error) {
      this.logger.error(
        `âŒ Execution ${executionId} failed (attempt ${job.attemptsMade || 1}):`,
        error instanceof Error ? error.message : 'Unknown error',
      );

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const errorCode = error instanceof Error ? error.name : 'UNKNOWN_ERROR';

      await this.updateExecutionStatus(executionId, PodExecutionStatus.ERROR, errorMessage);

      this.flowGateway.broadcastToFlow(flowId, 'execution:error', {
        executionId,
        podId,
        status: PodExecutionStatus.ERROR,
        error: errorMessage,
        errorCode,
        timestamp: new Date(),
      });

      throw error;
    }
  }

  private async updateExecutionStatus(
    executionId: string,
    status: PodExecutionStatus,
    errorMessage?: string,
  ): Promise<void> {
    try {
      await this.prisma.podExecution.update({
        where: { id: executionId },
        data: {
          status,
          ...(status === PodExecutionStatus.RUNNING && { startedAt: new Date() }),
          ...(errorMessage && {
            errorMessage,
            errorCode: 'EXECUTION_ERROR',
            finishedAt: new Date(),
          }),
        },
      });
    } catch (error) {
      this.logger.error(
        `Failed to update execution status for ${executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
    }
  }

  async getQueueMetrics() {
    try {
      const metrics = await this.executionQueue.getMetrics();

      this.logger.debug(
        `Queue metrics: waiting=${metrics.waiting}, active=${metrics.active}, completed=${metrics.completed}, failed=${metrics.failed}`,
      );

      return metrics;
    } catch (error) {
      this.logger.error('Failed to get queue metrics:', error);
      return {
        waiting: 0,
        active: 0,
        completed: 0,
        failed: 0,
      };
    }
  }

  async cancelExecution(executionId: string): Promise<boolean> {
    try {
      const cancelled = await this.executionQueue.cancel(executionId);

      if (cancelled) {
        await this.updateExecutionStatus(executionId, PodExecutionStatus.CANCELLED);
        this.logger.log(`ðŸ›‘ Cancelled execution ${executionId}`);
        return true;
      }

      this.logger.warn(`Failed to cancel execution ${executionId} - job not found in queue`);
      return false;
    } catch (error) {
      this.logger.error(
        `Error cancelling execution ${executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
      return false;
    }
  }

  async getExecutionQueueStatus(executionId: string) {
    try {
      return await this.executionQueue.getJobStatus(executionId);
    } catch (error) {
      this.logger.error(
        `Failed to get queue status for ${executionId}:`,
        error instanceof Error ? error.message : 'Unknown error',
      );
      return null;
    }
  }

  async onModuleDestroy() {
    try {
      this.logger.log('ðŸ›‘ Shutting down execution queue...');
      await this.executionQueue.close();
      this.logger.log('âœ… Execution queue closed successfully');
    } catch (error) {
      this.logger.error('Error closing execution queue:', error);
    }
  }
}

```

### `apps\backend\src\v1\execution\providers\anthropic.provider.ts`

```typescript
import { Injectable } from '@nestjs/common';
import axios from 'axios';
import { BaseLLMProvider } from './base-llm.provider';
import { LLMProvider } from '@actopod/schema';
import { LLMRequest, LLMResponse, LLMStreamChunk } from '../types/llm-provider.types';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class AnthropicProvider extends BaseLLMProvider {
  private readonly defaultBaseUrl = 'https://api.anthropic.com/v1';
  private readonly apiVersion = '2023-06-01';

  constructor(prisma: PrismaService) {
    super('AnthropicProvider', prisma);
  }

  async execute(request: LLMRequest): Promise<LLMResponse> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const systemMessage = request.messages.find((m) => m.role === 'system');
      const userMessages = request.messages.filter((m) => m.role !== 'system');

      const modelPricing = await this.getModelPricing(LLMProvider.ANTHROPIC, request.model);
      const supportsExtendedThinking = modelPricing?.modelId?.includes('4-5') || false;

      const requestBody: any = {
        model: request.model,
        messages: userMessages.map((m) => ({
          role: m.role,
          content: typeof m.content === 'string' ? m.content : JSON.stringify(m.content),
        })),
        max_tokens: request.maxTokens ?? this.getDefaultMaxTokens(request.model),
      };

      if (systemMessage) {
        requestBody.system =
          typeof systemMessage.content === 'string'
            ? systemMessage.content
            : JSON.stringify(systemMessage.content);
      }

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (request.topP !== undefined) {
        requestBody.top_p = request.topP;
      }

      if (supportsExtendedThinking && request.thinkingBudget) {
        requestBody.thinking = {
          type: 'enabled',
          budget_tokens: request.thinkingBudget,
        };
      }

      this.logger.debug(
        `Executing Anthropic request: model=${request.model}, max_tokens=${requestBody.max_tokens}`,
      );

      const response = await this.retryWithBackoff(() =>
        axios.post(`${baseUrl}/messages`, requestBody, {
          headers: this.getRequestHeaders(request.apiKey, request.model),
          timeout: 180000,
        }),
      );

      const data = response.data;

      let content = '';
      if (Array.isArray(data.content)) {
        const textBlocks = data.content.filter((block: any) => block.type === 'text');
        content = textBlocks.map((block: any) => block.text).join('\n');
      } else {
        content = data.content[0]?.text || '';
      }

      const result: LLMResponse = {
        id: data.id,
        model: data.model,
        provider: LLMProvider.ANTHROPIC,
        content,
        finishReason: data.stop_reason,
        usage: {
          promptTokens: data.usage.input_tokens,
          completionTokens: data.usage.output_tokens,
          totalTokens: data.usage.input_tokens + data.usage.output_tokens,
          cachedTokens: data.usage.cache_read_input_tokens,
        },
        rawResponse: data,
        timestamp: new Date(),
      };

      this.logger.log(`âœ… Anthropic execution completed: ${result.usage.totalTokens} tokens`);

      return result;
    } catch (error) {
      this.logger.error(
        `âŒ Anthropic execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      this.handleError(error, 'Anthropic');
    }
  }

  async *executeStream(request: LLMRequest): AsyncGenerator<LLMStreamChunk> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const systemMessage = request.messages.find((m) => m.role === 'system');
      const userMessages = request.messages.filter((m) => m.role !== 'system');

      const modelPricing = await this.getModelPricing(LLMProvider.ANTHROPIC, request.model);
      const supportsExtendedThinking = modelPricing?.modelId?.includes('4-5') || false;

      const requestBody: any = {
        model: request.model,
        messages: userMessages.map((m) => ({
          role: m.role,
          content: typeof m.content === 'string' ? m.content : JSON.stringify(m.content),
        })),
        max_tokens: request.maxTokens ?? this.getDefaultMaxTokens(request.model),
        stream: true,
      };

      if (systemMessage) {
        requestBody.system =
          typeof systemMessage.content === 'string'
            ? systemMessage.content
            : JSON.stringify(systemMessage.content);
      }

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (request.topP !== undefined) {
        requestBody.top_p = request.topP;
      }

      if (supportsExtendedThinking && request.thinkingBudget) {
        requestBody.thinking = {
          type: 'enabled',
          budget_tokens: request.thinkingBudget,
        };
      }

      this.logger.debug(
        `Streaming Anthropic request: model=${request.model}, max_tokens=${requestBody.max_tokens}`,
      );

      const response = await axios.post(`${baseUrl}/messages`, requestBody, {
        headers: this.getRequestHeaders(request.apiKey, request.model),
        responseType: 'stream',
        timeout: 180000,
      });

      yield { type: 'start' };

      let buffer = '';
      let finalUsage: any = null;

      for await (const chunk of response.data) {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '' || !line.startsWith('data: ')) continue;

          try {
            const data = JSON.parse(line.substring(6));

            if (data.type === 'content_block_delta') {
              if (data.delta?.type === 'text_delta' && data.delta?.text) {
                yield { type: 'token', content: data.delta.text };
              }
            }

            if (data.type === 'message_delta') {
              if (data.usage) {
                finalUsage = data.usage;
              }
            }

            if (data.type === 'message_stop') {
              if (finalUsage) {
                yield {
                  type: 'done',
                  finishReason: data.delta?.stop_reason || 'end_turn',
                  usage: {
                    promptTokens: finalUsage.input_tokens || 0,
                    completionTokens: finalUsage.output_tokens || 0,
                    totalTokens: (finalUsage.input_tokens || 0) + (finalUsage.output_tokens || 0),
                  },
                };
              } else {
                yield { type: 'done', finishReason: 'end_turn' };
              }
            }
          } catch {
            this.logger.warn(`Failed to parse SSE line: ${line}`);
          }
        }
      }

      this.logger.log(`âœ… Anthropic stream completed`);
    } catch (error) {
      this.logger.error(
        `âŒ Anthropic stream failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  private getDefaultMaxTokens(model: string): number {
    // Claude 3.7 Sonnet - 128K output
    if (model.includes('claude-3-7')) {
      return 128000;
    }

    // Claude Sonnet 4 - 64K output
    if (model.includes('claude-sonnet-4') || model.includes('sonnet-4-5')) {
      return 64000;
    }

    // Claude Opus 4 - 32K output
    if (model.includes('claude-opus-4') || model.includes('opus-4-1')) {
      return 32000;
    }

    // Claude 3.5 Sonnet - 8K output (with special header)
    if (model.includes('claude-3-5-sonnet') || model.includes('3-5-sonnet')) {
      return 8192;
    }

    // Claude Haiku - 10K output
    if (model.includes('haiku')) {
      return 10000;
    }

    // Default for older models
    return 4096;
  }

  private getRequestHeaders(apiKey: string, model: string): any {
    const headers: any = {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': this.apiVersion,
    };

    // Enable extended output for Claude 3.5 Sonnet
    if (model.includes('claude-3-5-sonnet')) {
      headers['anthropic-beta'] = 'max-tokens-3-5-sonnet-2024-07-15';
    }

    return headers;
  }

  async testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean> {
    try {
      const baseUrl = customEndpoint || this.defaultBaseUrl;
      await axios.post(
        `${baseUrl}/messages`,
        {
          model: 'claude-3-5-haiku-20241022',
          max_tokens: 10,
          messages: [{ role: 'user', content: 'test' }],
        },
        {
          headers: {
            'x-api-key': apiKey,
            'anthropic-version': this.apiVersion,
          },
          timeout: 10000,
        },
      );
      this.logger.log('âœ… Anthropic API key validation successful');
      return true;
    } catch {
      this.logger.warn('Anthropic API key validation failed');
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    const dbModels = await this.getModelsFromDb(LLMProvider.ANTHROPIC);
    if (dbModels.length > 0) {
      this.logger.debug(`Loaded ${dbModels.length} Anthropic models from database`);
      return dbModels;
    }

    const fallbackModels = [
      'claude-sonnet-4-5-20250929',
      'claude-haiku-4-5-20250929',
      'claude-opus-4-1-20250808',
      'claude-3-5-sonnet-20241022',
      'claude-3-5-haiku-20241022',
    ];

    this.logger.debug(`Using ${fallbackModels.length} fallback Anthropic models`);
    return fallbackModels;
  }
}

```

### `apps\backend\src\v1\execution\providers\base-llm.provider.ts`

```typescript
import { Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { ILLMProvider, LLMRequest, LLMResponse } from '../types/llm-provider.types';
import { LLMProvider, ModelPricingTier } from '@actopod/schema';

export abstract class BaseLLMProvider implements ILLMProvider {
  protected readonly logger: Logger;

  constructor(
    providerName: string,
    protected readonly prisma: PrismaService,
  ) {
    this.logger = new Logger(providerName);
  }

  abstract execute(request: LLMRequest): Promise<LLMResponse>;
  abstract testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean>;
  abstract getAvailableModels(): Promise<string[]>;

  /**
   * Get active models from database for this provider
   */
  protected async getModelsFromDb(provider: LLMProvider): Promise<string[]> {
    try {
      const models = await this.prisma.modelPricingTier.findMany({
        where: {
          provider,
          isActive: true,
        },
        select: {
          modelId: true,
          displayName: true,
        },
        orderBy: {
          displayName: 'asc',
        },
      });

      return models.map((m) => m.modelId);
    } catch (error) {
      this.logger.warn(
        `Failed to fetch models from DB: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      return [];
    }
  }

  /**
   * Get model pricing info from database
   */
  protected async getModelPricing(
    provider: LLMProvider,
    modelId: string,
  ): Promise<ModelPricingTier | null> {
    try {
      return await this.prisma.modelPricingTier.findFirst({
        where: {
          provider,
          modelId,
          isActive: true,
        },
        orderBy: {
          effectiveFrom: 'desc',
        },
      });
    } catch (error) {
      this.logger.warn(`Failed to fetch pricing for ${modelId}:`, error);
      return null;
    }
  }

  /**
   * Handle common errors with better messaging
   */
  protected handleError(error: any, provider: string): never {
    this.logger.error(`${provider} execution failed:`, error);

    const status = error.response?.status;
    const errorData = error.response?.data;

    // Handle specific HTTP status codes
    if (status === 401 || status === 403) {
      throw new Error(`Invalid or expired API key for ${provider}`);
    }
    if (status === 429) {
      const retryAfter = error.response?.headers?.['retry-after'];
      throw new Error(
        `Rate limit exceeded for ${provider}${retryAfter ? `. Retry after ${retryAfter} seconds` : ''}`,
      );
    }
    if (status === 400) {
      const message = errorData?.error?.message || errorData?.message || 'Bad request';
      throw new Error(`${provider} bad request: ${message}`);
    }
    if (status === 404) {
      throw new Error(`${provider} endpoint not found. Check your configuration.`);
    }
    if (status === 500 || status === 503) {
      throw new Error(`${provider} service unavailable. Please try again later.`);
    }
    if (status === 502 || status === 504) {
      throw new Error(`${provider} gateway timeout. Please try again.`);
    }

    // Handle timeout errors
    if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
      throw new Error(`${provider} request timeout. Please try again.`);
    }

    // Handle network errors
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      throw new Error(`${provider} network error. Check your internet connection.`);
    }

    // Generic error
    const message = error.message || 'Unknown error';
    throw new Error(`${provider} execution failed: ${message}`);
  }

  /**
   * Retry with exponential backoff and jitter
   */
  protected async retryWithBackoff<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    baseDelay: number = 1000,
  ): Promise<T> {
    let lastError: any;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error: any) {
        lastError = error;

        // Don't retry on client errors (4xx except 429)
        const status = error.response?.status;
        if (status && status >= 400 && status < 500 && status !== 429) {
          this.logger.warn(`Non-retryable error (${status}), failing immediately`);
          throw error;
        }

        // Don't retry if this is the last attempt
        if (attempt === maxRetries - 1) {
          this.logger.error(`Max retries (${maxRetries}) exceeded`);
          throw error;
        }

        // Calculate delay with exponential backoff + jitter
        const exponentialDelay = baseDelay * Math.pow(2, attempt);
        const jitter = Math.random() * 1000; // Random 0-1000ms jitter
        const delay = Math.min(exponentialDelay + jitter, 30000); // Cap at 30 seconds

        this.logger.warn(
          `Retry ${attempt + 1}/${maxRetries} after ${Math.round(delay)}ms (status: ${status || 'unknown'})`,
        );

        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }
}

```

### `apps\backend\src\v1\execution\providers\gemini.provider.ts`

```typescript
import { Injectable } from '@nestjs/common';
import axios, { AxiosError } from 'axios';
import { BaseLLMProvider } from './base-llm.provider';
import { LLMProvider } from '@actopod/schema';
import { LLMRequest, LLMResponse, LLMStreamChunk } from '../types/llm-provider.types';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class GeminiProvider extends BaseLLMProvider {
  private readonly defaultBaseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private readonly REQUEST_TIMEOUT = 180000;
  private readonly API_KEY_TEST_TIMEOUT = 10000;

  constructor(prisma: PrismaService) {
    super('GeminiProvider', prisma);
  }

  async execute(request: LLMRequest): Promise<LLMResponse> {
    const startTime = Date.now();

    try {
      this.validateRequest(request);

      const baseUrl = this.sanitizeUrl(request.customEndpoint || this.defaultBaseUrl);
      const contents = this.convertMessagesToGeminiFormat(request.messages);

      if (contents.length === 0) {
        throw new Error('No valid messages to send after filtering system messages');
      }

      const requestBody = this.buildRequestBody(request, contents);

      this.logger.debug(`Executing Gemini request: model=${request.model}`);

      const response = await this.retryWithBackoff(() =>
        axios.post(
          `${baseUrl}/models/${request.model}:generateContent?key=${request.apiKey}`,
          requestBody,
          {
            headers: { 'Content-Type': 'application/json' },
            timeout: this.REQUEST_TIMEOUT,
            validateStatus: (status) => status < 500,
          },
        ),
      );

      if (response.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.');
      }

      if (response.status === 401 || response.status === 403) {
        throw new Error('Invalid or unauthorized API key');
      }

      if (response.status >= 400) {
        const errorMessage = response.data?.error?.message || 'Unknown API error';
        throw new Error(`Gemini API error (${response.status}): ${errorMessage}`);
      }

      const data = this.validateResponse(response.data);
      const llmResponse = this.parseResponse(data, request.model);

      const executionTime = Date.now() - startTime;
      this.logger.log(
        `âœ… Gemini execution completed: ${llmResponse.usage.totalTokens} tokens in ${executionTime}ms`,
      );

      return llmResponse;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(
        `âŒ Gemini execution failed after ${executionTime}ms: ${this.getErrorMessage(error)}`,
      );
      this.handleError(error, 'Google Gemini');
    }
  }

  async *executeStream(request: LLMRequest): AsyncGenerator<LLMStreamChunk> {
    try {
      this.validateRequest(request);

      const baseUrl = this.sanitizeUrl(request.customEndpoint || this.defaultBaseUrl);
      const contents = this.convertMessagesToGeminiFormat(request.messages);

      if (contents.length === 0) {
        throw new Error('No valid messages to send');
      }

      const requestBody = this.buildRequestBody(request, contents);

      this.logger.debug(`Streaming Gemini request: model=${request.model}`);

      const response = await axios.post(
        `${baseUrl}/models/${request.model}:streamGenerateContent?key=${request.apiKey}&alt=sse`,
        requestBody,
        {
          headers: { 'Content-Type': 'application/json' },
          responseType: 'stream',
          timeout: this.REQUEST_TIMEOUT,
        },
      );

      yield { type: 'start' };

      let buffer = '';
      let totalUsage = {
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0,
      };

      for await (const chunk of response.data) {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '' || !line.startsWith('data: ')) continue;

          try {
            const data = JSON.parse(line.substring(6));

            if (data.candidates && data.candidates[0]?.content?.parts) {
              for (const part of data.candidates[0].content.parts) {
                if (part.text) {
                  yield { type: 'token', content: part.text };
                }
              }
            }

            if (data.usageMetadata) {
              totalUsage = {
                promptTokens: data.usageMetadata.promptTokenCount || 0,
                completionTokens: data.usageMetadata.candidatesTokenCount || 0,
                totalTokens: data.usageMetadata.totalTokenCount || 0,
              };
            }

            if (data.candidates && data.candidates[0]?.finishReason) {
              yield {
                type: 'done',
                finishReason: data.candidates[0].finishReason,
                usage: totalUsage,
              };
            }
          } catch {
            this.logger.warn(`Failed to parse SSE line: ${line}`);
          }
        }
      }

      this.logger.log(`âœ… Gemini stream completed`);
    } catch (error) {
      this.logger.error(`âŒ Gemini stream failed: ${this.getErrorMessage(error)}`);
      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  private validateRequest(request: LLMRequest): void {
    if (
      !request.apiKey ||
      typeof request.apiKey !== 'string' ||
      request.apiKey.trim().length === 0
    ) {
      throw new Error('Invalid API key');
    }

    if (!request.model || typeof request.model !== 'string') {
      throw new Error('Invalid model');
    }

    if (!Array.isArray(request.messages) || request.messages.length === 0) {
      throw new Error('Invalid messages');
    }

    if (request.temperature !== undefined && (request.temperature < 0 || request.temperature > 2)) {
      throw new Error('Temperature must be between 0 and 2');
    }

    if (request.maxTokens !== undefined && (request.maxTokens < 1 || request.maxTokens > 65536)) {
      throw new Error('maxTokens must be between 1 and 65536');
    }

    if (request.topP !== undefined && (request.topP < 0 || request.topP > 1)) {
      throw new Error('topP must be between 0 and 1');
    }
  }

  private sanitizeUrl(url: string): string {
    try {
      const urlObj = new URL(url);
      if (!['http:', 'https:'].includes(urlObj.protocol)) {
        throw new Error('Invalid protocol');
      }
      return url.replace(/\/$/, '');
    } catch {
      throw new Error(`Invalid URL format: ${url}`);
    }
  }

  private convertMessagesToGeminiFormat(messages: LLMRequest['messages']): Array<{
    role: string;
    parts: Array<{ text: string }>;
  }> {
    return messages
      .filter((m) => m.role !== 'system')
      .map((m) => {
        if (!m.role || !m.content) {
          this.logger.warn(`Skipping invalid message: ${JSON.stringify(m)}`);
          return null;
        }

        const text =
          typeof m.content === 'string'
            ? m.content
            : typeof m.content === 'object'
              ? JSON.stringify(m.content)
              : String(m.content);

        if (text.length === 0) {
          this.logger.warn(`Skipping empty message from role: ${m.role}`);
          return null;
        }

        return {
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text }],
        };
      })
      .filter((m): m is NonNullable<typeof m> => m !== null);
  }

  private buildRequestBody(request: LLMRequest, contents: any[]): any {
    const requestBody: any = { contents };
    const generationConfig: any = {};

    if (request.temperature !== undefined) {
      generationConfig.temperature = request.temperature;
    }

    // Set maximum output tokens per official docs
    if (request.maxTokens !== undefined) {
      generationConfig.maxOutputTokens = request.maxTokens;
    } else {
      // Use model-specific maximum defaults
      if (request.model.includes('gemini-2.5')) {
        generationConfig.maxOutputTokens = 65535; // Gemini 2.5 maximum
      } else if (request.model.includes('gemini-2.0')) {
        generationConfig.maxOutputTokens = 8192; // Gemini 2.0 maximum
      }
      // Don't set for gemini-1.5 - let Google use its default
    }

    if (request.topP !== undefined) {
      generationConfig.topP = request.topP;
    }

    if (request.responseFormat === 'json_object') {
      generationConfig.response_mime_type = 'application/json';
    }

    if (request.thinkingBudget && request.model.includes('2.5')) {
      generationConfig.thinking_config = {
        budget_tokens: request.thinkingBudget,
      };
    }

    if (Object.keys(generationConfig).length > 0) {
      requestBody.generationConfig = generationConfig;
    }

    const systemMessage = request.messages.find((m) => m.role === 'system');
    if (systemMessage && systemMessage.content) {
      const systemText =
        typeof systemMessage.content === 'string'
          ? systemMessage.content
          : JSON.stringify(systemMessage.content);

      if (systemText.length > 0) {
        requestBody.systemInstruction = { parts: [{ text: systemText }] };
      }
    }

    requestBody.safetySettings = [
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_ONLY_HIGH' },
    ];

    return requestBody;
  }

  private validateResponse(data: any): any {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid response');
    }

    if (data.promptFeedback?.blockReason) {
      throw new Error(`Content blocked: ${data.promptFeedback.blockReason}`);
    }

    if (!data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
      throw new Error('No candidates returned');
    }

    const candidate = data.candidates[0];

    if (candidate.finishReason === 'SAFETY') {
      throw new Error('Content blocked due to safety concerns');
    }

    if (!candidate.content || !Array.isArray(candidate.content.parts)) {
      throw new Error('Invalid candidate structure');
    }

    return data;
  }

  private parseResponse(data: any, model: string): LLMResponse {
    const candidate = data.candidates[0];

    const content = candidate.content.parts
      .map((p: any) => p.text || '')
      .filter((text: string) => text.length > 0)
      .join('\n');

    return {
      id: data.modelVersion || model,
      model,
      provider: LLMProvider.GOOGLE_GEMINI,
      content,
      finishReason: candidate.finishReason || 'unknown',
      usage: {
        promptTokens: data.usageMetadata?.promptTokenCount || 0,
        completionTokens: data.usageMetadata?.candidatesTokenCount || 0,
        totalTokens: data.usageMetadata?.totalTokenCount || 0,
        cachedTokens: data.usageMetadata?.cachedContentTokenCount || 0,
      },
      rawResponse: data,
      timestamp: new Date(),
    };
  }

  private getErrorMessage(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (axios.isAxiosError(error)) {
      const axiosError = error as AxiosError;
      if (axiosError.response?.data) {
        const data = axiosError.response.data as any;
        return data.error?.message || data.message || axiosError.message;
      }
      return axiosError.message;
    }
    return String(error);
  }

  async testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean> {
    try {
      if (!apiKey || apiKey.trim().length === 0) {
        return false;
      }

      const baseUrl = this.sanitizeUrl(customEndpoint || this.defaultBaseUrl);
      const response = await axios.get(`${baseUrl}/models?key=${apiKey}`, {
        timeout: this.API_KEY_TEST_TIMEOUT,
        validateStatus: (status) => status < 500,
      });

      if (response.status === 200) {
        this.logger.log('âœ… Gemini API key validation successful');
        return true;
      }

      return false;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    try {
      const dbModels = await this.getModelsFromDb(LLMProvider.GOOGLE_GEMINI);
      if (dbModels.length > 0) {
        return dbModels;
      }

      return [
        'gemini-2.5-pro',
        'gemini-2.5-flash',
        'gemini-2.5-flash-lite',
        'gemini-2.0-flash',
        'gemini-1.5-pro',
      ];
    } catch {
      return ['gemini-2.5-flash', 'gemini-1.5-pro'];
    }
  }
}

```

### `apps\backend\src\v1\execution\providers\openai.provider.ts`

```typescript
import { Injectable } from '@nestjs/common';
import axios from 'axios';
import { LLMProvider } from '@actopod/schema';
import { LLMRequest, LLMResponse, LLMStreamChunk } from '../types/llm-provider.types';
import { PrismaService } from '../../../prisma/prisma.service';
import { BaseLLMProvider } from './base-llm.provider';

@Injectable()
export class OpenAIProvider extends BaseLLMProvider {
  private readonly defaultBaseUrl = 'https://api.openai.com/v1';

  constructor(prisma: PrismaService) {
    super('OpenAIProvider', prisma);
  }

  async execute(request: LLMRequest): Promise<LLMResponse> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const modelPricing = await this.getModelPricing(LLMProvider.OPENAI, request.model);
      const isReasoningModel = (modelPricing?.creditsPerMillionReasoningTokens ?? 0) > 0;

      const requestBody: any = {
        model: request.model,
        messages: request.messages,
        stream: false,
      };

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (!isReasoningModel) {
        if (request.maxTokens !== undefined) {
          requestBody.max_tokens = request.maxTokens;
        }
        if (request.topP !== undefined) {
          requestBody.top_p = request.topP;
        }
        if (request.presencePenalty !== undefined) {
          requestBody.presence_penalty = request.presencePenalty;
        }
        if (request.frequencyPenalty !== undefined) {
          requestBody.frequency_penalty = request.frequencyPenalty;
        }
        if (request.responseFormat) {
          requestBody.response_format = { type: request.responseFormat };
        }
      } else {
        if (request.maxTokens !== undefined) {
          requestBody.max_completion_tokens = request.maxTokens;
        }
      }

      this.logger.debug(
        `Executing OpenAI request: model=${request.model}, isReasoning=${isReasoningModel}, temperature=${request.temperature ?? 'default'}, maxTokens=${request.maxTokens ?? 'default'}`,
      );

      const response = await this.retryWithBackoff(() =>
        axios.post(`${baseUrl}/chat/completions`, requestBody, {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${request.apiKey}`,
          },
          timeout: 180000,
        }),
      );

      const data = response.data;
      const choice = data.choices[0];

      const result: LLMResponse = {
        id: data.id,
        model: data.model,
        provider: LLMProvider.OPENAI,
        content: choice.message.content || '',
        finishReason: choice.finish_reason,
        usage: {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens,
          reasoningTokens: data.usage.completion_tokens_details?.reasoning_tokens,
          cachedTokens: data.usage.prompt_tokens_details?.cached_tokens,
        },
        rawResponse: data,
        timestamp: new Date(),
      };

      this.logger.log(
        `âœ… OpenAI execution completed: ${result.usage.totalTokens} tokens (${result.usage.promptTokens} input + ${result.usage.completionTokens} output${result.usage.reasoningTokens ? ` + ${result.usage.reasoningTokens} reasoning` : ''})`,
      );

      return result;
    } catch (error) {
      this.logger.error(
        `âŒ OpenAI execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      this.handleError(error, 'OpenAI');
    }
  }

  async *executeStream(request: LLMRequest): AsyncGenerator<LLMStreamChunk> {
    try {
      const baseUrl = request.customEndpoint || this.defaultBaseUrl;

      const modelPricing = await this.getModelPricing(LLMProvider.OPENAI, request.model);
      const isReasoningModel = (modelPricing?.creditsPerMillionReasoningTokens ?? 0) > 0;

      const requestBody: any = {
        model: request.model,
        messages: request.messages,
        stream: true,
        stream_options: { include_usage: true },
      };

      if (request.temperature !== undefined) {
        requestBody.temperature = request.temperature;
      }

      if (!isReasoningModel) {
        if (request.maxTokens !== undefined) {
          requestBody.max_tokens = request.maxTokens;
        }
        if (request.topP !== undefined) {
          requestBody.top_p = request.topP;
        }
        if (request.presencePenalty !== undefined) {
          requestBody.presence_penalty = request.presencePenalty;
        }
        if (request.frequencyPenalty !== undefined) {
          requestBody.frequency_penalty = request.frequencyPenalty;
        }
        if (request.responseFormat) {
          requestBody.response_format = { type: request.responseFormat };
        }
      } else {
        if (request.maxTokens !== undefined) {
          requestBody.max_completion_tokens = request.maxTokens;
        }
      }

      this.logger.debug(`Streaming OpenAI request: model=${request.model}`);

      const response = await axios.post(`${baseUrl}/chat/completions`, requestBody, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${request.apiKey}`,
        },
        responseType: 'stream',
        timeout: 180000,
      });

      yield { type: 'start' };

      let buffer = '';

      for await (const chunk of response.data) {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;
          if (!line.startsWith('data: ')) continue;

          try {
            const data = JSON.parse(line.substring(6));
            const delta = data.choices?.[0]?.delta;

            if (delta?.content) {
              yield { type: 'token', content: delta.content };
            }

            if (data.choices?.[0]?.finish_reason) {
              const usage = data.usage;
              if (usage) {
                yield {
                  type: 'done',
                  finishReason: data.choices[0].finish_reason,
                  usage: {
                    promptTokens: usage.prompt_tokens,
                    completionTokens: usage.completion_tokens,
                    totalTokens: usage.total_tokens,
                    reasoningTokens: usage.completion_tokens_details?.reasoning_tokens,
                    cachedTokens: usage.prompt_tokens_details?.cached_tokens,
                  },
                };
              } else {
                yield {
                  type: 'done',
                  finishReason: data.choices[0].finish_reason,
                };
              }
            }
          } catch {
            this.logger.warn(`Failed to parse SSE line: ${line}`);
          }
        }
      }

      this.logger.log(`âœ… OpenAI stream completed`);
    } catch (error) {
      this.logger.error(
        `âŒ OpenAI stream failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      yield {
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown streaming error',
      };
    }
  }

  async testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean> {
    try {
      const baseUrl = customEndpoint || this.defaultBaseUrl;
      await axios.get(`${baseUrl}/models`, {
        headers: { Authorization: `Bearer ${apiKey}` },
        timeout: 10000,
      });
      this.logger.log('âœ… OpenAI API key validation successful');
      return true;
    } catch {
      this.logger.warn('OpenAI API key validation failed');
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    const dbModels = await this.getModelsFromDb(LLMProvider.OPENAI);
    if (dbModels.length > 0) {
      this.logger.debug(`Loaded ${dbModels.length} OpenAI models from database`);
      return dbModels;
    }

    const fallbackModels = [
      'gpt-5',
      'gpt-5-mini',
      'gpt-5-nano',
      'gpt-5-pro',
      'gpt-4.1',
      'gpt-4.1-mini',
      'gpt-4.1-nano',
      'o3',
      'o3-pro',
      'o4-mini',
      'gpt-4o',
      'gpt-4o-mini',
    ];

    this.logger.debug(`Using ${fallbackModels.length} fallback OpenAI models`);
    return fallbackModels;
  }
}

```

### `apps\backend\src\v1\execution\providers\provider.factory.ts`

```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../../prisma/prisma.service';
import { LLMProvider, ProviderAPIKey } from '@actopod/schema';
import { OpenAIProvider } from './openai.provider';
import { AnthropicProvider } from './anthropic.provider';
import { GeminiProvider } from './gemini.provider';
import * as crypto from 'crypto';
import { ILLMProvider } from '../types/llm-provider.types';

/**
 * PRODUCTION-GRADE Provider Factory with:
 * - AES-256-GCM encryption for API keys
 * - Backward compatibility for old 16-byte IV format
 * - New 12-byte IV format (GCM standard)
 * - BYOK (Bring Your Own Key) support
 * - Usage tracking with fallback
 * - Circuit breaker pattern
 * - Comprehensive error handling
 */
@Injectable()
export class ProviderFactory implements OnModuleInit {
  private readonly logger = new Logger(ProviderFactory.name);
  private readonly encryptionKey: Buffer;
  private readonly encryptionAlgorithm = 'aes-256-gcm';
  private readonly NEW_IV_LENGTH = 12; // 96-bit IV for GCM (recommended)
  private readonly OLD_IV_LENGTH = 16; // 128-bit IV (legacy)
  private readonly AUTH_TAG_LENGTH = 16; // 128-bit auth tag

  // Circuit breaker state
  private readonly circuitBreaker = new Map<string, { failures: number; lastFailure: number }>();
  private readonly CIRCUIT_BREAKER_THRESHOLD = 5; // Failures before opening circuit
  private readonly CIRCUIT_BREAKER_TIMEOUT = 60000; // 1 minute cooldown

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
  ) {
    this.encryptionKey = this.initializeEncryption();
  }

  async onModuleInit() {
    await this.runHealthCheck();
  }

  /**
   * Initialize encryption with comprehensive validation
   */
  private initializeEncryption(): Buffer {
    try {
      const key = this.configService.get<string>('API_KEY_ENCRYPTION_SECRET');

      if (!key) {
        const errorMsg =
          'CRITICAL: API_KEY_ENCRYPTION_SECRET environment variable is not set. ' +
          "Generate one using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"";
        this.logger.error(errorMsg);
        throw new Error(errorMsg);
      }

      // Validate key format
      if (!/^[0-9a-fA-F]{64}$/.test(key)) {
        throw new Error(
          'API_KEY_ENCRYPTION_SECRET must be a 64-character hexadecimal string (32 bytes). ' +
            "Generate using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"",
        );
      }

      const keyBuffer = Buffer.from(key, 'hex');

      if (keyBuffer.length !== 32) {
        throw new Error(
          `API_KEY_ENCRYPTION_SECRET must be exactly 32 bytes (64 hex characters). Current: ${keyBuffer.length} bytes`,
        );
      }

      this.logger.log('âœ… Encryption key validated successfully');
      return keyBuffer;
    } catch (error) {
      this.logger.error('Failed to initialize encryption:', error);
      throw error;
    }
  }

  /**
   * Get provider instance with validation and caching
   */
  getProvider(provider: LLMProvider): ILLMProvider {
    try {
      if (!provider || typeof provider !== 'string') {
        throw new Error('Invalid provider: Provider must be a non-empty string');
      }

      switch (provider) {
        case LLMProvider.OPENAI:
          return new OpenAIProvider(this.prisma);
        case LLMProvider.ANTHROPIC:
          return new AnthropicProvider(this.prisma);
        case LLMProvider.GOOGLE_GEMINI:
          return new GeminiProvider(this.prisma);
        default:
          throw new Error(
            `Unsupported provider: ${provider}. Supported providers: ${Object.values(LLMProvider).join(', ')}`,
          );
      }
    } catch (error) {
      this.logger.error(`Failed to get provider instance for ${provider}:`, error);
      throw error;
    }
  }

  /**
   * Get and decrypt workspace API key with circuit breaker
   */
  async getWorkspaceApiKey(
    workspaceId: string,
    provider: LLMProvider,
  ): Promise<{ apiKey: string; keyId: string; customEndpoint?: string } | null> {
    try {
      // Input validation
      if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.trim().length === 0) {
        throw new Error('Invalid workspaceId: Must be a non-empty string');
      }

      if (!provider || typeof provider !== 'string') {
        throw new Error('Invalid provider: Must be a valid LLMProvider enum value');
      }

      // Check circuit breaker
      const circuitKey = `${workspaceId}:${provider}`;
      if (this.isCircuitOpen(circuitKey)) {
        throw new Error(
          `Circuit breaker open for ${provider}. Too many recent failures. Please try again later.`,
        );
      }

      const apiKeyRecord = await this.prisma.providerAPIKey.findFirst({
        where: {
          workspaceId,
          provider,
          isActive: true,
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      if (!apiKeyRecord) {
        this.logger.debug(
          `No active API key found for workspace ${workspaceId} and provider ${provider}`,
        );
        return null;
      }

      // Validate key record
      if (!apiKeyRecord.keyHash || typeof apiKeyRecord.keyHash !== 'string') {
        this.logger.error(
          `Invalid keyHash for API key ${apiKeyRecord.id}: keyHash is missing or invalid`,
        );
        throw new Error('Stored API key data is corrupted');
      }

      // Decrypt API key with backward compatibility
      const decryptedKey = this.decryptApiKey(apiKeyRecord.keyHash);

      if (!decryptedKey || decryptedKey.length === 0) {
        throw new Error('Decryption produced empty API key');
      }

      // Reset circuit breaker on success
      this.resetCircuitBreaker(circuitKey);

      this.logger.debug(
        `Successfully retrieved and decrypted API key ${apiKeyRecord.id} for workspace ${workspaceId}`,
      );

      return {
        apiKey: decryptedKey,
        keyId: apiKeyRecord.id,
        customEndpoint: (apiKeyRecord as any).customEndpoint || undefined,
      };
    } catch (error) {
      // Record failure in circuit breaker
      const circuitKey = `${workspaceId}:${provider}`;
      this.recordFailure(circuitKey);

      this.logger.error(
        `Failed to get workspace API key for ${workspaceId}/${provider}:`,
        error instanceof Error ? error.message : error,
      );
      throw new Error(
        `Failed to retrieve API key: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Circuit breaker: Check if circuit is open
   */
  private isCircuitOpen(key: string): boolean {
    const state = this.circuitBreaker.get(key);
    if (!state) return false;

    const now = Date.now();
    const timeSinceLastFailure = now - state.lastFailure;

    // Reset if cooldown period has passed
    if (timeSinceLastFailure > this.CIRCUIT_BREAKER_TIMEOUT) {
      this.circuitBreaker.delete(key);
      return false;
    }

    return state.failures >= this.CIRCUIT_BREAKER_THRESHOLD;
  }

  /**
   * Circuit breaker: Record failure
   */
  private recordFailure(key: string): void {
    const state = this.circuitBreaker.get(key) || { failures: 0, lastFailure: 0 };
    state.failures += 1;
    state.lastFailure = Date.now();
    this.circuitBreaker.set(key, state);

    if (state.failures >= this.CIRCUIT_BREAKER_THRESHOLD) {
      this.logger.warn(`Circuit breaker opened for ${key} after ${state.failures} failures`);
    }
  }

  /**
   * Circuit breaker: Reset on success
   */
  private resetCircuitBreaker(key: string): void {
    this.circuitBreaker.delete(key);
  }

  /**
   * Encrypt API key using AES-256-GCM with NEW 12-byte IV format
   */
  encryptApiKey(plaintext: string): string {
    try {
      // Input validation
      if (!plaintext || typeof plaintext !== 'string') {
        throw new Error('Invalid plaintext: Must be a non-empty string');
      }

      if (plaintext.trim().length === 0) {
        throw new Error('Cannot encrypt empty API key');
      }

      // Generate cryptographically secure 12-byte IV (GCM standard)
      const iv = crypto.randomBytes(this.NEW_IV_LENGTH);

      // Create cipher
      const cipher = crypto.createCipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);

      // Encrypt
      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      // Get authentication tag
      const authTag = cipher.getAuthTag();

      // Validate auth tag length
      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(
          `Invalid auth tag length: expected ${this.AUTH_TAG_LENGTH}, got ${authTag.length}`,
        );
      }

      // Format: iv:authTag:encrypted
      const result = `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;

      this.logger.debug('API key encrypted successfully with 12-byte IV');
      return result;
    } catch (error) {
      this.logger.error('Failed to encrypt API key:', error);
      throw new Error(
        `Encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Decrypt API key with BACKWARD COMPATIBILITY for both 12-byte and 16-byte IV formats
   */
  private decryptApiKey(encryptedData: string): string {
    try {
      // Input validation
      if (!encryptedData || typeof encryptedData !== 'string') {
        throw new Error('Invalid encrypted data: Must be a non-empty string');
      }

      // Parse encrypted data
      const parts = encryptedData.split(':');

      if (parts.length !== 3) {
        throw new Error(
          `Invalid encrypted data format: Expected 3 parts (iv:authTag:encrypted), got ${parts.length}`,
        );
      }

      const [ivHex, authTagHex, encrypted] = parts;

      // Validate parts
      if (!ivHex || !authTagHex || !encrypted) {
        throw new Error('One or more encrypted data components are empty');
      }

      // Validate hex format
      if (
        !/^[0-9a-fA-F]+$/.test(ivHex) ||
        !/^[0-9a-fA-F]+$/.test(authTagHex) ||
        !/^[0-9a-fA-F]+$/.test(encrypted)
      ) {
        throw new Error('Encrypted data contains invalid hexadecimal characters');
      }

      // Convert from hex
      const iv = Buffer.from(ivHex, 'hex');
      const authTag = Buffer.from(authTagHex, 'hex');

      // Determine IV format (backward compatibility)
      const ivLength = iv.length;

      if (ivLength !== this.NEW_IV_LENGTH && ivLength !== this.OLD_IV_LENGTH) {
        throw new Error(
          `Invalid IV length: expected ${this.NEW_IV_LENGTH} bytes (new format) or ${this.OLD_IV_LENGTH} bytes (legacy format), got ${ivLength} bytes`,
        );
      }

      // Log if using legacy format
      if (ivLength === this.OLD_IV_LENGTH) {
        this.logger.warn(
          `Decrypting API key with legacy 16-byte IV format. Consider re-encrypting with the new 12-byte format.`,
        );
      }

      // Validate auth tag length
      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(
          `Invalid auth tag length: expected ${this.AUTH_TAG_LENGTH} bytes, got ${authTag.length}`,
        );
      }

      // Create decipher
      const decipher = crypto.createDecipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);

      decipher.setAuthTag(authTag);

      // Decrypt
      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      if (!decrypted || decrypted.length === 0) {
        throw new Error('Decryption produced empty result');
      }

      this.logger.debug(`API key decrypted successfully (IV length: ${ivLength} bytes)`);
      return decrypted;
    } catch (error) {
      this.logger.error(
        'Failed to decrypt API key:',
        error instanceof Error ? error.message : error,
      );

      // Provide helpful error messages
      if (error instanceof Error) {
        if (error.message.includes('Unsupported state') || error.message.includes('auth')) {
          throw new Error('Authentication failed: API key may be corrupted or tampered with');
        }
        if (error.message.includes('bad decrypt')) {
          throw new Error('Decryption failed: Incorrect encryption key or corrupted data');
        }
      }

      throw new Error(
        `Decryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Track API key usage with comprehensive error handling and fallbacks
   */
  async trackApiKeyUsage(
    keyId: string,
    tokens: { input: number; output: number; reasoning?: number },
    cost: number,
    success: boolean,
  ): Promise<void> {
    try {
      // Input validation
      if (!keyId || typeof keyId !== 'string' || keyId.trim().length === 0) {
        throw new Error('Invalid keyId: Must be a non-empty string');
      }

      // Validate tokens
      if (typeof tokens.input !== 'number' || tokens.input < 0) {
        throw new Error(`Invalid input tokens: ${tokens.input}`);
      }
      if (typeof tokens.output !== 'number' || tokens.output < 0) {
        throw new Error(`Invalid output tokens: ${tokens.output}`);
      }
      if (
        tokens.reasoning !== undefined &&
        (typeof tokens.reasoning !== 'number' || tokens.reasoning < 0)
      ) {
        throw new Error(`Invalid reasoning tokens: ${tokens.reasoning}`);
      }

      // Validate cost
      if (typeof cost !== 'number' || cost < 0) {
        throw new Error(`Invalid cost: ${cost}`);
      }

      const totalTokens = tokens.input + tokens.output + (tokens.reasoning || 0);

      // Update API key stats with transaction
      await this.prisma.$transaction(
        async (tx) => {
          // Update API key
          await tx.providerAPIKey.update({
            where: { id: keyId },
            data: {
              lastUsedAt: new Date(),
              usageCount: { increment: 1 },
              totalTokens: { increment: BigInt(totalTokens) },
              totalCost: { increment: cost },
              ...(success ? {} : { lastErrorAt: new Date() }),
            },
          });

          // Get workspace ID
          const apiKey = await tx.providerAPIKey.findUnique({
            where: { id: keyId },
            select: { workspaceId: true },
          });

          if (!apiKey) {
            throw new Error(`API key ${keyId} not found`);
          }

          // Update daily metrics
          const today = new Date();
          today.setHours(0, 0, 0, 0);

          await tx.usageMetric.upsert({
            where: {
              keyId_date: {
                keyId,
                date: today,
              },
            },
            create: {
              keyId,
              workspaceId: apiKey.workspaceId,
              date: today,
              requestCount: 1,
              successCount: success ? 1 : 0,
              errorCount: success ? 0 : 1,
              promptTokens: BigInt(tokens.input),
              completionTokens: BigInt(tokens.output + (tokens.reasoning || 0)),
              totalTokens: BigInt(totalTokens),
              estimatedCost: cost,
            },
            update: {
              requestCount: { increment: 1 },
              successCount: success ? { increment: 1 } : undefined,
              errorCount: success ? undefined : { increment: 1 },
              promptTokens: { increment: BigInt(tokens.input) },
              completionTokens: { increment: BigInt(tokens.output + (tokens.reasoning || 0)) },
              totalTokens: { increment: BigInt(totalTokens) },
              estimatedCost: { increment: cost },
            },
          });
        },
        {
          timeout: 10000, // 10 second timeout
        },
      );

      this.logger.debug(
        `âœ… Usage tracked for key ${keyId}: ${totalTokens} tokens, $${cost.toFixed(6)}, success=${success}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to track usage for key ${keyId}:`,
        error instanceof Error ? error.message : error,
      );

      // Don't throw - tracking failure shouldn't break execution
      this.logger.warn('Usage tracking failure will not affect execution flow');
    }
  }

  /**
   * Get all active API keys for workspace with error handling
   */
  async getWorkspaceApiKeys(workspaceId: string): Promise<ProviderAPIKey[]> {
    try {
      // Input validation
      if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.trim().length === 0) {
        throw new Error('Invalid workspaceId: Must be a non-empty string');
      }

      const keys = await this.prisma.providerAPIKey.findMany({
        where: {
          workspaceId,
          isActive: true,
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      this.logger.debug(`Retrieved ${keys.length} active API keys for workspace ${workspaceId}`);
      return keys;
    } catch (error) {
      this.logger.error(
        `Failed to get workspace API keys for ${workspaceId}:`,
        error instanceof Error ? error.message : error,
      );
      throw new Error(
        `Failed to retrieve API keys: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Health check for encryption system (run on startup)
   */
  private async runHealthCheck(): Promise<void> {
    try {
      // Test encryption/decryption
      const testData = 'test-api-key-' + Date.now();
      const encrypted = this.encryptApiKey(testData);
      const decrypted = this.decryptApiKey(encrypted);

      if (decrypted !== testData) {
        throw new Error('Encryption round-trip test failed');
      }

      // Test database connection
      await this.prisma.$queryRaw`SELECT 1`;

      this.logger.log('âœ… Provider factory health check passed');
    } catch (error) {
      this.logger.error('âŒ Provider factory health check failed:', error);
      throw error;
    }
  }

  /**
   * Health check endpoint for monitoring
   */
  async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; details: string }> {
    try {
      await this.runHealthCheck();
      return {
        status: 'healthy',
        details: 'Encryption and database connectivity verified',
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}

```

### `apps\backend\src\v1\execution\providers\provider.module.ts`

```typescript
// execution/providers/provider.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { ProviderFactory } from './provider.factory';
import { OpenAIProvider } from './openai.provider';
import { AnthropicProvider } from './anthropic.provider';
import { GeminiProvider } from './gemini.provider';
import { PrismaModule } from '../../../prisma/prisma.module';

@Module({
  imports: [PrismaModule, ConfigModule],
  providers: [ProviderFactory, OpenAIProvider, AnthropicProvider, GeminiProvider],
  exports: [ProviderFactory],
})
export class ProviderModule {}

```

### `apps\backend\src\v1\execution\types\llm-provider.types.ts`

```typescript
// types/llm-provider.types.ts

import { LLMProvider } from '@actopod/schema';

export interface LLMRequest {
  provider: LLMProvider;
  model: string;
  messages: Array<{ role: string; content: string | any }>;
  apiKey: string;
  customEndpoint?: string;
  apiKeyId?: string;
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;
  thinkingBudget?: number;
  responseFormat?: 'text' | 'json_object' | 'json';
  stream?: boolean; // NEW: Enable streaming
}

export interface LLMResponse {
  id: string;
  model: string;
  provider: LLMProvider;
  content: string;
  finishReason: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    reasoningTokens?: number;
    cachedTokens?: number;
  };
  rawResponse: any;
  timestamp: Date;
}

// NEW: Streaming chunk interface
export interface LLMStreamChunk {
  type: 'start' | 'token' | 'done' | 'error';
  content?: string;
  usage?: LLMResponse['usage'];
  finishReason?: string;
  error?: string;
}

export interface ILLMProvider {
  execute(request: LLMRequest): Promise<LLMResponse>;
  executeStream?(request: LLMRequest): AsyncGenerator<LLMStreamChunk>; // NEW: Stream method
  testApiKey(apiKey: string, customEndpoint?: string): Promise<boolean>;
  getAvailableModels(): Promise<string[]>;
}

```

### `apps\backend\src\v1\flow\dto\add-collaborator.dto.ts`

```typescript
import { IsString, IsEmail, IsEnum, IsOptional } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { FlowAccessLevel } from '@actopod/schema';

export class AddCollaboratorDto {
  @ApiProperty({ example: 'user@example.com' })
  @IsEmail()
  email!: string;

  @ApiPropertyOptional({ enum: FlowAccessLevel, default: FlowAccessLevel.EDITOR })
  @IsOptional()
  @IsEnum(FlowAccessLevel)
  accessLevel?: FlowAccessLevel;

  @ApiPropertyOptional({ example: 'Can view and edit this workflow' })
  @IsOptional()
  @IsString()
  message?: string;
}

```

### `apps\backend\src\v1\flow\dto\create-flow.dto.ts`

```typescript
import { IsString, IsOptional, IsEnum, MaxLength, MinLength } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility } from '@actopod/schema';

export class CreateFlowDto {
  @ApiProperty({ example: 'My AI Workflow' })
  @IsString()
  @MinLength(1)
  @MaxLength(255)
  name!: string;

  @ApiPropertyOptional({ example: 'A multi-LLM workflow for content generation' })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  description?: string;

  @ApiPropertyOptional({ description: 'Space ID where this flow belongs' })
  @IsOptional()
  @IsString()
  spaceId?: string;

  @ApiPropertyOptional({ enum: FlowVisibility, default: 'PRIVATE' })
  @IsOptional()
  @IsEnum(FlowVisibility)
  visibility?: FlowVisibility = FlowVisibility.PRIVATE;
}

```

### `apps\backend\src\v1\flow\dto\flow-query.dto.ts`

```typescript
import { IsOptional, IsEnum, IsString, IsInt, Min, Max } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility } from '@actopod/schema';

export class FlowQueryDto {
  @ApiPropertyOptional({ example: 1, minimum: 1, default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page: number = 1;

  @ApiPropertyOptional({ example: 20, minimum: 1, maximum: 100, default: 20 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit: number = 20;

  @ApiPropertyOptional({ example: 'My Flow' })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ enum: FlowVisibility })
  @IsOptional()
  @IsEnum(FlowVisibility)
  visibility?: FlowVisibility;

  @ApiPropertyOptional({ description: 'Space ID to filter by' })
  @IsOptional()
  @IsString()
  spaceId?: string;

  get skip(): number {
    return (this.page - 1) * this.limit;
  }
}

```

### `apps\backend\src\v1\flow\dto\flow-response.dto.ts`

```typescript
import { Expose, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility, FlowAccessLevel, FlowActivityAction } from '@actopod/schema';

/**
 * Flow Response DTO
 * Represents a complete flow with metadata
 */
export class FlowResponseDto {
  @ApiProperty({
    description: 'Unique flow identifier',
    example: 'flow_clx123abc456',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'Workspace ID this flow belongs to',
    example: 'ws_clx789def012',
  })
  @Expose()
  workspaceId!: string;

  @ApiPropertyOptional({
    description: 'Space ID (folder) this flow is organized under',
    example: 'space_clx345ghi678',
    nullable: true,
  })
  @Expose()
  spaceId!: string | null;

  @ApiProperty({
    description: 'Flow name',
    example: 'Customer Support Automation',
    maxLength: 255,
  })
  @Expose()
  name!: string;

  @ApiPropertyOptional({
    description: 'Flow description',
    example: 'Automates customer support responses using GPT-4',
    maxLength: 500,
    nullable: true,
  })
  @Expose()
  description!: string | null;

  @ApiProperty({
    description: 'Flow visibility level',
    enum: FlowVisibility,
    example: FlowVisibility.PRIVATE,
    default: FlowVisibility.PRIVATE,
  })
  @Expose()
  visibility!: FlowVisibility;

  @ApiProperty({
    description: 'User ID of the flow creator',
    example: 'user_clx901jkl234',
  })
  @Expose()
  createdBy!: string;

  @ApiProperty({
    description: 'Flow creation timestamp',
    example: '2025-10-25T00:00:00.000Z',
    type: Date,
  })
  @Expose()
  createdAt!: Date;

  @ApiProperty({
    description: 'Last update timestamp',
    example: '2025-10-25T00:30:00.000Z',
    type: Date,
  })
  @Expose()
  updatedAt!: Date;

  @ApiProperty({
    description: 'Number of pods (nodes) in this flow',
    example: 15,
    minimum: 0,
  })
  @Expose()
  podCount!: number;

  @ApiProperty({
    description: 'Number of collaborators with access to this flow',
    example: 3,
    minimum: 0,
  })
  @Expose()
  collaboratorCount!: number;

  @ApiPropertyOptional({
    description: 'S3 key for flow thumbnail image',
    example: 'thumbnails/flow_clx123abc456.png',
    nullable: true,
  })
  @Expose()
  thumbnailS3Key!: string | null;

  @ApiPropertyOptional({
    description: 'Timestamp when thumbnail was last generated',
    example: '2025-10-25T00:15:00.000Z',
    type: Date,
    nullable: true,
  })
  @Expose()
  thumbnailGeneratedAt!: Date | null;
}

/**
 * Pagination Metadata DTO
 */
export class FlowPaginationDto {
  @ApiProperty({
    description: 'Total number of items across all pages',
    example: 47,
    minimum: 0,
  })
  @Expose()
  totalItems!: number;

  @ApiProperty({
    description: 'Total number of pages',
    example: 3,
    minimum: 0,
  })
  @Expose()
  totalPages!: number;

  @ApiProperty({
    description: 'Current page number (1-indexed)',
    example: 1,
    minimum: 1,
  })
  @Expose()
  currentPage!: number;

  @ApiProperty({
    description: 'Number of items on current page',
    example: 20,
    minimum: 0,
  })
  @Expose()
  pageSize!: number;
}

/**
 * Paginated Flow Response DTO
 */
export class FlowPaginatedResponseDto {
  @ApiProperty({
    description: 'Array of flow objects',
    type: [FlowResponseDto],
    isArray: true,
  })
  @Expose()
  @Type(() => FlowResponseDto)
  data!: FlowResponseDto[];

  @ApiProperty({
    description: 'Pagination metadata',
    type: FlowPaginationDto,
  })
  @Expose()
  @Type(() => FlowPaginationDto)
  pagination!: FlowPaginationDto;
}

/**
 * User Info DTO (Embedded in Collaborator Response)
 */
export class UserInfoDto {
  @ApiProperty({
    description: 'User ID',
    example: 'user_clx901jkl234',
  })
  id!: string;

  @ApiPropertyOptional({
    description: 'User display name',
    example: 'John Doe',
    nullable: true,
  })
  name!: string | null;

  @ApiProperty({
    description: 'User email address',
    example: 'john.doe@example.com',
  })
  email!: string;

  @ApiPropertyOptional({
    description: 'User profile image URL',
    example: 'https://example.com/avatar.jpg',
    nullable: true,
  })
  image!: string | null;
}

/**
 * Flow Collaborator Response DTO
 */
export class CollaboratorResponseDto {
  @ApiProperty({
    description: 'Collaborator record ID',
    example: 'collab_clx567mno890',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'User ID of the collaborator',
    example: 'user_clx901jkl234',
  })
  @Expose()
  userId!: string;

  @ApiProperty({
    description: 'Flow ID this collaboration is for',
    example: 'flow_clx123abc456',
  })
  @Expose()
  flowId!: string;

  @ApiProperty({
    description: 'Access level assigned to collaborator',
    enum: FlowAccessLevel,
    example: FlowAccessLevel.EDITOR,
  })
  @Expose()
  accessLevel!: FlowAccessLevel;

  @ApiProperty({
    description: 'Can edit flow content (pods, edges)',
    example: true,
    default: true,
  })
  @Expose()
  canEdit!: boolean;

  @ApiProperty({
    description: 'Can execute pods (run LLM queries)',
    example: true,
    default: true,
  })
  @Expose()
  canExecute!: boolean;

  @ApiProperty({
    description: 'Can delete pods and edges',
    example: false,
    default: false,
  })
  @Expose()
  canDelete!: boolean;

  @ApiProperty({
    description: 'Can share flow with others',
    example: false,
    default: false,
  })
  @Expose()
  canShare!: boolean;

  @ApiProperty({
    description: 'Can invite new collaborators',
    example: false,
    default: false,
  })
  @Expose()
  canInvite!: boolean;

  @ApiProperty({
    description: 'Timestamp when collaborator was invited',
    example: '2025-10-24T12:00:00.000Z',
    type: Date,
  })
  @Expose()
  invitedAt!: Date;

  @ApiPropertyOptional({
    description: 'Timestamp of last view/access',
    example: '2025-10-24T18:30:00.000Z',
    type: Date,
    nullable: true,
  })
  @Expose()
  lastViewedAt!: Date | null;

  @ApiProperty({
    description: 'Collaborator user information',
    type: UserInfoDto,
  })
  @Expose()
  @Type(() => UserInfoDto)
  user!: UserInfoDto;
}

/**
 * User Info DTO (for Activity Log)
 */
export class ActivityUserInfoDto {
  @ApiProperty({
    description: 'User ID',
    example: 'user_clx901jkl234',
  })
  id!: string;

  @ApiPropertyOptional({
    description: 'User display name',
    example: 'John Doe',
    nullable: true,
  })
  name!: string | null;

  @ApiProperty({
    description: 'User email address',
    example: 'john.doe@example.com',
  })
  email!: string;
}

/**
 * Flow Activity Log Response DTO
 */
export class ActivityLogResponseDto {
  @ApiProperty({
    description: 'Activity log entry ID',
    example: 'activity_clx789pqr012',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'Flow ID this activity belongs to',
    example: 'flow_clx123abc456',
  })
  @Expose()
  flowId!: string;

  @ApiPropertyOptional({
    description: 'User ID who performed the action',
    example: 'user_clx901jkl234',
    nullable: true,
  })
  @Expose()
  userId!: string | null;

  @ApiProperty({
    description: 'Type of action performed',
    enum: FlowActivityAction,
    example: FlowActivityAction.FLOW_UPDATED,
  })
  @Expose()
  action!: FlowActivityAction;

  @ApiPropertyOptional({
    description: 'Type of entity affected (pod, edge, collaborator, etc.)',
    example: 'pod',
    nullable: true,
  })
  @Expose()
  entityType!: string | null;

  @ApiPropertyOptional({
    description: 'ID of the affected entity',
    example: 'pod_clx456stu789',
    nullable: true,
  })
  @Expose()
  entityId!: string | null;

  @ApiPropertyOptional({
    description: 'JSON object containing change details',
    example: { name: 'Updated Flow Name', visibility: 'WORKSPACE' },
    nullable: true,
  })
  @Expose()
  changeData!: any;

  @ApiProperty({
    description: 'Timestamp when action was performed',
    example: '2025-10-24T15:45:00.000Z',
    type: Date,
  })
  @Expose()
  createdAt!: Date;

  @ApiPropertyOptional({
    description: 'User who performed the action (null for system actions)',
    type: ActivityUserInfoDto,
    nullable: true,
  })
  @Expose()
  @Type(() => ActivityUserInfoDto)
  user!: ActivityUserInfoDto | null;
}

```

### `apps\backend\src\v1\flow\dto\update-collaborator.dto.ts`

```typescript
import { IsEnum, IsBoolean, IsOptional } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { FlowAccessLevel } from '@actopod/schema';

export class UpdateCollaboratorDto {
  @ApiPropertyOptional({ enum: FlowAccessLevel })
  @IsOptional()
  @IsEnum(FlowAccessLevel)
  accessLevel?: FlowAccessLevel;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canEdit?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canExecute?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canDelete?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canShare?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  canInvite?: boolean;
}

```

### `apps\backend\src\v1\flow\dto\update-flow.dto.ts`

```typescript
import { IsString, IsOptional, IsEnum, MaxLength, MinLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { FlowVisibility } from '@actopod/schema';

export class UpdateFlowDto {
  @ApiPropertyOptional({ example: 'My Updated Workflow' })
  @IsOptional()
  @IsString()
  @MinLength(1)
  @MaxLength(255)
  name?: string;

  @ApiPropertyOptional({ example: 'Updated description' })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  description?: string;

  @ApiPropertyOptional({ description: 'Space ID' })
  @IsOptional()
  @IsString()
  spaceId?: string;

  @ApiPropertyOptional({ enum: FlowVisibility })
  @IsOptional()
  @IsEnum(FlowVisibility)
  visibility?: FlowVisibility;
}

```

### `apps\backend\src\v1\flow\flow.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
  ValidationPipe,
  ParseIntPipe,
  DefaultValuePipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
  ApiNotFoundResponse,
  ApiForbiddenResponse,
} from '@nestjs/swagger';
import { V1FlowService } from './flow.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { CreateFlowDto } from './dto/create-flow.dto';
import { UpdateFlowDto } from './dto/update-flow.dto';
import { FlowQueryDto } from './dto/flow-query.dto';
import { AddCollaboratorDto } from './dto/add-collaborator.dto';
import { UpdateCollaboratorDto } from './dto/update-collaborator.dto';
import {
  FlowResponseDto,
  FlowPaginatedResponseDto,
  CollaboratorResponseDto,
  ActivityLogResponseDto,
} from './dto/flow-response.dto';

@ApiTags('Flows')
@ApiBearerAuth('JWT')
@Controller({
  path: 'workspaces/:workspaceId/flows',
  version: '1',
})
@ApiUnauthorizedResponse({ description: 'Unauthorized' })
export class V1FlowController {
  constructor(private readonly flowService: V1FlowService) {}

  // ==================== FLOW CRUD ====================

  @Get()
  @ApiOperation({
    summary: 'Get all flows in workspace',
    description:
      'Returns paginated list of flows user has access to (owned, shared, or workspace-visible)',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Flows fetched successfully',
    type: FlowPaginatedResponseDto,
  })
  async getFlows(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Query(ValidationPipe) query: FlowQueryDto,
  ): Promise<FlowPaginatedResponseDto> {
    return this.flowService.getWorkspaceFlows(workspaceId, userId, query);
  }

  @Get(':id')
  @ApiOperation({
    summary: 'Get flow by ID',
    description: 'Returns detailed flow information including pod count and collaborators',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Flow fetched successfully',
    type: FlowResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Flow not found' })
  @ApiForbiddenResponse({ description: 'Access denied' })
  async getFlow(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<FlowResponseDto> {
    return this.flowService.getFlowById(flowId, workspaceId, userId);
  }

  @Post()
  @ApiOperation({
    summary: 'Create a new flow',
    description: 'Creates a new workflow canvas in the workspace',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiResponse({
    status: 201,
    description: 'Flow created successfully',
    type: FlowResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Invalid input or space not found' })
  async createFlow(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: CreateFlowDto,
  ): Promise<FlowResponseDto> {
    return this.flowService.createFlow(workspaceId, userId, dto);
  }

  @Patch(':id')
  @ApiOperation({
    summary: 'Update a flow',
    description: 'Updates flow metadata (name, description, space, visibility)',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Flow updated successfully',
    type: FlowResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Flow not found' })
  @ApiForbiddenResponse({ description: 'Edit permission required' })
  async updateFlow(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: UpdateFlowDto,
  ): Promise<FlowResponseDto> {
    return this.flowService.updateFlow(flowId, workspaceId, userId, dto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete a flow',
    description: 'Permanently deletes a flow and all associated data (pods, edges, activity logs)',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({ status: 204, description: 'Flow deleted successfully' })
  @ApiNotFoundResponse({ description: 'Flow not found' })
  @ApiForbiddenResponse({ description: 'Only owner can delete flow' })
  async deleteFlow(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.flowService.deleteFlow(flowId, workspaceId, userId);
  }

  // ==================== COLLABORATORS ====================

  @Get(':id/collaborators')
  @ApiOperation({
    summary: 'Get flow collaborators',
    description: 'Returns list of all users with access to this flow',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Collaborators fetched successfully',
    type: [CollaboratorResponseDto],
  })
  @ApiForbiddenResponse({ description: 'View permission required' })
  async getCollaborators(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<CollaboratorResponseDto[]> {
    return this.flowService.getFlowCollaborators(flowId, workspaceId, userId);
  }

  @Post(':id/collaborators')
  @ApiOperation({
    summary: 'Add collaborator to flow',
    description: 'Invites a user to collaborate on this flow',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 201,
    description: 'Collaborator added successfully',
    type: CollaboratorResponseDto,
  })
  @ApiBadRequestResponse({ description: 'User not found or already collaborator' })
  @ApiForbiddenResponse({ description: 'Invite permission required' })
  async addCollaborator(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: AddCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    return this.flowService.addCollaborator(flowId, workspaceId, userId, dto);
  }

  @Patch(':id/collaborators/:collaboratorId')
  @ApiOperation({
    summary: 'Update collaborator permissions',
    description: 'Changes access level and granular permissions for a collaborator',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiParam({ name: 'collaboratorId', description: 'Collaborator record ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Collaborator permissions updated',
    type: CollaboratorResponseDto,
  })
  @ApiForbiddenResponse({ description: 'Manage permission required' })
  async updateCollaborator(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @Param('collaboratorId') collaboratorId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: UpdateCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    return this.flowService.updateCollaborator(flowId, collaboratorId, workspaceId, userId, dto);
  }

  @Delete(':id/collaborators/:collaboratorId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Remove collaborator from flow',
    description: 'Revokes access for a collaborator',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiParam({ name: 'collaboratorId', description: 'Collaborator record ID', type: String })
  @ApiResponse({ status: 204, description: 'Collaborator removed successfully' })
  @ApiForbiddenResponse({ description: 'Manage permission required' })
  async removeCollaborator(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @Param('collaboratorId') collaboratorId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.flowService.removeCollaborator(flowId, collaboratorId, workspaceId, userId);
  }

  // ==================== ACTIVITY LOG ====================

  @Get(':id/activity')
  @ApiOperation({
    summary: 'Get flow activity log',
    description: 'Returns chronological list of all actions performed on this flow',
  })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID', type: String })
  @ApiParam({ name: 'id', description: 'Flow ID', type: String })
  @ApiResponse({
    status: 200,
    description: 'Activity log fetched successfully',
    type: [ActivityLogResponseDto],
  })
  async getActivity(
    @Param('workspaceId') workspaceId: string,
    @Param('id') flowId: string,
    @GetCurrentUserId() userId: string,
    @Query('limit', new DefaultValuePipe(50), ParseIntPipe) limit: number,
  ): Promise<ActivityLogResponseDto[]> {
    return this.flowService.getFlowActivity(flowId, workspaceId, userId, limit);
  }
}

```

### `apps\backend\src\v1\flow\flow.gateway.ts`

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, UseFilters } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { WsExceptionFilter } from '../../common/filters/ws-exception.filter';

interface FlowSession {
  userId: string;
  socketId: string;
  flowId: string;
  userName?: string;
  userColor?: string;
  joinedAt: Date;
}

/**
 * PRODUCTION-GRADE WebSocket Gateway for Flow Canvas
 * Features:
 * - Real-time collaboration
 * - Pod execution streaming
 * - Presence tracking
 * - Error handling
 * - Rate limiting
 * - Heartbeat monitoring
 */
@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true,
  },
  namespace: 'flows',
  transports: ['websocket', 'polling'],
  pingInterval: 25000, // 25 seconds
  pingTimeout: 60000, // 1 minute
  maxHttpBufferSize: 1e6, // 1MB
  perMessageDeflate: true,
})
@UseFilters(new WsExceptionFilter())
export class V1FlowGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server!: Server;

  private readonly logger = new Logger(V1FlowGateway.name);
  private flowSessions = new Map<string, Map<string, FlowSession>>();

  // Rate limiting: max events per second per client
  private readonly rateLimitMap = new Map<string, { count: number; resetTime: number }>();
  private readonly RATE_LIMIT = 100; // 100 events per second
  private readonly RATE_LIMIT_WINDOW = 1000; // 1 second

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  afterInit(): void {
    this.logger.log('ðŸ”Œ Flow WebSocket Gateway initialized');

    // Cleanup stale sessions every 5 minutes
    setInterval(() => this.cleanupStaleSessions(), 5 * 60 * 1000);
  }

  // ==================== CONNECTION MANAGEMENT ====================

  async handleConnection(client: Socket): Promise<void> {
    try {
      const token =
        client.handshake.auth?.token ||
        client.handshake.headers?.authorization?.replace('Bearer ', '') ||
        client.handshake.query?.token;

      if (!token) {
        this.logger.warn(`âŒ Client ${client.id}: No token provided`);
        client.emit('error', { message: 'Authentication required', code: 'NO_TOKEN' });
        client.disconnect(true);
        return;
      }

      const secret = this.configService.get<string>('JWT_ACCESS_TOKEN_SECRET');

      if (!secret) {
        this.logger.error('JWT_ACCESS_TOKEN_SECRET not configured');
        client.disconnect(true);
        return;
      }

      const payload = await this.jwtService.verifyAsync(token, { secret });
      const userId = payload.userId || payload.sub;

      if (!userId) {
        this.logger.warn(`âŒ Client ${client.id}: Invalid token payload`);
        client.emit('error', { message: 'Invalid token', code: 'INVALID_TOKEN' });
        client.disconnect(true);
        return;
      }

      // Store user data on socket
      client.data.userId = userId;
      client.data.connectedAt = new Date();

      // Send connection confirmation
      client.emit('connected', {
        message: 'Connected to flows',
        userId,
        serverTime: new Date().toISOString(),
      });

      this.logger.log(`âœ… User ${userId} connected (socket: ${client.id})`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Authentication failed';
      this.logger.error(`âŒ Connection failed for ${client.id}: ${errorMessage}`);
      client.emit('error', { message: 'Authentication failed', code: 'AUTH_ERROR' });
      client.disconnect(true);
    }
  }

  handleDisconnect(client: Socket): void {
    const userId = client.data.userId;
    const flowId = client.data.flowId;

    if (flowId && userId) {
      const sessions = this.flowSessions.get(flowId);
      if (sessions) {
        const session = sessions.get(client.id);
        sessions.delete(client.id);

        if (sessions.size === 0) {
          this.flowSessions.delete(flowId);
          this.logger.log(`ðŸ“Š Flow ${flowId} now empty, sessions cleared`);
        }

        // Notify others user left
        this.server.to(`flow:${flowId}`).emit('user:left', {
          userId,
          socketId: client.id,
          userName: session?.userName,
        });

        this.logger.log(`ðŸ”Œ User ${userId} left flow ${flowId}`);
      }
    }

    // Cleanup rate limiting
    this.rateLimitMap.delete(client.id);
  }

  // ==================== FLOW ROOM MANAGEMENT ====================

  @SubscribeMessage('flow:join')
  async handleJoinFlow(
    @MessageBody() data: { flowId: string; userName?: string; userColor?: string },
    @ConnectedSocket() client: Socket,
  ): Promise<void> {
    try {
      if (!data.flowId || typeof data.flowId !== 'string') {
        client.emit('error', { message: 'Invalid flowId', code: 'INVALID_FLOW_ID' });
        return;
      }

      const { flowId, userName, userColor } = data;
      const userId = client.data.userId;

      // Leave previous flow if any
      if (client.data.flowId && client.data.flowId !== flowId) {
        await client.leave(`flow:${client.data.flowId}`);
      }

      // Join new flow room
      await client.join(`flow:${flowId}`);
      client.data.flowId = flowId;

      // Initialize flow sessions map
      if (!this.flowSessions.has(flowId)) {
        this.flowSessions.set(flowId, new Map());
      }

      const session: FlowSession = {
        userId,
        socketId: client.id,
        flowId,
        userName,
        userColor,
        joinedAt: new Date(),
      };

      this.flowSessions.get(flowId)!.set(client.id, session);

      // Notify others user joined
      client.to(`flow:${flowId}`).emit('user:joined', session);

      // Send current users to the new joiner
      const currentUsers = Array.from(this.flowSessions.get(flowId)!.values());
      client.emit('flow:users', currentUsers);

      this.logger.log(
        `ðŸ“Š User ${userId} joined flow ${flowId} (${currentUsers.length} total users)`,
      );
    } catch (error) {
      this.logger.error(`Failed to join flow:`, error);
      client.emit('error', { message: 'Failed to join flow', code: 'JOIN_ERROR' });
    }
  }

  @SubscribeMessage('flow:leave')
  handleLeaveFlow(@ConnectedSocket() client: Socket): void {
    const flowId = client.data.flowId;
    const userId = client.data.userId;

    if (flowId) {
      client.leave(`flow:${flowId}`);

      const sessions = this.flowSessions.get(flowId);
      if (sessions) {
        const session = sessions.get(client.id);
        sessions.delete(client.id);

        if (sessions.size === 0) {
          this.flowSessions.delete(flowId);
        }

        // Use session data when notifying others
        client.to(`flow:${flowId}`).emit('user:left', {
          userId,
          socketId: client.id,
          userName: session?.userName, // Include user name
        });
      } else {
        // Sessions not found, still notify
        client.to(`flow:${flowId}`).emit('user:left', {
          userId,
          socketId: client.id,
        });
      }

      client.data.flowId = null;
      this.logger.log(`ðŸ”Œ User ${userId} explicitly left flow ${flowId}`);
    }
  }

  // ==================== POD OPERATIONS ====================

  @SubscribeMessage('pod:create')
  handlePodCreate(@MessageBody() data: { pod: any }, @ConnectedSocket() client: Socket): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) {
      client.emit('error', { message: 'Not in a flow', code: 'NOT_IN_FLOW' });
      return;
    }

    // Broadcast to all OTHER users in the flow
    client.to(`flow:${flowId}`).emit('pod:created', {
      pod: data.pod,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ“¦ Pod created in flow ${flowId} by user ${client.data.userId}`);
  }

  @SubscribeMessage('pod:update')
  handlePodUpdate(
    @MessageBody() data: { podId: string; updates: any },
    @ConnectedSocket() client: Socket,
  ): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:updated', {
      podId: data.podId,
      updates: data.updates,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ“¦ Pod ${data.podId} updated in flow ${flowId}`);
  }

  @SubscribeMessage('pod:delete')
  handlePodDelete(@MessageBody() data: { podId: string }, @ConnectedSocket() client: Socket): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:deleted', {
      podId: data.podId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ“¦ Pod ${data.podId} deleted in flow ${flowId}`);
  }

  @SubscribeMessage('pod:move')
  handlePodMove(
    @MessageBody() data: { podId: string; position: { x: number; y: number } },
    @ConnectedSocket() client: Socket,
  ): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    // High-frequency event, only broadcast position
    client.to(`flow:${flowId}`).emit('pod:moved', {
      podId: data.podId,
      position: data.position,
      userId: client.data.userId,
    });
  }

  @SubscribeMessage('pod:lock')
  handlePodLock(@MessageBody() data: { podId: string }, @ConnectedSocket() client: Socket): void {
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:locked', {
      podId: data.podId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });
  }

  @SubscribeMessage('pod:unlock')
  handlePodUnlock(@MessageBody() data: { podId: string }, @ConnectedSocket() client: Socket): void {
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('pod:unlocked', {
      podId: data.podId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });
  }

  // ==================== EDGE OPERATIONS ====================

  @SubscribeMessage('edge:create')
  handleEdgeCreate(@MessageBody() data: { edge: any }, @ConnectedSocket() client: Socket): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('edge:created', {
      edge: data.edge,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ”— Edge created in flow ${flowId}`);
  }

  @SubscribeMessage('edge:delete')
  handleEdgeDelete(
    @MessageBody() data: { edgeId: string },
    @ConnectedSocket() client: Socket,
  ): void {
    if (!this.checkRateLimit(client)) return;

    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('edge:deleted', {
      edgeId: data.edgeId,
      userId: client.data.userId,
      timestamp: new Date().toISOString(),
    });

    this.logger.debug(`ðŸ”— Edge ${data.edgeId} deleted in flow ${flowId}`);
  }

  // ==================== CURSOR & SELECTION ====================

  @SubscribeMessage('cursor:move')
  handleCursorMove(
    @MessageBody() data: { position: { x: number; y: number } },
    @ConnectedSocket() client: Socket,
  ): void {
    // Very high-frequency event, skip rate limit check for cursors
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('cursor:updated', {
      userId: client.data.userId,
      position: data.position,
      socketId: client.id,
    });
  }

  @SubscribeMessage('selection:change')
  handleSelectionChange(
    @MessageBody() data: { selectedPodIds: string[] },
    @ConnectedSocket() client: Socket,
  ): void {
    const flowId = client.data.flowId;
    if (!flowId) return;

    client.to(`flow:${flowId}`).emit('selection:changed', {
      userId: client.data.userId,
      selectedPodIds: data.selectedPodIds,
      socketId: client.id,
    });
  }

  // ==================== EXECUTION STREAMING (NEW) ====================

  /**
   * Broadcast execution start to flow
   */
  broadcastExecutionStart(flowId: string, executionId: string, podId: string): void {
    this.server.to(`flow:${flowId}`).emit('execution:started', {
      executionId,
      podId,
      status: 'RUNNING',
      timestamp: new Date().toISOString(),
    });
  }

  /**
   * Broadcast execution token stream to flow
   */
  broadcastExecutionToken(flowId: string, executionId: string, podId: string, token: string): void {
    this.server.to(`flow:${flowId}`).emit('execution:token', {
      executionId,
      podId,
      token,
    });
  }

  /**
   * Broadcast execution completion to flow
   */
  broadcastExecutionComplete(
    flowId: string,
    executionId: string,
    podId: string,
    result: any,
  ): void {
    this.server.to(`flow:${flowId}`).emit('execution:completed', {
      executionId,
      podId,
      status: 'COMPLETED',
      result,
      timestamp: new Date().toISOString(),
    });
  }

  /**
   * Broadcast execution error to flow
   */
  broadcastExecutionError(flowId: string, executionId: string, podId: string, error: string): void {
    this.server.to(`flow:${flowId}`).emit('execution:error', {
      executionId,
      podId,
      status: 'ERROR',
      error,
      timestamp: new Date().toISOString(),
    });
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Broadcast message to all users in a flow
   */
  broadcastToFlow(flowId: string, event: string, data: any): void {
    this.server.to(`flow:${flowId}`).emit(event, data);
  }

  /**
   * Get number of active users in a flow
   */
  getFlowUserCount(flowId: string): number {
    return this.flowSessions.get(flowId)?.size || 0;
  }

  /**
   * Get number of active flows
   */
  getActiveFlowsCount(): number {
    return this.flowSessions.size;
  }

  /**
   * Get all users in a flow
   */
  getFlowUsers(flowId: string): FlowSession[] {
    const sessions = this.flowSessions.get(flowId);
    return sessions ? Array.from(sessions.values()) : [];
  }

  /**
   * Rate limiting check
   */
  private checkRateLimit(client: Socket): boolean {
    const now = Date.now();
    const limit = this.rateLimitMap.get(client.id);

    if (!limit || now > limit.resetTime) {
      this.rateLimitMap.set(client.id, {
        count: 1,
        resetTime: now + this.RATE_LIMIT_WINDOW,
      });
      return true;
    }

    if (limit.count >= this.RATE_LIMIT) {
      client.emit('error', {
        message: 'Rate limit exceeded',
        code: 'RATE_LIMIT',
      });
      this.logger.warn(`Rate limit exceeded for client ${client.id}`);
      return false;
    }

    limit.count++;
    return true;
  }

  /**
   * Cleanup sessions older than 24 hours with no activity
   */
  private cleanupStaleSessions(): void {
    const now = Date.now();
    const staleThreshold = 24 * 60 * 60 * 1000; // 24 hours

    let cleaned = 0;

    for (const [flowId, sessions] of this.flowSessions.entries()) {
      for (const [socketId, session] of sessions.entries()) {
        if (now - session.joinedAt.getTime() > staleThreshold) {
          sessions.delete(socketId);
          cleaned++;
        }
      }

      if (sessions.size === 0) {
        this.flowSessions.delete(flowId);
      }
    }

    if (cleaned > 0) {
      this.logger.log(`ðŸ§¹ Cleaned up ${cleaned} stale sessions`);
    }
  }

  /**
   * Get statistics for monitoring
   */
  getStats(): {
    activeFlows: number;
    totalSessions: number;
    averageUsersPerFlow: number;
  } {
    const activeFlows = this.flowSessions.size;
    let totalSessions = 0;

    for (const sessions of this.flowSessions.values()) {
      totalSessions += sessions.size;
    }

    return {
      activeFlows,
      totalSessions,
      averageUsersPerFlow: activeFlows > 0 ? totalSessions / activeFlows : 0,
    };
  }
}

```

### `apps\backend\src\v1\flow\flow.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1FlowController } from './flow.controller';
import { V1FlowService } from './flow.service';
import { PrismaModule } from '../../prisma/prisma.module';
import { V1FlowGateway } from './flow.gateway';
import { JwtModule } from '@nestjs/jwt';

@Module({
  imports: [PrismaModule, JwtModule],
  controllers: [V1FlowController],
  providers: [V1FlowService, V1FlowGateway],
  exports: [V1FlowService, V1FlowGateway],
})
export class V1FlowModule {}

```

### `apps\backend\src\v1\flow\flow.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Prisma, FlowVisibility, FlowAccessLevel, FlowActivityAction } from '@actopod/schema';
import { plainToInstance } from 'class-transformer';
import { CreateFlowDto } from './dto/create-flow.dto';
import { UpdateFlowDto } from './dto/update-flow.dto';
import { FlowQueryDto } from './dto/flow-query.dto';
import { AddCollaboratorDto } from './dto/add-collaborator.dto';
import { UpdateCollaboratorDto } from './dto/update-collaborator.dto';
import {
  FlowResponseDto,
  FlowPaginatedResponseDto,
  FlowPaginationDto,
  CollaboratorResponseDto,
  ActivityLogResponseDto,
} from './dto/flow-response.dto';

@Injectable()
export class V1FlowService {
  private readonly logger = new Logger(V1FlowService.name);

  constructor(private readonly prisma: PrismaService) {}

  // ==================== FLOW CRUD ====================

  async getWorkspaceFlows(
    workspaceId: string,
    userId: string,
    query: FlowQueryDto,
  ): Promise<FlowPaginatedResponseDto> {
    try {
      // User can see: their own flows, flows shared with them, or workspace-visible flows
      const where: Prisma.FlowWhereInput = {
        workspaceId,
        OR: [
          { createdBy: userId },
          { collaborators: { some: { userId } } },
          { visibility: FlowVisibility.WORKSPACE },
        ],
        ...(query.search && {
          AND: [
            {
              OR: [
                { name: { contains: query.search, mode: 'insensitive' } },
                { description: { contains: query.search, mode: 'insensitive' } },
              ],
            },
          ],
        }),
        ...(query.visibility && { visibility: query.visibility }),
        ...(query.spaceId && { spaceId: query.spaceId }),
      };

      const [flows, totalItems] = await Promise.all([
        this.prisma.flow.findMany({
          where,
          include: {
            _count: {
              select: {
                pods: true,
                collaborators: true,
              },
            },
          },
          orderBy: { updatedAt: 'desc' },
          skip: query.skip,
          take: query.limit,
        }),
        this.prisma.flow.count({ where }),
      ]);

      const totalPages = Math.ceil(totalItems / query.limit);

      const pagination: FlowPaginationDto = {
        totalItems,
        totalPages,
        currentPage: query.page,
        pageSize: flows.length,
      };

      const data = flows.map((flow) =>
        plainToInstance(
          FlowResponseDto,
          {
            ...flow,
            podCount: flow._count.pods,
            collaboratorCount: flow._count.collaborators,
          },
          { excludeExtraneousValues: true },
        ),
      );

      return { data, pagination };
    } catch (error) {
      this.logger.error(`Failed to fetch flows for workspace ${workspaceId}`, error);
      throw new InternalServerErrorException('Failed to fetch flows');
    }
  }

  async getFlowById(flowId: string, workspaceId: string, userId: string): Promise<FlowResponseDto> {
    try {
      const flow = await this.prisma.flow.findFirst({
        where: {
          id: flowId,
          workspaceId,
        },
        include: {
          _count: {
            select: {
              pods: true,
              collaborators: true,
            },
          },
        },
      });

      if (!flow) {
        throw new NotFoundException('Flow not found');
      }

      // Verify user has access
      await this.verifyFlowAccess(flowId, userId, 'VIEW');

      return plainToInstance(
        FlowResponseDto,
        {
          ...flow,
          podCount: flow._count.pods,
          collaboratorCount: flow._count.collaborators,
        },
        { excludeExtraneousValues: true },
      );
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to fetch flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch flow');
    }
  }

  async createFlow(
    workspaceId: string,
    userId: string,
    dto: CreateFlowDto,
  ): Promise<FlowResponseDto> {
    try {
      if (dto.spaceId) {
        const space = await this.prisma.space.findFirst({
          where: { id: dto.spaceId, workspaceId },
        });

        if (!space) {
          throw new BadRequestException('Space not found in this workspace');
        }
      }

      const flow = await this.prisma.flow.create({
        data: {
          workspaceId,
          spaceId: dto.spaceId,
          name: dto.name,
          description: dto.description,
          visibility: dto.visibility || FlowVisibility.PRIVATE,
          createdBy: userId,
        },
        include: {
          _count: {
            select: {
              pods: true,
              collaborators: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flow.id, userId, FlowActivityAction.FLOW_CREATED, {
        name: flow.name,
        visibility: flow.visibility,
      });

      this.logger.log(`âœ… Flow created: ${flow.id} by user ${userId}`);

      return plainToInstance(
        FlowResponseDto,
        {
          ...flow,
          podCount: flow._count.pods,
          collaboratorCount: flow._count.collaborators,
        },
        { excludeExtraneousValues: true },
      );
    } catch (error) {
      if (error instanceof BadRequestException) throw error;
      this.logger.error('Failed to create flow', error);
      throw new InternalServerErrorException('Failed to create flow');
    }
  }

  async updateFlow(
    flowId: string,
    workspaceId: string,
    userId: string,
    dto: UpdateFlowDto,
  ): Promise<FlowResponseDto> {
    try {
      const existingFlow = await this.prisma.flow.findFirst({
        where: {
          id: flowId,
          workspaceId,
        },
      });

      if (!existingFlow) {
        throw new NotFoundException('Flow not found');
      }

      // Verify edit permission
      await this.verifyFlowAccess(flowId, userId, 'EDIT');

      if (dto.spaceId) {
        const space = await this.prisma.space.findFirst({
          where: { id: dto.spaceId, workspaceId },
        });

        if (!space) {
          throw new BadRequestException('Space not found in this workspace');
        }
      }

      const flow = await this.prisma.flow.update({
        where: { id: flowId },
        data: {
          ...(dto.name && { name: dto.name }),
          ...(dto.description !== undefined && { description: dto.description }),
          ...(dto.spaceId !== undefined && { spaceId: dto.spaceId }),
          ...(dto.visibility && { visibility: dto.visibility }),
        },
        include: {
          _count: {
            select: {
              pods: true,
              collaborators: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.FLOW_UPDATED, dto);

      this.logger.log(`âœ… Flow updated: ${flowId} by user ${userId}`);

      return plainToInstance(
        FlowResponseDto,
        {
          ...flow,
          podCount: flow._count.pods,
          collaboratorCount: flow._count.collaborators,
        },
        { excludeExtraneousValues: true },
      );
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error(`Failed to update flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to update flow');
    }
  }

  async deleteFlow(flowId: string, workspaceId: string, userId: string): Promise<void> {
    try {
      const flow = await this.prisma.flow.findFirst({
        where: {
          id: flowId,
          workspaceId,
        },
      });

      if (!flow) {
        throw new NotFoundException('Flow not found');
      }

      // Only owner can delete
      if (flow.createdBy !== userId) {
        throw new ForbiddenException('Only the flow owner can delete this flow');
      }

      await this.prisma.flow.delete({
        where: { id: flowId },
      });

      this.logger.log(`âœ… Flow deleted: ${flowId} by user ${userId}`);
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to delete flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to delete flow');
    }
  }

  // ==================== COLLABORATOR MANAGEMENT ====================

  async getFlowCollaborators(
    flowId: string,
    workspaceId: string,
    userId: string,
  ): Promise<CollaboratorResponseDto[]> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'VIEW');

      const collaborators = await this.prisma.flowCollaborator.findMany({
        where: { flowId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
        orderBy: { invitedAt: 'asc' },
      });

      return collaborators.map((collab) =>
        plainToInstance(CollaboratorResponseDto, collab, { excludeExtraneousValues: true }),
      );
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to fetch collaborators for flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch collaborators');
    }
  }

  async addCollaborator(
    flowId: string,
    workspaceId: string,
    userId: string,
    dto: AddCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'INVITE');

      // Find user by email
      const targetUser = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });

      if (!targetUser) {
        throw new BadRequestException('User with this email not found');
      }

      // Check if already collaborator
      const existing = await this.prisma.flowCollaborator.findUnique({
        where: {
          flowId_userId: {
            flowId,
            userId: targetUser.id,
          },
        },
      });

      if (existing) {
        throw new BadRequestException('User is already a collaborator on this flow');
      }

      // Check if user is owner
      const flow = await this.prisma.flow.findUnique({ where: { id: flowId } });
      if (flow?.createdBy === targetUser.id) {
        throw new BadRequestException('Cannot add owner as collaborator');
      }

      const collaborator = await this.prisma.flowCollaborator.create({
        data: {
          flowId,
          userId: targetUser.id,
          accessLevel: dto.accessLevel || FlowAccessLevel.EDITOR,
          invitedBy: userId,
          canEdit: dto.accessLevel !== FlowAccessLevel.VIEWER,
          canExecute: true,
          canDelete: false,
          canShare: false,
          canInvite: false,
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.COLLABORATOR_ADDED, {
        collaboratorEmail: dto.email,
        accessLevel: dto.accessLevel,
      });

      this.logger.log(`âœ… Collaborator added to flow ${flowId}: ${dto.email}`);

      return plainToInstance(CollaboratorResponseDto, collaborator, {
        excludeExtraneousValues: true,
      });
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error(`Failed to add collaborator to flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to add collaborator');
    }
  }

  async updateCollaborator(
    flowId: string,
    collaboratorId: string,
    workspaceId: string,
    userId: string,
    dto: UpdateCollaboratorDto,
  ): Promise<CollaboratorResponseDto> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'MANAGE');

      const collaborator = await this.prisma.flowCollaborator.update({
        where: { id: collaboratorId, flowId },
        data: dto,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.COLLABORATOR_PERMISSIONS_CHANGED, {
        collaboratorId,
        changes: dto,
      });

      this.logger.log(`âœ… Collaborator updated in flow ${flowId}: ${collaboratorId}`);

      return plainToInstance(CollaboratorResponseDto, collaborator, {
        excludeExtraneousValues: true,
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to update collaborator ${collaboratorId}`, error);
      throw new InternalServerErrorException('Failed to update collaborator');
    }
  }

  async removeCollaborator(
    flowId: string,
    collaboratorId: string,
    workspaceId: string,
    userId: string,
  ): Promise<void> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'MANAGE');

      const collaborator = await this.prisma.flowCollaborator.findUnique({
        where: { id: collaboratorId },
        include: { user: true },
      });

      await this.prisma.flowCollaborator.delete({
        where: { id: collaboratorId, flowId },
      });

      // Log activity
      await this.logActivity(flowId, userId, FlowActivityAction.COLLABORATOR_REMOVED, {
        collaboratorEmail: collaborator?.user.email,
      });

      this.logger.log(`âœ… Collaborator removed from flow ${flowId}: ${collaboratorId}`);
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to remove collaborator ${collaboratorId}`, error);
      throw new InternalServerErrorException('Failed to remove collaborator');
    }
  }

  // ==================== ACTIVITY LOG ====================

  async getFlowActivity(
    flowId: string,
    workspaceId: string,
    userId: string,
    limit: number = 50,
  ): Promise<ActivityLogResponseDto[]> {
    try {
      await this.verifyFlowExists(flowId, workspaceId);
      await this.verifyFlowAccess(flowId, userId, 'VIEW');

      const activities = await this.prisma.flowActivityLog.findMany({
        where: { flowId },
        orderBy: { createdAt: 'desc' },
        take: limit,
      });

      // Fetch users for activities
      const userIds = activities.map((a) => a.userId).filter((id): id is string => id !== null);
      const users = await this.prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, name: true, email: true },
      });

      const userMap = new Map(users.map((u) => [u.id, u]));

      return activities.map((activity) => {
        const user = activity.userId ? userMap.get(activity.userId) || null : null;

        return plainToInstance(
          ActivityLogResponseDto,
          {
            ...activity,
            user,
          },
          { excludeExtraneousValues: true },
        );
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to fetch activity for flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch activity log');
    }
  }

  // ==================== HELPER METHODS ====================

  private async logActivity(
    flowId: string,
    userId: string | null,
    action: FlowActivityAction,
    changeData?: any,
  ): Promise<void> {
    try {
      await this.prisma.flowActivityLog.create({
        data: {
          flowId,
          userId,
          action,
          changeData,
        },
      });
    } catch (error) {
      this.logger.warn(`Failed to log activity for flow ${flowId}:`, error);
    }
  }

  private async verifyFlowExists(flowId: string, workspaceId: string): Promise<void> {
    const flow = await this.prisma.flow.findFirst({
      where: { id: flowId, workspaceId },
    });

    if (!flow) {
      throw new NotFoundException('Flow not found');
    }
  }

  private async verifyFlowAccess(
    flowId: string,
    userId: string,
    action: 'VIEW' | 'EDIT' | 'DELETE' | 'INVITE' | 'MANAGE',
  ): Promise<void> {
    const flow = await this.prisma.flow.findUnique({
      where: { id: flowId },
      include: {
        collaborators: {
          where: { userId },
        },
      },
    });

    if (!flow) {
      throw new NotFoundException('Flow not found');
    }

    // Owner has all permissions
    if (flow.createdBy === userId) {
      return;
    }

    // Workspace-visible flows can be viewed by workspace members
    if (action === 'VIEW' && flow.visibility === FlowVisibility.WORKSPACE) {
      return;
    }

    const collaborator = flow.collaborators[0];

    if (!collaborator) {
      throw new ForbiddenException('Access denied to this flow');
    }

    // Check specific permissions
    switch (action) {
      case 'VIEW':
        return; // All collaborators can view
      case 'EDIT':
        if (!collaborator.canEdit) {
          throw new ForbiddenException('Edit permission required');
        }
        break;
      case 'DELETE':
        if (!collaborator.canDelete) {
          throw new ForbiddenException('Delete permission required');
        }
        break;
      case 'INVITE':
        if (!collaborator.canInvite) {
          throw new ForbiddenException('Invite permission required');
        }
        break;
      case 'MANAGE':
        if (collaborator.accessLevel !== FlowAccessLevel.OWNER) {
          throw new ForbiddenException('Owner permission required');
        }
        break;
    }
  }
}

```

### `apps\backend\src\v1\models\dto\model-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';
import { Expose } from 'class-transformer';

export class ModelPricingDto {
  @Expose()
  @ApiProperty({ example: 'gpt-4o' })
  modelId!: string;

  @Expose()
  @ApiProperty({ example: 'gpt-4o-2024-05-13' })
  modelName!: string;

  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ example: '2.50' })
  inputTokenCost!: string;

  @Expose()
  @ApiProperty({ example: '10.00' })
  outputTokenCost!: string;

  @Expose()
  @ApiProperty({ example: '0.00', nullable: true })
  reasoningTokenCost!: string | null;

  @Expose()
  @ApiProperty({ example: 128000 })
  contextWindow!: number;

  @Expose()
  @ApiProperty({ example: true })
  supportsVision!: boolean;

  @Expose()
  @ApiProperty({ example: true })
  supportsFunctionCalling!: boolean;

  @Expose()
  @ApiProperty({ example: false })
  supportsStreaming!: boolean;

  @Expose()
  @ApiProperty({ example: true })
  isActive!: boolean;

  @Expose()
  @ApiProperty({ example: '2024-05-13T00:00:00.000Z' })
  effectiveFrom!: Date;
}

export class ModelsByProviderDto {
  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ type: [ModelPricingDto] })
  models!: ModelPricingDto[];

  @Expose()
  @ApiProperty({ example: 15 })
  count!: number;
}

```

### `apps\backend\src\v1\models\dto\provider-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';
import { Expose } from 'class-transformer';

export class ProviderInfoDto {
  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ example: 'OpenAI' })
  displayName!: string;

  @Expose()
  @ApiProperty({ example: 15 })
  modelCount!: number;

  @Expose()
  @ApiProperty({ example: true })
  isAvailable!: boolean;

  @Expose()
  @ApiProperty({
    example: ['text', 'vision', 'function-calling', 'reasoning'],
    type: [String],
  })
  capabilities!: string[];
}

```

### `apps\backend\src\v1\models\models.controller.ts`

```typescript
import { Controller, Get, Param, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam } from '@nestjs/swagger';
import { V1ModelsService } from './models.service';
import { ModelPricingDto, ModelsByProviderDto } from './dto/model-response.dto';
import { ProviderInfoDto } from './dto/provider-response.dto';
import { LLMProvider } from '@actopod/schema';
import { Public } from '../../common/decorators/common';

@ApiTags('Models & Providers')
@Controller('models')
export class V1ModelsController {
  constructor(private readonly modelsService: V1ModelsService) {}

  @Get('providers')
  @Public()
  @ApiOperation({
    summary: 'Get all available LLM providers',
    description: 'Returns list of all providers with their capabilities and model counts',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of providers',
    type: [ProviderInfoDto],
  })
  async getAllProviders(): Promise<ProviderInfoDto[]> {
    return this.modelsService.getAllProviders();
  }

  @Get()
  @Public() // Make this public so frontend can show models in UI
  @ApiOperation({
    summary: 'Get all available models',
    description: 'Returns all active models with pricing and capabilities',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'List of all models',
    type: [ModelPricingDto],
  })
  async getAllModels(): Promise<ModelPricingDto[]> {
    return this.modelsService.getAllModels();
  }

  @Get('grouped')
  @Public()
  @ApiOperation({
    summary: 'Get models grouped by provider',
    description: 'Returns models organized by provider',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Models grouped by provider',
    type: [ModelsByProviderDto],
  })
  async getModelsGroupedByProvider(): Promise<ModelsByProviderDto[]> {
    return this.modelsService.getModelsGroupedByProvider();
  }

  @Get('provider/:provider')
  @Public()
  @ApiOperation({
    summary: 'Get models for specific provider',
    description: 'Returns all models for the specified provider',
  })
  @ApiParam({
    name: 'provider',
    enum: LLMProvider,
    description: 'LLM provider name',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Models for the provider',
    type: ModelsByProviderDto,
  })
  async getModelsByProvider(
    @Param('provider') provider: LLMProvider,
  ): Promise<ModelsByProviderDto> {
    return this.modelsService.getModelsByProvider(provider);
  }

  @Get('provider/:provider/:modelId')
  @Public()
  @ApiOperation({
    summary: 'Get specific model details',
    description: 'Returns detailed information about a specific model',
  })
  @ApiParam({
    name: 'provider',
    enum: LLMProvider,
    description: 'LLM provider name',
  })
  @ApiParam({
    name: 'modelId',
    description: 'Model ID',
    example: 'gpt-4o',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Model details',
    type: ModelPricingDto,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Model not found',
  })
  async getModelById(
    @Param('provider') provider: LLMProvider,
    @Param('modelId') modelId: string,
  ): Promise<ModelPricingDto | null> {
    return this.modelsService.getModelById(provider, modelId);
  }
}

```

### `apps\backend\src\v1\models\models.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1ModelsController } from './models.controller';
import { V1ModelsService } from './models.service';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [V1ModelsController],
  providers: [V1ModelsService],
  exports: [V1ModelsService],
})
export class V1ModelsModule {}

```

### `apps\backend\src\v1\models\models.service.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { LLMProvider } from '@actopod/schema';
import { plainToInstance } from 'class-transformer';
import { ModelPricingDto, ModelsByProviderDto } from './dto/model-response.dto';
import { ProviderInfoDto } from './dto/provider-response.dto';

@Injectable()
export class V1ModelsService {
  private readonly logger = new Logger(V1ModelsService.name);

  // Provider display names and capabilities
  private readonly PROVIDER_INFO: Record<
    LLMProvider,
    { displayName: string; capabilities: string[] }
  > = {
    [LLMProvider.OPENAI]: {
      displayName: 'OpenAI',
      capabilities: ['text', 'vision', 'function-calling', 'reasoning', 'streaming'],
    },
    [LLMProvider.ANTHROPIC]: {
      displayName: 'Anthropic',
      capabilities: ['text', 'vision', 'function-calling', 'streaming'],
    },
    [LLMProvider.GOOGLE_GEMINI]: {
      displayName: 'Google AI',
      capabilities: ['text', 'vision', 'function-calling', 'streaming'],
    },
    [LLMProvider.PERPLEXITY]: {
      displayName: 'Perplexity',
      capabilities: ['text', 'search', 'real-time'],
    },
    [LLMProvider.MISTRAL]: {
      displayName: 'Mistral AI',
      capabilities: ['text', 'function-calling'],
    },
    [LLMProvider.COHERE]: {
      displayName: 'Cohere',
      capabilities: ['text', 'embedding', 'reranking'],
    },
    [LLMProvider.GROQ]: {
      displayName: 'Groq',
      capabilities: ['text', 'ultra-fast'],
    },
    [LLMProvider.XAI]: {
      displayName: 'xAI',
      capabilities: ['text', 'function-calling'],
    },
    [LLMProvider.DEEPSEEK]: {
      displayName: 'DeepSeek',
      capabilities: ['text', 'reasoning', 'cost-effective'],
    },
    [LLMProvider.CUSTOM]: {
      displayName: 'Custom',
      capabilities: ['text'],
    },
  };

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get all available providers with model counts
   */
  async getAllProviders(): Promise<ProviderInfoDto[]> {
    const modelCounts = await this.prisma.modelPricingTier.groupBy({
      by: ['provider'],
      where: { isActive: true },
      _count: { modelId: true },
    });

    const providers = Object.values(LLMProvider).map((provider) => {
      const count = modelCounts.find((mc) => mc.provider === provider)?._count.modelId || 0;
      const info = this.PROVIDER_INFO[provider];

      return plainToInstance(ProviderInfoDto, {
        provider,
        displayName: info.displayName,
        modelCount: count,
        isAvailable: count > 0,
        capabilities: info.capabilities,
      });
    });

    return providers.filter((p) => p.isAvailable);
  }

  /**
   * Get all active models (latest pricing for each model)
   */
  async getAllModels(): Promise<ModelPricingDto[]> {
    const models = await this.prisma.modelPricingTier.findMany({
      where: { isActive: true },
      orderBy: [{ provider: 'asc' }, { modelId: 'asc' }],
      distinct: ['provider', 'modelId'],
    });

    return models.map((model) =>
      plainToInstance(ModelPricingDto, {
        modelId: model.modelId,
        modelName: model.displayName, // âœ… FIXED: Use displayName
        provider: model.provider,
        inputTokenCost: model.inputTokenCost.toString(),
        outputTokenCost: model.outputTokenCost.toString(),
        reasoningTokenCost: model.reasoningTokenCost?.toString() || null,
        contextWindow: model.maxTokens || 0, // âœ… FIXED: Use maxTokens
        supportsVision: model.supportsVision,
        supportsFunctionCalling: model.supportsFunctions, // âœ… FIXED: Use supportsFunctions
        supportsStreaming: model.supportsStreaming,
        isActive: model.isActive,
        effectiveFrom: model.effectiveFrom,
      }),
    );
  }

  /**
   * Get models by specific provider
   */
  async getModelsByProvider(provider: LLMProvider): Promise<ModelsByProviderDto> {
    const models = await this.prisma.modelPricingTier.findMany({
      where: {
        provider,
        isActive: true,
      },
      orderBy: { modelId: 'asc' },
      distinct: ['modelId'],
    });

    const modelDtos = models.map((model) =>
      plainToInstance(ModelPricingDto, {
        modelId: model.modelId,
        modelName: model.displayName, // âœ… FIXED
        provider: model.provider,
        inputTokenCost: model.inputTokenCost.toString(),
        outputTokenCost: model.outputTokenCost.toString(),
        reasoningTokenCost: model.reasoningTokenCost?.toString() || null,
        contextWindow: model.maxTokens || 0, // âœ… FIXED
        supportsVision: model.supportsVision,
        supportsFunctionCalling: model.supportsFunctions, // âœ… FIXED
        supportsStreaming: model.supportsStreaming,
        isActive: model.isActive,
        effectiveFrom: model.effectiveFrom,
      }),
    );

    return plainToInstance(ModelsByProviderDto, {
      provider,
      models: modelDtos,
      count: modelDtos.length,
    });
  }

  /**
   * Get specific model details
   */
  async getModelById(provider: LLMProvider, modelId: string): Promise<ModelPricingDto | null> {
    const model = await this.prisma.modelPricingTier.findFirst({
      where: {
        provider,
        modelId,
        isActive: true,
      },
      orderBy: { effectiveFrom: 'desc' },
    });

    if (!model) return null;

    return plainToInstance(ModelPricingDto, {
      modelId: model.modelId,
      modelName: model.displayName, // âœ… FIXED
      provider: model.provider,
      inputTokenCost: model.inputTokenCost.toString(),
      outputTokenCost: model.outputTokenCost.toString(),
      reasoningTokenCost: model.reasoningTokenCost?.toString() || null,
      contextWindow: model.maxTokens || 0, // âœ… FIXED
      supportsVision: model.supportsVision,
      supportsFunctionCalling: model.supportsFunctions, // âœ… FIXED
      supportsStreaming: model.supportsStreaming,
      isActive: model.isActive,
      effectiveFrom: model.effectiveFrom,
    });
  }

  /**
   * Get models grouped by provider
   */
  async getModelsGroupedByProvider(): Promise<ModelsByProviderDto[]> {
    const providers = await this.getAllProviders();

    const groupedModels = await Promise.all(
      providers.map((provider) => this.getModelsByProvider(provider.provider)),
    );

    return groupedModels;
  }
}

```

### `apps\backend\src\v1\notification\dto\notification-count-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';

export class NotificationCountResponseDto {
  @ApiProperty({
    description: 'Number of notifications affected',
    example: 5,
  })
  count!: number;

  @ApiProperty({
    description: 'Success message',
    example: 'Successfully marked 5 notifications as read',
  })
  message!: string;
}

```

### `apps\backend\src\v1\notification\dto\notification-mark-read.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsString, ArrayNotEmpty, ArrayMaxSize } from 'class-validator';

export class NotificationMarkReadDto {
  @ApiProperty({
    description: 'Array of notification IDs to mark as read',
    type: [String],
    example: ['cm2abc123', 'cm2def456'],
    minItems: 1,
    maxItems: 50,
  })
  @IsArray()
  @ArrayNotEmpty()
  @ArrayMaxSize(50)
  @IsString({ each: true })
  notificationIds!: string[];
}

```

### `apps\backend\src\v1\notification\dto\notification-paginated-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { NotificationResponseDto } from './notification-response.dto';

/**
 * Compatible with your ResponseInterceptor's pagination format
 */
export class NotificationPaginationDto {
  @ApiProperty({
    description: 'Total number of items',
    example: 45,
  })
  totalItems!: number;

  @ApiProperty({
    description: 'Total number of pages',
    example: 3,
  })
  totalPages!: number;

  @ApiProperty({
    description: 'Current page number',
    example: 1,
  })
  currentPage!: number;

  @ApiProperty({
    description: 'Number of items in current page',
    example: 20,
  })
  pageSize!: number;
}

export class NotificationPaginatedResponseDto {
  @ApiProperty({
    description: 'Array of notifications',
    type: [NotificationResponseDto],
  })
  data!: NotificationResponseDto[];

  @ApiProperty({
    description: 'Pagination metadata',
    type: NotificationPaginationDto,
  })
  pagination!: NotificationPaginationDto;

  @ApiProperty({
    description: 'Number of unread notifications',
    example: 12,
  })
  unreadCount!: number;
}

```

### `apps\backend\src\v1\notification\dto\notification-query.dto.ts`

```typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, IsInt, Min, Max, IsEnum } from 'class-validator';
import { NotificationType } from '@actopod/schema';

export class NotificationQueryDto {
  @ApiPropertyOptional({
    description: 'Filter by read/unread status',
    example: false,
    type: Boolean,
    default: false,
  })
  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  unreadOnly: boolean = false;

  @ApiPropertyOptional({
    description: 'Filter by notification type',
    enum: NotificationType,
    example: NotificationType.WORKSPACE_INVITATION,
  })
  @IsOptional()
  @IsEnum(NotificationType)
  type?: NotificationType;

  @ApiPropertyOptional({
    description: 'Page number (starts from 1)',
    minimum: 1,
    default: 1,
    example: 1,
  })
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @IsOptional()
  page: number = 1;

  @ApiPropertyOptional({
    description: 'Number of items per page',
    minimum: 1,
    maximum: 100,
    default: 20,
    example: 20,
  })
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  @IsOptional()
  limit: number = 20;

  get skip(): number {
    return (this.page - 1) * this.limit;
  }
}

```

### `apps\backend\src\v1\notification\dto\notification-response.dto.ts`

```typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { NotificationType } from '@actopod/schema';
import { Exclude, Expose, Type } from 'class-transformer';

@Exclude()
export class NotificationResponseDto {
  @ApiProperty({
    description: 'Unique notification identifier',
    example: 'cm2abc123xyz',
  })
  @Expose()
  id!: string;

  @ApiProperty({
    description: 'User ID who owns this notification',
    example: 'cm1user456',
  })
  @Expose()
  userId!: string;

  @ApiProperty({
    description: 'Type of notification',
    enum: NotificationType,
    example: NotificationType.WORKSPACE_INVITATION,
  })
  @Expose()
  type!: NotificationType;

  @ApiProperty({
    description: 'Notification title',
    example: 'Workspace Invitation: Acme Corp',
  })
  @Expose()
  title!: string;

  @ApiProperty({
    description: 'Notification body/content',
    example: "You've been invited to join Acme Corp as MEMBER",
  })
  @Expose()
  body!: string;

  @ApiPropertyOptional({
    description: 'Type of related entity',
    example: 'workspace_invitation',
    nullable: true,
  })
  @Expose()
  entityType?: string | null;

  @ApiPropertyOptional({
    description: 'ID of related entity',
    example: 'cm2workspace789',
    nullable: true,
  })
  @Expose()
  entityId?: string | null;

  @ApiPropertyOptional({
    description: 'Additional metadata',
    example: { workspaceId: 'cm2ws123', role: 'MEMBER' },
    nullable: true,
  })
  @Expose()
  metadata?: Record<string, any> | null;

  @ApiProperty({
    description: 'Whether notification has been read',
    example: false,
  })
  @Expose()
  isRead!: boolean;

  @ApiPropertyOptional({
    description: 'Timestamp when notification was read',
    example: '2025-10-16T14:30:00.000Z',
    nullable: true,
  })
  @Expose()
  @Type(() => Date)
  readAt?: Date | null;

  @ApiPropertyOptional({
    description: 'URL to navigate when notification is clicked',
    example: '/workspace/invite/abc123token',
    nullable: true,
  })
  @Expose()
  actionUrl?: string | null;

  @ApiProperty({
    description: 'Notification creation timestamp',
    example: '2025-10-16T12:00:00.000Z',
  })
  @Expose()
  @Type(() => Date)
  createdAt!: Date;

  @ApiPropertyOptional({
    description: 'Notification expiration timestamp',
    example: '2025-10-23T12:00:00.000Z',
    nullable: true,
  })
  @Expose()
  @Type(() => Date)
  expiresAt?: Date | null;
}

```

### `apps\backend\src\v1\notification\dto\notification-unread-count-response.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';

export class NotificationUnreadCountResponseDto {
  @ApiProperty({
    description: 'Number of unread notifications',
    example: 12,
  })
  count!: number;
}

```

### `apps\backend\src\v1\notification\notification.controller.ts`

```typescript
import {
  Controller,
  Get,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
  ValidationPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
  ApiNotFoundResponse,
  ApiInternalServerErrorResponse,
} from '@nestjs/swagger';
import { V1NotificationService } from './notification.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { NotificationQueryDto } from './dto/notification-query.dto';
import { NotificationMarkReadDto } from './dto/notification-mark-read.dto';
import { NotificationPaginatedResponseDto } from './dto/notification-paginated-response.dto';
import { NotificationUnreadCountResponseDto } from './dto/notification-unread-count-response.dto';
import { NotificationCountResponseDto } from './dto/notification-count-response.dto';

@ApiTags('Notifications')
@ApiBearerAuth('JWT')
@Controller({
  path: 'notifications',
  version: '1',
})
@ApiUnauthorizedResponse({
  description: 'Unauthorized - Invalid or missing JWT token',
})
@ApiInternalServerErrorResponse({
  description: 'Internal server error',
})
export class V1NotificationController {
  constructor(private readonly notificationService: V1NotificationService) {}

  @Get()
  @ApiOperation({
    summary: 'Get user notifications',
    description:
      'Retrieve a paginated list of notifications for the authenticated user. ' +
      'Supports filtering by read status and notification type. ' +
      'Automatically excludes expired notifications.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully retrieved notifications',
    type: NotificationPaginatedResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid query parameters',
  })
  async getNotifications(
    @GetCurrentUserId() userId: string,
    @Query(new ValidationPipe({ transform: true, whitelist: true }))
    query: NotificationQueryDto,
  ): Promise<NotificationPaginatedResponseDto> {
    return this.notificationService.getUserNotifications(userId, query);
  }

  @Get('unread-count')
  @ApiOperation({
    summary: 'Get unread notification count',
    description: 'Get the total count of unread notifications for the authenticated user.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully retrieved unread count',
    type: NotificationUnreadCountResponseDto,
  })
  async getUnreadCount(
    @GetCurrentUserId() userId: string,
  ): Promise<NotificationUnreadCountResponseDto> {
    const count = await this.notificationService.getUnreadCount(userId);
    return { count };
  }

  // âœ… REMOVED ParseUUIDPipe - CUID IDs are not UUIDs
  @Patch(':id/read')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Mark notification as read',
    description:
      'Mark a single notification as read. The notification must belong to the authenticated user.',
  })
  @ApiParam({
    name: 'id',
    description: 'Notification ID (CUID format)',
    example: 'cm2abc123xyz',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Notification successfully marked as read',
  })
  @ApiNotFoundResponse({
    description: 'Notification not found or does not belong to user',
  })
  async markAsRead(
    @Param('id') notificationId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.notificationService.markAsRead(notificationId, userId);
  }

  @Patch('read-many')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Mark multiple notifications as read',
    description:
      'Mark multiple notifications as read in a single batch operation. Maximum 50 notification IDs per request.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully marked notifications as read',
    type: NotificationCountResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid request body or too many IDs',
  })
  async markManyAsRead(
    @Body(ValidationPipe) dto: NotificationMarkReadDto,
    @GetCurrentUserId() userId: string,
  ): Promise<NotificationCountResponseDto> {
    const count = await this.notificationService.markManyAsRead(dto.notificationIds, userId);
    return {
      count,
      message: `Successfully marked ${count} notification${count !== 1 ? 's' : ''} as read`,
    };
  }

  @Patch('read-all')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Mark all notifications as read',
    description: 'Mark all unread notifications as read for the authenticated user.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully marked all notifications as read',
    type: NotificationCountResponseDto,
  })
  async markAllAsRead(@GetCurrentUserId() userId: string): Promise<NotificationCountResponseDto> {
    const count = await this.notificationService.markAllAsRead(userId);
    return {
      count,
      message: `Successfully marked ${count} notification${count !== 1 ? 's' : ''} as read`,
    };
  }

  // âœ… REMOVED ParseUUIDPipe
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete notification',
    description:
      'Permanently delete a notification. The notification must belong to the authenticated user.',
  })
  @ApiParam({
    name: 'id',
    description: 'Notification ID (CUID format)',
    example: 'cm2abc123xyz',
  })
  @ApiResponse({
    status: HttpStatus.NO_CONTENT,
    description: 'Notification successfully deleted',
  })
  @ApiNotFoundResponse({
    description: 'Notification not found or does not belong to user',
  })
  async deleteNotification(
    @Param('id') notificationId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.notificationService.deleteNotification(notificationId, userId);
  }

  @Delete('read')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete all read notifications',
    description: 'Delete all read notifications for the authenticated user.',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Successfully deleted read notifications',
    type: NotificationCountResponseDto,
  })
  async deleteAllRead(@GetCurrentUserId() userId: string): Promise<NotificationCountResponseDto> {
    const count = await this.notificationService.deleteAllRead(userId);
    return {
      count,
      message: `Successfully deleted ${count} notification${count !== 1 ? 's' : ''}`,
    };
  }
}

```

### `apps\backend\src\v1\notification\notification.gateway.ts`

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true,
  },
  namespace: 'notifications',
  transports: ['websocket', 'polling'],
})
export class V1NotificationGateway
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server!: Server;

  private readonly logger = new Logger(V1NotificationGateway.name);
  private userSockets = new Map<string, Set<string>>();

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  afterInit(): void {
    this.logger.log('ðŸ”Œ Notification WebSocket Gateway initialized');
  }

  async handleConnection(client: Socket): Promise<void> {
    try {
      const token =
        client.handshake.auth?.token ||
        client.handshake.headers?.authorization?.replace('Bearer ', '') ||
        client.handshake.query?.token;

      if (!token) {
        this.logger.warn(`âŒ Client ${client.id}: No token`);
        client.emit('error', { message: 'Authentication required' });
        client.disconnect(true);
        return;
      }

      const secret = this.configService.get<string>('JWT_ACCESS_TOKEN_SECRET');
      const payload = await this.jwtService.verifyAsync(token, { secret });

      // âœ… Use userId instead of sub (matches your JWT payload structure)
      const userId = payload.userId || payload.sub;

      if (!userId) {
        this.logger.warn(`âŒ Client ${client.id}: Invalid token - no userId in payload`);
        client.disconnect(true);
        return;
      }

      if (!this.userSockets.has(userId)) {
        this.userSockets.set(userId, new Set());
      }
      this.userSockets.get(userId)!.add(client.id);

      await client.join(`user:${userId}`);
      client.data.userId = userId;

      client.emit('connected', {
        message: 'Connected to notifications',
        userId,
      });

      const deviceCount = this.userSockets.get(userId)!.size;
      this.logger.log(`âœ… User ${userId} connected [${deviceCount} device(s)]`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Auth failed';
      this.logger.error(`âŒ Connection failed: ${errorMessage}`);
      client.emit('error', { message: 'Authentication failed' });
      client.disconnect(true);
    }
  }

  handleDisconnect(client: Socket): void {
    const userId = client.data.userId;
    if (userId) {
      const userSocketSet = this.userSockets.get(userId);
      if (userSocketSet) {
        userSocketSet.delete(client.id);
        if (userSocketSet.size === 0) {
          this.userSockets.delete(userId);
          this.logger.log(`ðŸ”Œ User ${userId} fully disconnected`);
        } else {
          this.logger.log(
            `ðŸ”Œ User ${userId} device disconnected [${userSocketSet.size} remaining]`,
          );
        }
      }
    }
  }

  sendNotificationToUser(userId: string, notification: any): void {
    try {
      this.server.to(`user:${userId}`).emit('notification:new', notification);
      const deviceCount = this.userSockets.get(userId)?.size || 0;
      this.logger.debug(`ðŸ“¤ Notification sent to ${userId} [${deviceCount} device(s)]`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`âŒ Failed to send notification: ${errorMessage}`);
    }
  }

  sendUnreadCountUpdate(userId: string, count: number): void {
    try {
      this.server.to(`user:${userId}`).emit('notification:unread_count', count);
      this.logger.debug(`ðŸ“Š Unread count updated: ${userId} = ${count}`);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`âŒ Failed to send unread count: ${errorMessage}`);
    }
  }

  getConnectedUsersCount(): number {
    return this.userSockets.size;
  }

  isUserConnected(userId: string): boolean {
    return this.userSockets.has(userId) && this.userSockets.get(userId)!.size > 0;
  }

  getUserDeviceCount(userId: string): number {
    return this.userSockets.get(userId)?.size || 0;
  }
}

```

### `apps\backend\src\v1\notification\notification.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1NotificationController } from './notification.controller';
import { V1NotificationService } from './notification.service';
import { V1NotificationGateway } from './notification.gateway';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [V1NotificationController],
  providers: [V1NotificationService, V1NotificationGateway],
  exports: [V1NotificationService, V1NotificationGateway],
})
export class V1NotificationModule {}

```

### `apps\backend\src\v1\notification\notification.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { NotificationType, Notification, Prisma } from '@actopod/schema';
import { V1NotificationGateway } from './notification.gateway';
import { NotificationQueryDto } from './dto/notification-query.dto';
import {
  NotificationPaginatedResponseDto,
  NotificationPaginationDto,
} from './dto/notification-paginated-response.dto';
import { NotificationResponseDto } from './dto/notification-response.dto';
import { plainToInstance } from 'class-transformer';

/**
 * Production-Grade Notification Service
 * Features:
 * - Real-time WebSocket notifications
 * - Pagination support compatible with ResponseInterceptor
 * - Type-safe operations
 * - Comprehensive error handling
 * - Automatic cleanup of expired notifications
 * - Batch operations for performance
 * - Non-blocking WebSocket delivery
 */
@Injectable()
export class V1NotificationService {
  private readonly logger = new Logger(V1NotificationService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly notificationGateway: V1NotificationGateway,
  ) {}

  /**
   * Create a new notification with real-time delivery
   */
  async createNotification(data: {
    userId: string;
    type: NotificationType;
    title: string;
    body: string;
    entityType?: string;
    entityId?: string;
    metadata?: Record<string, any>;
    actionUrl?: string;
    expiresAt?: Date;
  }): Promise<Notification> {
    try {
      const notification = await this.prisma.notification.create({
        data: {
          userId: data.userId,
          type: data.type,
          title: data.title,
          body: data.body,
          entityType: data.entityType,
          entityId: data.entityId,
          metadata: data.metadata as any,
          actionUrl: data.actionUrl,
          expiresAt: data.expiresAt,
        },
      });

      this.logger.log(
        `Notification created: ${notification.id} for user ${data.userId} (type: ${data.type})`,
      );

      // âœ… Send real-time notification (non-blocking)
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(data.userId)) {
            this.notificationGateway.sendNotificationToUser(data.userId, notification);

            const unreadCount = await this.getUnreadCount(data.userId);
            this.notificationGateway.sendUnreadCountUpdate(data.userId, unreadCount);

            this.logger.debug(`Real-time notification sent to user ${data.userId}`);
          }
        } catch (wsError) {
          this.logger.warn(
            `WebSocket delivery failed for notification ${notification.id}`,
            wsError,
          );
        }
      });

      return notification;
    } catch (error) {
      this.logger.error(`Failed to create notification for user ${data.userId}`, error);
      throw new InternalServerErrorException('Failed to create notification');
    }
  }

  /**
   * Get paginated notifications with real-time metadata
   */
  async getUserNotifications(
    userId: string,
    query: NotificationQueryDto,
  ): Promise<NotificationPaginatedResponseDto> {
    try {
      const where: Prisma.NotificationWhereInput = {
        userId,
        ...(query.unreadOnly && { isRead: false }),
        ...(query.type && { type: query.type }),
        OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
      };

      const [notifications, totalItems, unreadCount] = await Promise.all([
        this.prisma.notification.findMany({
          where,
          orderBy: { createdAt: 'desc' },
          skip: query.skip,
          take: query.limit,
        }),
        this.prisma.notification.count({ where }),
        this.prisma.notification.count({
          where: {
            userId,
            isRead: false,
            OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
          },
        }),
      ]);

      const totalPages = Math.ceil(totalItems / query.limit);

      const pagination: NotificationPaginationDto = {
        totalItems,
        totalPages,
        currentPage: query.page,
        pageSize: notifications.length,
      };

      const data = plainToInstance(NotificationResponseDto, notifications, {
        excludeExtraneousValues: true,
      });

      return {
        data,
        pagination,
        unreadCount,
      };
    } catch (error) {
      this.logger.error(`Failed to fetch notifications for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to fetch notifications');
    }
  }

  /**
   * Get unread count
   */
  async getUnreadCount(userId: string): Promise<number> {
    try {
      return await this.prisma.notification.count({
        where: {
          userId,
          isRead: false,
          OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
        },
      });
    } catch (error) {
      this.logger.error(`Failed to get unread count for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to get unread count');
    }
  }

  /**
   * Mark notification as read with real-time update
   */
  async markAsRead(notificationId: string, userId: string): Promise<void> {
    try {
      const result = await this.prisma.notification.updateMany({
        where: { id: notificationId, userId },
        data: { isRead: true, readAt: new Date() },
      });

      if (result.count === 0) {
        throw new NotFoundException('Notification not found');
      }

      // âœ… Update unread count in real-time
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(userId)) {
            const unreadCount = await this.getUnreadCount(userId);
            this.notificationGateway.sendUnreadCountUpdate(userId, unreadCount);
          }
        } catch (wsError) {
          this.logger.warn('WebSocket update failed for markAsRead', wsError);
        }
      });

      this.logger.debug(`Notification ${notificationId} marked as read by user ${userId}`);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to mark notification ${notificationId} as read`, error);
      throw new InternalServerErrorException('Failed to mark notification as read');
    }
  }

  /**
   * Mark multiple notifications as read with real-time update
   */
  async markManyAsRead(notificationIds: string[], userId: string): Promise<number> {
    try {
      if (!notificationIds || notificationIds.length === 0) {
        throw new BadRequestException('No notification IDs provided');
      }

      const result = await this.prisma.notification.updateMany({
        where: {
          id: { in: notificationIds },
          userId,
        },
        data: { isRead: true, readAt: new Date() },
      });

      // âœ… Update unread count in real-time
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(userId)) {
            const unreadCount = await this.getUnreadCount(userId);
            this.notificationGateway.sendUnreadCountUpdate(userId, unreadCount);
          }
        } catch (wsError) {
          this.logger.warn('WebSocket update failed for markManyAsRead', wsError);
        }
      });

      this.logger.log(`Marked ${result.count} notifications as read for user ${userId}`);

      return result.count;
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to mark multiple notifications as read`, error);
      throw new InternalServerErrorException('Failed to mark notifications as read');
    }
  }

  /**
   * Mark all notifications as read with real-time update
   */
  async markAllAsRead(userId: string): Promise<number> {
    try {
      const result = await this.prisma.notification.updateMany({
        where: { userId, isRead: false },
        data: { isRead: true, readAt: new Date() },
      });

      // âœ… Update unread count in real-time
      setImmediate(async () => {
        try {
          if (this.notificationGateway.isUserConnected(userId)) {
            this.notificationGateway.sendUnreadCountUpdate(userId, 0);
          }
        } catch (wsError) {
          this.logger.warn('WebSocket update failed for markAllAsRead', wsError);
        }
      });

      this.logger.log(`Marked all ${result.count} notifications as read for user ${userId}`);

      return result.count;
    } catch (error) {
      this.logger.error(`Failed to mark all notifications as read for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to mark all notifications as read');
    }
  }

  /**
   * Delete notification with real-time update
   */
  async deleteNotification(notificationId: string, userId: string): Promise<void> {
    try {
      // Check if notification is unread before deleting
      const notification = await this.prisma.notification.findFirst({
        where: { id: notificationId, userId },
        select: { isRead: true },
      });

      const result = await this.prisma.notification.deleteMany({
        where: { id: notificationId, userId },
      });

      if (result.count === 0) {
        throw new NotFoundException('Notification not found');
      }

      // âœ… Update unread count if deleted notification was unread
      if (notification && !notification.isRead) {
        setImmediate(async () => {
          try {
            if (this.notificationGateway.isUserConnected(userId)) {
              const unreadCount = await this.getUnreadCount(userId);
              this.notificationGateway.sendUnreadCountUpdate(userId, unreadCount);
            }
          } catch (wsError) {
            this.logger.warn('WebSocket update failed for deleteNotification', wsError);
          }
        });
      }

      this.logger.debug(`Notification ${notificationId} deleted by user ${userId}`);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to delete notification ${notificationId}`, error);
      throw new InternalServerErrorException('Failed to delete notification');
    }
  }

  /**
   * Delete all read notifications
   */
  async deleteAllRead(userId: string): Promise<number> {
    try {
      const result = await this.prisma.notification.deleteMany({
        where: { userId, isRead: true },
      });

      this.logger.log(`Deleted ${result.count} read notifications for user ${userId}`);

      return result.count;
    } catch (error) {
      this.logger.error(`Failed to delete read notifications for user ${userId}`, error);
      throw new InternalServerErrorException('Failed to delete read notifications');
    }
  }

  /**
   * Cleanup expired notifications (CRON job)
   */
  async cleanupExpiredNotifications(): Promise<number> {
    try {
      const result = await this.prisma.notification.deleteMany({
        where: {
          expiresAt: { lt: new Date() },
        },
      });

      this.logger.log(`Cleaned up ${result.count} expired notifications`);

      return result.count;
    } catch (error) {
      this.logger.error('Failed to cleanup expired notifications', error);
      throw new InternalServerErrorException('Failed to cleanup expired notifications');
    }
  }
}

```

### `apps\backend\src\v1\notification\types\notification.types.ts`

```typescript
import { NotificationType } from '@actopod/schema';

export interface NotificationResponse {
  id: string;
  userId: string;
  type: NotificationType;
  title: string;
  body: string;
  entityType?: string | null;
  entityId?: string | null;
  metadata?: Record<string, any> | null;
  isRead: boolean;
  readAt?: Date | null;
  actionUrl?: string | null;
  createdAt: Date;
  expiresAt?: Date | null;
}

export interface NotificationListResponse {
  notifications: NotificationResponse[];
  unreadCount: number;
  total: number;
}

export interface UnreadCountResponse {
  count: number;
}

export type NotificationCreateInput = {
  userId: string;
  type: NotificationType;
  title: string;
  body: string;
  entityType?: string;
  entityId?: string;
  metadata?: Record<string, any>;
  actionUrl?: string;
  expiresAt?: Date;
};

```

### `apps\backend\src\v1\pods\dto\create-edge.dto.ts`

```typescript
import { IsString, IsOptional, IsBoolean } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateEdgeDto {
  @ApiProperty()
  @IsString()
  flowId!: string;

  @ApiProperty()
  @IsString()
  sourcePodId!: string;

  @ApiProperty()
  @IsString()
  targetPodId!: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  sourceHandle?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  targetHandle?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  animated?: boolean;
}

```

### `apps\backend\src\v1\pods\dto\create-pod.dto.ts`

```typescript
// dto/create-pod.dto.ts

import {
  IsString,
  IsEnum,
  IsObject,
  ValidateNested,
  IsOptional,
  IsNumber,
  IsArray,
  Min,
  Max,
} from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PodType, LLMProvider } from '@actopod/schema';

export class PositionDto {
  @ApiProperty()
  @IsNumber()
  x!: number;

  @ApiProperty()
  @IsNumber()
  y!: number;
}

export class LLMConfigDto {
  @ApiProperty({ enum: LLMProvider })
  @IsEnum(LLMProvider)
  provider!: LLMProvider;

  @ApiProperty({ example: 'gpt-4' })
  @IsString()
  model!: string;

  @ApiPropertyOptional({
    description: 'Custom system prompt. If not provided, uses default.',
    example: 'You are a helpful assistant specialized in data analysis.',
  })
  @IsOptional()
  @IsString()
  systemPrompt?: string;

  @ApiPropertyOptional({
    example: 'Analyze the following data: {{input}}',
    description: 'User prompt template. Can be empty initially.',
  })
  @IsOptional()
  @IsString()
  userPrompt?: string;

  @ApiPropertyOptional({
    minimum: 0,
    maximum: 2,
    default: 0.7,
    description: 'Controls randomness. Lower = more focused, Higher = more creative',
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(2)
  temperature?: number;

  @ApiPropertyOptional({
    minimum: 1,
    default: 4096,
    description: 'Maximum tokens in response',
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  maxTokens?: number;

  @ApiPropertyOptional({
    description: 'Thinking budget for reasoning models (o1, o3)',
    example: 10000,
  })
  @IsOptional()
  @IsNumber()
  thinkingBudget?: number;

  @ApiPropertyOptional({ minimum: 0, maximum: 1, default: 1.0 })
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Max(1)
  topP?: number;

  @ApiPropertyOptional({ minimum: -2, maximum: 2, default: 0 })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  presencePenalty?: number;

  @ApiPropertyOptional({ minimum: -2, maximum: 2, default: 0 })
  @IsOptional()
  @IsNumber()
  @Min(-2)
  @Max(2)
  frequencyPenalty?: number;

  @ApiPropertyOptional({ enum: ['text', 'json', 'json_object'], default: 'text' })
  @IsOptional()
  @IsString()
  responseFormat?: 'text' | 'json' | 'json_object';

  @ApiPropertyOptional({ default: false })
  @IsOptional()
  streamEnabled?: boolean;
}

export class CreatePodDto {
  @ApiProperty()
  @IsString()
  flowId!: string;

  @ApiProperty({ enum: PodType })
  @IsEnum(PodType)
  type!: PodType;

  @ApiProperty()
  @ValidateNested()
  @Type(() => PositionDto)
  position!: PositionDto;

  @ApiProperty()
  @IsString()
  label!: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description?: string;

  @ApiProperty({ description: 'Pod configuration (type-specific)' })
  @IsObject()
  config!: any; // Will be LLMConfigDto for LLM pods

  @ApiPropertyOptional()
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextPods?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}

```

### `apps\backend\src\v1\pods\dto\pod-config-response.dto.ts`

```typescript
import { Expose } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';

export class PodConfigResponseDto {
  @Expose()
  @ApiProperty({ enum: LLMProvider })
  provider!: LLMProvider;

  @Expose()
  @ApiProperty({ example: 'gpt-4o' })
  model!: string;

  @Expose()
  @ApiPropertyOptional()
  systemPrompt?: string;

  @Expose()
  @ApiProperty()
  temperature!: number;

  @Expose()
  @ApiProperty()
  maxTokens!: number;

  @Expose()
  @ApiPropertyOptional()
  thinkingBudget?: number;

  @Expose()
  @ApiPropertyOptional()
  topP?: number;

  @Expose()
  @ApiPropertyOptional()
  presencePenalty?: number;

  @Expose()
  @ApiPropertyOptional()
  frequencyPenalty?: number;

  @Expose()
  @ApiPropertyOptional()
  responseFormat?: 'text' | 'json' | 'json_object';

  @Expose()
  @ApiPropertyOptional()
  streamEnabled?: boolean;
}

```

### `apps\backend\src\v1\pods\dto\pod-response.dto.ts`

```typescript
import { Expose } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';
import { PodType, PodExecutionStatus } from '@actopod/schema';

export class PodResponseDto {
  @Expose()
  @ApiProperty()
  id!: string;

  @Expose()
  @ApiProperty()
  flowId!: string;

  @Expose()
  @ApiProperty({ enum: PodType })
  type!: PodType;

  @Expose()
  @ApiProperty()
  position!: any;

  @Expose()
  @ApiProperty({ enum: PodExecutionStatus })
  executionStatus!: PodExecutionStatus;

  @Expose()
  @ApiProperty()
  createdAt!: Date;

  @Expose()
  @ApiProperty()
  updatedAt!: Date;

  @Expose()
  @ApiProperty({ description: 'Pod content from DynamoDB' })
  content?: any;

  @Expose()
  @ApiProperty({ description: 'Context pods attached' })
  contextPods?: string[];

  @Expose()
  @ApiProperty({ description: 'Lock information' })
  lockedBy?: string | null;

  @Expose()
  @ApiProperty()
  lockedAt?: Date | null;
}

export class EdgeResponseDto {
  @Expose()
  @ApiProperty()
  id!: string;

  @Expose()
  @ApiProperty()
  flowId!: string;

  @Expose()
  @ApiProperty()
  sourcePodId!: string;

  @Expose()
  @ApiProperty()
  targetPodId!: string;

  @Expose()
  @ApiProperty()
  sourceHandle!: string | null;

  @Expose()
  @ApiProperty()
  targetHandle!: string | null;

  @Expose()
  @ApiProperty()
  animated!: boolean;

  @Expose()
  @ApiProperty()
  createdAt!: Date;
}

export class FlowCanvasResponseDto {
  @ApiProperty({ type: [PodResponseDto] })
  pods!: PodResponseDto[];

  @ApiProperty({ type: [EdgeResponseDto] })
  edges!: EdgeResponseDto[];
}

```

### `apps\backend\src\v1\pods\dto\update-pod.dto.ts`

```typescript
// dto/update-pod.dto.ts

import { IsOptional, IsString, IsObject, ValidateNested, IsArray } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { PositionDto, LLMConfigDto } from './create-pod.dto';

export class UpdatePodDto {
  @ApiPropertyOptional()
  @IsOptional()
  @ValidateNested()
  @Type(() => PositionDto)
  position?: PositionDto;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  label?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({
    description:
      'Partial config update. For LLM pods, can update individual fields like systemPrompt, temperature, etc.',
  })
  @IsOptional()
  @IsObject()
  config?: Partial<LLMConfigDto> | any;

  @ApiPropertyOptional()
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextPods?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}

```

### `apps\backend\src\v1\pods\edge.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';
import { plainToInstance } from 'class-transformer';
import { CreateEdgeDto } from './dto/create-edge.dto';
import { EdgeResponseDto } from './dto/pod-response.dto';
import { V1FlowGateway } from '../flow/flow.gateway';

@Injectable()
export class V1EdgeService {
  private readonly logger = new Logger(V1EdgeService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
    private readonly flowGateway: V1FlowGateway,
  ) {}

  /**
   * Create an edge connection between two pods
   */
  async createEdge(
    workspaceId: string,
    userId: string,
    dto: CreateEdgeDto,
  ): Promise<EdgeResponseDto> {
    try {
      // Verify flow exists in workspace
      const flow = await this.prisma.flow.findFirst({
        where: { id: dto.flowId, workspaceId },
      });

      if (!flow) {
        throw new NotFoundException(`Flow ${dto.flowId} not found`);
      }

      // Verify both pods exist in the flow
      const [sourcePod, targetPod] = await Promise.all([
        this.prisma.pod.findFirst({
          where: { id: dto.sourcePodId, flowId: dto.flowId },
        }),
        this.prisma.pod.findFirst({
          where: { id: dto.targetPodId, flowId: dto.flowId },
        }),
      ]);

      if (!sourcePod) {
        throw new BadRequestException(`Source pod ${dto.sourcePodId} not found in flow`);
      }

      if (!targetPod) {
        throw new BadRequestException(`Target pod ${dto.targetPodId} not found in flow`);
      }

      // Prevent self-loops
      if (dto.sourcePodId === dto.targetPodId) {
        throw new BadRequestException('Cannot create edge from pod to itself');
      }

      // Check for duplicate edges
      const existingEdge = await this.prisma.edge.findFirst({
        where: {
          flowId: dto.flowId,
          sourcePodId: dto.sourcePodId,
          targetPodId: dto.targetPodId,
          sourceHandle: dto.sourceHandle || null,
          targetHandle: dto.targetHandle || null,
        },
      });

      if (existingEdge) {
        throw new BadRequestException('Edge already exists between these pods and handles');
      }

      // Create edge in PostgreSQL
      const edge = await this.prisma.edge.create({
        data: {
          flowId: dto.flowId,
          sourcePodId: dto.sourcePodId,
          targetPodId: dto.targetPodId,
          sourceHandle: dto.sourceHandle,
          targetHandle: dto.targetHandle,
          animated: dto.animated || false,
        },
      });

      // Update DynamoDB connectedPods
      const tableName = this.dynamoDb.getTableNames().pods;
      try {
        const sourceItem = await this.dynamoDb.getItem(tableName, {
          pk: sourcePod.dynamoPartitionKey,
          sk: sourcePod.dynamoSortKey,
        });

        if (sourceItem) {
          const updatedConnectedPods = [
            ...new Set([...(sourceItem.connectedPods || []), dto.targetPodId]),
          ];
          await this.dynamoDb.putItem(tableName, {
            ...sourceItem,
            connectedPods: updatedConnectedPods,
            updatedAt: new Date().toISOString(),
          });
        }
      } catch (dynamoError) {
        this.logger.warn(
          `Failed to update connectedPods in DynamoDB for pod ${dto.sourcePodId}:`,
          dynamoError,
        );
        // Don't fail edge creation if DynamoDB update fails
      }

      this.logger.log(
        `âœ… Edge created: ${edge.id} (${dto.sourcePodId} â†’ ${dto.targetPodId}) by user ${userId}`,
      );

      const result = plainToInstance(EdgeResponseDto, edge, {
        excludeExtraneousValues: true,
      });

      // Broadcast to all users
      this.flowGateway.broadcastToFlow(dto.flowId, 'edge:created', {
        edge: result,
        userId,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof BadRequestException) throw error;
      this.logger.error('âŒ Failed to create edge', error);
      throw new InternalServerErrorException('Failed to create edge');
    }
  }

  /**
   * Delete an edge connection
   */
  async deleteEdge(edgeId: string, workspaceId: string, userId: string): Promise<void> {
    try {
      // Fetch edge with related pods
      const edge = await this.prisma.edge.findFirst({
        where: {
          id: edgeId,
          flow: { workspaceId },
        },
        include: {
          sourcePod: true,
          targetPod: true,
        },
      });

      if (!edge) {
        throw new NotFoundException(`Edge ${edgeId} not found`);
      }

      const flowId = edge.flowId;

      // Update DynamoDB connectedPods
      const tableName = this.dynamoDb.getTableNames().pods;
      try {
        const sourceItem = await this.dynamoDb.getItem(tableName, {
          pk: edge.sourcePod.dynamoPartitionKey,
          sk: edge.sourcePod.dynamoSortKey,
        });

        if (sourceItem) {
          const updatedConnectedPods = (sourceItem.connectedPods || []).filter(
            (podId: string) => podId !== edge.targetPodId,
          );
          await this.dynamoDb.putItem(tableName, {
            ...sourceItem,
            connectedPods: updatedConnectedPods,
            updatedAt: new Date().toISOString(),
          });
        }
      } catch (dynamoError) {
        this.logger.warn(
          `Failed to update connectedPods in DynamoDB for pod ${edge.sourcePodId}:`,
          dynamoError,
        );
        // Don't fail edge deletion if DynamoDB update fails
      }

      // Delete edge from PostgreSQL
      await this.prisma.edge.delete({
        where: { id: edgeId },
      });

      this.logger.log(`âœ… Edge deleted: ${edgeId} by user ${userId}`);

      // Broadcast deletion
      this.flowGateway.broadcastToFlow(flowId, 'edge:deleted', {
        edgeId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`âŒ Failed to delete edge ${edgeId}`, error);
      throw new InternalServerErrorException('Failed to delete edge');
    }
  }
}

```

### `apps\backend\src\v1\pods\pod.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  HttpCode,
  HttpStatus,
  ValidationPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
  ApiNotFoundResponse,
} from '@nestjs/swagger';
import { V1PodService } from './pod.service';
import { V1EdgeService } from './edge.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { CreatePodDto } from './dto/create-pod.dto';
import { UpdatePodDto } from './dto/update-pod.dto';
import { CreateEdgeDto } from './dto/create-edge.dto';
import { PodResponseDto, EdgeResponseDto, FlowCanvasResponseDto } from './dto/pod-response.dto';

@ApiTags('Pods & Edges')
@ApiBearerAuth('JWT')
@Controller({
  path: 'workspaces/:workspaceId/flows/:flowId/canvas',
  version: '1',
})
@ApiUnauthorizedResponse({ description: 'Unauthorized' })
export class V1PodController {
  constructor(
    private readonly podService: V1PodService,
    private readonly edgeService: V1EdgeService,
  ) {}

  // ==================== CANVAS ====================

  @Get()
  @ApiOperation({ summary: 'Get complete canvas (pods + edges)' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiResponse({ status: 200, type: FlowCanvasResponseDto })
  async getCanvas(
    @Param('workspaceId') workspaceId: string,
    @Param('flowId') flowId: string,
  ): Promise<FlowCanvasResponseDto> {
    return this.podService.getFlowCanvas(flowId, workspaceId);
  }

  // ==================== PODS ====================

  @Post('pods')
  @ApiOperation({ summary: 'Create a new pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiResponse({ status: 201, type: PodResponseDto })
  @ApiBadRequestResponse({ description: 'Invalid input' })
  async createPod(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: CreatePodDto,
  ): Promise<PodResponseDto> {
    return this.podService.createPod(workspaceId, userId, dto);
  }

  @Patch('pods/:podId')
  @ApiOperation({ summary: 'Update a pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 200, type: PodResponseDto })
  @ApiNotFoundResponse({ description: 'Pod not found' })
  async updatePod(
    @Param('workspaceId') workspaceId: string,
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: UpdatePodDto,
  ): Promise<PodResponseDto> {
    return this.podService.updatePod(podId, workspaceId, userId, dto);
  }

  @Delete('pods/:podId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete a pod' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 204, description: 'Pod deleted' })
  @ApiNotFoundResponse({ description: 'Pod not found' })
  async deletePod(
    @Param('workspaceId') workspaceId: string,
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.podService.deletePod(podId, workspaceId, userId);
  }

  @Post('pods/:podId/lock')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Lock pod for editing' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 200, description: 'Pod locked' })
  async lockPod(
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<{ message: string }> {
    await this.podService.lockPod(podId, userId);
    return { message: 'Pod locked successfully' };
  }

  @Post('pods/:podId/unlock')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Unlock pod' })
  @ApiParam({ name: 'podId', description: 'Pod ID' })
  @ApiResponse({ status: 200, description: 'Pod unlocked' })
  async unlockPod(
    @Param('podId') podId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<{ message: string }> {
    await this.podService.unlockPod(podId, userId);
    return { message: 'Pod unlocked successfully' };
  }

  // ==================== EDGES ====================

  @Post('edges')
  @ApiOperation({ summary: 'Create an edge (connection)' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiResponse({ status: 201, type: EdgeResponseDto })
  @ApiBadRequestResponse({ description: 'Invalid input' })
  async createEdge(
    @Param('workspaceId') workspaceId: string,
    @GetCurrentUserId() userId: string,
    @Body(ValidationPipe) dto: CreateEdgeDto,
  ): Promise<EdgeResponseDto> {
    return this.edgeService.createEdge(workspaceId, userId, dto);
  }

  @Delete('edges/:edgeId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete an edge' })
  @ApiParam({ name: 'workspaceId', description: 'Workspace ID' })
  @ApiParam({ name: 'flowId', description: 'Flow ID' })
  @ApiParam({ name: 'edgeId', description: 'Edge ID' })
  @ApiResponse({ status: 204, description: 'Edge deleted' })
  @ApiNotFoundResponse({ description: 'Edge not found' })
  async deleteEdge(
    @Param('workspaceId') workspaceId: string,
    @Param('edgeId') edgeId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<void> {
    await this.edgeService.deleteEdge(edgeId, workspaceId, userId);
  }
}

```

### `apps\backend\src\v1\pods\pod.module.ts`

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { V1PodController } from './pod.controller';
import { V1PodService } from './pod.service';
import { V1EdgeService } from './edge.service';
import { PrismaModule } from '../../prisma/prisma.module';
import { AwsModule } from '../../common/aws/aws.module';
import { V1FlowModule } from '../flow/flow.module';

@Module({
  imports: [PrismaModule, AwsModule, forwardRef(() => V1FlowModule)],
  controllers: [V1PodController],
  providers: [V1PodService, V1EdgeService],
  exports: [V1PodService, V1EdgeService],
})
export class V1PodModule {}

```

### `apps\backend\src\v1\pods\pod.service.ts`

```typescript
import {
  Injectable,
  Logger,
  NotFoundException,
  InternalServerErrorException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { PodType, PodExecutionStatus } from '@actopod/schema';
import { plainToInstance } from 'class-transformer';
import { CreatePodDto } from './dto/create-pod.dto';
import { UpdatePodDto } from './dto/update-pod.dto';
import { PodResponseDto, EdgeResponseDto, FlowCanvasResponseDto } from './dto/pod-response.dto';
import { DynamoPodItem, PodContent } from './types/pod-content.types';
import { DynamoDbService } from '../../common/aws/dynamodb/dynamodb.service';
import { V1FlowGateway } from '../flow/flow.gateway';

@Injectable()
export class V1PodService {
  private readonly logger = new Logger(V1PodService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly dynamoDb: DynamoDbService,
    private readonly flowGateway: V1FlowGateway,
  ) {}

  /**
   * Get all pods and edges in a flow
   * Fetches metadata from PostgreSQL and content from DynamoDB
   */
  async getFlowCanvas(flowId: string, workspaceId: string): Promise<FlowCanvasResponseDto> {
    try {
      // Verify flow exists and user has access
      const flow = await this.prisma.flow.findFirst({
        where: { id: flowId, workspaceId },
      });

      if (!flow) {
        throw new NotFoundException(`Flow ${flowId} not found`);
      }

      const [pods, edges] = await Promise.all([
        this.prisma.pod.findMany({
          where: { flowId },
          orderBy: { createdAt: 'asc' },
        }),
        this.prisma.edge.findMany({
          where: { flowId },
          orderBy: { createdAt: 'asc' },
        }),
      ]);

      const tableName = this.dynamoDb.getTableNames().pods;

      // Fetch DynamoDB content for all pods
      const podsWithContent = await Promise.all(
        pods.map(async (pod) => {
          try {
            const dynamoItem = await this.dynamoDb.getItem(tableName, {
              pk: pod.dynamoPartitionKey,
              sk: pod.dynamoSortKey,
            });

            return plainToInstance(
              PodResponseDto,
              {
                ...pod,
                content: dynamoItem?.content || null,
                contextPods: dynamoItem?.contextPods || [],
              },
              { excludeExtraneousValues: true },
            );
          } catch (err) {
            this.logger.warn(
              `Failed to fetch content for pod ${pod.id}: ${err instanceof Error ? err.message : 'Unknown error'}`,
            );
            // Return pod with null content instead of failing entire request
            return plainToInstance(
              PodResponseDto,
              { ...pod, content: null, contextPods: [] },
              { excludeExtraneousValues: true },
            );
          }
        }),
      );

      const edgeResponses = edges.map((edge) =>
        plainToInstance(EdgeResponseDto, edge, { excludeExtraneousValues: true }),
      );

      this.logger.debug(
        `âœ… Fetched canvas for flow ${flowId}: ${podsWithContent.length} pods, ${edgeResponses.length} edges`,
      );

      return {
        pods: podsWithContent,
        edges: edgeResponses,
      };
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to fetch canvas for flow ${flowId}`, error);
      throw new InternalServerErrorException('Failed to fetch flow canvas');
    }
  }

  /**
   * Create a new pod with content in DynamoDB
   */
  async createPod(workspaceId: string, userId: string, dto: CreatePodDto): Promise<PodResponseDto> {
    try {
      // Verify flow exists
      const flow = await this.prisma.flow.findFirst({
        where: { id: dto.flowId, workspaceId },
      });

      if (!flow) {
        throw new NotFoundException(`Flow ${dto.flowId} not found`);
      }

      // Validate config based on pod type
      this.validatePodConfig(dto.type, dto.config);

      const podId = this.generateId();
      const pk = `WORKSPACE#${workspaceId}`;
      const sk = `FLOW#${dto.flowId}#POD#${podId}`;
      const gsi1pk = `FLOW#${dto.flowId}`;
      const gsi1sk = `POD#${podId}`;

      // Serialize position to plain object
      const positionPlain = this.serializePosition(dto.position);

      const content: PodContent = {
        type: dto.type,
        label: dto.label,
        description: dto.description,
        position: positionPlain,
        config: dto.config,
        inputs: this.getDefaultInputs(dto.type),
        outputs: this.getDefaultOutputs(dto.type),
        metadata: dto.metadata || {},
      } as any;

      const dynamoItem: DynamoPodItem = {
        pk,
        sk,
        gsi1pk,
        gsi1sk,
        podId,
        flowId: dto.flowId,
        workspaceId,
        content,
        connectedPods: [],
        contextPods: dto.contextPods || [],
        version: 1,
        createdBy: userId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Save to DynamoDB first
      const tableName = this.dynamoDb.getTableNames().pods;
      await this.dynamoDb.putItem(tableName, dynamoItem);

      // Then save to PostgreSQL
      const pod = await this.prisma.pod.create({
        data: {
          id: podId,
          flowId: dto.flowId,
          type: dto.type,
          position: positionPlain,
          executionStatus: PodExecutionStatus.IDLE,
          dynamoPartitionKey: pk,
          dynamoSortKey: sk,
        },
      });

      this.logger.log(
        `âœ… Pod created: ${pod.id} (${dto.type}) in flow ${dto.flowId} by user ${userId}`,
      );

      const result = plainToInstance(
        PodResponseDto,
        {
          ...pod,
          content,
          contextPods: dto.contextPods || [],
        },
        { excludeExtraneousValues: true },
      );

      // Broadcast to all users in the flow
      this.flowGateway.broadcastToFlow(dto.flowId, 'pod:created', {
        pod: result,
        userId,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof BadRequestException) throw error;
      this.logger.error('âŒ Failed to create pod', error);
      throw new InternalServerErrorException('Failed to create pod');
    }
  }

  /**
   * Update pod content in DynamoDB
   */
  async updatePod(
    podId: string,
    workspaceId: string,
    userId: string,
    dto: UpdatePodDto,
  ): Promise<PodResponseDto> {
    try {
      // Fetch pod with flow for workspace validation
      const pod = await this.prisma.pod.findFirst({
        where: {
          id: podId,
          flow: { workspaceId },
        },
      });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      // Check if pod is locked by another user
      if (pod.lockedBy && pod.lockedBy !== userId) {
        throw new ConflictException(`Pod is locked by user ${pod.lockedBy}`);
      }

      const tableName = this.dynamoDb.getTableNames().pods;
      const existingItem = (await this.dynamoDb.getItem(tableName, {
        pk: pod.dynamoPartitionKey,
        sk: pod.dynamoSortKey,
      })) as DynamoPodItem | null;

      if (!existingItem) {
        throw new NotFoundException('Pod content not found in DynamoDB');
      }

      // Serialize position if provided
      const positionPlain = dto.position ? this.serializePosition(dto.position) : undefined;

      // Merge config changes (deep merge for partial updates)
      const updatedConfig = dto.config
        ? this.mergeConfig(existingItem.content.config, dto.config)
        : existingItem.content.config;

      const updatedContent: PodContent = {
        ...existingItem.content,
        ...(dto.label && { label: dto.label }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(positionPlain && { position: positionPlain }),
        config: updatedConfig,
        ...(dto.metadata && {
          metadata: { ...existingItem.content.metadata, ...dto.metadata },
        }),
      };

      const updatedItem: DynamoPodItem = {
        ...existingItem,
        content: updatedContent,
        contextPods: dto.contextPods ?? existingItem.contextPods,
        version: existingItem.version + 1,
        updatedAt: new Date().toISOString(),
      };

      // Update DynamoDB
      await this.dynamoDb.putItem(tableName, updatedItem);

      // Update PostgreSQL position if changed
      if (positionPlain) {
        await this.prisma.pod.update({
          where: { id: podId },
          data: { position: positionPlain },
        });
      }

      this.logger.log(`âœ… Pod updated: ${podId} by user ${userId}`);

      const result = plainToInstance(
        PodResponseDto,
        {
          ...pod,
          position: positionPlain || pod.position,
          content: updatedContent,
          contextPods: updatedItem.contextPods,
        },
        { excludeExtraneousValues: true },
      );

      // Broadcast update to all users
      this.flowGateway.broadcastToFlow(pod.flowId, 'pod:updated', {
        podId,
        updates: result,
        userId,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof BadRequestException
      )
        throw error;
      this.logger.error(`âŒ Failed to update pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to update pod');
    }
  }

  /**
   * Delete pod from both PostgreSQL and DynamoDB
   */
  async deletePod(podId: string, workspaceId: string, userId: string): Promise<void> {
    try {
      const pod = await this.prisma.pod.findFirst({
        where: {
          id: podId,
          flow: { workspaceId },
        },
      });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      const flowId = pod.flowId;

      // Delete from DynamoDB first
      const tableName = this.dynamoDb.getTableNames().pods;
      await this.dynamoDb.deleteItem(tableName, {
        pk: pod.dynamoPartitionKey,
        sk: pod.dynamoSortKey,
      });

      // Then delete from PostgreSQL (cascades edges automatically via schema)
      await this.prisma.pod.delete({
        where: { id: podId },
      });

      this.logger.log(`âœ… Pod deleted: ${podId} by user ${userId}`);

      // Broadcast deletion
      this.flowGateway.broadcastToFlow(flowId, 'pod:deleted', {
        podId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`âŒ Failed to delete pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to delete pod');
    }
  }

  /**
   * Lock pod for editing
   */
  async lockPod(podId: string, userId: string): Promise<void> {
    try {
      const pod = await this.prisma.pod.findUnique({ where: { id: podId } });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      if (pod.lockedBy && pod.lockedBy !== userId) {
        throw new ConflictException(`Pod is already locked by user ${pod.lockedBy}`);
      }

      await this.prisma.pod.update({
        where: { id: podId },
        data: {
          lockedBy: userId,
          lockedAt: new Date(),
        },
      });

      this.logger.debug(`ðŸ”’ Pod locked: ${podId} by user ${userId}`);

      // Broadcast lock status
      this.flowGateway.broadcastToFlow(pod.flowId, 'pod:locked', {
        podId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ConflictException) throw error;
      this.logger.error(`Failed to lock pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to lock pod');
    }
  }

  /**
   * Unlock pod after editing
   */
  async unlockPod(podId: string, userId: string): Promise<void> {
    try {
      const pod = await this.prisma.pod.findUnique({ where: { id: podId } });

      if (!pod) {
        throw new NotFoundException(`Pod ${podId} not found`);
      }

      if (pod.lockedBy && pod.lockedBy !== userId) {
        throw new ConflictException(`Cannot unlock pod locked by another user`);
      }

      await this.prisma.pod.update({
        where: { id: podId },
        data: {
          lockedBy: null,
          lockedAt: null,
        },
      });

      this.logger.debug(`ðŸ”“ Pod unlocked: ${podId} by user ${userId}`);

      // Broadcast unlock status
      this.flowGateway.broadcastToFlow(pod.flowId, 'pod:unlocked', {
        podId,
        userId,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ConflictException) throw error;
      this.logger.error(`Failed to unlock pod ${podId}`, error);
      throw new InternalServerErrorException('Failed to unlock pod');
    }
  }

  // ==================== PRIVATE HELPER METHODS ====================

  private validatePodConfig(type: PodType, config: any): void {
    if (type === PodType.LLM_PROMPT) {
      if (!config.provider || !config.model) {
        throw new BadRequestException('LLM pods require provider and model in config');
      }
    }
  }

  private serializePosition(position: any): { x: number; y: number } {
    return JSON.parse(JSON.stringify(position));
  }

  private mergeConfig(existing: any, updates: any): any {
    return { ...existing, ...updates };
  }

  private getDefaultInputs(type: PodType) {
    switch (type) {
      case PodType.LLM_PROMPT:
        return [
          { id: 'input', label: 'Input', type: 'target' as const, dataType: 'string' as const },
          {
            id: 'context',
            label: 'Context',
            type: 'target' as const,
            dataType: 'document' as const,
          },
        ];
      case PodType.TEXT_OUTPUT:
      case PodType.IMAGE_OUTPUT:
        return [{ id: 'input', label: 'Input', type: 'target' as const, dataType: 'any' as const }];
      default:
        return [];
    }
  }

  private getDefaultOutputs(type: PodType) {
    switch (type) {
      case PodType.TEXT_INPUT:
      case PodType.LLM_PROMPT:
      case PodType.CODE_EXECUTION:
        return [
          { id: 'output', label: 'Output', type: 'source' as const, dataType: 'string' as const },
        ];
      case PodType.DOCUMENT_INPUT:
        return [
          {
            id: 'output',
            label: 'Document',
            type: 'source' as const,
            dataType: 'document' as const,
          },
        ];
      case PodType.IMAGE_INPUT:
        return [
          { id: 'output', label: 'Image', type: 'source' as const, dataType: 'image' as const },
        ];
      default:
        return [];
    }
  }

  private generateId(): string {
    return `pod_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

```

### `apps\backend\src\v1\pods\types\pod-content.types.ts`

```typescript
import { LLMProvider } from '@actopod/schema';

// ==========================================
// CORE TYPES
// ==========================================

export type PodPort = {
  id: string;
  label: string;
  type: 'source' | 'target';
  dataType:
    | 'string'
    | 'number'
    | 'boolean'
    | 'object'
    | 'array'
    | 'document'
    | 'image'
    | 'video'
    | 'audio'
    | 'any';
};

export type Position = {
  x: number;
  y: number;
};

// ==========================================
// POD CONFIGURATIONS (TYPE-SPECIFIC)
// ==========================================

export type LLMConfig = {
  provider: LLMProvider;
  model: string;
  systemPrompt?: string;
  userPrompt: string;
  temperature?: number;
  maxTokens?: number;
  thinkingBudget?: number;
  topP?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;
  responseFormat?: 'text' | 'json' | 'json_object';
  streamEnabled?: boolean;
};

export type TextInputConfig = {
  text: string;
  placeholder?: string;
  multiline?: boolean;
  maxLength?: number;
};

export type DocumentInputConfig = {
  documentId: string;
  extractionType: 'full' | 'chunk';
  chunkSize?: number;
  chunkOverlap?: number;
};

export type URLInputConfig = {
  url: string;
  extractionType: 'full' | 'summary';
  timeout?: number;
};

export type ImageInputConfig = {
  imageUrl?: string;
  imageS3Key?: string;
  altText?: string;
};

export type VideoInputConfig = {
  videoUrl?: string;
  videoS3Key?: string;
  transcriptionEnabled?: boolean;
};

export type AudioInputConfig = {
  audioUrl?: string;
  audioS3Key?: string;
  transcriptionEnabled?: boolean;
};

export type CodeExecutionConfig = {
  language: 'javascript' | 'python' | 'typescript';
  code: string;
  timeout?: number;
};

export type EmbeddingConfig = {
  provider: LLMProvider;
  model: string;
  dimensions?: number;
};

export type ToolConfig = {
  toolName: string;
  toolParameters: Record<string, any>;
};

export type OutputConfig = {
  format?: 'text' | 'json' | 'markdown';
  saveToS3?: boolean;
};

export type ContextModuleConfig = {
  contextModuleId: string;
  parameters?: Record<string, any>;
};

export type FlowContextInputConfig = {
  sourceFlowId: string;
  selectedPodIds?: string[];
};

// ==========================================
// UNIFIED POD CONTENT (ALL TYPES)
// ==========================================

export type PodContent =
  | {
      type: 'LLM_PROMPT';
      label: string;
      description?: string;
      position: Position;
      config: LLMConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'TEXT_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: TextInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'DOCUMENT_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: DocumentInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'URL_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: URLInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'IMAGE_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: ImageInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'VIDEO_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: VideoInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'AUDIO_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: AudioInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'CODE_EXECUTION';
      label: string;
      description?: string;
      position: Position;
      config: CodeExecutionConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'EMBEDDING_POD';
      label: string;
      description?: string;
      position: Position;
      config: EmbeddingConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'TOOL_POD';
      label: string;
      description?: string;
      position: Position;
      config: ToolConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'TEXT_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'IMAGE_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'VIDEO_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'AUDIO_OUTPUT';
      label: string;
      description?: string;
      position: Position;
      config: OutputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'CONTEXT_MODULE';
      label: string;
      description?: string;
      position: Position;
      config: ContextModuleConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    }
  | {
      type: 'FLOW_CONTEXT_INPUT';
      label: string;
      description?: string;
      position: Position;
      config: FlowContextInputConfig;
      inputs: PodPort[];
      outputs: PodPort[];
      metadata?: Record<string, any>;
    };

// ==========================================
// CONTEXT MAPPINGS (PINNED EXECUTIONS)
// ==========================================

export type PodContextMapping = {
  sourcePodId: string;
  pinnedExecutionId: string | null;
};

// ==========================================
// DYNAMODB POD ITEM
// ==========================================

export type DynamoPodItem = {
  pk: string;
  sk: string;
  gsi1pk: string;
  gsi1sk: string;
  podId: string;
  flowId: string;
  workspaceId: string;
  content: PodContent;
  connectedPods: string[];
  contextPods: string[];
  contextMappings?: PodContextMapping[];
  version: number;
  createdBy: string;
  createdAt: string;
  updatedAt: string;
  ttl?: number;
};

// ==========================================
// TYPE GUARDS (ALL POD TYPES)
// ==========================================

export type LLMPromptPodContent = Extract<PodContent, { type: 'LLM_PROMPT' }>;
export type TextInputPodContent = Extract<PodContent, { type: 'TEXT_INPUT' }>;
export type DocumentInputPodContent = Extract<PodContent, { type: 'DOCUMENT_INPUT' }>;
export type URLInputPodContent = Extract<PodContent, { type: 'URL_INPUT' }>;
export type ImageInputPodContent = Extract<PodContent, { type: 'IMAGE_INPUT' }>;
export type VideoInputPodContent = Extract<PodContent, { type: 'VIDEO_INPUT' }>;
export type AudioInputPodContent = Extract<PodContent, { type: 'AUDIO_INPUT' }>;
export type CodeExecutionPodContent = Extract<PodContent, { type: 'CODE_EXECUTION' }>;
export type EmbeddingPodContent = Extract<PodContent, { type: 'EMBEDDING_POD' }>;
export type ToolPodContent = Extract<PodContent, { type: 'TOOL_POD' }>;
export type TextOutputPodContent = Extract<PodContent, { type: 'TEXT_OUTPUT' }>;
export type ImageOutputPodContent = Extract<PodContent, { type: 'IMAGE_OUTPUT' }>;
export type VideoOutputPodContent = Extract<PodContent, { type: 'VIDEO_OUTPUT' }>;
export type AudioOutputPodContent = Extract<PodContent, { type: 'AUDIO_OUTPUT' }>;
export type ContextModulePodContent = Extract<PodContent, { type: 'CONTEXT_MODULE' }>;
export type FlowContextInputPodContent = Extract<PodContent, { type: 'FLOW_CONTEXT_INPUT' }>;

```

### `apps\backend\src\v1\server\health\health.controller.ts`

```typescript
import { Controller, Get } from '@nestjs/common';
import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';
import { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';
import { PrismaHealthIndicator } from './prisma.health';
import { Public } from '../../../common/decorators/common';

@Controller({ version: '1', path: 'health' })
@ApiTags('Health')
export class V1HealthController {
  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
    private prismaHealthIndicator: PrismaHealthIndicator,
  ) {}

  @Public()
  @Get()
  @HealthCheck()
  @ApiOperation({ summary: 'Perform health checks for the application' })
  @ApiResponse({
    status: 200,
    description: 'Health check successful',
    schema: {
      example: {
        statusCode: 200,
        message: 'Health check successful',
        data: {
          details: {
            google: { status: 'up' },
            database: { status: 'up' },
          },
          error: {},
          info: {
            google: { status: 'up' },
            database: { status: 'up' },
          },
        },
        errors: [],
        timestamp: '2024-09-08T17:38:42.611Z',
      },
    },
  })
  @ApiResponse({
    status: 500,
    description: 'Health check failed',
    schema: {
      example: {
        statusCode: 500,
        message: 'Health check failed',
        data: null,
        errors: ['Health check failure message'],
        timestamp: '2024-09-08T17:38:42.611Z',
      },
    },
  })
  async check() {
    const healthChecks = [
      () => this.http.pingCheck('google', 'https://www.google.com'),
      () => this.prismaHealthIndicator.isHealthy('database'),
    ];

    try {
      const result = await this.health.check(healthChecks);

      return {
        statusCode: 200,
        message: 'Health check successful',
        data: result,
        errors: [],
        timestamp: new Date().toISOString(),
      };
    } catch (error: any) {
      return {
        statusCode: error?.response?.status || 500,
        message: 'Health check failed',
        data: error?.response || null,
        errors: [error?.message || 'Unknown error'],
        timestamp: new Date().toISOString(),
      };
    }
  }
}

```

### `apps\backend\src\v1\server\health\health.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HttpModule } from '@nestjs/axios';
import { V1HealthController } from './health.controller';
import { PrismaHealthIndicator } from './prisma.health';
import { PrismaModule } from '../../../prisma/prisma.module';

@Module({
  imports: [TerminusModule, HttpModule, PrismaModule],
  controllers: [V1HealthController],
  providers: [PrismaHealthIndicator],
})
export class V1HealthModule {}

```

### `apps\backend\src\v1\server\health\prisma.health.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class PrismaHealthIndicator extends HealthIndicator {
  constructor(private readonly prisma: PrismaService) {
    super();
  }

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return this.getStatus(key, true);
    } catch (error: any) {
      const status = this.getStatus(key, false, { message: error?.message });
      throw new HealthCheckError('Prisma check failed', status);
    }
  }
}

```

### `apps\backend\src\v1\server\server.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1HealthModule as V1HealthModule } from './health/health.module';

@Module({
  imports: [V1HealthModule],
  exports: [V1HealthModule],
})
export class V1ServerModule {}

```

### `apps\backend\src\v1\user\user.controller.ts`

```typescript
import { Controller, Get, Logger } from '@nestjs/common';
import { V1UserService } from './user.service';
import { GetCurrentUserId } from '../../common/decorators/user';

@Controller('users')
export class V1UserController {
  private readonly logger = new Logger(V1UserController.name);

  constructor(private readonly userService: V1UserService) {}

  /**
   * GET /api/v1/users/me
   * Get current authenticated user
   */
  @Get('me')
  async getMe(@GetCurrentUserId('userId') userId: string) {
    this.logger.log(`User me endpoint called by: ${userId}`);

    const user = await this.userService.getCurrentUser(userId);

    return {
      statusCode: 200,
      message: 'User fetched successfully',
      data: {
        userId: user.id,
        email: user.email,
        name: user.name,
        image: user.image,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      errors: [],
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * GET /api/v1/users/me/verification-status
   * Check email verification status
   */
  @Get('me/verification-status')
  async getVerificationStatus(@GetCurrentUserId('userId') userId: string) {
    this.logger.log(`Verification status check for: ${userId}`);

    const status = await this.userService.checkEmailVerificationStatus(userId);

    return {
      statusCode: 200,
      message: 'Verification status fetched successfully',
      data: status,
      errors: [],
      timestamp: new Date().toISOString(),
    };
  }
}

```

### `apps\backend\src\v1\user\user.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { PrismaModule } from '../../prisma/prisma.module';
import { V1UserController } from './user.controller';
import { V1UserService } from './user.service';

@Module({
  imports: [PrismaModule],
  controllers: [V1UserController],
  providers: [V1UserService],
  exports: [V1UserService],
})
export class V1UserModule {}

```

### `apps\backend\src\v1\user\user.service.ts`

```typescript
import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class V1UserService {
  private readonly logger = new Logger(V1UserService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get user by ID with selected fields
   */
  async findById(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        image: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  /**
   * Get current authenticated user
   */
  async getCurrentUser(userId: string) {
    this.logger.log(`Fetching user data for: ${userId}`);
    return this.findById(userId);
  }

  /**
   * Get user with accounts (for checking email verification status)
   */
  async getUserWithAccounts(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        accounts: {
          select: {
            provider: true,
            providerAccountId: true,
            accessToken: true,
          },
        },
      },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  /**
   * Check if user's email is verified
   */
  async checkEmailVerificationStatus(userId: string): Promise<{
    isVerified: boolean;
    email: string;
  }> {
    const user = await this.getUserWithAccounts(userId);

    // Find email account
    const emailAccount = user.accounts.find((acc) => acc.provider === 'EMAIL');

    // Email is verified if:
    // 1. No email account exists (OAuth user)
    // 2. Email account exists but accessToken is null (verified)
    const isVerified = !emailAccount || !emailAccount.accessToken;

    return {
      isVerified,
      email: user.email,
    };
  }
}

```

### `apps\backend\src\v1\workspace\dto\workspace-add-api-key.dto.ts`

```typescript
// src/modules/workspace/dto/workspace-add-api-key.dto.ts

import { IsString, IsEnum, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { LLMProvider } from '@actopod/schema';

export class WorkspaceAddApiKeyDto {
  @ApiProperty({
    description: 'LLM provider',
    enum: LLMProvider,
    example: 'OPENAI',
  })
  @IsEnum(LLMProvider)
  provider!: LLMProvider;

  @ApiProperty({
    description: 'Display name for the key',
    example: 'My OpenAI Key',
    maxLength: 100,
  })
  @IsString()
  @MaxLength(100)
  displayName!: string;

  @ApiProperty({
    description: 'The API key (will be encrypted)',
    example: 'sk-proj-abc123...',
  })
  @IsString()
  apiKey!: string;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-create.dto.ts`

```typescript
import { IsString, IsNotEmpty, MaxLength, IsEnum, IsOptional } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { WorkspaceType } from '@actopod/schema';

/**
 * DTO for creating a new workspace
 * Only TEAM workspaces can be created via API (PERSONAL auto-created on registration)
 */
export class WorkspaceCreateDto {
  @ApiProperty({
    description: 'Workspace name',
    example: 'My Team Workspace',
    maxLength: 255,
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  name!: string;

  @ApiProperty({
    description: 'Workspace type (PERSONAL workspaces are auto-created)',
    enum: WorkspaceType,
    default: WorkspaceType.TEAM,
    required: false,
  })
  @IsEnum(WorkspaceType)
  @IsOptional()
  type?: WorkspaceType = WorkspaceType.TEAM;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-send-invitation.dto.ts`

```typescript
import { IsEmail, IsEnum, IsOptional, IsObject } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { WorkspaceRole } from '@actopod/schema';

/**
 * DTO for sending workspace invitation via email
 * Requires canInviteMembers permission
 */
export class WorkspaceSendInvitationDto {
  @ApiProperty({
    description: 'Email to send invitation',
    example: 'invite@example.com',
  })
  @IsEmail()
  email!: string;

  @ApiProperty({
    description: 'Role for invited user',
    enum: WorkspaceRole,
    default: WorkspaceRole.MEMBER,
    required: false,
  })
  @IsEnum(WorkspaceRole)
  @IsOptional()
  role?: WorkspaceRole = WorkspaceRole.MEMBER;

  @ApiProperty({
    description: 'Custom permissions (optional override)',
    required: false,
    example: { canCreateCanvas: true, canDeleteCanvas: false },
  })
  @IsObject()
  @IsOptional()
  permissions?: Record<string, boolean>;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-update.dto.ts`

```typescript
import { IsString, IsNotEmpty, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

/**
 * DTO for updating workspace details
 * Currently only name is updatable
 */
export class WorkspaceUpdateDto {
  @ApiProperty({
    description: 'Updated workspace name',
    example: 'Updated Team Name',
    maxLength: 255,
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  name!: string;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-update-api-key.dto.ts`

```typescript
// src/modules/workspace/dto/workspace-update-api-key.dto.ts

import { IsString, IsOptional, IsBoolean, MaxLength } from 'class-validator';
import { ApiPropertyOptional } from '@nestjs/swagger';

export class WorkspaceUpdateApiKeyDto {
  @ApiPropertyOptional({
    description: 'Display name',
    example: 'Updated Key Name',
    maxLength: 100,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  displayName?: string;

  @ApiPropertyOptional({
    description: 'New API key (for rotation)',
    example: 'sk-proj-xyz789...',
  })
  @IsOptional()
  @IsString()
  apiKey?: string;

  @ApiPropertyOptional({
    description: 'Active status',
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

```

### `apps\backend\src\v1\workspace\dto\workspace-update-member.dto.ts`

```typescript
import { IsEnum, IsOptional, IsBoolean } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { WorkspaceRole } from '@actopod/schema';

/**
 * DTO for updating existing member's role and permissions
 * Cannot modify workspace OWNER
 */
export class WorkspaceUpdateMemberDto {
  @ApiProperty({
    description: 'Updated role',
    enum: WorkspaceRole,
    required: false,
  })
  @IsEnum(WorkspaceRole)
  @IsOptional()
  role?: WorkspaceRole;

  @ApiProperty({
    description: 'Can create canvas',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canCreateCanvas?: boolean;

  @ApiProperty({
    description: 'Can delete canvas',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canDeleteCanvas?: boolean;

  @ApiProperty({
    description: 'Can invite members',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canInviteMembers?: boolean;

  @ApiProperty({
    description: 'Can manage members',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canManageMembers?: boolean;

  @ApiProperty({
    description: 'Can manage API keys',
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  canManageApiKeys?: boolean;
}

```

### `apps\backend\src\v1\workspace\types\workspace.types.ts`

```typescript
// src/modules/workspace/types/workspace.types.ts

import { WorkspaceType, WorkspaceRole, InvitationStatus, LLMProvider } from '@actopod/schema';

export interface InvitationDetailsResponse {
  workspace: {
    id: string;
    name: string;
    type: string;
  };
  email: string;
  role: string;
  permissions: Record<string, boolean> | null;
  expiresAt: Date;
  status: string;
}
/**
 * Response type for workspace list
 */
export interface WorkspaceListItem {
  id: string;
  name: string;
  type: WorkspaceType;
  role: WorkspaceRole;
  permissions: {
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
  };
  memberCount: number;
  canvasCount: number;
  joinedAt: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Response type for workspace details
 */
export interface WorkspaceDetails {
  id: string;
  name: string;
  type: WorkspaceType;
  createdAt: Date;
  updatedAt: Date;
  members: Array<{
    userId: string;
    workspaceId: string;
    role: WorkspaceRole;
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
    joinedAt: Date;
    invitedBy: string | null;
    user: {
      id: string;
      email: string;
      name: string | null;
      image: string | null;
    };
  }>;
  _count: {
    flows: number;
    documents: number;
    apiKeys: number;
  };
  currentUserRole: WorkspaceRole;
  currentUserPermissions: {
    canCreateCanvas: boolean;
    canDeleteCanvas: boolean;
    canManageBilling: boolean;
    canInviteMembers: boolean;
    canManageMembers: boolean;
    canManageApiKeys: boolean;
  };
}

/**
 * Response type for workspace member
 */
export interface WorkspaceMemberResponse {
  userId: string;
  workspaceId: string;
  role: WorkspaceRole;
  canCreateCanvas: boolean;
  canDeleteCanvas: boolean;
  canManageBilling: boolean;
  canInviteMembers: boolean;
  canManageMembers: boolean;
  canManageApiKeys: boolean;
  joinedAt: Date;
  invitedBy: string | null;
  user: {
    id: string;
    email: string;
    name: string | null;
    image: string | null;
  };
}

/**
 * Simplified API key response (with usage tracking)
 */
export interface ApiKeyResponse {
  id: string;
  provider: LLMProvider;
  displayName: string;
  isActive: boolean;
  lastUsedAt: Date | null;
  createdAt: Date;

  // Usage metrics
  usageCount: number;
  totalTokens: string; // BigInt as string
  totalCost: number;

  // Error tracking
  lastErrorAt: Date | null;

  // Creator
  createdBy: {
    id: string;
    name: string | null;
    email: string;
  };
}

/**
 * Response type for invitations
 */
export interface InvitationResponse {
  id: string;
  workspaceId: string;
  email: string;
  role: WorkspaceRole;
  permissions: any;
  token: string;
  status: InvitationStatus;
  expiresAt: Date;
  createdAt: Date;
  invitedBy: string;
  invitedUserId: string | null;
  acceptedAt: Date | null;
}

/**
 * Response type for invitation acceptance
 */
export interface AcceptInvitationResponse {
  workspace: {
    id: string;
    name: string;
    type: WorkspaceType;
    createdAt: Date;
    updatedAt: Date;
  };
  member: any;
  message: string;
}

/**
 * Standard message response
 */
export interface MessageResponse {
  message: string;
}

/**
 * API key usage statistics (simplified)
 */
export interface ApiKeyUsageStats {
  totalKeys: number;
  activeKeys: number;
  inactiveKeys: number;
  providerBreakdown: Record<string, number>;

  // Cumulative metrics
  totalUsageCount: number;
  totalTokensConsumed: string; // BigInt as string
  totalCostIncurred: number;
}

/**
 * Usage metric response (daily aggregated)
 */
export interface UsageMetricResponse {
  id: string;
  date: Date;
  requestCount: number;
  successCount: number;
  errorCount: number;
  promptTokens: string; // BigInt as string
  completionTokens: string; // BigInt as string
  totalTokens: string; // BigInt as string
  estimatedCost: number;
}

```

### `apps\backend\src\v1\workspace\workspace.controller.ts`

```typescript
// src/modules/workspace/workspace.controller.ts

import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  HttpCode,
  HttpStatus,
  Query,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { V1WorkspaceService } from './workspace.service';
import { GetCurrentUserId } from '../../common/decorators/user';
import { WorkspaceCreateDto } from './dto/workspace-create.dto';
import { WorkspaceUpdateDto } from './dto/workspace-update.dto';
import { WorkspaceUpdateMemberDto } from './dto/workspace-update-member.dto';
import { WorkspaceSendInvitationDto } from './dto/workspace-send-invitation.dto';
import { WorkspaceAddApiKeyDto } from './dto/workspace-add-api-key.dto';
import { WorkspaceUpdateApiKeyDto } from './dto/workspace-update-api-key.dto';
import {
  WorkspaceListItem,
  WorkspaceDetails,
  WorkspaceMemberResponse,
  ApiKeyResponse,
  InvitationResponse,
  MessageResponse,
  UsageMetricResponse,
  ApiKeyUsageStats,
} from './types/workspace.types';
import { Public } from '../../common/decorators/common';

/**
 * V1 Workspace Controller
 *
 * @description Comprehensive workspace management controller handling:
 * - Workspace CRUD operations (create, read, update, delete)
 * - Team member management (add, update, remove)
 * - Email-based invitation system with secure tokens
 * - LLM provider API key management with AES-256-GCM encryption
 * - API key usage tracking and cost analytics
 * - Ownership transfer and workspace statistics
 *
 * @security Requires JWT Bearer token authentication for all endpoints
 * @version 1.0.0
 * @author Actopod Team
 * @see {@link V1WorkspaceService} for business logic implementation
 *
 * @remarks
 * All endpoints enforce workspace membership and permission checks.
 * OWNER role has all permissions by default.
 * PERSONAL workspaces cannot be created manually or deleted.
 */
@ApiTags('Workspaces')
@ApiBearerAuth()
@Controller({ path: 'workspaces', version: '1' })
export class V1WorkspaceController {
  constructor(private readonly workspaceService: V1WorkspaceService) {}

  // ==========================================
  // WORKSPACE CRUD OPERATIONS
  // ==========================================

  /**
   * Get all workspaces for current user
   *
   * @description Retrieves all workspaces where the authenticated user is a member.
   * Returns comprehensive information including role, granular permissions,
   * member count, canvas count, and join date for each workspace.
   *
   * @returns {Promise<WorkspaceListItem[]>} Array of workspace summaries
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   *
   * @example
   * ```
   * GET /api/v1/workspaces
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * [
   *   {
   *     "id": "clx123abc",
   *     "name": "My Team",
   *     "type": "TEAM",
   *     "role": "OWNER",
   *     "permissions": {
   *       "canCreateCanvas": true,
   *       "canDeleteCanvas": true,
   *       "canManageBilling": true,
   *       "canInviteMembers": true,
   *       "canManageMembers": true,
   *       "canManageApiKeys": true
   *     },
   *     "memberCount": 5,
   *     "canvasCount": 12,
   *     "joinedAt": "2025-01-15T10:30:00Z",
   *     "createdAt": "2025-01-15T10:30:00Z",
   *     "updatedAt": "2025-10-10T14:22:00Z"
   *   }
   * ]
   * ```
   */
  @Get()
  @ApiOperation({
    summary: 'List all workspaces for current user',
    description:
      'Retrieves all workspaces where the user is a member, ordered by join date (newest first)',
  })
  @ApiResponse({
    status: 200,
    description: 'Workspaces retrieved successfully',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string', example: 'clx123abc' },
          name: { type: 'string', example: 'My Team Workspace' },
          type: { type: 'string', enum: ['PERSONAL', 'TEAM'], example: 'TEAM' },
          role: { type: 'string', enum: ['OWNER', 'ADMIN', 'MEMBER', 'VIEWER'], example: 'OWNER' },
          permissions: {
            type: 'object',
            properties: {
              canCreateCanvas: { type: 'boolean' },
              canDeleteCanvas: { type: 'boolean' },
              canManageBilling: { type: 'boolean' },
              canInviteMembers: { type: 'boolean' },
              canManageMembers: { type: 'boolean' },
              canManageApiKeys: { type: 'boolean' },
            },
          },
          memberCount: { type: 'number', example: 5 },
          canvasCount: { type: 'number', example: 12 },
          joinedAt: { type: 'string', format: 'date-time' },
          createdAt: { type: 'string', format: 'date-time' },
          updatedAt: { type: 'string', format: 'date-time' },
        },
      },
    },
  })
  @ApiResponse({ status: 401, description: 'Unauthorized - Invalid or missing token' })
  async getAllWorkspaces(@GetCurrentUserId() userId: string): Promise<WorkspaceListItem[]> {
    return this.workspaceService.getAllWorkspaces(userId);
  }

  /**
   * Get workspace details by ID
   *
   * @description Retrieves complete workspace information including all members,
   * their roles and permissions, aggregate counts, and the current user's
   * access level.
   *
   * @param {string} id - Workspace unique identifier (CUID)
   * @returns {Promise<WorkspaceDetails>} Complete workspace data
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a member of this workspace
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "id": "clx123abc",
   *   "name": "My Team",
   *   "type": "TEAM",
   *   "members": [...],
   *   "_count": {
   *     "flows": 24,
   *     "documents": 45,
   *     "apiKeys": 3
   *   },
   *   "currentUserRole": "OWNER",
   *   "currentUserPermissions": {...}
   * }
   * ```
   */
  @Get(':id')
  @ApiOperation({
    summary: 'Get workspace details by ID',
    description:
      'Retrieves detailed workspace information including members, counts, and permissions',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID (CUID)', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Workspace details retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized - Invalid or missing token' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getWorkspaceById(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<WorkspaceDetails> {
    return this.workspaceService.getWorkspaceById(id, userId);
  }

  /**
   * Get workspace statistics
   *
   * @description Retrieves aggregate statistics and analytics for a workspace,
   * including total members, flows, documents, API keys, and role distribution.
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<any>} Workspace statistics object
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a workspace member
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/stats
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "totalMembers": 8,
   *   "totalFlows": 24,
   *   "totalDocuments": 45,
   *   "totalApiKeys": 3,
   *   "roleDistribution": {
   *     "owners": 1,
   *     "admins": 2,
   *     "members": 5
   *   }
   * }
   * ```
   */
  @Get(':id/stats')
  @ApiOperation({
    summary: 'Get workspace statistics and analytics',
    description: 'Retrieves aggregate counts and role distribution for workspace',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Statistics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getWorkspaceStats(@Param('id') id: string, @GetCurrentUserId() userId: string) {
    return this.workspaceService.getWorkspaceStats(id, userId);
  }

  /**
   * Create a new workspace
   *
   * @description Creates a new TEAM workspace with the creator automatically
   * assigned as OWNER with full permissions. PERSONAL workspaces cannot be
   * created manually (they are auto-created during user registration).
   *
   * @param {WorkspaceCreateDto} dto - Workspace creation data (name and type)
   * @returns {Promise<any>} Created workspace with initial member
   *
   * @throws {400} Bad Request - Attempting to create PERSONAL workspace or invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   *
   * @example
   * ```
   * POST /api/v1/workspaces
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "name": "My New Team",
   *   "type": "TEAM"
   * }
   * ```
   */
  @Post()
  @ApiOperation({
    summary: 'Create a new workspace',
    description:
      'Creates a new TEAM workspace with creator as OWNER (PERSONAL workspaces auto-created)',
  })
  @ApiResponse({ status: 201, description: 'Workspace created successfully' })
  @ApiResponse({
    status: 400,
    description: 'Bad Request - Invalid input or PERSONAL workspace attempt',
  })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async createWorkspace(
    @Body() dto: WorkspaceCreateDto,
    @GetCurrentUserId() userId: string,
  ): Promise<any> {
    return this.workspaceService.createWorkspace(userId, dto);
  }

  /**
   * Update workspace name
   *
   * @description Updates the workspace name. Requires `canManageMembers` permission.
   * Only the workspace name can be modified; type cannot be changed after creation.
   *
   * @param {string} id - Workspace unique identifier
   * @param {WorkspaceUpdateDto} dto - Update data (name)
   * @returns {Promise<any>} Updated workspace object
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageMembers)
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * PATCH /api/v1/workspaces/clx123abc
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "name": "Updated Team Name"
   * }
   * ```
   */
  @Patch(':id')
  @ApiOperation({
    summary: 'Update workspace name',
    description: 'Updates workspace name (requires canManageMembers permission)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Workspace updated successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async updateWorkspace(
    @Param('id') id: string,
    @Body() dto: WorkspaceUpdateDto,
    @GetCurrentUserId() userId: string,
  ): Promise<any> {
    return this.workspaceService.updateWorkspace(id, userId, dto);
  }

  /**
   * Delete workspace permanently
   *
   * @description Permanently deletes a workspace and all associated data.
   * Only workspace OWNERs can delete workspaces. PERSONAL workspaces
   * cannot be deleted (tied to user account lifecycle).
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {400} Bad Request - Attempting to delete PERSONAL workspace
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Only OWNER can delete workspaces
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "message": "Workspace deleted successfully"
   * }
   * ```
   */
  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete workspace',
    description: 'Permanently deletes workspace (OWNER only, not PERSONAL workspaces)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Workspace deleted successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Cannot delete PERSONAL workspace' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Only OWNER can delete' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async deleteWorkspace(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.deleteWorkspace(id, userId);
  }

  /**
   * Transfer workspace ownership
   *
   * @description Transfers workspace ownership to another member. The current
   * OWNER is demoted to ADMIN, and the target member is promoted to OWNER
   * with all permissions. Only the current OWNER can initiate transfer.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} newOwnerId - User ID of new owner (must be existing member)
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Only current OWNER can transfer ownership
   * @throws {404} Not Found - Workspace or target user not found
   *
   * @example
   * ```
   * POST /api/v1/workspaces/clx123abc/transfer-ownership/user_456
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Post(':id/transfer-ownership/:userId')
  @ApiOperation({
    summary: 'Transfer workspace ownership',
    description: 'Transfers ownership to another member (current OWNER becomes ADMIN)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'userId', description: 'New owner user ID', example: 'user_456' })
  @ApiResponse({ status: 200, description: 'Ownership transferred successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Only OWNER can transfer' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace or user not found' })
  async transferOwnership(
    @Param('id') id: string,
    @Param('userId') newOwnerId: string,
    @GetCurrentUserId() currentUserId: string,
  ) {
    return this.workspaceService.transferOwnership(id, currentUserId, newOwnerId);
  }

  // ==========================================
  // MEMBER MANAGEMENT
  // ==========================================

  /**
   * Get all workspace members
   *
   * @description Retrieves all members of a workspace with their roles,
   * granular permissions, join dates, and user profile information.
   * Results are ordered by join date (newest first).
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<WorkspaceMemberResponse[]>} Array of workspace members
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a workspace member
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/members
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/members')
  @ApiOperation({
    summary: 'List all workspace members',
    description: 'Retrieves all members with roles, permissions, and profile info',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Members retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getMembers(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<WorkspaceMemberResponse[]> {
    return this.workspaceService.getMembers(id, userId);
  }

  /**
   * Update workspace member
   *
   * @description Updates an existing member's role and granular permissions.
   * Cannot modify workspace OWNER. Requires `canManageMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} targetUserId - User ID of member to update
   * @param {WorkspaceUpdateMemberDto} dto - Update data (role, permissions)
   * @returns {Promise<WorkspaceMemberResponse>} Updated member record
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Cannot modify OWNER or insufficient permissions
   * @throws {404} Not Found - Member not found
   *
   * @example
   * ```
   * PATCH /api/v1/workspaces/clx123abc/members/user_456
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "role": "ADMIN",
   *   "canDeleteCanvas": true,
   *   "canManageMembers": true
   * }
   * ```
   */
  @Patch(':id/members/:userId')
  @ApiOperation({
    summary: 'Update member role and permissions',
    description: 'Updates member role/permissions (cannot modify OWNER, requires canManageMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'userId', description: 'Target user ID', example: 'user_456' })
  @ApiResponse({ status: 200, description: 'Member updated successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Cannot modify OWNER or insufficient permissions',
  })
  @ApiResponse({ status: 404, description: 'Not Found - Member not found' })
  async updateMember(
    @Param('id') id: string,
    @Param('userId') targetUserId: string,
    @Body() dto: WorkspaceUpdateMemberDto,
    @GetCurrentUserId() currentUserId: string,
  ): Promise<WorkspaceMemberResponse> {
    return this.workspaceService.updateMember(id, targetUserId, currentUserId, dto);
  }

  /**
   * Remove member from workspace
   *
   * @description Removes a member from the workspace. Cannot remove workspace
   * OWNER. Auto-converts TEAM workspace to PERSONAL if only 1 member remains.
   * Requires `canManageMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} targetUserId - User ID of member to remove
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Cannot remove OWNER or insufficient permissions
   * @throws {404} Not Found - Member not found
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc/members/user_456
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Delete(':id/members/:userId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Remove member from workspace',
    description: 'Removes member (cannot remove OWNER, requires canManageMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'userId', description: 'Target user ID', example: 'user_456' })
  @ApiResponse({ status: 200, description: 'Member removed successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Cannot remove OWNER or insufficient permissions',
  })
  @ApiResponse({ status: 404, description: 'Not Found - Member not found' })
  async removeMember(
    @Param('id') id: string,
    @Param('userId') targetUserId: string,
    @GetCurrentUserId() currentUserId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.removeMember(id, targetUserId, currentUserId);
  }

  // ==========================================
  // INVITATION SYSTEM
  // ==========================================

  /**
   * Send workspace invitation via email
   *
   * @description Sends an email invitation with a secure token to join the workspace.
   * Token expires in 7 days. Invitation can be sent to both registered and
   * unregistered users. Requires `canInviteMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {WorkspaceSendInvitationDto} dto - Invitation data (email, role, permissions)
   * @returns {Promise<InvitationResponse & MessageResponse>} Created invitation with token
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canInviteMembers)
   * @throws {404} Not Found - Workspace does not exist
   * @throws {409} Conflict - User already invited or is a member
   *
   * @example
   * ```
   * POST /api/v1/workspaces/clx123abc/invitations
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "email": "newuser@example.com",
   *   "role": "MEMBER",
   *   "permissions": {
   *     "canCreateCanvas": true,
   *     "canDeleteCanvas": false
   *   }
   * }
   * ```
   */
  @Post(':id/invitations')
  @ApiOperation({
    summary: 'Send workspace invitation',
    description: 'Sends email invitation with 7-day token (requires canInviteMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 201, description: 'Invitation sent successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  @ApiResponse({ status: 409, description: 'Conflict - User already invited or is member' })
  async sendInvitation(
    @Param('id') id: string,
    @Body() dto: WorkspaceSendInvitationDto,
    @GetCurrentUserId() userId: string,
  ): Promise<InvitationResponse & MessageResponse> {
    return this.workspaceService.sendInvitation(id, userId, dto);
  }

  /**
   * Get pending invitations
   *
   * @description Retrieves all pending invitations for the workspace.
   * Shows email, role, permissions, expiration date, and invitation status.
   * Ordered by creation date (newest first).
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<InvitationResponse[]>} Array of pending invitations
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - User is not a workspace member
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/invitations
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/invitations')
  @ApiOperation({
    summary: 'List pending invitations',
    description: 'Retrieves all pending workspace invitations',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Invitations retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Not a workspace member' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getInvitations(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<InvitationResponse[]> {
    return this.workspaceService.getInvitations(id, userId);
  }

  /**
   * GET INVITATION DETAILS (PUBLIC - No Auth Required)
   * This endpoint should be accessible without authentication
   */
  @Get('invitations/:token/details')
  @Public()
  @ApiOperation({
    summary: 'Get invitation details (public)',
    description:
      'Get workspace invitation details for preview before acceptance. No authentication required.',
  })
  @ApiParam({
    name: 'token',
    description: 'Invitation token',
    example: 'ff08ff32428b36add715719515d133d806ae0b759792952dd6815931827cc92d',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Invitation details retrieved successfully',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Invitation not found',
  })
  async getInvitationDetails(@Param('token') token: string) {
    return this.workspaceService.getInvitationDetails(token);
  }

  /**
   * Accept workspace invitation
   *
   * @description Accepts an invitation via token and joins the workspace.
   * Validates email match, token expiration, and prevents duplicate membership.
   * Marks invitation as ACCEPTED upon success.
   *
   * @param {string} token - Invitation token from email (32-byte hex string)
   * @returns {Promise<AcceptInvitationResponse>} Workspace and member info
   *
   * @throws {400} Bad Request - Invalid or expired invitation
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Email mismatch (invitation sent to different email)
   * @throws {404} Not Found - Invitation not found
   * @throws {409} Conflict - User is already a workspace member
   *
   * @example
   * ```
   * POST /api/v1/workspaces/invitations/abc123def456.../accept
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  /**
   * ACCEPT INVITATION
   * Requires authentication - user must be logged in
   */
  @Post('invitations/:token/accept')
  @ApiOperation({
    summary: 'Accept workspace invitation',
    description: 'Accept a workspace invitation and join the workspace. Requires authentication.',
  })
  @ApiParam({
    name: 'token',
    description: 'Invitation token',
    example: 'ff08ff32428b36add715719515d133d806ae0b759792952dd6815931827cc92d',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Invitation accepted successfully',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invitation is invalid, expired, or already used',
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: 'Email mismatch - invitation sent to different email',
  })
  async acceptInvitation(@Param('token') token: string, @GetCurrentUserId() userId: string) {
    return this.workspaceService.acceptInvitation(token, userId);
  }
  /**
   * Revoke pending invitation
   *
   * @description Revokes a pending invitation, preventing it from being accepted.
   * Marks invitation status as REVOKED. Requires `canInviteMembers` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} invitationId - Invitation unique identifier
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canInviteMembers)
   * @throws {404} Not Found - Invitation not found
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc/invitations/inv_789
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Delete(':id/invitations/:invitationId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Revoke pending invitation',
    description: 'Revokes invitation (requires canInviteMembers)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'invitationId', description: 'Invitation ID', example: 'inv_789' })
  @ApiResponse({ status: 200, description: 'Invitation revoked successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Invitation not found' })
  async revokeInvitation(
    @Param('id') id: string,
    @Param('invitationId') invitationId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.revokeInvitation(invitationId, id, userId);
  }

  // ==========================================
  // API KEY MANAGEMENT (LLM PROVIDERS)
  // ==========================================

  /**
   * Get API key usage statistics
   *
   * @description Retrieves aggregate statistics for all API keys in the workspace,
   * including totals, provider breakdown, and usage metrics.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<ApiKeyUsageStats>} Aggregate statistics
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/api-keys/stats
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "totalKeys": 5,
   *   "activeKeys": 4,
   *   "inactiveKeys": 1,
   *   "providerBreakdown": {
   *     "OPENAI": 2,
   *     "ANTHROPIC": 2,
   *     "PERPLEXITY": 1
   *   },
   *   "totalUsageCount": 1247,
   *   "totalTokensConsumed": "5234812",
   *   "totalCostIncurred": 127.45
   * }
   * ```
   */
  @Get(':id/api-keys/stats')
  @ApiOperation({
    summary: 'Get API key usage statistics',
    description: 'Retrieves aggregate stats for all workspace API keys',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'Statistics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getApiKeyUsageStats(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyUsageStats> {
    return this.workspaceService.getApiKeyUsageStats(id, userId);
  }

  /**
   * Get all workspace API keys
   *
   * @description Retrieves all API keys for the workspace with usage metrics.
   * Excludes sensitive keyHash for security. Includes status, usage statistics,
   * and creator info. Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @returns {Promise<ApiKeyResponse[]>} Array of API keys
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/api-keys
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/api-keys')
  @ApiOperation({
    summary: 'List all workspace API keys',
    description: 'Retrieves all API keys with usage metrics (excludes keyHash for security)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 200, description: 'API keys retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  async getApiKeys(
    @Param('id') id: string,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyResponse[]> {
    return this.workspaceService.getApiKeys(id, userId);
  }

  /**
   * Get daily usage metrics for API key
   *
   * @description Retrieves time-series usage metrics for a specific API key,
   * aggregated by day. Includes request counts, token consumption, cost estimates.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} keyId - API key unique identifier
   * @param {string} startDate - Start date (ISO 8601, optional)
   * @param {string} endDate - End date (ISO 8601, optional)
   * @returns {Promise<UsageMetricResponse[]>} Array of daily metrics (last 30 days)
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace or API key does not exist
   *
   * @example
   * ```
   * GET /api/v1/workspaces/clx123abc/api-keys/key_789/metrics?startDate=2025-10-01&endDate=2025-10-15
   * Authorization: Bearer <your_jwt_token>
   * ```
   */
  @Get(':id/api-keys/:keyId/metrics')
  @ApiOperation({
    summary: 'Get daily usage metrics for API key',
    description: 'Retrieves time-series usage data (requests, tokens, cost)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'keyId', description: 'API key ID', example: 'key_789' })
  @ApiQuery({
    name: 'startDate',
    required: false,
    description: 'Start date (ISO 8601)',
    example: '2025-10-01',
  })
  @ApiQuery({
    name: 'endDate',
    required: false,
    description: 'End date (ISO 8601)',
    example: '2025-10-15',
  })
  @ApiResponse({ status: 200, description: 'Usage metrics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace or API key not found' })
  async getUsageMetrics(
    @Param('id') id: string,
    @Param('keyId') keyId: string,
    @GetCurrentUserId() userId: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
  ): Promise<UsageMetricResponse[]> {
    return this.workspaceService.getUsageMetrics(
      id,
      keyId,
      userId,
      startDate ? new Date(startDate) : undefined,
      endDate ? new Date(endDate) : undefined,
    );
  }

  /**
   * Add new API key
   *
   * @description Adds an encrypted API key for an LLM provider.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {WorkspaceAddApiKeyDto} dto - API key data (provider, key, name)
   * @returns {Promise<ApiKeyResponse>} Created API key (excludes keyHash)
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - Workspace does not exist
   * @throws {409} Conflict - API key name already exists for provider
   *
   * @example
   * ```
   * POST /api/v1/workspaces/clx123abc/api-keys
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "provider": "OPENAI",
   *   "displayName": "Production Key",
   *   "apiKey": "sk-proj-abc123..."
   * }
   * ```
   */
  @Post(':id/api-keys')
  @ApiOperation({
    summary: 'Add new API key',
    description: 'Adds encrypted LLM provider API key',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiResponse({ status: 201, description: 'API key added successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - Workspace does not exist' })
  @ApiResponse({ status: 409, description: 'Conflict - API key name already exists' })
  async addApiKey(
    @Param('id') id: string,
    @Body() dto: WorkspaceAddApiKeyDto,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyResponse> {
    return this.workspaceService.addApiKey(id, userId, dto);
  }

  /**
   * Update API key
   *
   * @description Updates API key properties. Can rotate the key value (re-encrypts).
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} keyId - API key unique identifier
   * @param {WorkspaceUpdateApiKeyDto} dto - Update data
   * @returns {Promise<ApiKeyResponse>} Updated API key
   *
   * @throws {400} Bad Request - Invalid input
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - API key not found
   *
   * @example
   * ```
   * PATCH /api/v1/workspaces/clx123abc/api-keys/key_789
   * Content-Type: application/json
   * Authorization: Bearer <your_jwt_token>
   *
   * {
   *   "displayName": "Updated Production Key",
   *   "isActive": false
   * }
   * ```
   */
  @Patch(':id/api-keys/:keyId')
  @ApiOperation({
    summary: 'Update API key',
    description: 'Updates API key properties (can rotate key, requires canManageApiKeys)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'keyId', description: 'API key ID', example: 'key_789' })
  @ApiResponse({ status: 200, description: 'API key updated successfully' })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid input' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - API key not found' })
  async updateApiKey(
    @Param('id') id: string,
    @Param('keyId') keyId: string,
    @Body() dto: WorkspaceUpdateApiKeyDto,
    @GetCurrentUserId() userId: string,
  ): Promise<ApiKeyResponse> {
    return this.workspaceService.updateApiKey(id, keyId, userId, dto);
  }

  /**
   * Delete API key
   *
   * @description Permanently deletes an API key. This action cannot be undone.
   * Requires `canManageApiKeys` permission.
   *
   * @param {string} id - Workspace unique identifier
   * @param {string} keyId - API key unique identifier
   * @returns {Promise<MessageResponse>} Success confirmation message
   *
   * @throws {401} Unauthorized - Invalid or missing JWT token
   * @throws {403} Forbidden - Insufficient permissions (requires canManageApiKeys)
   * @throws {404} Not Found - API key not found
   *
   * @example
   * ```
   * DELETE /api/v1/workspaces/clx123abc/api-keys/key_789
   * Authorization: Bearer <your_jwt_token>
   * ```
   *
   * @example Response
   * ```
   * {
   *   "message": "API key deleted successfully"
   * }
   * ```
   */
  @Delete(':id/api-keys/:keyId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete API key',
    description: 'Permanently deletes API key (requires canManageApiKeys)',
  })
  @ApiParam({ name: 'id', description: 'Workspace ID', example: 'clx123abc' })
  @ApiParam({ name: 'keyId', description: 'API key ID', example: 'key_789' })
  @ApiResponse({ status: 200, description: 'API key deleted successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - Insufficient permissions' })
  @ApiResponse({ status: 404, description: 'Not Found - API key not found' })
  async deleteApiKey(
    @Param('id') id: string,
    @Param('keyId') keyId: string,
    @GetCurrentUserId() userId: string,
  ): Promise<MessageResponse> {
    return this.workspaceService.deleteApiKey(id, keyId, userId);
  }
}

```

### `apps\backend\src\v1\workspace\workspace.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { V1WorkspaceController } from './workspace.controller';
import { V1WorkspaceService } from './workspace.service';
import { V1NotificationModule } from '../notification/notification.module';

@Module({
  imports: [V1NotificationModule],
  controllers: [V1WorkspaceController],
  providers: [V1WorkspaceService],
  exports: [V1WorkspaceService],
})
export class V1WorkspaceModule {}

```

### `apps\backend\src\v1\workspace\workspace.service.ts`

```typescript
// src/modules/workspace/workspace.service.ts

import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  ConflictException,
  BadRequestException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AwsSesEmailService } from '../../common/aws/ses/ses-email.service';
import { ConfigService } from '@nestjs/config';
import { WorkspaceCreateDto } from './dto/workspace-create.dto';
import { WorkspaceUpdateDto } from './dto/workspace-update.dto';
import { WorkspaceUpdateMemberDto } from './dto/workspace-update-member.dto';
import { WorkspaceSendInvitationDto } from './dto/workspace-send-invitation.dto';
import { WorkspaceAddApiKeyDto } from './dto/workspace-add-api-key.dto';
import { WorkspaceUpdateApiKeyDto } from './dto/workspace-update-api-key.dto';
import { WorkspaceType, WorkspaceRole, InvitationStatus, NotificationType } from '@actopod/schema';
import * as crypto from 'crypto';
import { workspaceInvitationTemplate } from '../../common/aws/ses/templates/workspace/invitation.template';
import {
  WorkspaceListItem,
  WorkspaceDetails,
  WorkspaceMemberResponse,
  ApiKeyResponse,
  InvitationResponse,
  AcceptInvitationResponse,
  MessageResponse,
  ApiKeyUsageStats,
  UsageMetricResponse,
  InvitationDetailsResponse,
} from './types/workspace.types';
import { V1NotificationService } from '../notification/notification.service';

/**
 * PRODUCTION-GRADE Workspace Service
 * Features:
 * - AES-256-GCM encryption (12-byte IV, new standard)
 * - Backward compatibility (16-byte IV, legacy format)
 * - Auto workspace type switching (PERSONAL â†” TEAM)
 * - Comprehensive error handling
 * - Audit logging
 * - Permission management
 */
@Injectable()
export class V1WorkspaceService {
  private readonly logger = new Logger(V1WorkspaceService.name);
  private readonly encryptionKey: Buffer;
  private readonly encryptionAlgorithm = 'aes-256-gcm';
  private readonly NEW_IV_LENGTH = 12; // 96-bit IV (GCM standard)
  private readonly OLD_IV_LENGTH = 16; // 128-bit IV (legacy)
  private readonly AUTH_TAG_LENGTH = 16; // 128-bit auth tag

  constructor(
    private readonly prisma: PrismaService,
    private readonly emailService: AwsSesEmailService,
    private readonly configService: ConfigService,
    private readonly notificationService: V1NotificationService,
  ) {
    this.encryptionKey = this.initializeEncryption();
  }

  /**
   * Initialize and validate encryption key
   */
  private initializeEncryption(): Buffer {
    try {
      const key = this.configService.get<string>('API_KEY_ENCRYPTION_SECRET');

      if (!key) {
        const errorMsg =
          'CRITICAL: API_KEY_ENCRYPTION_SECRET environment variable is not set. ' +
          "Generate one using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"";
        this.logger.error(errorMsg);
        throw new Error(errorMsg);
      }

      // Validate hex format
      if (!/^[0-9a-fA-F]{64}$/.test(key)) {
        throw new Error(
          'API_KEY_ENCRYPTION_SECRET must be a 64-character hexadecimal string (32 bytes). ' +
            "Generate using: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"",
        );
      }

      const keyBuffer = Buffer.from(key, 'hex');

      if (keyBuffer.length !== 32) {
        throw new Error(
          `API_KEY_ENCRYPTION_SECRET must be exactly 32 bytes (64 hex characters). Current: ${keyBuffer.length} bytes`,
        );
      }

      this.logger.log('âœ… Encryption key validated successfully');
      return keyBuffer;
    } catch (error) {
      this.logger.error('Failed to initialize encryption:', error);
      throw error;
    }
  }

  // ==================== WORKSPACE CRUD ====================

  /**
   * AUTO-SWITCH WORKSPACE TYPE LOGIC
   * - 1 member = PERSONAL
   * - 2+ members = TEAM
   */
  private async autoSwitchWorkspaceType(workspaceId: string): Promise<void> {
    try {
      const memberCount = await this.prisma.workspaceUser.count({
        where: { workspaceId },
      });

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
        select: { type: true },
      });

      if (!workspace) return;

      // Switch to TEAM if 2+ members
      if (memberCount >= 2 && workspace.type === WorkspaceType.PERSONAL) {
        await this.prisma.workspace.update({
          where: { id: workspaceId },
          data: { type: WorkspaceType.TEAM },
        });
        this.logger.log(
          `ðŸ”„ Workspace ${workspaceId} auto-switched to TEAM (${memberCount} members)`,
        );
      }

      // Switch to PERSONAL if only 1 member
      if (memberCount === 1 && workspace.type === WorkspaceType.TEAM) {
        await this.prisma.workspace.update({
          where: { id: workspaceId },
          data: { type: WorkspaceType.PERSONAL },
        });
        this.logger.log(`ðŸ”„ Workspace ${workspaceId} auto-switched to PERSONAL (1 member)`);
      }
    } catch (error) {
      this.logger.error(`Failed to auto-switch workspace type for ${workspaceId}:`, error);
      // Don't throw - this is a non-critical operation
    }
  }

  async getAllWorkspaces(userId: string): Promise<WorkspaceListItem[]> {
    try {
      const workspaceUsers = await this.prisma.workspaceUser.findMany({
        where: { userId },
        include: {
          workspace: {
            include: {
              _count: {
                select: {
                  members: true,
                  flows: true,
                },
              },
            },
          },
        },
        orderBy: {
          joinedAt: 'desc',
        },
      });

      return workspaceUsers.map((wu) => ({
        id: wu.workspace.id,
        name: wu.workspace.name,
        type: wu.workspace.type,
        role: wu.role,
        permissions: {
          canCreateCanvas: wu.canCreateCanvas,
          canDeleteCanvas: wu.canDeleteCanvas,
          canManageBilling: wu.canManageBilling,
          canInviteMembers: wu.canInviteMembers,
          canManageMembers: wu.canManageMembers,
          canManageApiKeys: wu.canManageApiKeys,
        },
        memberCount: wu.workspace._count.members,
        canvasCount: wu.workspace._count.flows,
        joinedAt: wu.joinedAt,
        createdAt: wu.workspace.createdAt,
        updatedAt: wu.workspace.updatedAt,
      }));
    } catch (error) {
      this.logger.error(`Failed to get workspaces for user ${userId}:`, error);
      throw new InternalServerErrorException('Failed to fetch workspaces');
    }
  }

  async getWorkspaceById(workspaceId: string, userId: string): Promise<WorkspaceDetails> {
    try {
      const member = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId, workspaceId },
        },
      });

      if (!member) {
        throw new ForbiddenException('You do not have access to this workspace');
      }

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  email: true,
                  name: true,
                  image: true,
                },
              },
            },
          },
          _count: {
            select: {
              flows: true,
              documents: true,
              apiKeys: true,
            },
          },
        },
      });

      if (!workspace) {
        throw new NotFoundException('Workspace not found');
      }

      return {
        id: workspace.id,
        name: workspace.name,
        type: workspace.type,
        createdAt: workspace.createdAt,
        updatedAt: workspace.updatedAt,
        members: workspace.members,
        _count: workspace._count,
        currentUserRole: member.role,
        currentUserPermissions: {
          canCreateCanvas: member.canCreateCanvas,
          canDeleteCanvas: member.canDeleteCanvas,
          canManageBilling: member.canManageBilling,
          canInviteMembers: member.canInviteMembers,
          canManageMembers: member.canManageMembers,
          canManageApiKeys: member.canManageApiKeys,
        },
      };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch workspace');
    }
  }

  async createWorkspace(userId: string, dto: WorkspaceCreateDto): Promise<any> {
    try {
      const workspace = await this.prisma.workspace.create({
        data: {
          name: dto.name,
          type: dto.type ?? WorkspaceType.PERSONAL,
          members: {
            create: {
              userId,
              role: WorkspaceRole.OWNER,
              canCreateCanvas: true,
              canDeleteCanvas: true,
              canManageBilling: true,
              canInviteMembers: true,
              canManageMembers: true,
              canManageApiKeys: true,
            },
          },
        },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  email: true,
                  name: true,
                  image: true,
                },
              },
            },
          },
        },
      });

      this.logger.log(`âœ… Workspace created: ${workspace.id} by user ${userId}`);
      return workspace;
    } catch (error) {
      this.logger.error('Failed to create workspace:', error);
      throw new InternalServerErrorException('Failed to create workspace');
    }
  }

  async updateWorkspace(
    workspaceId: string,
    userId: string,
    dto: WorkspaceUpdateDto,
  ): Promise<any> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageMembers');

      const workspace = await this.prisma.workspace.update({
        where: { id: workspaceId },
        data: { name: dto.name },
      });

      this.logger.log(`âœ… Workspace updated: ${workspaceId} by user ${userId}`);
      return workspace;
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to update workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to update workspace');
    }
  }

  async deleteWorkspace(workspaceId: string, userId: string): Promise<MessageResponse> {
    try {
      const member = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId, workspaceId },
        },
      });

      if (!member || member.role !== WorkspaceRole.OWNER) {
        throw new ForbiddenException('Only workspace owners can delete workspaces');
      }

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
      });

      if (!workspace) {
        throw new NotFoundException('Workspace not found');
      }

      if (workspace.type === WorkspaceType.PERSONAL) {
        throw new BadRequestException('Personal workspaces cannot be deleted');
      }

      await this.prisma.workspace.delete({
        where: { id: workspaceId },
      });

      this.logger.log(`âœ… Workspace deleted: ${workspaceId} by user ${userId}`);
      return { message: 'Workspace deleted successfully' };
    } catch (error) {
      if (
        error instanceof ForbiddenException ||
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      )
        throw error;
      this.logger.error(`Failed to delete workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to delete workspace');
    }
  }

  async transferOwnership(
    workspaceId: string,
    currentOwnerId: string,
    newOwnerId: string,
  ): Promise<MessageResponse> {
    try {
      const currentOwner = await this.prisma.workspaceUser.findUnique({
        where: { userId_workspaceId: { userId: currentOwnerId, workspaceId } },
      });

      if (!currentOwner || currentOwner.role !== WorkspaceRole.OWNER) {
        throw new ForbiddenException('Only the workspace owner can transfer ownership');
      }

      const newOwner = await this.prisma.workspaceUser.findUnique({
        where: { userId_workspaceId: { userId: newOwnerId, workspaceId } },
      });

      if (!newOwner) {
        throw new NotFoundException('Target user is not a member of this workspace');
      }

      await this.prisma.$transaction([
        this.prisma.workspaceUser.update({
          where: { userId_workspaceId: { userId: currentOwnerId, workspaceId } },
          data: { role: WorkspaceRole.ADMIN },
        }),
        this.prisma.workspaceUser.update({
          where: { userId_workspaceId: { userId: newOwnerId, workspaceId } },
          data: {
            role: WorkspaceRole.OWNER,
            canCreateCanvas: true,
            canDeleteCanvas: true,
            canManageBilling: true,
            canInviteMembers: true,
            canManageMembers: true,
            canManageApiKeys: true,
          },
        }),
      ]);

      this.logger.log(`âœ… Ownership transferred: ${currentOwnerId} â†’ ${newOwnerId}`);
      return { message: 'Ownership transferred successfully' };
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error('Failed to transfer ownership:', error);
      throw new InternalServerErrorException('Failed to transfer ownership');
    }
  }

  async getWorkspaceStats(workspaceId: string, userId: string) {
    try {
      await this.verifyMembership(workspaceId, userId);

      const stats = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
        include: {
          _count: {
            select: {
              members: true,
              flows: true,
              documents: true,
              apiKeys: true,
            },
          },
          members: {
            select: { role: true },
          },
        },
      });

      if (!stats) {
        throw new NotFoundException('Workspace not found');
      }

      return {
        totalMembers: stats._count.members,
        totalFlows: stats._count.flows,
        totalDocuments: stats._count.documents,
        totalApiKeys: stats._count.apiKeys,
        roleDistribution: {
          owners: stats.members.filter((m) => m.role === WorkspaceRole.OWNER).length,
          admins: stats.members.filter((m) => m.role === WorkspaceRole.ADMIN).length,
          members: stats.members.filter((m) => m.role === WorkspaceRole.MEMBER).length,
        },
      };
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to get workspace stats for ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch workspace stats');
    }
  }

  // ==================== MEMBERS ====================

  async getMembers(workspaceId: string, userId: string): Promise<WorkspaceMemberResponse[]> {
    try {
      await this.verifyMembership(workspaceId, userId);

      const members = await this.prisma.workspaceUser.findMany({
        where: { workspaceId },
        include: {
          user: {
            select: {
              id: true,
              email: true,
              name: true,
              image: true,
            },
          },
        },
        orderBy: {
          joinedAt: 'desc',
        },
      });

      return members as WorkspaceMemberResponse[];
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get members for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch members');
    }
  }

  async updateMember(
    workspaceId: string,
    targetUserId: string,
    currentUserId: string,
    dto: WorkspaceUpdateMemberDto,
  ): Promise<WorkspaceMemberResponse> {
    try {
      await this.verifyPermission(workspaceId, currentUserId, 'canManageMembers');

      const targetMember = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
      });

      if (!targetMember) {
        throw new NotFoundException('Member not found');
      }

      if (targetMember.role === WorkspaceRole.OWNER) {
        throw new ForbiddenException('Cannot modify workspace owner');
      }

      const updatedMember = await this.prisma.workspaceUser.update({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
        data: dto,
        include: {
          user: {
            select: {
              id: true,
              email: true,
              name: true,
              image: true,
            },
          },
        },
      });

      this.logger.log(`âœ… Member updated: ${targetUserId} in workspace ${workspaceId}`);
      return updatedMember as WorkspaceMemberResponse;
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to update member ${targetUserId}:`, error);
      throw new InternalServerErrorException('Failed to update member');
    }
  }

  async removeMember(
    workspaceId: string,
    targetUserId: string,
    currentUserId: string,
  ): Promise<MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, currentUserId, 'canManageMembers');

      const targetMember = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
      });

      if (!targetMember) {
        throw new NotFoundException('Member not found');
      }

      if (targetMember.role === WorkspaceRole.OWNER) {
        throw new ForbiddenException('Cannot remove workspace owner');
      }

      await this.prisma.workspaceUser.delete({
        where: {
          userId_workspaceId: { userId: targetUserId, workspaceId },
        },
      });

      // Auto-switch workspace type
      await this.autoSwitchWorkspaceType(workspaceId);

      this.logger.log(`âœ… Member removed: ${targetUserId} from workspace ${workspaceId}`);
      return { message: 'Member removed successfully' };
    } catch (error) {
      if (error instanceof ForbiddenException || error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to remove member ${targetUserId}:`, error);
      throw new InternalServerErrorException('Failed to remove member');
    }
  }

  // ==================== INVITATIONS ====================

  async sendInvitation(
    workspaceId: string,
    userId: string,
    dto: WorkspaceSendInvitationDto,
  ): Promise<InvitationResponse & MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canInviteMembers');

      const workspace = await this.prisma.workspace.findUnique({
        where: { id: workspaceId },
      });

      if (!workspace) {
        throw new NotFoundException('Workspace not found');
      }

      const existingUser = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });

      if (existingUser) {
        const isMember = await this.prisma.workspaceUser.findUnique({
          where: {
            userId_workspaceId: { userId: existingUser.id, workspaceId },
          },
        });

        if (isMember) {
          throw new ConflictException('User is already a member of this workspace');
        }
      }

      const existing = await this.prisma.workspaceInvitation.findFirst({
        where: {
          workspaceId,
          email: dto.email,
          status: InvitationStatus.PENDING,
        },
      });

      if (existing) {
        throw new ConflictException('An invitation has already been sent to this email');
      }

      const token = crypto.randomBytes(32).toString('hex');

      const invitation = await this.prisma.workspaceInvitation.create({
        data: {
          workspaceId,
          email: dto.email,
          role: dto.role ?? WorkspaceRole.MEMBER,
          permissions: dto.permissions as any,
          invitedBy: userId,
          invitedUserId: existingUser?.id,
          token,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        },
      });

      // Create in-app notification if user exists
      if (existingUser) {
        await this.notificationService.createNotification({
          userId: existingUser.id,
          type: NotificationType.WORKSPACE_INVITATION,
          title: `Workspace Invitation: ${workspace.name}`,
          body: `You've been invited to join ${workspace.name} as ${dto.role ?? WorkspaceRole.MEMBER}`,
          entityType: 'workspace_invitation',
          entityId: invitation.id,
          metadata: {
            workspaceId,
            workspaceName: workspace.name,
            role: dto.role ?? WorkspaceRole.MEMBER,
            inviterName: userId,
          },
          actionUrl: `/workspace/invite/${token}`,
          expiresAt: invitation.expiresAt,
        });
      }

      const inviteLink = `${this.configService.get('FRONTEND_URL')}/workspace/invite/${token}`;

      await this.emailService.sendEmail({
        to: dto.email,
        subject: `You've been invited to join ${workspace.name} on Actopod`,
        bodyHtml: workspaceInvitationTemplate(
          workspace.name,
          inviteLink,
          dto.role ?? WorkspaceRole.MEMBER,
        ),
      });

      this.logger.log(`âœ… Invitation sent to ${dto.email} for workspace ${workspaceId}`);
      return {
        ...(invitation as InvitationResponse),
        message: 'Invitation sent successfully',
      };
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error('Failed to send invitation:', error);
      throw new InternalServerErrorException('Failed to send invitation');
    }
  }

  async getInvitations(workspaceId: string, userId: string): Promise<InvitationResponse[]> {
    try {
      await this.verifyMembership(workspaceId, userId);

      const invitations = await this.prisma.workspaceInvitation.findMany({
        where: {
          workspaceId,
          status: InvitationStatus.PENDING,
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      return invitations as InvitationResponse[];
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get invitations for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch invitations');
    }
  }

  async acceptInvitation(token: string, userId: string): Promise<AcceptInvitationResponse> {
    try {
      const invitation = await this.prisma.workspaceInvitation.findUnique({
        where: { token },
        include: { workspace: true },
      });

      if (!invitation) {
        throw new NotFoundException('Invitation not found');
      }

      if (invitation.status !== InvitationStatus.PENDING) {
        throw new BadRequestException('Invitation is no longer valid');
      }

      if (invitation.expiresAt < new Date()) {
        await this.prisma.workspaceInvitation.update({
          where: { id: invitation.id },
          data: { status: InvitationStatus.EXPIRED },
        });
        throw new BadRequestException('Invitation has expired');
      }

      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user || user.email !== invitation.email) {
        throw new ForbiddenException('This invitation was sent to a different email address');
      }

      const existing = await this.prisma.workspaceUser.findUnique({
        where: {
          userId_workspaceId: { userId, workspaceId: invitation.workspaceId },
        },
      });

      if (existing) {
        throw new ConflictException('You are already a member of this workspace');
      }

      const permissions = (invitation.permissions as Record<string, boolean> | null) || {};

      const defaultPermissions = {
        canCreateCanvas: true,
        canDeleteCanvas: false,
        canInviteMembers: false,
        canManageMembers: false,
        canManageApiKeys: false,
        canManageBilling: false,
      };

      const member = await this.prisma.workspaceUser.create({
        data: {
          userId,
          workspaceId: invitation.workspaceId,
          role: invitation.role,
          canCreateCanvas: permissions.canCreateCanvas ?? defaultPermissions.canCreateCanvas,
          canDeleteCanvas: permissions.canDeleteCanvas ?? defaultPermissions.canDeleteCanvas,
          canInviteMembers: permissions.canInviteMembers ?? defaultPermissions.canInviteMembers,
          canManageMembers: permissions.canManageMembers ?? defaultPermissions.canManageMembers,
          canManageApiKeys: permissions.canManageApiKeys ?? defaultPermissions.canManageApiKeys,
          canManageBilling: permissions.canManageBilling ?? defaultPermissions.canManageBilling,
          invitedBy: invitation.invitedBy,
        },
      });

      await this.prisma.workspaceInvitation.update({
        where: { id: invitation.id },
        data: {
          status: InvitationStatus.ACCEPTED,
          acceptedAt: new Date(),
        },
      });

      // Auto-switch workspace type
      await this.autoSwitchWorkspaceType(invitation.workspaceId);

      // Notify workspace admins/owner
      const admins = await this.prisma.workspaceUser.findMany({
        where: {
          workspaceId: invitation.workspaceId,
          role: { in: [WorkspaceRole.OWNER, WorkspaceRole.ADMIN] },
        },
      });

      for (const admin of admins) {
        await this.notificationService.createNotification({
          userId: admin.userId,
          type: NotificationType.WORKSPACE_MEMBER_JOINED,
          title: 'New Member Joined',
          body: `${user.name || user.email} has joined ${invitation.workspace.name}`,
          entityType: 'workspace',
          entityId: invitation.workspaceId,
          metadata: {
            workspaceId: invitation.workspaceId,
            newMemberEmail: user.email,
            newMemberName: user.name,
            role: invitation.role,
          },
          actionUrl: `/settings?tab=members`,
        });
      }

      this.logger.log(`âœ… Invitation accepted: ${token} by user ${userId}`);
      return {
        workspace: invitation.workspace,
        member,
        message: 'Successfully joined workspace',
      };
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException ||
        error instanceof ForbiddenException ||
        error instanceof ConflictException
      )
        throw error;
      this.logger.error('Failed to accept invitation:', error);
      throw new InternalServerErrorException('Failed to accept invitation');
    }
  }

  async getInvitationDetails(token: string): Promise<InvitationDetailsResponse> {
    try {
      const invitation = await this.prisma.workspaceInvitation.findUnique({
        where: { token },
        include: { workspace: true },
      });

      if (!invitation) {
        throw new NotFoundException('Invitation not found');
      }

      if (invitation.status !== InvitationStatus.PENDING) {
        throw new BadRequestException(`Invitation is ${invitation.status.toLowerCase()}`);
      }

      return {
        workspace: {
          id: invitation.workspace.id,
          name: invitation.workspace.name,
          type: invitation.workspace.type,
        },
        email: invitation.email,
        role: invitation.role,
        permissions: invitation.permissions as Record<string, boolean> | null,
        expiresAt: invitation.expiresAt,
        status: invitation.status,
      };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof BadRequestException) throw error;
      this.logger.error('Failed to get invitation details:', error);
      throw new InternalServerErrorException('Failed to fetch invitation details');
    }
  }

  async revokeInvitation(
    invitationId: string,
    workspaceId: string,
    userId: string,
  ): Promise<MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canInviteMembers');

      const invitation = await this.prisma.workspaceInvitation.findUnique({
        where: { id: invitationId },
      });

      if (!invitation || invitation.workspaceId !== workspaceId) {
        throw new NotFoundException('Invitation not found');
      }

      await this.prisma.workspaceInvitation.update({
        where: { id: invitationId },
        data: { status: InvitationStatus.REVOKED },
      });

      this.logger.log(`âœ… Invitation revoked: ${invitationId}`);
      return { message: 'Invitation revoked successfully' };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to revoke invitation ${invitationId}:`, error);
      throw new InternalServerErrorException('Failed to revoke invitation');
    }
  }

  // ==================== API KEYS ====================

  async getApiKeys(workspaceId: string, userId: string): Promise<ApiKeyResponse[]> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const apiKeys = await this.prisma.providerAPIKey.findMany({
        where: { workspaceId },
        select: {
          id: true,
          provider: true,
          displayName: true,
          isActive: true,
          lastUsedAt: true,
          createdAt: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
          lastErrorAt: true,
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      });

      return apiKeys.map((key) => ({
        ...key,
        totalTokens: key.totalTokens.toString(),
        totalCost: Number(key.totalCost),
      })) as ApiKeyResponse[];
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get API keys for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch API keys');
    }
  }

  async addApiKey(
    workspaceId: string,
    userId: string,
    dto: WorkspaceAddApiKeyDto,
  ): Promise<ApiKeyResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const existing = await this.prisma.providerAPIKey.findUnique({
        where: {
          workspaceId_provider_displayName: {
            workspaceId,
            provider: dto.provider,
            displayName: dto.displayName,
          },
        },
      });

      if (existing) {
        throw new ConflictException('An API key with this name already exists for this provider');
      }

      const keyHash = this.encryptApiKey(dto.apiKey);

      const apiKey = await this.prisma.providerAPIKey.create({
        data: {
          workspaceId,
          provider: dto.provider,
          displayName: dto.displayName,
          keyHash,
          createdById: userId,
        },
        select: {
          id: true,
          provider: true,
          displayName: true,
          isActive: true,
          lastUsedAt: true,
          createdAt: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
          lastErrorAt: true,
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      this.logger.log(`âœ… API key added: ${dto.provider}/${dto.displayName} by user ${userId}`);

      return {
        ...apiKey,
        totalTokens: apiKey.totalTokens.toString(),
        totalCost: Number(apiKey.totalCost),
      } as ApiKeyResponse;
    } catch (error) {
      if (error instanceof ConflictException || error instanceof ForbiddenException) throw error;
      this.logger.error('Failed to add API key:', error);
      throw new InternalServerErrorException('Failed to add API key');
    }
  }

  async updateApiKey(
    workspaceId: string,
    keyId: string,
    userId: string,
    dto: WorkspaceUpdateApiKeyDto,
  ): Promise<ApiKeyResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const existing = await this.prisma.providerAPIKey.findFirst({
        where: {
          id: keyId,
          workspaceId,
        },
      });

      if (!existing) {
        throw new NotFoundException('API key not found');
      }

      if (dto.displayName && dto.displayName !== existing.displayName) {
        const duplicate = await this.prisma.providerAPIKey.findUnique({
          where: {
            workspaceId_provider_displayName: {
              workspaceId,
              provider: existing.provider,
              displayName: dto.displayName,
            },
          },
        });

        if (duplicate) {
          throw new ConflictException('An API key with this name already exists');
        }
      }

      const updateData: any = {};

      if (dto.displayName !== undefined) {
        updateData.displayName = dto.displayName;
      }

      if (dto.isActive !== undefined) {
        updateData.isActive = dto.isActive;
      }

      if (dto.apiKey) {
        updateData.keyHash = this.encryptApiKey(dto.apiKey);
      }

      const apiKey = await this.prisma.providerAPIKey.update({
        where: { id: keyId },
        data: updateData,
        select: {
          id: true,
          provider: true,
          displayName: true,
          isActive: true,
          lastUsedAt: true,
          createdAt: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
          lastErrorAt: true,
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      this.logger.log(`âœ… API key updated: ${keyId} by user ${userId}`);

      return {
        ...apiKey,
        totalTokens: apiKey.totalTokens.toString(),
        totalCost: Number(apiKey.totalCost),
      } as ApiKeyResponse;
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof ForbiddenException
      )
        throw error;
      this.logger.error(`Failed to update API key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to update API key');
    }
  }

  async deleteApiKey(workspaceId: string, keyId: string, userId: string): Promise<MessageResponse> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const apiKey = await this.prisma.providerAPIKey.findFirst({
        where: {
          id: keyId,
          workspaceId,
        },
      });

      if (!apiKey) {
        throw new NotFoundException('API key not found');
      }

      await this.prisma.providerAPIKey.delete({
        where: { id: keyId },
      });

      this.logger.log(`âœ… API key deleted: ${keyId} by user ${userId}`);

      return { message: 'API key deleted successfully' };
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to delete API key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to delete API key');
    }
  }

  async getApiKeyUsageStats(workspaceId: string, userId: string): Promise<ApiKeyUsageStats> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const apiKeys = await this.prisma.providerAPIKey.findMany({
        where: { workspaceId },
        select: {
          provider: true,
          isActive: true,
          usageCount: true,
          totalTokens: true,
          totalCost: true,
        },
      });

      const totalKeys = apiKeys.length;
      const activeKeys = apiKeys.filter((k) => k.isActive).length;
      const inactiveKeys = totalKeys - activeKeys;

      const providerBreakdown = apiKeys.reduce(
        (acc, key) => {
          acc[key.provider] = (acc[key.provider] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      const totalUsageCount = apiKeys.reduce((sum, k) => sum + k.usageCount, 0);

      const totalTokensConsumed = apiKeys.reduce(
        (sum, k) => sum + BigInt(k.totalTokens),
        BigInt(0),
      );

      const totalCostIncurred = apiKeys.reduce((sum, k) => sum + Number(k.totalCost), 0);

      return {
        totalKeys,
        activeKeys,
        inactiveKeys,
        providerBreakdown,
        totalUsageCount,
        totalTokensConsumed: totalTokensConsumed.toString(),
        totalCostIncurred,
      };
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get usage stats for workspace ${workspaceId}:`, error);
      throw new InternalServerErrorException('Failed to fetch usage stats');
    }
  }

  async getUsageMetrics(
    workspaceId: string,
    keyId: string,
    userId: string,
    startDate?: Date,
    endDate?: Date,
  ): Promise<UsageMetricResponse[]> {
    try {
      await this.verifyPermission(workspaceId, userId, 'canManageApiKeys');

      const whereClause: any = { workspaceId, keyId };
      if (startDate || endDate) {
        whereClause.date = {};
        if (startDate) whereClause.date.gte = startDate;
        if (endDate) whereClause.date.lte = endDate;
      }

      const metrics = await this.prisma.usageMetric.findMany({
        where: whereClause,
        orderBy: { date: 'desc' },
        take: 30,
      });

      return metrics.map((m) => ({
        id: m.id,
        date: m.date,
        requestCount: m.requestCount,
        successCount: m.successCount,
        errorCount: m.errorCount,
        promptTokens: m.promptTokens.toString(),
        completionTokens: m.completionTokens.toString(),
        totalTokens: m.totalTokens.toString(),
        estimatedCost: Number(m.estimatedCost),
      }));
    } catch (error) {
      if (error instanceof ForbiddenException) throw error;
      this.logger.error(`Failed to get usage metrics for key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to fetch usage metrics');
    }
  }

  async getDecryptedApiKey(keyId: string, workspaceId: string): Promise<string> {
    try {
      const apiKey = await this.prisma.providerAPIKey.findFirst({
        where: {
          id: keyId,
          workspaceId,
          isActive: true,
        },
        select: {
          keyHash: true,
        },
      });

      if (!apiKey) {
        throw new NotFoundException('API key not found or inactive');
      }

      return this.decryptApiKey(apiKey.keyHash);
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      this.logger.error(`Failed to decrypt API key ${keyId}:`, error);
      throw new InternalServerErrorException('Failed to decrypt API key');
    }
  }

  // ==================== PRIVATE HELPERS ====================

  private async verifyMembership(workspaceId: string, userId: string): Promise<any> {
    const member = await this.prisma.workspaceUser.findUnique({
      where: {
        userId_workspaceId: { userId, workspaceId },
      },
    });

    if (!member) {
      throw new ForbiddenException('You do not have access to this workspace');
    }

    return member;
  }

  private async verifyPermission(
    workspaceId: string,
    userId: string,
    permission: string,
  ): Promise<any> {
    const member = await this.verifyMembership(workspaceId, userId);

    if (member.role === WorkspaceRole.OWNER) {
      return member;
    }

    if (!(member as any)[permission]) {
      throw new ForbiddenException('You do not have permission to perform this action');
    }

    return member;
  }

  /**
   * Encrypt API key using AES-256-GCM with NEW 12-byte IV format
   * Format: iv:authTag:encrypted
   */
  private encryptApiKey(plaintext: string): string {
    try {
      if (!plaintext || typeof plaintext !== 'string' || plaintext.trim().length === 0) {
        throw new Error('Cannot encrypt empty API key');
      }

      const iv = crypto.randomBytes(this.NEW_IV_LENGTH);
      const cipher = crypto.createCipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);

      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      const authTag = cipher.getAuthTag();

      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(`Invalid auth tag length: ${authTag.length}`);
      }

      const result = `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;

      this.logger.debug('API key encrypted successfully with 12-byte IV');
      return result;
    } catch (error) {
      this.logger.error('Encryption failed:', error);
      throw new InternalServerErrorException(
        `Failed to encrypt API key: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Decrypt API key with BACKWARD COMPATIBILITY for both 12-byte and 16-byte IV formats
   * Format: iv:authTag:encrypted
   */
  private decryptApiKey(encryptedData: string): string {
    try {
      if (!encryptedData || typeof encryptedData !== 'string') {
        throw new Error('Invalid encrypted data');
      }

      const parts = encryptedData.split(':');

      if (parts.length !== 3) {
        throw new Error(`Invalid encrypted data format: expected 3 parts, got ${parts.length}`);
      }

      const [ivHex, authTagHex, encrypted] = parts;

      if (!ivHex || !authTagHex || !encrypted) {
        throw new Error('One or more encrypted data components are empty');
      }

      if (
        !/^[0-9a-fA-F]+$/.test(ivHex) ||
        !/^[0-9a-fA-F]+$/.test(authTagHex) ||
        !/^[0-9a-fA-F]+$/.test(encrypted)
      ) {
        throw new Error('Encrypted data contains invalid hexadecimal characters');
      }

      const iv = Buffer.from(ivHex, 'hex');
      const authTag = Buffer.from(authTagHex, 'hex');

      const ivLength = iv.length;

      if (ivLength !== this.NEW_IV_LENGTH && ivLength !== this.OLD_IV_LENGTH) {
        throw new Error(
          `Invalid IV length: expected ${this.NEW_IV_LENGTH} bytes (new) or ${this.OLD_IV_LENGTH} bytes (legacy), got ${ivLength} bytes`,
        );
      }

      if (ivLength === this.OLD_IV_LENGTH) {
        this.logger.warn(
          `Decrypting API key with legacy 16-byte IV format. Consider re-encrypting with the new 12-byte format.`,
        );
      }

      if (authTag.length !== this.AUTH_TAG_LENGTH) {
        throw new Error(`Invalid auth tag length: ${authTag.length} bytes`);
      }

      const decipher = crypto.createDecipheriv(this.encryptionAlgorithm, this.encryptionKey, iv);
      decipher.setAuthTag(authTag);

      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      if (!decrypted || decrypted.length === 0) {
        throw new Error('Decryption produced empty result');
      }

      this.logger.debug(`API key decrypted successfully (IV length: ${ivLength} bytes)`);
      return decrypted;
    } catch (error) {
      this.logger.error('Decryption failed:', error);

      if (error instanceof Error) {
        if (error.message.includes('Unsupported state') || error.message.includes('auth')) {
          throw new InternalServerErrorException(
            'Authentication failed: API key may be corrupted or tampered with',
          );
        }
        if (error.message.includes('bad decrypt')) {
          throw new InternalServerErrorException(
            'Decryption failed: Incorrect encryption key or corrupted data',
          );
        }
      }

      throw new InternalServerErrorException(
        `Failed to decrypt API key: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }
}

```

---

## Frontend Configuration

### `apps\frontend\components.json`

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}

```

### `apps\frontend\index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Actopod</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

### `apps\frontend\package.json`

```json
{
  "name": "@actopod/frontend",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --port ${FRONTEND_PORT:-5173}",
    "build": "tsc && vite build",
    "start": "vite preview --port ${FRONTEND_PORT:-5173}",
    "preview": "vite preview --port ${FRONTEND_PORT:-5173}",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint . --ext ts,tsx --fix",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:ui": "vitest --ui",
    "type-check": "tsc --noEmit",
    "clean": "rimraf dist node_modules .turbo"
  },
  "dependencies": {
    "@actopod/schema": "*",
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.90.2",
    "@tanstack/react-query-devtools": "^5.90.2",
    "axios": "^1.12.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "crypto-js": "^4.2.0",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.23.24",
    "highlight.js": "^11.11.1",
    "js-cookie": "^3.0.5",
    "lucide-react": "^0.545.0",
    "next-themes": "^0.4.6",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.65.0",
    "react-markdown": "^10.1.0",
    "react-router-dom": "^7.9.4",
    "reactflow": "^11.11.4",
    "remark-gfm": "^4.0.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.3.1",
    "uuid": "^13.0.0",
    "zod": "^4.1.12",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@actopod/eslint-config": "workspace:^",
    "@actopod/tsconfig": "*",
    "@types/crypto-js": "^4.2.2",
    "@types/js-cookie": "^3.0.6",
    "@types/react": "^19.2.2",
    "@types/react-dom": "^19.2.1",
    "@types/uuid": "^11.0.0",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.37.0",
    "eslint-plugin-react-hooks": "^7.0.0",
    "eslint-plugin-react-refresh": "^0.4.23",
    "jsdom": "^27.0.0",
    "postcss": "^8.5.6",
    "prettier": "^3.6.2",
    "prettier-plugin-tailwindcss": "^0.6.14",
    "rimraf": "^6.0.1",
    "tailwindcss": "^4.1.14",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5.9.3",
    "vite": "^7.1.9",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^3.2.4"
  }
}

```

### `apps\frontend\tsconfig.app.json`

```json
{
  "compilerOptions": {
    "composite": true,
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "emitDeclarationOnly": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "jsx": "react-jsx",

    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    "paths": {
      "@/*": ["./src/*"],
      "@actopod/schema": ["../../packages/schema/src"]
    }
  },
  "include": ["src", "vite-env.d.ts"]
}

```

### `apps\frontend\tsconfig.json`

```json
{
  "extends": "@actopod/tsconfig/react.json",
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"],
      "@actopod/schema": ["../../packages/schema/src"]
    }
  },
  "include": ["src", "vite-env.d.ts"],
  "references": [{ "path": "./tsconfig.node.json" }, { "path": "./tsconfig.app.json" }]
}

```

### `apps\frontend\tsconfig.node.json`

```json
{
  "extends": "@actopod/tsconfig/base.json",
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "types": ["node"]
  },
  "include": ["vite.config.ts"]
}

```

### `apps\frontend\vite.config.ts`

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tsconfigPaths from 'vite-tsconfig-paths';
import tailwindcss from '@tailwindcss/vite';
import path from 'path';

export default defineConfig({
  plugins: [react(), tsconfigPaths(), tailwindcss()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: process.env.FRONTEND_PORT ? parseInt(process.env.FRONTEND_PORT) : 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5173',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
  optimizeDeps: {
    exclude: ['@actopod/schema'],
  },
});

```

---

## Docker Configuration

### `docker\db-docker-compose.yaml`

```yaml
name: actopod

services:
  actopod-db:
    image: postgres:16-alpine
    container_name: actopod-db
    ports:
      - '5434:5432'
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-123}
      POSTGRES_DB: ${POSTGRES_DB:-actopod}
    volumes:
      - actopod_db_data:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U ${POSTGRES_USER:-postgres}']
      interval: 10s
      retries: 5
      timeout: 5s
      start_period: 10s
    networks:
      - actopod_network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M

volumes:
  actopod_db_data:
    driver: local

networks:
  actopod_network:
    driver: bridge

```

---

## Export Summary

| Metric | Value |
|--------|-------|
| Files Exported | 381 |
| File Size | 1.37 MB |
| Generated | 2025-10-26 16:16:36 IST |

### What's Included

- Backend NestJS source code (apps/backend/src)
- Frontend React/Vite source code (apps/frontend/src)
- Prisma schema files and migrations (packages/schema/prisma)
- Shared ESLint and TSConfig packages
- All configuration files
- Docker compose files
- Build scripts

### Excluded

- node_modules (dependency code)
- Generated Prisma client (packages/schema/client)
- Build artifacts (dist, .turbo, .yarn)

