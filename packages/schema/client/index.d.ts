
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminSession
 * 
 */
export type AdminSession = $Result.DefaultSelection<Prisma.$AdminSessionPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model AdminPermission
 * 
 */
export type AdminPermission = $Result.DefaultSelection<Prisma.$AdminPermissionPayload>
/**
 * Model AdminAPIKey
 * 
 */
export type AdminAPIKey = $Result.DefaultSelection<Prisma.$AdminAPIKeyPayload>
/**
 * Model AdminInvitation
 * 
 */
export type AdminInvitation = $Result.DefaultSelection<Prisma.$AdminInvitationPayload>
/**
 * Model AdminSecurityEvent
 * 
 */
export type AdminSecurityEvent = $Result.DefaultSelection<Prisma.$AdminSecurityEventPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model CreditPurchase
 * 
 */
export type CreditPurchase = $Result.DefaultSelection<Prisma.$CreditPurchasePayload>
/**
 * Model CreditUsageLog
 * 
 */
export type CreditUsageLog = $Result.DefaultSelection<Prisma.$CreditUsageLogPayload>
/**
 * Model ModelPricingTier
 * 
 */
export type ModelPricingTier = $Result.DefaultSelection<Prisma.$ModelPricingTierPayload>
/**
 * Model Space
 * 
 */
export type Space = $Result.DefaultSelection<Prisma.$SpacePayload>
/**
 * Model Flow
 * 
 */
export type Flow = $Result.DefaultSelection<Prisma.$FlowPayload>
/**
 * Model FlowInvitation
 * 
 */
export type FlowInvitation = $Result.DefaultSelection<Prisma.$FlowInvitationPayload>
/**
 * Model FlowCollaborator
 * 
 */
export type FlowCollaborator = $Result.DefaultSelection<Prisma.$FlowCollaboratorPayload>
/**
 * Model FlowSession
 * 
 */
export type FlowSession = $Result.DefaultSelection<Prisma.$FlowSessionPayload>
/**
 * Model FlowActivityLog
 * 
 */
export type FlowActivityLog = $Result.DefaultSelection<Prisma.$FlowActivityLogPayload>
/**
 * Model FlowComment
 * 
 */
export type FlowComment = $Result.DefaultSelection<Prisma.$FlowCommentPayload>
/**
 * Model Pod
 * 
 */
export type Pod = $Result.DefaultSelection<Prisma.$PodPayload>
/**
 * Model Edge
 * 
 */
export type Edge = $Result.DefaultSelection<Prisma.$EdgePayload>
/**
 * Model PodExecution
 * 
 */
export type PodExecution = $Result.DefaultSelection<Prisma.$PodExecutionPayload>
/**
 * Model PodUsageLog
 * 
 */
export type PodUsageLog = $Result.DefaultSelection<Prisma.$PodUsageLogPayload>
/**
 * Model ContextModule
 * 
 */
export type ContextModule = $Result.DefaultSelection<Prisma.$ContextModulePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceUser
 * 
 */
export type WorkspaceUser = $Result.DefaultSelection<Prisma.$WorkspaceUserPayload>
/**
 * Model WorkspaceInvitation
 * 
 */
export type WorkspaceInvitation = $Result.DefaultSelection<Prisma.$WorkspaceInvitationPayload>
/**
 * Model ProviderAPIKey
 * 
 */
export type ProviderAPIKey = $Result.DefaultSelection<Prisma.$ProviderAPIKeyPayload>
/**
 * Model ShareLink
 * 
 */
export type ShareLink = $Result.DefaultSelection<Prisma.$ShareLinkPayload>
/**
 * Model DocumentFolder
 * 
 */
export type DocumentFolder = $Result.DefaultSelection<Prisma.$DocumentFolderPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Embedding
 * 
 */
export type Embedding = $Result.DefaultSelection<Prisma.$EmbeddingPayload>
/**
 * Model DocumentProcessingCost
 * 
 */
export type DocumentProcessingCost = $Result.DefaultSelection<Prisma.$DocumentProcessingCostPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AdminRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  FINANCE: 'FINANCE',
  SUPPORT: 'SUPPORT',
  DEVELOPER: 'DEVELOPER',
  ANALYST: 'ANALYST'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]


export const AdminStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DEACTIVATED: 'DEACTIVATED',
  LOCKED: 'LOCKED'
};

export type AdminStatus = (typeof AdminStatus)[keyof typeof AdminStatus]


export const AdminAction: {
  USER_CREATED: 'USER_CREATED',
  USER_UPDATED: 'USER_UPDATED',
  USER_DELETED: 'USER_DELETED',
  USER_SUSPENDED: 'USER_SUSPENDED',
  WORKSPACE_DELETED: 'WORKSPACE_DELETED',
  SUBSCRIPTION_UPDATED: 'SUBSCRIPTION_UPDATED',
  SUBSCRIPTION_CANCELLED: 'SUBSCRIPTION_CANCELLED',
  CREDITS_ADDED: 'CREDITS_ADDED',
  CREDITS_REMOVED: 'CREDITS_REMOVED',
  REFUND_ISSUED: 'REFUND_ISSUED',
  MODEL_ADDED: 'MODEL_ADDED',
  MODEL_UPDATED: 'MODEL_UPDATED',
  PRICING_CHANGED: 'PRICING_CHANGED',
  ADMIN_INVITED: 'ADMIN_INVITED',
  ADMIN_CREATED: 'ADMIN_CREATED',
  ADMIN_ROLE_CHANGED: 'ADMIN_ROLE_CHANGED',
  PERMISSION_GRANTED: 'PERMISSION_GRANTED',
  SESSION_REVOKED: 'SESSION_REVOKED',
  CONFIG_CHANGED: 'CONFIG_CHANGED',
  DATA_EXPORTED: 'DATA_EXPORTED'
};

export type AdminAction = (typeof AdminAction)[keyof typeof AdminAction]


export const AdminResource: {
  USER: 'USER',
  WORKSPACE: 'WORKSPACE',
  SUBSCRIPTION: 'SUBSCRIPTION',
  CREDIT: 'CREDIT',
  MODEL: 'MODEL',
  ADMIN: 'ADMIN',
  PERMISSION: 'PERMISSION',
  SESSION: 'SESSION',
  API_KEY: 'API_KEY',
  CANVAS: 'CANVAS',
  ACTION_POD: 'ACTION_POD',
  DOCUMENT: 'DOCUMENT',
  AUDIT_LOG: 'AUDIT_LOG',
  SYSTEM_CONFIG: 'SYSTEM_CONFIG'
};

export type AdminResource = (typeof AdminResource)[keyof typeof AdminResource]


export const SpecificPermission: {
  USER_VIEW: 'USER_VIEW',
  USER_UPDATE: 'USER_UPDATE',
  USER_DELETE: 'USER_DELETE',
  USER_SUSPEND: 'USER_SUSPEND',
  WORKSPACE_VIEW: 'WORKSPACE_VIEW',
  WORKSPACE_DELETE: 'WORKSPACE_DELETE',
  BILLING_VIEW: 'BILLING_VIEW',
  BILLING_MANAGE: 'BILLING_MANAGE',
  CREDITS_MANAGE: 'CREDITS_MANAGE',
  REFUND_ISSUE: 'REFUND_ISSUE',
  MODEL_VIEW: 'MODEL_VIEW',
  MODEL_MANAGE: 'MODEL_MANAGE',
  PRICING_MANAGE: 'PRICING_MANAGE',
  ADMIN_VIEW: 'ADMIN_VIEW',
  ADMIN_INVITE: 'ADMIN_INVITE',
  ADMIN_MANAGE: 'ADMIN_MANAGE',
  SYSTEM_CONFIG_VIEW: 'SYSTEM_CONFIG_VIEW',
  SYSTEM_CONFIG_MANAGE: 'SYSTEM_CONFIG_MANAGE',
  AUDIT_LOG_VIEW: 'AUDIT_LOG_VIEW',
  AUDIT_LOG_EXPORT: 'AUDIT_LOG_EXPORT',
  DATA_EXPORT: 'DATA_EXPORT',
  DATA_DELETE: 'DATA_DELETE'
};

export type SpecificPermission = (typeof SpecificPermission)[keyof typeof SpecificPermission]


export const SecurityEventType: {
  FAILED_LOGIN: 'FAILED_LOGIN',
  MULTIPLE_FAILED_LOGINS: 'MULTIPLE_FAILED_LOGINS',
  SUSPICIOUS_IP: 'SUSPICIOUS_IP',
  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
  MFA_FAILED: 'MFA_FAILED',
  UNAUTHORIZED_ACCESS_ATTEMPT: 'UNAUTHORIZED_ACCESS_ATTEMPT'
};

export type SecurityEventType = (typeof SecurityEventType)[keyof typeof SecurityEventType]


export const SecuritySeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type SecuritySeverity = (typeof SecuritySeverity)[keyof typeof SecuritySeverity]


export const SubscriptionTier: {
  HOBBYIST: 'HOBBYIST',
  PRO: 'PRO',
  TEAM: 'TEAM'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELED: 'CANCELED',
  PAST_DUE: 'PAST_DUE',
  TRIALING: 'TRIALING',
  INCOMPLETE: 'INCOMPLETE',
  PAUSED: 'PAUSED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const ModelCategory: {
  WORKHORSE: 'WORKHORSE',
  POWERHOUSE: 'POWERHOUSE',
  REASONING: 'REASONING',
  SPECIALIST: 'SPECIALIST',
  IMAGE_GEN: 'IMAGE_GEN',
  VIDEO_GEN: 'VIDEO_GEN',
  AUDIO_GEN: 'AUDIO_GEN',
  EMBEDDING: 'EMBEDDING',
  RERANKING: 'RERANKING',
  MODERATION: 'MODERATION',
  SEARCH: 'SEARCH',
  TRANSLATION: 'TRANSLATION'
};

export type ModelCategory = (typeof ModelCategory)[keyof typeof ModelCategory]


export const PodType: {
  TEXT_INPUT: 'TEXT_INPUT',
  DOCUMENT_INPUT: 'DOCUMENT_INPUT',
  URL_INPUT: 'URL_INPUT',
  IMAGE_INPUT: 'IMAGE_INPUT',
  VIDEO_INPUT: 'VIDEO_INPUT',
  AUDIO_INPUT: 'AUDIO_INPUT',
  LLM_PROMPT: 'LLM_PROMPT',
  EMBEDDING_POD: 'EMBEDDING_POD',
  TOOL_POD: 'TOOL_POD',
  TEXT_OUTPUT: 'TEXT_OUTPUT',
  IMAGE_OUTPUT: 'IMAGE_OUTPUT',
  VIDEO_OUTPUT: 'VIDEO_OUTPUT',
  AUDIO_OUTPUT: 'AUDIO_OUTPUT',
  CONTEXT_MODULE: 'CONTEXT_MODULE',
  FLOW_CONTEXT_INPUT: 'FLOW_CONTEXT_INPUT',
  CODE_EXECUTION: 'CODE_EXECUTION'
};

export type PodType = (typeof PodType)[keyof typeof PodType]


export const PodExecutionStatus: {
  IDLE: 'IDLE',
  QUEUED: 'QUEUED',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  CANCELLED: 'CANCELLED'
};

export type PodExecutionStatus = (typeof PodExecutionStatus)[keyof typeof PodExecutionStatus]


export const FlowVisibility: {
  PRIVATE: 'PRIVATE',
  WORKSPACE: 'WORKSPACE',
  PUBLIC: 'PUBLIC'
};

export type FlowVisibility = (typeof FlowVisibility)[keyof typeof FlowVisibility]


export const FlowAccessLevel: {
  VIEWER: 'VIEWER',
  COMMENTER: 'COMMENTER',
  EDITOR: 'EDITOR',
  OWNER: 'OWNER'
};

export type FlowAccessLevel = (typeof FlowAccessLevel)[keyof typeof FlowAccessLevel]


export const FlowActivityAction: {
  FLOW_CREATED: 'FLOW_CREATED',
  FLOW_UPDATED: 'FLOW_UPDATED',
  FLOW_DELETED: 'FLOW_DELETED',
  FLOW_SHARED: 'FLOW_SHARED',
  FLOW_VISIBILITY_CHANGED: 'FLOW_VISIBILITY_CHANGED',
  POD_CREATED: 'POD_CREATED',
  POD_UPDATED: 'POD_UPDATED',
  POD_DELETED: 'POD_DELETED',
  POD_MOVED: 'POD_MOVED',
  POD_EXECUTED: 'POD_EXECUTED',
  POD_LOCKED: 'POD_LOCKED',
  POD_UNLOCKED: 'POD_UNLOCKED',
  EDGE_CREATED: 'EDGE_CREATED',
  EDGE_DELETED: 'EDGE_DELETED',
  COLLABORATOR_ADDED: 'COLLABORATOR_ADDED',
  COLLABORATOR_REMOVED: 'COLLABORATOR_REMOVED',
  COLLABORATOR_PERMISSIONS_CHANGED: 'COLLABORATOR_PERMISSIONS_CHANGED',
  COMMENT_ADDED: 'COMMENT_ADDED',
  COMMENT_RESOLVED: 'COMMENT_RESOLVED',
  USER_JOINED: 'USER_JOINED',
  USER_LEFT: 'USER_LEFT'
};

export type FlowActivityAction = (typeof FlowActivityAction)[keyof typeof FlowActivityAction]


export const AuthProvider: {
  GOOGLE: 'GOOGLE',
  GITHUB: 'GITHUB',
  EMAIL: 'EMAIL'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const WorkspaceType: {
  PERSONAL: 'PERSONAL',
  TEAM: 'TEAM'
};

export type WorkspaceType = (typeof WorkspaceType)[keyof typeof WorkspaceType]


export const WorkspaceRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type WorkspaceRole = (typeof WorkspaceRole)[keyof typeof WorkspaceRole]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const ShareAccessLevel: {
  VIEW_ONLY: 'VIEW_ONLY',
  COMMENT: 'COMMENT',
  EDIT: 'EDIT'
};

export type ShareAccessLevel = (typeof ShareAccessLevel)[keyof typeof ShareAccessLevel]


export const LLMProvider: {
  OPENAI: 'OPENAI',
  ANTHROPIC: 'ANTHROPIC',
  GOOGLE_GEMINI: 'GOOGLE_GEMINI',
  PERPLEXITY: 'PERPLEXITY',
  MISTRAL: 'MISTRAL',
  META_AI: 'META_AI',
  XAI: 'XAI',
  DEEPSEEK: 'DEEPSEEK',
  COHERE: 'COHERE',
  GROQ: 'GROQ',
  TOGETHER: 'TOGETHER',
  REPLICATE: 'REPLICATE',
  HUGGINGFACE: 'HUGGINGFACE',
  OPENROUTER: 'OPENROUTER',
  BEDROCK: 'BEDROCK',
  OLLAMA: 'OLLAMA',
  VLLM: 'VLLM',
  LLAMACPP: 'LLAMACPP',
  TEXTGEN_WEBUI: 'TEXTGEN_WEBUI',
  CUSTOM: 'CUSTOM'
};

export type LLMProvider = (typeof LLMProvider)[keyof typeof LLMProvider]


export const AuthType: {
  BEARER_TOKEN: 'BEARER_TOKEN',
  API_KEY_HEADER: 'API_KEY_HEADER',
  BASIC_AUTH: 'BASIC_AUTH',
  OAUTH2: 'OAUTH2',
  AWS_SIGV4: 'AWS_SIGV4',
  CUSTOM_HEADER: 'CUSTOM_HEADER'
};

export type AuthType = (typeof AuthType)[keyof typeof AuthType]


export const ShareableAssetType: {
  FLOW: 'FLOW',
  CONTEXT_MODULE: 'CONTEXT_MODULE'
};

export type ShareableAssetType = (typeof ShareableAssetType)[keyof typeof ShareableAssetType]


export const DocumentStatus: {
  UPLOADING: 'UPLOADING',
  PROCESSING: 'PROCESSING',
  READY: 'READY',
  ERROR: 'ERROR',
  ARCHIVED: 'ARCHIVED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const DocumentSourceType: {
  INTERNAL: 'INTERNAL',
  GOOGLE_DRIVE: 'GOOGLE_DRIVE',
  YOUTUBE: 'YOUTUBE',
  VIMEO: 'VIMEO',
  LOOM: 'LOOM',
  URL: 'URL'
};

export type DocumentSourceType = (typeof DocumentSourceType)[keyof typeof DocumentSourceType]


export const DocumentProcessingType: {
  PDF_TEXT_EXTRACTION: 'PDF_TEXT_EXTRACTION',
  IMAGE_OCR: 'IMAGE_OCR',
  VIDEO_TRANSCRIPT: 'VIDEO_TRANSCRIPT',
  AUDIO_TRANSCRIPT: 'AUDIO_TRANSCRIPT',
  DOCUMENT_EMBEDDING: 'DOCUMENT_EMBEDDING',
  URL_SCRAPING: 'URL_SCRAPING',
  VISION_EXTRACTION: 'VISION_EXTRACTION'
};

export type DocumentProcessingType = (typeof DocumentProcessingType)[keyof typeof DocumentProcessingType]

}

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

export type AdminStatus = $Enums.AdminStatus

export const AdminStatus: typeof $Enums.AdminStatus

export type AdminAction = $Enums.AdminAction

export const AdminAction: typeof $Enums.AdminAction

export type AdminResource = $Enums.AdminResource

export const AdminResource: typeof $Enums.AdminResource

export type SpecificPermission = $Enums.SpecificPermission

export const SpecificPermission: typeof $Enums.SpecificPermission

export type SecurityEventType = $Enums.SecurityEventType

export const SecurityEventType: typeof $Enums.SecurityEventType

export type SecuritySeverity = $Enums.SecuritySeverity

export const SecuritySeverity: typeof $Enums.SecuritySeverity

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type ModelCategory = $Enums.ModelCategory

export const ModelCategory: typeof $Enums.ModelCategory

export type PodType = $Enums.PodType

export const PodType: typeof $Enums.PodType

export type PodExecutionStatus = $Enums.PodExecutionStatus

export const PodExecutionStatus: typeof $Enums.PodExecutionStatus

export type FlowVisibility = $Enums.FlowVisibility

export const FlowVisibility: typeof $Enums.FlowVisibility

export type FlowAccessLevel = $Enums.FlowAccessLevel

export const FlowAccessLevel: typeof $Enums.FlowAccessLevel

export type FlowActivityAction = $Enums.FlowActivityAction

export const FlowActivityAction: typeof $Enums.FlowActivityAction

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type WorkspaceType = $Enums.WorkspaceType

export const WorkspaceType: typeof $Enums.WorkspaceType

export type WorkspaceRole = $Enums.WorkspaceRole

export const WorkspaceRole: typeof $Enums.WorkspaceRole

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type ShareAccessLevel = $Enums.ShareAccessLevel

export const ShareAccessLevel: typeof $Enums.ShareAccessLevel

export type LLMProvider = $Enums.LLMProvider

export const LLMProvider: typeof $Enums.LLMProvider

export type AuthType = $Enums.AuthType

export const AuthType: typeof $Enums.AuthType

export type ShareableAssetType = $Enums.ShareableAssetType

export const ShareableAssetType: typeof $Enums.ShareableAssetType

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type DocumentSourceType = $Enums.DocumentSourceType

export const DocumentSourceType: typeof $Enums.DocumentSourceType

export type DocumentProcessingType = $Enums.DocumentProcessingType

export const DocumentProcessingType: typeof $Enums.DocumentProcessingType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSession`: Exposes CRUD operations for the **AdminSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSessions
    * const adminSessions = await prisma.adminSession.findMany()
    * ```
    */
  get adminSession(): Prisma.AdminSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminPermission`: Exposes CRUD operations for the **AdminPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminPermissions
    * const adminPermissions = await prisma.adminPermission.findMany()
    * ```
    */
  get adminPermission(): Prisma.AdminPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAPIKey`: Exposes CRUD operations for the **AdminAPIKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAPIKeys
    * const adminAPIKeys = await prisma.adminAPIKey.findMany()
    * ```
    */
  get adminAPIKey(): Prisma.AdminAPIKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminInvitation`: Exposes CRUD operations for the **AdminInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminInvitations
    * const adminInvitations = await prisma.adminInvitation.findMany()
    * ```
    */
  get adminInvitation(): Prisma.AdminInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSecurityEvent`: Exposes CRUD operations for the **AdminSecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSecurityEvents
    * const adminSecurityEvents = await prisma.adminSecurityEvent.findMany()
    * ```
    */
  get adminSecurityEvent(): Prisma.AdminSecurityEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditPurchase`: Exposes CRUD operations for the **CreditPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditPurchases
    * const creditPurchases = await prisma.creditPurchase.findMany()
    * ```
    */
  get creditPurchase(): Prisma.CreditPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditUsageLog`: Exposes CRUD operations for the **CreditUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditUsageLogs
    * const creditUsageLogs = await prisma.creditUsageLog.findMany()
    * ```
    */
  get creditUsageLog(): Prisma.CreditUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelPricingTier`: Exposes CRUD operations for the **ModelPricingTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelPricingTiers
    * const modelPricingTiers = await prisma.modelPricingTier.findMany()
    * ```
    */
  get modelPricingTier(): Prisma.ModelPricingTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.space`: Exposes CRUD operations for the **Space** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spaces
    * const spaces = await prisma.space.findMany()
    * ```
    */
  get space(): Prisma.SpaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flow`: Exposes CRUD operations for the **Flow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flows
    * const flows = await prisma.flow.findMany()
    * ```
    */
  get flow(): Prisma.FlowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowInvitation`: Exposes CRUD operations for the **FlowInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowInvitations
    * const flowInvitations = await prisma.flowInvitation.findMany()
    * ```
    */
  get flowInvitation(): Prisma.FlowInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowCollaborator`: Exposes CRUD operations for the **FlowCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowCollaborators
    * const flowCollaborators = await prisma.flowCollaborator.findMany()
    * ```
    */
  get flowCollaborator(): Prisma.FlowCollaboratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowSession`: Exposes CRUD operations for the **FlowSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowSessions
    * const flowSessions = await prisma.flowSession.findMany()
    * ```
    */
  get flowSession(): Prisma.FlowSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowActivityLog`: Exposes CRUD operations for the **FlowActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowActivityLogs
    * const flowActivityLogs = await prisma.flowActivityLog.findMany()
    * ```
    */
  get flowActivityLog(): Prisma.FlowActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowComment`: Exposes CRUD operations for the **FlowComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowComments
    * const flowComments = await prisma.flowComment.findMany()
    * ```
    */
  get flowComment(): Prisma.FlowCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pod`: Exposes CRUD operations for the **Pod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pods
    * const pods = await prisma.pod.findMany()
    * ```
    */
  get pod(): Prisma.PodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edge`: Exposes CRUD operations for the **Edge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Edges
    * const edges = await prisma.edge.findMany()
    * ```
    */
  get edge(): Prisma.EdgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podExecution`: Exposes CRUD operations for the **PodExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodExecutions
    * const podExecutions = await prisma.podExecution.findMany()
    * ```
    */
  get podExecution(): Prisma.PodExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podUsageLog`: Exposes CRUD operations for the **PodUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodUsageLogs
    * const podUsageLogs = await prisma.podUsageLog.findMany()
    * ```
    */
  get podUsageLog(): Prisma.PodUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contextModule`: Exposes CRUD operations for the **ContextModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextModules
    * const contextModules = await prisma.contextModule.findMany()
    * ```
    */
  get contextModule(): Prisma.ContextModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceUser`: Exposes CRUD operations for the **WorkspaceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUsers
    * const workspaceUsers = await prisma.workspaceUser.findMany()
    * ```
    */
  get workspaceUser(): Prisma.WorkspaceUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceInvitation`: Exposes CRUD operations for the **WorkspaceInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceInvitations
    * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
    * ```
    */
  get workspaceInvitation(): Prisma.WorkspaceInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerAPIKey`: Exposes CRUD operations for the **ProviderAPIKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderAPIKeys
    * const providerAPIKeys = await prisma.providerAPIKey.findMany()
    * ```
    */
  get providerAPIKey(): Prisma.ProviderAPIKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareLink`: Exposes CRUD operations for the **ShareLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareLinks
    * const shareLinks = await prisma.shareLink.findMany()
    * ```
    */
  get shareLink(): Prisma.ShareLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentFolder`: Exposes CRUD operations for the **DocumentFolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentFolders
    * const documentFolders = await prisma.documentFolder.findMany()
    * ```
    */
  get documentFolder(): Prisma.DocumentFolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.embedding`: Exposes CRUD operations for the **Embedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Embeddings
    * const embeddings = await prisma.embedding.findMany()
    * ```
    */
  get embedding(): Prisma.EmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentProcessingCost`: Exposes CRUD operations for the **DocumentProcessingCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentProcessingCosts
    * const documentProcessingCosts = await prisma.documentProcessingCost.findMany()
    * ```
    */
  get documentProcessingCost(): Prisma.DocumentProcessingCostDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    AdminSession: 'AdminSession',
    AdminAuditLog: 'AdminAuditLog',
    AdminPermission: 'AdminPermission',
    AdminAPIKey: 'AdminAPIKey',
    AdminInvitation: 'AdminInvitation',
    AdminSecurityEvent: 'AdminSecurityEvent',
    Subscription: 'Subscription',
    CreditPurchase: 'CreditPurchase',
    CreditUsageLog: 'CreditUsageLog',
    ModelPricingTier: 'ModelPricingTier',
    Space: 'Space',
    Flow: 'Flow',
    FlowInvitation: 'FlowInvitation',
    FlowCollaborator: 'FlowCollaborator',
    FlowSession: 'FlowSession',
    FlowActivityLog: 'FlowActivityLog',
    FlowComment: 'FlowComment',
    Pod: 'Pod',
    Edge: 'Edge',
    PodExecution: 'PodExecution',
    PodUsageLog: 'PodUsageLog',
    ContextModule: 'ContextModule',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Account: 'Account',
    Workspace: 'Workspace',
    WorkspaceUser: 'WorkspaceUser',
    WorkspaceInvitation: 'WorkspaceInvitation',
    ProviderAPIKey: 'ProviderAPIKey',
    ShareLink: 'ShareLink',
    DocumentFolder: 'DocumentFolder',
    Document: 'Document',
    Embedding: 'Embedding',
    DocumentProcessingCost: 'DocumentProcessingCost'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "adminSession" | "adminAuditLog" | "adminPermission" | "adminAPIKey" | "adminInvitation" | "adminSecurityEvent" | "subscription" | "creditPurchase" | "creditUsageLog" | "modelPricingTier" | "space" | "flow" | "flowInvitation" | "flowCollaborator" | "flowSession" | "flowActivityLog" | "flowComment" | "pod" | "edge" | "podExecution" | "podUsageLog" | "contextModule" | "user" | "refreshToken" | "account" | "workspace" | "workspaceUser" | "workspaceInvitation" | "providerAPIKey" | "shareLink" | "documentFolder" | "document" | "embedding" | "documentProcessingCost"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminSession: {
        payload: Prisma.$AdminSessionPayload<ExtArgs>
        fields: Prisma.AdminSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findFirst: {
            args: Prisma.AdminSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findMany: {
            args: Prisma.AdminSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          create: {
            args: Prisma.AdminSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          createMany: {
            args: Prisma.AdminSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          delete: {
            args: Prisma.AdminSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          update: {
            args: Prisma.AdminSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          deleteMany: {
            args: Prisma.AdminSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          upsert: {
            args: Prisma.AdminSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          aggregate: {
            args: Prisma.AdminSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSession>
          }
          groupBy: {
            args: Prisma.AdminSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      AdminPermission: {
        payload: Prisma.$AdminPermissionPayload<ExtArgs>
        fields: Prisma.AdminPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          findFirst: {
            args: Prisma.AdminPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          findMany: {
            args: Prisma.AdminPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          create: {
            args: Prisma.AdminPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          createMany: {
            args: Prisma.AdminPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          delete: {
            args: Prisma.AdminPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          update: {
            args: Prisma.AdminPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          deleteMany: {
            args: Prisma.AdminPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          upsert: {
            args: Prisma.AdminPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          aggregate: {
            args: Prisma.AdminPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminPermission>
          }
          groupBy: {
            args: Prisma.AdminPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminPermissionCountAggregateOutputType> | number
          }
        }
      }
      AdminAPIKey: {
        payload: Prisma.$AdminAPIKeyPayload<ExtArgs>
        fields: Prisma.AdminAPIKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAPIKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAPIKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          findFirst: {
            args: Prisma.AdminAPIKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAPIKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          findMany: {
            args: Prisma.AdminAPIKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>[]
          }
          create: {
            args: Prisma.AdminAPIKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          createMany: {
            args: Prisma.AdminAPIKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAPIKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>[]
          }
          delete: {
            args: Prisma.AdminAPIKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          update: {
            args: Prisma.AdminAPIKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          deleteMany: {
            args: Prisma.AdminAPIKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAPIKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAPIKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>[]
          }
          upsert: {
            args: Prisma.AdminAPIKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          aggregate: {
            args: Prisma.AdminAPIKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAPIKey>
          }
          groupBy: {
            args: Prisma.AdminAPIKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAPIKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAPIKeyCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAPIKeyCountAggregateOutputType> | number
          }
        }
      }
      AdminInvitation: {
        payload: Prisma.$AdminInvitationPayload<ExtArgs>
        fields: Prisma.AdminInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          findFirst: {
            args: Prisma.AdminInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          findMany: {
            args: Prisma.AdminInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>[]
          }
          create: {
            args: Prisma.AdminInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          createMany: {
            args: Prisma.AdminInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>[]
          }
          delete: {
            args: Prisma.AdminInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          update: {
            args: Prisma.AdminInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          deleteMany: {
            args: Prisma.AdminInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>[]
          }
          upsert: {
            args: Prisma.AdminInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          aggregate: {
            args: Prisma.AdminInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminInvitation>
          }
          groupBy: {
            args: Prisma.AdminInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<AdminInvitationCountAggregateOutputType> | number
          }
        }
      }
      AdminSecurityEvent: {
        payload: Prisma.$AdminSecurityEventPayload<ExtArgs>
        fields: Prisma.AdminSecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          findFirst: {
            args: Prisma.AdminSecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          findMany: {
            args: Prisma.AdminSecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>[]
          }
          create: {
            args: Prisma.AdminSecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          createMany: {
            args: Prisma.AdminSecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>[]
          }
          delete: {
            args: Prisma.AdminSecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          update: {
            args: Prisma.AdminSecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.AdminSecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminSecurityEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>[]
          }
          upsert: {
            args: Prisma.AdminSecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          aggregate: {
            args: Prisma.AdminSecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSecurityEvent>
          }
          groupBy: {
            args: Prisma.AdminSecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSecurityEventCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      CreditPurchase: {
        payload: Prisma.$CreditPurchasePayload<ExtArgs>
        fields: Prisma.CreditPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          findFirst: {
            args: Prisma.CreditPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          findMany: {
            args: Prisma.CreditPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>[]
          }
          create: {
            args: Prisma.CreditPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          createMany: {
            args: Prisma.CreditPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditPurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>[]
          }
          delete: {
            args: Prisma.CreditPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          update: {
            args: Prisma.CreditPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          deleteMany: {
            args: Prisma.CreditPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditPurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>[]
          }
          upsert: {
            args: Prisma.CreditPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          aggregate: {
            args: Prisma.CreditPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditPurchase>
          }
          groupBy: {
            args: Prisma.CreditPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<CreditPurchaseCountAggregateOutputType> | number
          }
        }
      }
      CreditUsageLog: {
        payload: Prisma.$CreditUsageLogPayload<ExtArgs>
        fields: Prisma.CreditUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          findFirst: {
            args: Prisma.CreditUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          findMany: {
            args: Prisma.CreditUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>[]
          }
          create: {
            args: Prisma.CreditUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          createMany: {
            args: Prisma.CreditUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>[]
          }
          delete: {
            args: Prisma.CreditUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          update: {
            args: Prisma.CreditUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.CreditUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.CreditUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          aggregate: {
            args: Prisma.CreditUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditUsageLog>
          }
          groupBy: {
            args: Prisma.CreditUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<CreditUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ModelPricingTier: {
        payload: Prisma.$ModelPricingTierPayload<ExtArgs>
        fields: Prisma.ModelPricingTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelPricingTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelPricingTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          findFirst: {
            args: Prisma.ModelPricingTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelPricingTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          findMany: {
            args: Prisma.ModelPricingTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>[]
          }
          create: {
            args: Prisma.ModelPricingTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          createMany: {
            args: Prisma.ModelPricingTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelPricingTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>[]
          }
          delete: {
            args: Prisma.ModelPricingTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          update: {
            args: Prisma.ModelPricingTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          deleteMany: {
            args: Prisma.ModelPricingTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelPricingTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelPricingTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>[]
          }
          upsert: {
            args: Prisma.ModelPricingTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          aggregate: {
            args: Prisma.ModelPricingTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelPricingTier>
          }
          groupBy: {
            args: Prisma.ModelPricingTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelPricingTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelPricingTierCountArgs<ExtArgs>
            result: $Utils.Optional<ModelPricingTierCountAggregateOutputType> | number
          }
        }
      }
      Space: {
        payload: Prisma.$SpacePayload<ExtArgs>
        fields: Prisma.SpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findFirst: {
            args: Prisma.SpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findMany: {
            args: Prisma.SpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          create: {
            args: Prisma.SpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          createMany: {
            args: Prisma.SpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          delete: {
            args: Prisma.SpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          update: {
            args: Prisma.SpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          deleteMany: {
            args: Prisma.SpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          upsert: {
            args: Prisma.SpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          aggregate: {
            args: Prisma.SpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpace>
          }
          groupBy: {
            args: Prisma.SpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceCountAggregateOutputType> | number
          }
        }
      }
      Flow: {
        payload: Prisma.$FlowPayload<ExtArgs>
        fields: Prisma.FlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          findFirst: {
            args: Prisma.FlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          findMany: {
            args: Prisma.FlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>[]
          }
          create: {
            args: Prisma.FlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          createMany: {
            args: Prisma.FlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>[]
          }
          delete: {
            args: Prisma.FlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          update: {
            args: Prisma.FlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          deleteMany: {
            args: Prisma.FlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>[]
          }
          upsert: {
            args: Prisma.FlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          aggregate: {
            args: Prisma.FlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlow>
          }
          groupBy: {
            args: Prisma.FlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowCountArgs<ExtArgs>
            result: $Utils.Optional<FlowCountAggregateOutputType> | number
          }
        }
      }
      FlowInvitation: {
        payload: Prisma.$FlowInvitationPayload<ExtArgs>
        fields: Prisma.FlowInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>
          }
          findFirst: {
            args: Prisma.FlowInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>
          }
          findMany: {
            args: Prisma.FlowInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>[]
          }
          create: {
            args: Prisma.FlowInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>
          }
          createMany: {
            args: Prisma.FlowInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>[]
          }
          delete: {
            args: Prisma.FlowInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>
          }
          update: {
            args: Prisma.FlowInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>
          }
          deleteMany: {
            args: Prisma.FlowInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>[]
          }
          upsert: {
            args: Prisma.FlowInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowInvitationPayload>
          }
          aggregate: {
            args: Prisma.FlowInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowInvitation>
          }
          groupBy: {
            args: Prisma.FlowInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<FlowInvitationCountAggregateOutputType> | number
          }
        }
      }
      FlowCollaborator: {
        payload: Prisma.$FlowCollaboratorPayload<ExtArgs>
        fields: Prisma.FlowCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.FlowCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>
          }
          findMany: {
            args: Prisma.FlowCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>[]
          }
          create: {
            args: Prisma.FlowCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>
          }
          createMany: {
            args: Prisma.FlowCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.FlowCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>
          }
          update: {
            args: Prisma.FlowCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.FlowCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowCollaboratorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>[]
          }
          upsert: {
            args: Prisma.FlowCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.FlowCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowCollaborator>
          }
          groupBy: {
            args: Prisma.FlowCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<FlowCollaboratorCountAggregateOutputType> | number
          }
        }
      }
      FlowSession: {
        payload: Prisma.$FlowSessionPayload<ExtArgs>
        fields: Prisma.FlowSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>
          }
          findFirst: {
            args: Prisma.FlowSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>
          }
          findMany: {
            args: Prisma.FlowSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>[]
          }
          create: {
            args: Prisma.FlowSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>
          }
          createMany: {
            args: Prisma.FlowSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>[]
          }
          delete: {
            args: Prisma.FlowSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>
          }
          update: {
            args: Prisma.FlowSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>
          }
          deleteMany: {
            args: Prisma.FlowSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>[]
          }
          upsert: {
            args: Prisma.FlowSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowSessionPayload>
          }
          aggregate: {
            args: Prisma.FlowSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowSession>
          }
          groupBy: {
            args: Prisma.FlowSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowSessionCountArgs<ExtArgs>
            result: $Utils.Optional<FlowSessionCountAggregateOutputType> | number
          }
        }
      }
      FlowActivityLog: {
        payload: Prisma.$FlowActivityLogPayload<ExtArgs>
        fields: Prisma.FlowActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>
          }
          findFirst: {
            args: Prisma.FlowActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>
          }
          findMany: {
            args: Prisma.FlowActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>[]
          }
          create: {
            args: Prisma.FlowActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>
          }
          createMany: {
            args: Prisma.FlowActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>[]
          }
          delete: {
            args: Prisma.FlowActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>
          }
          update: {
            args: Prisma.FlowActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.FlowActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.FlowActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowActivityLogPayload>
          }
          aggregate: {
            args: Prisma.FlowActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowActivityLog>
          }
          groupBy: {
            args: Prisma.FlowActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<FlowActivityLogCountAggregateOutputType> | number
          }
        }
      }
      FlowComment: {
        payload: Prisma.$FlowCommentPayload<ExtArgs>
        fields: Prisma.FlowCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>
          }
          findFirst: {
            args: Prisma.FlowCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>
          }
          findMany: {
            args: Prisma.FlowCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>[]
          }
          create: {
            args: Prisma.FlowCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>
          }
          createMany: {
            args: Prisma.FlowCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>[]
          }
          delete: {
            args: Prisma.FlowCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>
          }
          update: {
            args: Prisma.FlowCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>
          }
          deleteMany: {
            args: Prisma.FlowCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>[]
          }
          upsert: {
            args: Prisma.FlowCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowCommentPayload>
          }
          aggregate: {
            args: Prisma.FlowCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowComment>
          }
          groupBy: {
            args: Prisma.FlowCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowCommentCountArgs<ExtArgs>
            result: $Utils.Optional<FlowCommentCountAggregateOutputType> | number
          }
        }
      }
      Pod: {
        payload: Prisma.$PodPayload<ExtArgs>
        fields: Prisma.PodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          findFirst: {
            args: Prisma.PodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          findMany: {
            args: Prisma.PodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>[]
          }
          create: {
            args: Prisma.PodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          createMany: {
            args: Prisma.PodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>[]
          }
          delete: {
            args: Prisma.PodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          update: {
            args: Prisma.PodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          deleteMany: {
            args: Prisma.PodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>[]
          }
          upsert: {
            args: Prisma.PodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          aggregate: {
            args: Prisma.PodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePod>
          }
          groupBy: {
            args: Prisma.PodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodCountArgs<ExtArgs>
            result: $Utils.Optional<PodCountAggregateOutputType> | number
          }
        }
      }
      Edge: {
        payload: Prisma.$EdgePayload<ExtArgs>
        fields: Prisma.EdgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EdgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EdgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          findFirst: {
            args: Prisma.EdgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EdgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          findMany: {
            args: Prisma.EdgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]
          }
          create: {
            args: Prisma.EdgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          createMany: {
            args: Prisma.EdgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EdgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]
          }
          delete: {
            args: Prisma.EdgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          update: {
            args: Prisma.EdgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          deleteMany: {
            args: Prisma.EdgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EdgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EdgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]
          }
          upsert: {
            args: Prisma.EdgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          aggregate: {
            args: Prisma.EdgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdge>
          }
          groupBy: {
            args: Prisma.EdgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EdgeCountArgs<ExtArgs>
            result: $Utils.Optional<EdgeCountAggregateOutputType> | number
          }
        }
      }
      PodExecution: {
        payload: Prisma.$PodExecutionPayload<ExtArgs>
        fields: Prisma.PodExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>
          }
          findFirst: {
            args: Prisma.PodExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>
          }
          findMany: {
            args: Prisma.PodExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>[]
          }
          create: {
            args: Prisma.PodExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>
          }
          createMany: {
            args: Prisma.PodExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>[]
          }
          delete: {
            args: Prisma.PodExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>
          }
          update: {
            args: Prisma.PodExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>
          }
          deleteMany: {
            args: Prisma.PodExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>[]
          }
          upsert: {
            args: Prisma.PodExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodExecutionPayload>
          }
          aggregate: {
            args: Prisma.PodExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodExecution>
          }
          groupBy: {
            args: Prisma.PodExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<PodExecutionCountAggregateOutputType> | number
          }
        }
      }
      PodUsageLog: {
        payload: Prisma.$PodUsageLogPayload<ExtArgs>
        fields: Prisma.PodUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          findFirst: {
            args: Prisma.PodUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          findMany: {
            args: Prisma.PodUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>[]
          }
          create: {
            args: Prisma.PodUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          createMany: {
            args: Prisma.PodUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>[]
          }
          delete: {
            args: Prisma.PodUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          update: {
            args: Prisma.PodUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.PodUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.PodUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          aggregate: {
            args: Prisma.PodUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodUsageLog>
          }
          groupBy: {
            args: Prisma.PodUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<PodUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ContextModule: {
        payload: Prisma.$ContextModulePayload<ExtArgs>
        fields: Prisma.ContextModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          findFirst: {
            args: Prisma.ContextModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          findMany: {
            args: Prisma.ContextModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>[]
          }
          create: {
            args: Prisma.ContextModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          createMany: {
            args: Prisma.ContextModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContextModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>[]
          }
          delete: {
            args: Prisma.ContextModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          update: {
            args: Prisma.ContextModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          deleteMany: {
            args: Prisma.ContextModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContextModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContextModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>[]
          }
          upsert: {
            args: Prisma.ContextModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          aggregate: {
            args: Prisma.ContextModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContextModule>
          }
          groupBy: {
            args: Prisma.ContextModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContextModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ContextModuleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUser: {
        payload: Prisma.$WorkspaceUserPayload<ExtArgs>
        fields: Prisma.WorkspaceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          update: {
            args: Prisma.WorkspaceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUser>
          }
          groupBy: {
            args: Prisma.WorkspaceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceInvitation: {
        payload: Prisma.$WorkspaceInvitationPayload<ExtArgs>
        fields: Prisma.WorkspaceInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          update: {
            args: Prisma.WorkspaceInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceInvitation>
          }
          groupBy: {
            args: Prisma.WorkspaceInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationCountAggregateOutputType> | number
          }
        }
      }
      ProviderAPIKey: {
        payload: Prisma.$ProviderAPIKeyPayload<ExtArgs>
        fields: Prisma.ProviderAPIKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderAPIKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderAPIKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          findFirst: {
            args: Prisma.ProviderAPIKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderAPIKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          findMany: {
            args: Prisma.ProviderAPIKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>[]
          }
          create: {
            args: Prisma.ProviderAPIKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          createMany: {
            args: Prisma.ProviderAPIKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderAPIKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>[]
          }
          delete: {
            args: Prisma.ProviderAPIKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          update: {
            args: Prisma.ProviderAPIKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          deleteMany: {
            args: Prisma.ProviderAPIKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderAPIKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderAPIKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>[]
          }
          upsert: {
            args: Prisma.ProviderAPIKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          aggregate: {
            args: Prisma.ProviderAPIKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderAPIKey>
          }
          groupBy: {
            args: Prisma.ProviderAPIKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderAPIKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderAPIKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderAPIKeyCountAggregateOutputType> | number
          }
        }
      }
      ShareLink: {
        payload: Prisma.$ShareLinkPayload<ExtArgs>
        fields: Prisma.ShareLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          findFirst: {
            args: Prisma.ShareLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          findMany: {
            args: Prisma.ShareLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          create: {
            args: Prisma.ShareLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          createMany: {
            args: Prisma.ShareLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          delete: {
            args: Prisma.ShareLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          update: {
            args: Prisma.ShareLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          deleteMany: {
            args: Prisma.ShareLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShareLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          upsert: {
            args: Prisma.ShareLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          aggregate: {
            args: Prisma.ShareLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareLink>
          }
          groupBy: {
            args: Prisma.ShareLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ShareLinkCountAggregateOutputType> | number
          }
        }
      }
      DocumentFolder: {
        payload: Prisma.$DocumentFolderPayload<ExtArgs>
        fields: Prisma.DocumentFolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>
          }
          findFirst: {
            args: Prisma.DocumentFolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>
          }
          findMany: {
            args: Prisma.DocumentFolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>[]
          }
          create: {
            args: Prisma.DocumentFolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>
          }
          createMany: {
            args: Prisma.DocumentFolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentFolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>[]
          }
          delete: {
            args: Prisma.DocumentFolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>
          }
          update: {
            args: Prisma.DocumentFolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>
          }
          deleteMany: {
            args: Prisma.DocumentFolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentFolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentFolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>[]
          }
          upsert: {
            args: Prisma.DocumentFolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFolderPayload>
          }
          aggregate: {
            args: Prisma.DocumentFolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentFolder>
          }
          groupBy: {
            args: Prisma.DocumentFolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentFolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentFolderCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentFolderCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Embedding: {
        payload: Prisma.$EmbeddingPayload<ExtArgs>
        fields: Prisma.EmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          findFirst: {
            args: Prisma.EmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          findMany: {
            args: Prisma.EmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          create: {
            args: Prisma.EmbeddingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          createMany: {
            args: Prisma.EmbeddingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmbeddingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          delete: {
            args: Prisma.EmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          update: {
            args: Prisma.EmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.EmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          upsert: {
            args: Prisma.EmbeddingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          aggregate: {
            args: Prisma.EmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmbedding>
          }
          groupBy: {
            args: Prisma.EmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingCountAggregateOutputType> | number
          }
        }
      }
      DocumentProcessingCost: {
        payload: Prisma.$DocumentProcessingCostPayload<ExtArgs>
        fields: Prisma.DocumentProcessingCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentProcessingCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentProcessingCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>
          }
          findFirst: {
            args: Prisma.DocumentProcessingCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentProcessingCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>
          }
          findMany: {
            args: Prisma.DocumentProcessingCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>[]
          }
          create: {
            args: Prisma.DocumentProcessingCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>
          }
          createMany: {
            args: Prisma.DocumentProcessingCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentProcessingCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>[]
          }
          delete: {
            args: Prisma.DocumentProcessingCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>
          }
          update: {
            args: Prisma.DocumentProcessingCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>
          }
          deleteMany: {
            args: Prisma.DocumentProcessingCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentProcessingCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentProcessingCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>[]
          }
          upsert: {
            args: Prisma.DocumentProcessingCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingCostPayload>
          }
          aggregate: {
            args: Prisma.DocumentProcessingCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentProcessingCost>
          }
          groupBy: {
            args: Prisma.DocumentProcessingCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentProcessingCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentProcessingCostCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentProcessingCostCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    adminSession?: AdminSessionOmit
    adminAuditLog?: AdminAuditLogOmit
    adminPermission?: AdminPermissionOmit
    adminAPIKey?: AdminAPIKeyOmit
    adminInvitation?: AdminInvitationOmit
    adminSecurityEvent?: AdminSecurityEventOmit
    subscription?: SubscriptionOmit
    creditPurchase?: CreditPurchaseOmit
    creditUsageLog?: CreditUsageLogOmit
    modelPricingTier?: ModelPricingTierOmit
    space?: SpaceOmit
    flow?: FlowOmit
    flowInvitation?: FlowInvitationOmit
    flowCollaborator?: FlowCollaboratorOmit
    flowSession?: FlowSessionOmit
    flowActivityLog?: FlowActivityLogOmit
    flowComment?: FlowCommentOmit
    pod?: PodOmit
    edge?: EdgeOmit
    podExecution?: PodExecutionOmit
    podUsageLog?: PodUsageLogOmit
    contextModule?: ContextModuleOmit
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    account?: AccountOmit
    workspace?: WorkspaceOmit
    workspaceUser?: WorkspaceUserOmit
    workspaceInvitation?: WorkspaceInvitationOmit
    providerAPIKey?: ProviderAPIKeyOmit
    shareLink?: ShareLinkOmit
    documentFolder?: DocumentFolderOmit
    document?: DocumentOmit
    embedding?: EmbeddingOmit
    documentProcessingCost?: DocumentProcessingCostOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    sessions: number
    auditLogs: number
    permissions: number
    apiKeys: number
    invitations: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AdminCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | AdminCountOutputTypeCountAuditLogsArgs
    permissions?: boolean | AdminCountOutputTypeCountPermissionsArgs
    apiKeys?: boolean | AdminCountOutputTypeCountApiKeysArgs
    invitations?: boolean | AdminCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPermissionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAPIKeyWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminInvitationWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    usageLogs: number
    creditPurchases: number
    creditUsage: number
    documentProcessingCost: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | SubscriptionCountOutputTypeCountUsageLogsArgs
    creditPurchases?: boolean | SubscriptionCountOutputTypeCountCreditPurchasesArgs
    creditUsage?: boolean | SubscriptionCountOutputTypeCountCreditUsageArgs
    documentProcessingCost?: boolean | SubscriptionCountOutputTypeCountDocumentProcessingCostArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodUsageLogWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountCreditPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPurchaseWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountCreditUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditUsageLogWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountDocumentProcessingCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentProcessingCostWhereInput
  }


  /**
   * Count Type SpaceCountOutputType
   */

  export type SpaceCountOutputType = {
    flows: number
  }

  export type SpaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flows?: boolean | SpaceCountOutputTypeCountFlowsArgs
  }

  // Custom InputTypes
  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceCountOutputType
     */
    select?: SpaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowWhereInput
  }


  /**
   * Count Type FlowCountOutputType
   */

  export type FlowCountOutputType = {
    pods: number
    edges: number
    contextualPods: number
    contextModules: number
    collaborators: number
    invitations: number
    sessions: number
    activityLog: number
    comments: number
  }

  export type FlowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pods?: boolean | FlowCountOutputTypeCountPodsArgs
    edges?: boolean | FlowCountOutputTypeCountEdgesArgs
    contextualPods?: boolean | FlowCountOutputTypeCountContextualPodsArgs
    contextModules?: boolean | FlowCountOutputTypeCountContextModulesArgs
    collaborators?: boolean | FlowCountOutputTypeCountCollaboratorsArgs
    invitations?: boolean | FlowCountOutputTypeCountInvitationsArgs
    sessions?: boolean | FlowCountOutputTypeCountSessionsArgs
    activityLog?: boolean | FlowCountOutputTypeCountActivityLogArgs
    comments?: boolean | FlowCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCountOutputType
     */
    select?: FlowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountContextualPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountContextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextModuleWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowCollaboratorWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowInvitationWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowSessionWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowActivityLogWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowCommentWhereInput
  }


  /**
   * Count Type PodCountOutputType
   */

  export type PodCountOutputType = {
    sourceEdges: number
    targetEdges: number
    executions: number
    usageLogs: number
  }

  export type PodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceEdges?: boolean | PodCountOutputTypeCountSourceEdgesArgs
    targetEdges?: boolean | PodCountOutputTypeCountTargetEdgesArgs
    executions?: boolean | PodCountOutputTypeCountExecutionsArgs
    usageLogs?: boolean | PodCountOutputTypeCountUsageLogsArgs
  }

  // Custom InputTypes
  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodCountOutputType
     */
    select?: PodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountSourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountTargetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodExecutionWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodUsageLogWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    workspaces: number
    refreshTokens: number
    flowCollaborations: number
    sentWorkspaceInvites: number
    receivedWorkspaceInvites: number
    sentFlowInvites: number
    receivedFlowInvites: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    flowCollaborations?: boolean | UserCountOutputTypeCountFlowCollaborationsArgs
    sentWorkspaceInvites?: boolean | UserCountOutputTypeCountSentWorkspaceInvitesArgs
    receivedWorkspaceInvites?: boolean | UserCountOutputTypeCountReceivedWorkspaceInvitesArgs
    sentFlowInvites?: boolean | UserCountOutputTypeCountSentFlowInvitesArgs
    receivedFlowInvites?: boolean | UserCountOutputTypeCountReceivedFlowInvitesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlowCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowCollaboratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentFlowInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedFlowInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowInvitationWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    members: number
    spaces: number
    flows: number
    documents: number
    documentFolders: number
    contextModules: number
    shareLinks: number
    apiKeys: number
    invitations: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceCountOutputTypeCountMembersArgs
    spaces?: boolean | WorkspaceCountOutputTypeCountSpacesArgs
    flows?: boolean | WorkspaceCountOutputTypeCountFlowsArgs
    documents?: boolean | WorkspaceCountOutputTypeCountDocumentsArgs
    documentFolders?: boolean | WorkspaceCountOutputTypeCountDocumentFoldersArgs
    contextModules?: boolean | WorkspaceCountOutputTypeCountContextModulesArgs
    shareLinks?: boolean | WorkspaceCountOutputTypeCountShareLinksArgs
    apiKeys?: boolean | WorkspaceCountOutputTypeCountApiKeysArgs
    invitations?: boolean | WorkspaceCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDocumentFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentFolderWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountContextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextModuleWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountShareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderAPIKeyWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }


  /**
   * Count Type DocumentFolderCountOutputType
   */

  export type DocumentFolderCountOutputType = {
    children: number
    documents: number
  }

  export type DocumentFolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | DocumentFolderCountOutputTypeCountChildrenArgs
    documents?: boolean | DocumentFolderCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentFolderCountOutputType without action
   */
  export type DocumentFolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolderCountOutputType
     */
    select?: DocumentFolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentFolderCountOutputType without action
   */
  export type DocumentFolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentFolderWhereInput
  }

  /**
   * DocumentFolderCountOutputType without action
   */
  export type DocumentFolderCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    embeddings: number
    pods: number
    processingCostRecords: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | DocumentCountOutputTypeCountEmbeddingsArgs
    pods?: boolean | DocumentCountOutputTypeCountPodsArgs
    processingCostRecords?: boolean | DocumentCountOutputTypeCountProcessingCostRecordsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountEmbeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbeddingWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountProcessingCostRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentProcessingCostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type AdminSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.AdminRole | null
    status: $Enums.AdminStatus | null
    isSuperAdmin: boolean | null
    requiresMfa: boolean | null
    mfaSecret: string | null
    mfaVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    deactivatedAt: Date | null
    deactivatedBy: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.AdminRole | null
    status: $Enums.AdminStatus | null
    isSuperAdmin: boolean | null
    requiresMfa: boolean | null
    mfaSecret: string | null
    mfaVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    deactivatedAt: Date | null
    deactivatedBy: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    role: number
    status: number
    isSuperAdmin: number
    requiresMfa: number
    mfaSecret: number
    mfaBackupCodes: number
    mfaVerifiedAt: number
    allowedIpAddresses: number
    lastLoginAt: number
    lastLoginIp: number
    failedLoginAttempts: number
    lockedUntil: number
    passwordChangedAt: number
    passwordResetToken: number
    passwordResetExpiry: number
    createdAt: number
    updatedAt: number
    createdBy: number
    deactivatedAt: number
    deactivatedBy: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type AdminSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    status?: true
    isSuperAdmin?: true
    requiresMfa?: true
    mfaSecret?: true
    mfaVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    status?: true
    isSuperAdmin?: true
    requiresMfa?: true
    mfaSecret?: true
    mfaVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    status?: true
    isSuperAdmin?: true
    requiresMfa?: true
    mfaSecret?: true
    mfaBackupCodes?: true
    mfaVerifiedAt?: true
    allowedIpAddresses?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    role: $Enums.AdminRole
    status: $Enums.AdminStatus
    isSuperAdmin: boolean
    requiresMfa: boolean
    mfaSecret: string | null
    mfaBackupCodes: JsonValue | null
    mfaVerifiedAt: Date | null
    allowedIpAddresses: JsonValue | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginAttempts: number
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    deactivatedAt: Date | null
    deactivatedBy: string | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
    sessions?: boolean | Admin$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Admin$auditLogsArgs<ExtArgs>
    permissions?: boolean | Admin$permissionsArgs<ExtArgs>
    apiKeys?: boolean | Admin$apiKeysArgs<ExtArgs>
    invitations?: boolean | Admin$invitationsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "passwordHash" | "role" | "status" | "isSuperAdmin" | "requiresMfa" | "mfaSecret" | "mfaBackupCodes" | "mfaVerifiedAt" | "allowedIpAddresses" | "lastLoginAt" | "lastLoginIp" | "failedLoginAttempts" | "lockedUntil" | "passwordChangedAt" | "passwordResetToken" | "passwordResetExpiry" | "createdAt" | "updatedAt" | "createdBy" | "deactivatedAt" | "deactivatedBy", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Admin$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Admin$auditLogsArgs<ExtArgs>
    permissions?: boolean | Admin$permissionsArgs<ExtArgs>
    apiKeys?: boolean | Admin$apiKeysArgs<ExtArgs>
    invitations?: boolean | Admin$invitationsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      sessions: Prisma.$AdminSessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
      permissions: Prisma.$AdminPermissionPayload<ExtArgs>[]
      apiKeys: Prisma.$AdminAPIKeyPayload<ExtArgs>[]
      invitations: Prisma.$AdminInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      role: $Enums.AdminRole
      status: $Enums.AdminStatus
      isSuperAdmin: boolean
      requiresMfa: boolean
      mfaSecret: string | null
      mfaBackupCodes: Prisma.JsonValue | null
      mfaVerifiedAt: Date | null
      allowedIpAddresses: Prisma.JsonValue | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedLoginAttempts: number
      lockedUntil: Date | null
      passwordChangedAt: Date | null
      passwordResetToken: string | null
      passwordResetExpiry: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      deactivatedAt: Date | null
      deactivatedBy: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Admin$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Admin$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Admin$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends Admin$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Admin$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Admin$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly passwordHash: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'AdminRole'>
    readonly status: FieldRef<"Admin", 'AdminStatus'>
    readonly isSuperAdmin: FieldRef<"Admin", 'Boolean'>
    readonly requiresMfa: FieldRef<"Admin", 'Boolean'>
    readonly mfaSecret: FieldRef<"Admin", 'String'>
    readonly mfaBackupCodes: FieldRef<"Admin", 'Json'>
    readonly mfaVerifiedAt: FieldRef<"Admin", 'DateTime'>
    readonly allowedIpAddresses: FieldRef<"Admin", 'Json'>
    readonly lastLoginAt: FieldRef<"Admin", 'DateTime'>
    readonly lastLoginIp: FieldRef<"Admin", 'String'>
    readonly failedLoginAttempts: FieldRef<"Admin", 'Int'>
    readonly lockedUntil: FieldRef<"Admin", 'DateTime'>
    readonly passwordChangedAt: FieldRef<"Admin", 'DateTime'>
    readonly passwordResetToken: FieldRef<"Admin", 'String'>
    readonly passwordResetExpiry: FieldRef<"Admin", 'DateTime'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly createdBy: FieldRef<"Admin", 'String'>
    readonly deactivatedAt: FieldRef<"Admin", 'DateTime'>
    readonly deactivatedBy: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.sessions
   */
  export type Admin$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    cursor?: AdminSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * Admin.auditLogs
   */
  export type Admin$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * Admin.permissions
   */
  export type Admin$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    where?: AdminPermissionWhereInput
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    cursor?: AdminPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * Admin.apiKeys
   */
  export type Admin$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    where?: AdminAPIKeyWhereInput
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    cursor?: AdminAPIKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * Admin.invitations
   */
  export type Admin$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    where?: AdminInvitationWhereInput
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    cursor?: AdminInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model AdminSession
   */

  export type AggregateAdminSession = {
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  export type AdminSessionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    createdAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    revokedAt: Date | null
    revokedReason: string | null
  }

  export type AdminSessionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    createdAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    revokedAt: Date | null
    revokedReason: string | null
  }

  export type AdminSessionCountAggregateOutputType = {
    id: number
    adminId: number
    token: number
    refreshToken: number
    ipAddress: number
    userAgent: number
    deviceFingerprint: number
    createdAt: number
    expiresAt: number
    lastActivityAt: number
    revokedAt: number
    revokedReason: number
    _all: number
  }


  export type AdminSessionMinAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    createdAt?: true
    expiresAt?: true
    lastActivityAt?: true
    revokedAt?: true
    revokedReason?: true
  }

  export type AdminSessionMaxAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    createdAt?: true
    expiresAt?: true
    lastActivityAt?: true
    revokedAt?: true
    revokedReason?: true
  }

  export type AdminSessionCountAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    createdAt?: true
    expiresAt?: true
    lastActivityAt?: true
    revokedAt?: true
    revokedReason?: true
    _all?: true
  }

  export type AdminSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSession to aggregate.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSessions
    **/
    _count?: true | AdminSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSessionMaxAggregateInputType
  }

  export type GetAdminSessionAggregateType<T extends AdminSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSession[P]>
      : GetScalarType<T[P], AggregateAdminSession[P]>
  }




  export type AdminSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithAggregationInput | AdminSessionOrderByWithAggregationInput[]
    by: AdminSessionScalarFieldEnum[] | AdminSessionScalarFieldEnum
    having?: AdminSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSessionCountAggregateInputType | true
    _min?: AdminSessionMinAggregateInputType
    _max?: AdminSessionMaxAggregateInputType
  }

  export type AdminSessionGroupByOutputType = {
    id: string
    adminId: string
    token: string
    refreshToken: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint: string | null
    createdAt: Date
    expiresAt: Date
    lastActivityAt: Date
    revokedAt: Date | null
    revokedReason: string | null
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  type GetAdminSessionGroupByPayload<T extends AdminSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
        }
      >
    >


  export type AdminSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectScalar = {
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
  }

  export type AdminSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "token" | "refreshToken" | "ipAddress" | "userAgent" | "deviceFingerprint" | "createdAt" | "expiresAt" | "lastActivityAt" | "revokedAt" | "revokedReason", ExtArgs["result"]["adminSession"]>
  export type AdminSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSession"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      token: string
      refreshToken: string | null
      ipAddress: string
      userAgent: string
      deviceFingerprint: string | null
      createdAt: Date
      expiresAt: Date
      lastActivityAt: Date
      revokedAt: Date | null
      revokedReason: string | null
    }, ExtArgs["result"]["adminSession"]>
    composites: {}
  }

  type AdminSessionGetPayload<S extends boolean | null | undefined | AdminSessionDefaultArgs> = $Result.GetResult<Prisma.$AdminSessionPayload, S>

  type AdminSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminSessionCountAggregateInputType | true
    }

  export interface AdminSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSession'], meta: { name: 'AdminSession' } }
    /**
     * Find zero or one AdminSession that matches the filter.
     * @param {AdminSessionFindUniqueArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSessionFindUniqueArgs>(args: SelectSubset<T, AdminSessionFindUniqueArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSessionFindUniqueOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSessionFindFirstArgs>(args?: SelectSubset<T, AdminSessionFindFirstArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSessions
     * const adminSessions = await prisma.adminSession.findMany()
     * 
     * // Get first 10 AdminSessions
     * const adminSessions = await prisma.adminSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSessionFindManyArgs>(args?: SelectSubset<T, AdminSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminSession.
     * @param {AdminSessionCreateArgs} args - Arguments to create a AdminSession.
     * @example
     * // Create one AdminSession
     * const AdminSession = await prisma.adminSession.create({
     *   data: {
     *     // ... data to create a AdminSession
     *   }
     * })
     * 
     */
    create<T extends AdminSessionCreateArgs>(args: SelectSubset<T, AdminSessionCreateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminSessions.
     * @param {AdminSessionCreateManyArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSessionCreateManyArgs>(args?: SelectSubset<T, AdminSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSessions and returns the data saved in the database.
     * @param {AdminSessionCreateManyAndReturnArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminSession.
     * @param {AdminSessionDeleteArgs} args - Arguments to delete one AdminSession.
     * @example
     * // Delete one AdminSession
     * const AdminSession = await prisma.adminSession.delete({
     *   where: {
     *     // ... filter to delete one AdminSession
     *   }
     * })
     * 
     */
    delete<T extends AdminSessionDeleteArgs>(args: SelectSubset<T, AdminSessionDeleteArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminSession.
     * @param {AdminSessionUpdateArgs} args - Arguments to update one AdminSession.
     * @example
     * // Update one AdminSession
     * const adminSession = await prisma.adminSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSessionUpdateArgs>(args: SelectSubset<T, AdminSessionUpdateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminSessions.
     * @param {AdminSessionDeleteManyArgs} args - Arguments to filter AdminSessions to delete.
     * @example
     * // Delete a few AdminSessions
     * const { count } = await prisma.adminSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSessionDeleteManyArgs>(args?: SelectSubset<T, AdminSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSessionUpdateManyArgs>(args: SelectSubset<T, AdminSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions and returns the data updated in the database.
     * @param {AdminSessionUpdateManyAndReturnArgs} args - Arguments to update many AdminSessions.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminSession.
     * @param {AdminSessionUpsertArgs} args - Arguments to update or create a AdminSession.
     * @example
     * // Update or create a AdminSession
     * const adminSession = await prisma.adminSession.upsert({
     *   create: {
     *     // ... data to create a AdminSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSession we want to update
     *   }
     * })
     */
    upsert<T extends AdminSessionUpsertArgs>(args: SelectSubset<T, AdminSessionUpsertArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionCountArgs} args - Arguments to filter AdminSessions to count.
     * @example
     * // Count the number of AdminSessions
     * const count = await prisma.adminSession.count({
     *   where: {
     *     // ... the filter for the AdminSessions we want to count
     *   }
     * })
    **/
    count<T extends AdminSessionCountArgs>(
      args?: Subset<T, AdminSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSessionAggregateArgs>(args: Subset<T, AdminSessionAggregateArgs>): Prisma.PrismaPromise<GetAdminSessionAggregateType<T>>

    /**
     * Group by AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSessionGroupByArgs['orderBy'] }
        : { orderBy?: AdminSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSession model
   */
  readonly fields: AdminSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSession model
   */
  interface AdminSessionFieldRefs {
    readonly id: FieldRef<"AdminSession", 'String'>
    readonly adminId: FieldRef<"AdminSession", 'String'>
    readonly token: FieldRef<"AdminSession", 'String'>
    readonly refreshToken: FieldRef<"AdminSession", 'String'>
    readonly ipAddress: FieldRef<"AdminSession", 'String'>
    readonly userAgent: FieldRef<"AdminSession", 'String'>
    readonly deviceFingerprint: FieldRef<"AdminSession", 'String'>
    readonly createdAt: FieldRef<"AdminSession", 'DateTime'>
    readonly expiresAt: FieldRef<"AdminSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"AdminSession", 'DateTime'>
    readonly revokedAt: FieldRef<"AdminSession", 'DateTime'>
    readonly revokedReason: FieldRef<"AdminSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminSession findUnique
   */
  export type AdminSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findUniqueOrThrow
   */
  export type AdminSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findFirst
   */
  export type AdminSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findFirstOrThrow
   */
  export type AdminSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findMany
   */
  export type AdminSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSessions to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession create
   */
  export type AdminSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminSession.
     */
    data: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
  }

  /**
   * AdminSession createMany
   */
  export type AdminSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSession createManyAndReturn
   */
  export type AdminSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession update
   */
  export type AdminSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminSession.
     */
    data: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
    /**
     * Choose, which AdminSession to update.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession updateMany
   */
  export type AdminSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to update.
     */
    limit?: number
  }

  /**
   * AdminSession updateManyAndReturn
   */
  export type AdminSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession upsert
   */
  export type AdminSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminSession to update in case it exists.
     */
    where: AdminSessionWhereUniqueInput
    /**
     * In case the AdminSession found by the `where` argument doesn't exist, create a new AdminSession with this data.
     */
    create: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
    /**
     * In case the AdminSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
  }

  /**
   * AdminSession delete
   */
  export type AdminSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter which AdminSession to delete.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession deleteMany
   */
  export type AdminSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSessions to delete
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to delete.
     */
    limit?: number
  }

  /**
   * AdminSession without action
   */
  export type AdminSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _avg: AdminAuditLogAvgAggregateOutputType | null
    _sum: AdminAuditLogSumAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogAvgAggregateOutputType = {
    status: number | null
    executionTimeMs: number | null
  }

  export type AdminAuditLogSumAggregateOutputType = {
    status: number | null
    executionTimeMs: number | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: $Enums.AdminAction | null
    resource: $Enums.AdminResource | null
    resourceId: string | null
    method: string | null
    endpoint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: number | null
    errorMessage: string | null
    executionTimeMs: number | null
    createdAt: Date | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: $Enums.AdminAction | null
    resource: $Enums.AdminResource | null
    resourceId: string | null
    method: string | null
    endpoint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: number | null
    errorMessage: string | null
    executionTimeMs: number | null
    createdAt: Date | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    resource: number
    resourceId: number
    method: number
    endpoint: number
    ipAddress: number
    userAgent: number
    changesBefore: number
    changesAfter: number
    status: number
    errorMessage: number
    metadata: number
    executionTimeMs: number
    createdAt: number
    _all: number
  }


  export type AdminAuditLogAvgAggregateInputType = {
    status?: true
    executionTimeMs?: true
  }

  export type AdminAuditLogSumAggregateInputType = {
    status?: true
    executionTimeMs?: true
  }

  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    method?: true
    endpoint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    method?: true
    endpoint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    method?: true
    endpoint?: true
    ipAddress?: true
    userAgent?: true
    changesBefore?: true
    changesAfter?: true
    status?: true
    errorMessage?: true
    metadata?: true
    executionTimeMs?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _avg?: AdminAuditLogAvgAggregateInputType
    _sum?: AdminAuditLogSumAggregateInputType
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    adminId: string | null
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent: string | null
    changesBefore: JsonValue | null
    changesAfter: JsonValue | null
    status: number
    errorMessage: string | null
    metadata: JsonValue | null
    executionTimeMs: number | null
    createdAt: Date
    _count: AdminAuditLogCountAggregateOutputType | null
    _avg: AdminAuditLogAvgAggregateOutputType | null
    _sum: AdminAuditLogSumAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
  }

  export type AdminAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "resource" | "resourceId" | "method" | "endpoint" | "ipAddress" | "userAgent" | "changesBefore" | "changesAfter" | "status" | "errorMessage" | "metadata" | "executionTimeMs" | "createdAt", ExtArgs["result"]["adminAuditLog"]>
  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string | null
      action: $Enums.AdminAction
      resource: $Enums.AdminResource
      resourceId: string | null
      method: string
      endpoint: string
      ipAddress: string
      userAgent: string | null
      changesBefore: Prisma.JsonValue | null
      changesAfter: Prisma.JsonValue | null
      status: number
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      executionTimeMs: number | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs and returns the data updated in the database.
     * @param {AdminAuditLogUpdateManyAndReturnArgs} args - Arguments to update many AdminAuditLogs.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminAuditLog$adminArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuditLog$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly adminId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'AdminAction'>
    readonly resource: FieldRef<"AdminAuditLog", 'AdminResource'>
    readonly resourceId: FieldRef<"AdminAuditLog", 'String'>
    readonly method: FieldRef<"AdminAuditLog", 'String'>
    readonly endpoint: FieldRef<"AdminAuditLog", 'String'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
    readonly userAgent: FieldRef<"AdminAuditLog", 'String'>
    readonly changesBefore: FieldRef<"AdminAuditLog", 'Json'>
    readonly changesAfter: FieldRef<"AdminAuditLog", 'Json'>
    readonly status: FieldRef<"AdminAuditLog", 'Int'>
    readonly errorMessage: FieldRef<"AdminAuditLog", 'String'>
    readonly metadata: FieldRef<"AdminAuditLog", 'Json'>
    readonly executionTimeMs: FieldRef<"AdminAuditLog", 'Int'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
  }

  /**
   * AdminAuditLog updateManyAndReturn
   */
  export type AdminAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminAuditLog.admin
   */
  export type AdminAuditLog$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AdminPermission
   */

  export type AggregateAdminPermission = {
    _count: AdminPermissionCountAggregateOutputType | null
    _min: AdminPermissionMinAggregateOutputType | null
    _max: AdminPermissionMaxAggregateOutputType | null
  }

  export type AdminPermissionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    permission: $Enums.SpecificPermission | null
    resource: $Enums.AdminResource | null
    grantedAt: Date | null
    grantedBy: string | null
    expiresAt: Date | null
  }

  export type AdminPermissionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    permission: $Enums.SpecificPermission | null
    resource: $Enums.AdminResource | null
    grantedAt: Date | null
    grantedBy: string | null
    expiresAt: Date | null
  }

  export type AdminPermissionCountAggregateOutputType = {
    id: number
    adminId: number
    permission: number
    resource: number
    grantedAt: number
    grantedBy: number
    expiresAt: number
    _all: number
  }


  export type AdminPermissionMinAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    resource?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
  }

  export type AdminPermissionMaxAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    resource?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
  }

  export type AdminPermissionCountAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    resource?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
    _all?: true
  }

  export type AdminPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPermission to aggregate.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminPermissions
    **/
    _count?: true | AdminPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminPermissionMaxAggregateInputType
  }

  export type GetAdminPermissionAggregateType<T extends AdminPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminPermission[P]>
      : GetScalarType<T[P], AggregateAdminPermission[P]>
  }




  export type AdminPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPermissionWhereInput
    orderBy?: AdminPermissionOrderByWithAggregationInput | AdminPermissionOrderByWithAggregationInput[]
    by: AdminPermissionScalarFieldEnum[] | AdminPermissionScalarFieldEnum
    having?: AdminPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminPermissionCountAggregateInputType | true
    _min?: AdminPermissionMinAggregateInputType
    _max?: AdminPermissionMaxAggregateInputType
  }

  export type AdminPermissionGroupByOutputType = {
    id: string
    adminId: string
    permission: $Enums.SpecificPermission
    resource: $Enums.AdminResource | null
    grantedAt: Date
    grantedBy: string | null
    expiresAt: Date | null
    _count: AdminPermissionCountAggregateOutputType | null
    _min: AdminPermissionMinAggregateOutputType | null
    _max: AdminPermissionMaxAggregateOutputType | null
  }

  type GetAdminPermissionGroupByPayload<T extends AdminPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminPermissionGroupByOutputType[P]>
        }
      >
    >


  export type AdminPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectScalar = {
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
  }

  export type AdminPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "permission" | "resource" | "grantedAt" | "grantedBy" | "expiresAt", ExtArgs["result"]["adminPermission"]>
  export type AdminPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminPermission"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      permission: $Enums.SpecificPermission
      resource: $Enums.AdminResource | null
      grantedAt: Date
      grantedBy: string | null
      expiresAt: Date | null
    }, ExtArgs["result"]["adminPermission"]>
    composites: {}
  }

  type AdminPermissionGetPayload<S extends boolean | null | undefined | AdminPermissionDefaultArgs> = $Result.GetResult<Prisma.$AdminPermissionPayload, S>

  type AdminPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminPermissionCountAggregateInputType | true
    }

  export interface AdminPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminPermission'], meta: { name: 'AdminPermission' } }
    /**
     * Find zero or one AdminPermission that matches the filter.
     * @param {AdminPermissionFindUniqueArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminPermissionFindUniqueArgs>(args: SelectSubset<T, AdminPermissionFindUniqueArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminPermissionFindUniqueOrThrowArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindFirstArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminPermissionFindFirstArgs>(args?: SelectSubset<T, AdminPermissionFindFirstArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindFirstOrThrowArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminPermissions
     * const adminPermissions = await prisma.adminPermission.findMany()
     * 
     * // Get first 10 AdminPermissions
     * const adminPermissions = await prisma.adminPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminPermissionFindManyArgs>(args?: SelectSubset<T, AdminPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminPermission.
     * @param {AdminPermissionCreateArgs} args - Arguments to create a AdminPermission.
     * @example
     * // Create one AdminPermission
     * const AdminPermission = await prisma.adminPermission.create({
     *   data: {
     *     // ... data to create a AdminPermission
     *   }
     * })
     * 
     */
    create<T extends AdminPermissionCreateArgs>(args: SelectSubset<T, AdminPermissionCreateArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminPermissions.
     * @param {AdminPermissionCreateManyArgs} args - Arguments to create many AdminPermissions.
     * @example
     * // Create many AdminPermissions
     * const adminPermission = await prisma.adminPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminPermissionCreateManyArgs>(args?: SelectSubset<T, AdminPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminPermissions and returns the data saved in the database.
     * @param {AdminPermissionCreateManyAndReturnArgs} args - Arguments to create many AdminPermissions.
     * @example
     * // Create many AdminPermissions
     * const adminPermission = await prisma.adminPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminPermissions and only return the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminPermission.
     * @param {AdminPermissionDeleteArgs} args - Arguments to delete one AdminPermission.
     * @example
     * // Delete one AdminPermission
     * const AdminPermission = await prisma.adminPermission.delete({
     *   where: {
     *     // ... filter to delete one AdminPermission
     *   }
     * })
     * 
     */
    delete<T extends AdminPermissionDeleteArgs>(args: SelectSubset<T, AdminPermissionDeleteArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminPermission.
     * @param {AdminPermissionUpdateArgs} args - Arguments to update one AdminPermission.
     * @example
     * // Update one AdminPermission
     * const adminPermission = await prisma.adminPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminPermissionUpdateArgs>(args: SelectSubset<T, AdminPermissionUpdateArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminPermissions.
     * @param {AdminPermissionDeleteManyArgs} args - Arguments to filter AdminPermissions to delete.
     * @example
     * // Delete a few AdminPermissions
     * const { count } = await prisma.adminPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminPermissionDeleteManyArgs>(args?: SelectSubset<T, AdminPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminPermissions
     * const adminPermission = await prisma.adminPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminPermissionUpdateManyArgs>(args: SelectSubset<T, AdminPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPermissions and returns the data updated in the database.
     * @param {AdminPermissionUpdateManyAndReturnArgs} args - Arguments to update many AdminPermissions.
     * @example
     * // Update many AdminPermissions
     * const adminPermission = await prisma.adminPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminPermissions and only return the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminPermission.
     * @param {AdminPermissionUpsertArgs} args - Arguments to update or create a AdminPermission.
     * @example
     * // Update or create a AdminPermission
     * const adminPermission = await prisma.adminPermission.upsert({
     *   create: {
     *     // ... data to create a AdminPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminPermission we want to update
     *   }
     * })
     */
    upsert<T extends AdminPermissionUpsertArgs>(args: SelectSubset<T, AdminPermissionUpsertArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionCountArgs} args - Arguments to filter AdminPermissions to count.
     * @example
     * // Count the number of AdminPermissions
     * const count = await prisma.adminPermission.count({
     *   where: {
     *     // ... the filter for the AdminPermissions we want to count
     *   }
     * })
    **/
    count<T extends AdminPermissionCountArgs>(
      args?: Subset<T, AdminPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminPermissionAggregateArgs>(args: Subset<T, AdminPermissionAggregateArgs>): Prisma.PrismaPromise<GetAdminPermissionAggregateType<T>>

    /**
     * Group by AdminPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminPermissionGroupByArgs['orderBy'] }
        : { orderBy?: AdminPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminPermission model
   */
  readonly fields: AdminPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminPermission model
   */
  interface AdminPermissionFieldRefs {
    readonly id: FieldRef<"AdminPermission", 'String'>
    readonly adminId: FieldRef<"AdminPermission", 'String'>
    readonly permission: FieldRef<"AdminPermission", 'SpecificPermission'>
    readonly resource: FieldRef<"AdminPermission", 'AdminResource'>
    readonly grantedAt: FieldRef<"AdminPermission", 'DateTime'>
    readonly grantedBy: FieldRef<"AdminPermission", 'String'>
    readonly expiresAt: FieldRef<"AdminPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminPermission findUnique
   */
  export type AdminPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission findUniqueOrThrow
   */
  export type AdminPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission findFirst
   */
  export type AdminPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPermissions.
     */
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission findFirstOrThrow
   */
  export type AdminPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPermissions.
     */
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission findMany
   */
  export type AdminPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermissions to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission create
   */
  export type AdminPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminPermission.
     */
    data: XOR<AdminPermissionCreateInput, AdminPermissionUncheckedCreateInput>
  }

  /**
   * AdminPermission createMany
   */
  export type AdminPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminPermissions.
     */
    data: AdminPermissionCreateManyInput | AdminPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPermission createManyAndReturn
   */
  export type AdminPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminPermissions.
     */
    data: AdminPermissionCreateManyInput | AdminPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminPermission update
   */
  export type AdminPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminPermission.
     */
    data: XOR<AdminPermissionUpdateInput, AdminPermissionUncheckedUpdateInput>
    /**
     * Choose, which AdminPermission to update.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission updateMany
   */
  export type AdminPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminPermissions.
     */
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPermissions to update
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to update.
     */
    limit?: number
  }

  /**
   * AdminPermission updateManyAndReturn
   */
  export type AdminPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * The data used to update AdminPermissions.
     */
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPermissions to update
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminPermission upsert
   */
  export type AdminPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminPermission to update in case it exists.
     */
    where: AdminPermissionWhereUniqueInput
    /**
     * In case the AdminPermission found by the `where` argument doesn't exist, create a new AdminPermission with this data.
     */
    create: XOR<AdminPermissionCreateInput, AdminPermissionUncheckedCreateInput>
    /**
     * In case the AdminPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminPermissionUpdateInput, AdminPermissionUncheckedUpdateInput>
  }

  /**
   * AdminPermission delete
   */
  export type AdminPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter which AdminPermission to delete.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission deleteMany
   */
  export type AdminPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPermissions to delete
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to delete.
     */
    limit?: number
  }

  /**
   * AdminPermission without action
   */
  export type AdminPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAPIKey
   */

  export type AggregateAdminAPIKey = {
    _count: AdminAPIKeyCountAggregateOutputType | null
    _avg: AdminAPIKeyAvgAggregateOutputType | null
    _sum: AdminAPIKeySumAggregateOutputType | null
    _min: AdminAPIKeyMinAggregateOutputType | null
    _max: AdminAPIKeyMaxAggregateOutputType | null
  }

  export type AdminAPIKeyAvgAggregateOutputType = {
    rateLimit: number | null
  }

  export type AdminAPIKeySumAggregateOutputType = {
    rateLimit: number | null
  }

  export type AdminAPIKeyMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    name: string | null
    keyHash: string | null
    keyPrefix: string | null
    rateLimit: number | null
    createdAt: Date | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
  }

  export type AdminAPIKeyMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    name: string | null
    keyHash: string | null
    keyPrefix: string | null
    rateLimit: number | null
    createdAt: Date | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
  }

  export type AdminAPIKeyCountAggregateOutputType = {
    id: number
    adminId: number
    name: number
    keyHash: number
    keyPrefix: number
    scopes: number
    rateLimit: number
    allowedIps: number
    createdAt: number
    lastUsedAt: number
    expiresAt: number
    revokedAt: number
    _all: number
  }


  export type AdminAPIKeyAvgAggregateInputType = {
    rateLimit?: true
  }

  export type AdminAPIKeySumAggregateInputType = {
    rateLimit?: true
  }

  export type AdminAPIKeyMinAggregateInputType = {
    id?: true
    adminId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    rateLimit?: true
    createdAt?: true
    lastUsedAt?: true
    expiresAt?: true
    revokedAt?: true
  }

  export type AdminAPIKeyMaxAggregateInputType = {
    id?: true
    adminId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    rateLimit?: true
    createdAt?: true
    lastUsedAt?: true
    expiresAt?: true
    revokedAt?: true
  }

  export type AdminAPIKeyCountAggregateInputType = {
    id?: true
    adminId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    scopes?: true
    rateLimit?: true
    allowedIps?: true
    createdAt?: true
    lastUsedAt?: true
    expiresAt?: true
    revokedAt?: true
    _all?: true
  }

  export type AdminAPIKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAPIKey to aggregate.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAPIKeys
    **/
    _count?: true | AdminAPIKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAPIKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAPIKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAPIKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAPIKeyMaxAggregateInputType
  }

  export type GetAdminAPIKeyAggregateType<T extends AdminAPIKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAPIKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAPIKey[P]>
      : GetScalarType<T[P], AggregateAdminAPIKey[P]>
  }




  export type AdminAPIKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAPIKeyWhereInput
    orderBy?: AdminAPIKeyOrderByWithAggregationInput | AdminAPIKeyOrderByWithAggregationInput[]
    by: AdminAPIKeyScalarFieldEnum[] | AdminAPIKeyScalarFieldEnum
    having?: AdminAPIKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAPIKeyCountAggregateInputType | true
    _avg?: AdminAPIKeyAvgAggregateInputType
    _sum?: AdminAPIKeySumAggregateInputType
    _min?: AdminAPIKeyMinAggregateInputType
    _max?: AdminAPIKeyMaxAggregateInputType
  }

  export type AdminAPIKeyGroupByOutputType = {
    id: string
    adminId: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonValue
    rateLimit: number | null
    allowedIps: JsonValue | null
    createdAt: Date
    lastUsedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
    _count: AdminAPIKeyCountAggregateOutputType | null
    _avg: AdminAPIKeyAvgAggregateOutputType | null
    _sum: AdminAPIKeySumAggregateOutputType | null
    _min: AdminAPIKeyMinAggregateOutputType | null
    _max: AdminAPIKeyMaxAggregateOutputType | null
  }

  type GetAdminAPIKeyGroupByPayload<T extends AdminAPIKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAPIKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAPIKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAPIKeyGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAPIKeyGroupByOutputType[P]>
        }
      >
    >


  export type AdminAPIKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAPIKey"]>

  export type AdminAPIKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAPIKey"]>

  export type AdminAPIKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAPIKey"]>

  export type AdminAPIKeySelectScalar = {
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
  }

  export type AdminAPIKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "name" | "keyHash" | "keyPrefix" | "scopes" | "rateLimit" | "allowedIps" | "createdAt" | "lastUsedAt" | "expiresAt" | "revokedAt", ExtArgs["result"]["adminAPIKey"]>
  export type AdminAPIKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminAPIKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminAPIKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminAPIKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAPIKey"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      name: string
      keyHash: string
      keyPrefix: string
      scopes: Prisma.JsonValue
      rateLimit: number | null
      allowedIps: Prisma.JsonValue | null
      createdAt: Date
      lastUsedAt: Date | null
      expiresAt: Date | null
      revokedAt: Date | null
    }, ExtArgs["result"]["adminAPIKey"]>
    composites: {}
  }

  type AdminAPIKeyGetPayload<S extends boolean | null | undefined | AdminAPIKeyDefaultArgs> = $Result.GetResult<Prisma.$AdminAPIKeyPayload, S>

  type AdminAPIKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAPIKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAPIKeyCountAggregateInputType | true
    }

  export interface AdminAPIKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAPIKey'], meta: { name: 'AdminAPIKey' } }
    /**
     * Find zero or one AdminAPIKey that matches the filter.
     * @param {AdminAPIKeyFindUniqueArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAPIKeyFindUniqueArgs>(args: SelectSubset<T, AdminAPIKeyFindUniqueArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAPIKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAPIKeyFindUniqueOrThrowArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAPIKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAPIKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAPIKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyFindFirstArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAPIKeyFindFirstArgs>(args?: SelectSubset<T, AdminAPIKeyFindFirstArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAPIKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyFindFirstOrThrowArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAPIKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAPIKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAPIKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAPIKeys
     * const adminAPIKeys = await prisma.adminAPIKey.findMany()
     * 
     * // Get first 10 AdminAPIKeys
     * const adminAPIKeys = await prisma.adminAPIKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAPIKeyWithIdOnly = await prisma.adminAPIKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAPIKeyFindManyArgs>(args?: SelectSubset<T, AdminAPIKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAPIKey.
     * @param {AdminAPIKeyCreateArgs} args - Arguments to create a AdminAPIKey.
     * @example
     * // Create one AdminAPIKey
     * const AdminAPIKey = await prisma.adminAPIKey.create({
     *   data: {
     *     // ... data to create a AdminAPIKey
     *   }
     * })
     * 
     */
    create<T extends AdminAPIKeyCreateArgs>(args: SelectSubset<T, AdminAPIKeyCreateArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAPIKeys.
     * @param {AdminAPIKeyCreateManyArgs} args - Arguments to create many AdminAPIKeys.
     * @example
     * // Create many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAPIKeyCreateManyArgs>(args?: SelectSubset<T, AdminAPIKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAPIKeys and returns the data saved in the database.
     * @param {AdminAPIKeyCreateManyAndReturnArgs} args - Arguments to create many AdminAPIKeys.
     * @example
     * // Create many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAPIKeys and only return the `id`
     * const adminAPIKeyWithIdOnly = await prisma.adminAPIKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAPIKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAPIKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAPIKey.
     * @param {AdminAPIKeyDeleteArgs} args - Arguments to delete one AdminAPIKey.
     * @example
     * // Delete one AdminAPIKey
     * const AdminAPIKey = await prisma.adminAPIKey.delete({
     *   where: {
     *     // ... filter to delete one AdminAPIKey
     *   }
     * })
     * 
     */
    delete<T extends AdminAPIKeyDeleteArgs>(args: SelectSubset<T, AdminAPIKeyDeleteArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAPIKey.
     * @param {AdminAPIKeyUpdateArgs} args - Arguments to update one AdminAPIKey.
     * @example
     * // Update one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAPIKeyUpdateArgs>(args: SelectSubset<T, AdminAPIKeyUpdateArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAPIKeys.
     * @param {AdminAPIKeyDeleteManyArgs} args - Arguments to filter AdminAPIKeys to delete.
     * @example
     * // Delete a few AdminAPIKeys
     * const { count } = await prisma.adminAPIKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAPIKeyDeleteManyArgs>(args?: SelectSubset<T, AdminAPIKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAPIKeyUpdateManyArgs>(args: SelectSubset<T, AdminAPIKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAPIKeys and returns the data updated in the database.
     * @param {AdminAPIKeyUpdateManyAndReturnArgs} args - Arguments to update many AdminAPIKeys.
     * @example
     * // Update many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAPIKeys and only return the `id`
     * const adminAPIKeyWithIdOnly = await prisma.adminAPIKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAPIKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAPIKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAPIKey.
     * @param {AdminAPIKeyUpsertArgs} args - Arguments to update or create a AdminAPIKey.
     * @example
     * // Update or create a AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.upsert({
     *   create: {
     *     // ... data to create a AdminAPIKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAPIKey we want to update
     *   }
     * })
     */
    upsert<T extends AdminAPIKeyUpsertArgs>(args: SelectSubset<T, AdminAPIKeyUpsertArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyCountArgs} args - Arguments to filter AdminAPIKeys to count.
     * @example
     * // Count the number of AdminAPIKeys
     * const count = await prisma.adminAPIKey.count({
     *   where: {
     *     // ... the filter for the AdminAPIKeys we want to count
     *   }
     * })
    **/
    count<T extends AdminAPIKeyCountArgs>(
      args?: Subset<T, AdminAPIKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAPIKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAPIKeyAggregateArgs>(args: Subset<T, AdminAPIKeyAggregateArgs>): Prisma.PrismaPromise<GetAdminAPIKeyAggregateType<T>>

    /**
     * Group by AdminAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAPIKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAPIKeyGroupByArgs['orderBy'] }
        : { orderBy?: AdminAPIKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAPIKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAPIKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAPIKey model
   */
  readonly fields: AdminAPIKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAPIKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAPIKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAPIKey model
   */
  interface AdminAPIKeyFieldRefs {
    readonly id: FieldRef<"AdminAPIKey", 'String'>
    readonly adminId: FieldRef<"AdminAPIKey", 'String'>
    readonly name: FieldRef<"AdminAPIKey", 'String'>
    readonly keyHash: FieldRef<"AdminAPIKey", 'String'>
    readonly keyPrefix: FieldRef<"AdminAPIKey", 'String'>
    readonly scopes: FieldRef<"AdminAPIKey", 'Json'>
    readonly rateLimit: FieldRef<"AdminAPIKey", 'Int'>
    readonly allowedIps: FieldRef<"AdminAPIKey", 'Json'>
    readonly createdAt: FieldRef<"AdminAPIKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"AdminAPIKey", 'DateTime'>
    readonly expiresAt: FieldRef<"AdminAPIKey", 'DateTime'>
    readonly revokedAt: FieldRef<"AdminAPIKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAPIKey findUnique
   */
  export type AdminAPIKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey findUniqueOrThrow
   */
  export type AdminAPIKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey findFirst
   */
  export type AdminAPIKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAPIKeys.
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAPIKeys.
     */
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * AdminAPIKey findFirstOrThrow
   */
  export type AdminAPIKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAPIKeys.
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAPIKeys.
     */
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * AdminAPIKey findMany
   */
  export type AdminAPIKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKeys to fetch.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAPIKeys.
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * AdminAPIKey create
   */
  export type AdminAPIKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAPIKey.
     */
    data: XOR<AdminAPIKeyCreateInput, AdminAPIKeyUncheckedCreateInput>
  }

  /**
   * AdminAPIKey createMany
   */
  export type AdminAPIKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAPIKeys.
     */
    data: AdminAPIKeyCreateManyInput | AdminAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAPIKey createManyAndReturn
   */
  export type AdminAPIKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAPIKeys.
     */
    data: AdminAPIKeyCreateManyInput | AdminAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAPIKey update
   */
  export type AdminAPIKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAPIKey.
     */
    data: XOR<AdminAPIKeyUpdateInput, AdminAPIKeyUncheckedUpdateInput>
    /**
     * Choose, which AdminAPIKey to update.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey updateMany
   */
  export type AdminAPIKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAPIKeys.
     */
    data: XOR<AdminAPIKeyUpdateManyMutationInput, AdminAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which AdminAPIKeys to update
     */
    where?: AdminAPIKeyWhereInput
    /**
     * Limit how many AdminAPIKeys to update.
     */
    limit?: number
  }

  /**
   * AdminAPIKey updateManyAndReturn
   */
  export type AdminAPIKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to update AdminAPIKeys.
     */
    data: XOR<AdminAPIKeyUpdateManyMutationInput, AdminAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which AdminAPIKeys to update
     */
    where?: AdminAPIKeyWhereInput
    /**
     * Limit how many AdminAPIKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAPIKey upsert
   */
  export type AdminAPIKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAPIKey to update in case it exists.
     */
    where: AdminAPIKeyWhereUniqueInput
    /**
     * In case the AdminAPIKey found by the `where` argument doesn't exist, create a new AdminAPIKey with this data.
     */
    create: XOR<AdminAPIKeyCreateInput, AdminAPIKeyUncheckedCreateInput>
    /**
     * In case the AdminAPIKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAPIKeyUpdateInput, AdminAPIKeyUncheckedUpdateInput>
  }

  /**
   * AdminAPIKey delete
   */
  export type AdminAPIKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter which AdminAPIKey to delete.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey deleteMany
   */
  export type AdminAPIKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAPIKeys to delete
     */
    where?: AdminAPIKeyWhereInput
    /**
     * Limit how many AdminAPIKeys to delete.
     */
    limit?: number
  }

  /**
   * AdminAPIKey without action
   */
  export type AdminAPIKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
  }


  /**
   * Model AdminInvitation
   */

  export type AggregateAdminInvitation = {
    _count: AdminInvitationCountAggregateOutputType | null
    _min: AdminInvitationMinAggregateOutputType | null
    _max: AdminInvitationMaxAggregateOutputType | null
  }

  export type AdminInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.AdminRole | null
    token: string | null
    invitedBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type AdminInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.AdminRole | null
    token: string | null
    invitedBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type AdminInvitationCountAggregateOutputType = {
    id: number
    email: number
    role: number
    token: number
    invitedBy: number
    createdAt: number
    expiresAt: number
    acceptedAt: number
    _all: number
  }


  export type AdminInvitationMinAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    invitedBy?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type AdminInvitationMaxAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    invitedBy?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type AdminInvitationCountAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    invitedBy?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type AdminInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminInvitation to aggregate.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminInvitations
    **/
    _count?: true | AdminInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminInvitationMaxAggregateInputType
  }

  export type GetAdminInvitationAggregateType<T extends AdminInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminInvitation[P]>
      : GetScalarType<T[P], AggregateAdminInvitation[P]>
  }




  export type AdminInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminInvitationWhereInput
    orderBy?: AdminInvitationOrderByWithAggregationInput | AdminInvitationOrderByWithAggregationInput[]
    by: AdminInvitationScalarFieldEnum[] | AdminInvitationScalarFieldEnum
    having?: AdminInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminInvitationCountAggregateInputType | true
    _min?: AdminInvitationMinAggregateInputType
    _max?: AdminInvitationMaxAggregateInputType
  }

  export type AdminInvitationGroupByOutputType = {
    id: string
    email: string
    role: $Enums.AdminRole
    token: string
    invitedBy: string
    createdAt: Date
    expiresAt: Date
    acceptedAt: Date | null
    _count: AdminInvitationCountAggregateOutputType | null
    _min: AdminInvitationMinAggregateOutputType | null
    _max: AdminInvitationMaxAggregateOutputType | null
  }

  type GetAdminInvitationGroupByPayload<T extends AdminInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], AdminInvitationGroupByOutputType[P]>
        }
      >
    >


  export type AdminInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminInvitation"]>

  export type AdminInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminInvitation"]>

  export type AdminInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminInvitation"]>

  export type AdminInvitationSelectScalar = {
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
  }

  export type AdminInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "role" | "token" | "invitedBy" | "createdAt" | "expiresAt" | "acceptedAt", ExtArgs["result"]["adminInvitation"]>
  export type AdminInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminInvitation"
    objects: {
      inviter: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      role: $Enums.AdminRole
      token: string
      invitedBy: string
      createdAt: Date
      expiresAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["adminInvitation"]>
    composites: {}
  }

  type AdminInvitationGetPayload<S extends boolean | null | undefined | AdminInvitationDefaultArgs> = $Result.GetResult<Prisma.$AdminInvitationPayload, S>

  type AdminInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminInvitationCountAggregateInputType | true
    }

  export interface AdminInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminInvitation'], meta: { name: 'AdminInvitation' } }
    /**
     * Find zero or one AdminInvitation that matches the filter.
     * @param {AdminInvitationFindUniqueArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminInvitationFindUniqueArgs>(args: SelectSubset<T, AdminInvitationFindUniqueArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminInvitationFindUniqueOrThrowArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationFindFirstArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminInvitationFindFirstArgs>(args?: SelectSubset<T, AdminInvitationFindFirstArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationFindFirstOrThrowArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminInvitations
     * const adminInvitations = await prisma.adminInvitation.findMany()
     * 
     * // Get first 10 AdminInvitations
     * const adminInvitations = await prisma.adminInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminInvitationWithIdOnly = await prisma.adminInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminInvitationFindManyArgs>(args?: SelectSubset<T, AdminInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminInvitation.
     * @param {AdminInvitationCreateArgs} args - Arguments to create a AdminInvitation.
     * @example
     * // Create one AdminInvitation
     * const AdminInvitation = await prisma.adminInvitation.create({
     *   data: {
     *     // ... data to create a AdminInvitation
     *   }
     * })
     * 
     */
    create<T extends AdminInvitationCreateArgs>(args: SelectSubset<T, AdminInvitationCreateArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminInvitations.
     * @param {AdminInvitationCreateManyArgs} args - Arguments to create many AdminInvitations.
     * @example
     * // Create many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminInvitationCreateManyArgs>(args?: SelectSubset<T, AdminInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminInvitations and returns the data saved in the database.
     * @param {AdminInvitationCreateManyAndReturnArgs} args - Arguments to create many AdminInvitations.
     * @example
     * // Create many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminInvitations and only return the `id`
     * const adminInvitationWithIdOnly = await prisma.adminInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminInvitation.
     * @param {AdminInvitationDeleteArgs} args - Arguments to delete one AdminInvitation.
     * @example
     * // Delete one AdminInvitation
     * const AdminInvitation = await prisma.adminInvitation.delete({
     *   where: {
     *     // ... filter to delete one AdminInvitation
     *   }
     * })
     * 
     */
    delete<T extends AdminInvitationDeleteArgs>(args: SelectSubset<T, AdminInvitationDeleteArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminInvitation.
     * @param {AdminInvitationUpdateArgs} args - Arguments to update one AdminInvitation.
     * @example
     * // Update one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminInvitationUpdateArgs>(args: SelectSubset<T, AdminInvitationUpdateArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminInvitations.
     * @param {AdminInvitationDeleteManyArgs} args - Arguments to filter AdminInvitations to delete.
     * @example
     * // Delete a few AdminInvitations
     * const { count } = await prisma.adminInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminInvitationDeleteManyArgs>(args?: SelectSubset<T, AdminInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminInvitationUpdateManyArgs>(args: SelectSubset<T, AdminInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminInvitations and returns the data updated in the database.
     * @param {AdminInvitationUpdateManyAndReturnArgs} args - Arguments to update many AdminInvitations.
     * @example
     * // Update many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminInvitations and only return the `id`
     * const adminInvitationWithIdOnly = await prisma.adminInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminInvitation.
     * @param {AdminInvitationUpsertArgs} args - Arguments to update or create a AdminInvitation.
     * @example
     * // Update or create a AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.upsert({
     *   create: {
     *     // ... data to create a AdminInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminInvitation we want to update
     *   }
     * })
     */
    upsert<T extends AdminInvitationUpsertArgs>(args: SelectSubset<T, AdminInvitationUpsertArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationCountArgs} args - Arguments to filter AdminInvitations to count.
     * @example
     * // Count the number of AdminInvitations
     * const count = await prisma.adminInvitation.count({
     *   where: {
     *     // ... the filter for the AdminInvitations we want to count
     *   }
     * })
    **/
    count<T extends AdminInvitationCountArgs>(
      args?: Subset<T, AdminInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminInvitationAggregateArgs>(args: Subset<T, AdminInvitationAggregateArgs>): Prisma.PrismaPromise<GetAdminInvitationAggregateType<T>>

    /**
     * Group by AdminInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminInvitationGroupByArgs['orderBy'] }
        : { orderBy?: AdminInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminInvitation model
   */
  readonly fields: AdminInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminInvitation model
   */
  interface AdminInvitationFieldRefs {
    readonly id: FieldRef<"AdminInvitation", 'String'>
    readonly email: FieldRef<"AdminInvitation", 'String'>
    readonly role: FieldRef<"AdminInvitation", 'AdminRole'>
    readonly token: FieldRef<"AdminInvitation", 'String'>
    readonly invitedBy: FieldRef<"AdminInvitation", 'String'>
    readonly createdAt: FieldRef<"AdminInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"AdminInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"AdminInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminInvitation findUnique
   */
  export type AdminInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation findUniqueOrThrow
   */
  export type AdminInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation findFirst
   */
  export type AdminInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminInvitations.
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminInvitations.
     */
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * AdminInvitation findFirstOrThrow
   */
  export type AdminInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminInvitations.
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminInvitations.
     */
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * AdminInvitation findMany
   */
  export type AdminInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitations to fetch.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminInvitations.
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * AdminInvitation create
   */
  export type AdminInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminInvitation.
     */
    data: XOR<AdminInvitationCreateInput, AdminInvitationUncheckedCreateInput>
  }

  /**
   * AdminInvitation createMany
   */
  export type AdminInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminInvitations.
     */
    data: AdminInvitationCreateManyInput | AdminInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminInvitation createManyAndReturn
   */
  export type AdminInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many AdminInvitations.
     */
    data: AdminInvitationCreateManyInput | AdminInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminInvitation update
   */
  export type AdminInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminInvitation.
     */
    data: XOR<AdminInvitationUpdateInput, AdminInvitationUncheckedUpdateInput>
    /**
     * Choose, which AdminInvitation to update.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation updateMany
   */
  export type AdminInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminInvitations.
     */
    data: XOR<AdminInvitationUpdateManyMutationInput, AdminInvitationUncheckedUpdateManyInput>
    /**
     * Filter which AdminInvitations to update
     */
    where?: AdminInvitationWhereInput
    /**
     * Limit how many AdminInvitations to update.
     */
    limit?: number
  }

  /**
   * AdminInvitation updateManyAndReturn
   */
  export type AdminInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * The data used to update AdminInvitations.
     */
    data: XOR<AdminInvitationUpdateManyMutationInput, AdminInvitationUncheckedUpdateManyInput>
    /**
     * Filter which AdminInvitations to update
     */
    where?: AdminInvitationWhereInput
    /**
     * Limit how many AdminInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminInvitation upsert
   */
  export type AdminInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminInvitation to update in case it exists.
     */
    where: AdminInvitationWhereUniqueInput
    /**
     * In case the AdminInvitation found by the `where` argument doesn't exist, create a new AdminInvitation with this data.
     */
    create: XOR<AdminInvitationCreateInput, AdminInvitationUncheckedCreateInput>
    /**
     * In case the AdminInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminInvitationUpdateInput, AdminInvitationUncheckedUpdateInput>
  }

  /**
   * AdminInvitation delete
   */
  export type AdminInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter which AdminInvitation to delete.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation deleteMany
   */
  export type AdminInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminInvitations to delete
     */
    where?: AdminInvitationWhereInput
    /**
     * Limit how many AdminInvitations to delete.
     */
    limit?: number
  }

  /**
   * AdminInvitation without action
   */
  export type AdminInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
  }


  /**
   * Model AdminSecurityEvent
   */

  export type AggregateAdminSecurityEvent = {
    _count: AdminSecurityEventCountAggregateOutputType | null
    _min: AdminSecurityEventMinAggregateOutputType | null
    _max: AdminSecurityEventMaxAggregateOutputType | null
  }

  export type AdminSecurityEventMinAggregateOutputType = {
    id: string | null
    eventType: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    adminId: string | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type AdminSecurityEventMaxAggregateOutputType = {
    id: string | null
    eventType: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    adminId: string | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type AdminSecurityEventCountAggregateOutputType = {
    id: number
    eventType: number
    severity: number
    adminId: number
    ipAddress: number
    userAgent: number
    description: number
    metadata: number
    resolved: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    _all: number
  }


  export type AdminSecurityEventMinAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type AdminSecurityEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type AdminSecurityEventCountAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    metadata?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    _all?: true
  }

  export type AdminSecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSecurityEvent to aggregate.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSecurityEvents
    **/
    _count?: true | AdminSecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSecurityEventMaxAggregateInputType
  }

  export type GetAdminSecurityEventAggregateType<T extends AdminSecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSecurityEvent[P]>
      : GetScalarType<T[P], AggregateAdminSecurityEvent[P]>
  }




  export type AdminSecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSecurityEventWhereInput
    orderBy?: AdminSecurityEventOrderByWithAggregationInput | AdminSecurityEventOrderByWithAggregationInput[]
    by: AdminSecurityEventScalarFieldEnum[] | AdminSecurityEventScalarFieldEnum
    having?: AdminSecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSecurityEventCountAggregateInputType | true
    _min?: AdminSecurityEventMinAggregateInputType
    _max?: AdminSecurityEventMaxAggregateInputType
  }

  export type AdminSecurityEventGroupByOutputType = {
    id: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId: string | null
    ipAddress: string
    userAgent: string | null
    description: string
    metadata: JsonValue | null
    resolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    _count: AdminSecurityEventCountAggregateOutputType | null
    _min: AdminSecurityEventMinAggregateOutputType | null
    _max: AdminSecurityEventMaxAggregateOutputType | null
  }

  type GetAdminSecurityEventGroupByPayload<T extends AdminSecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type AdminSecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminSecurityEvent"]>

  export type AdminSecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminSecurityEvent"]>

  export type AdminSecurityEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminSecurityEvent"]>

  export type AdminSecurityEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }

  export type AdminSecurityEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "severity" | "adminId" | "ipAddress" | "userAgent" | "description" | "metadata" | "resolved" | "resolvedAt" | "resolvedBy" | "createdAt", ExtArgs["result"]["adminSecurityEvent"]>

  export type $AdminSecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSecurityEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: $Enums.SecurityEventType
      severity: $Enums.SecuritySeverity
      adminId: string | null
      ipAddress: string
      userAgent: string | null
      description: string
      metadata: Prisma.JsonValue | null
      resolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminSecurityEvent"]>
    composites: {}
  }

  type AdminSecurityEventGetPayload<S extends boolean | null | undefined | AdminSecurityEventDefaultArgs> = $Result.GetResult<Prisma.$AdminSecurityEventPayload, S>

  type AdminSecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminSecurityEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminSecurityEventCountAggregateInputType | true
    }

  export interface AdminSecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSecurityEvent'], meta: { name: 'AdminSecurityEvent' } }
    /**
     * Find zero or one AdminSecurityEvent that matches the filter.
     * @param {AdminSecurityEventFindUniqueArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSecurityEventFindUniqueArgs>(args: SelectSubset<T, AdminSecurityEventFindUniqueArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminSecurityEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSecurityEventFindUniqueOrThrowArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventFindFirstArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSecurityEventFindFirstArgs>(args?: SelectSubset<T, AdminSecurityEventFindFirstArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventFindFirstOrThrowArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminSecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSecurityEvents
     * const adminSecurityEvents = await prisma.adminSecurityEvent.findMany()
     * 
     * // Get first 10 AdminSecurityEvents
     * const adminSecurityEvents = await prisma.adminSecurityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSecurityEventWithIdOnly = await prisma.adminSecurityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSecurityEventFindManyArgs>(args?: SelectSubset<T, AdminSecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminSecurityEvent.
     * @param {AdminSecurityEventCreateArgs} args - Arguments to create a AdminSecurityEvent.
     * @example
     * // Create one AdminSecurityEvent
     * const AdminSecurityEvent = await prisma.adminSecurityEvent.create({
     *   data: {
     *     // ... data to create a AdminSecurityEvent
     *   }
     * })
     * 
     */
    create<T extends AdminSecurityEventCreateArgs>(args: SelectSubset<T, AdminSecurityEventCreateArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminSecurityEvents.
     * @param {AdminSecurityEventCreateManyArgs} args - Arguments to create many AdminSecurityEvents.
     * @example
     * // Create many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSecurityEventCreateManyArgs>(args?: SelectSubset<T, AdminSecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSecurityEvents and returns the data saved in the database.
     * @param {AdminSecurityEventCreateManyAndReturnArgs} args - Arguments to create many AdminSecurityEvents.
     * @example
     * // Create many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSecurityEvents and only return the `id`
     * const adminSecurityEventWithIdOnly = await prisma.adminSecurityEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminSecurityEvent.
     * @param {AdminSecurityEventDeleteArgs} args - Arguments to delete one AdminSecurityEvent.
     * @example
     * // Delete one AdminSecurityEvent
     * const AdminSecurityEvent = await prisma.adminSecurityEvent.delete({
     *   where: {
     *     // ... filter to delete one AdminSecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends AdminSecurityEventDeleteArgs>(args: SelectSubset<T, AdminSecurityEventDeleteArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminSecurityEvent.
     * @param {AdminSecurityEventUpdateArgs} args - Arguments to update one AdminSecurityEvent.
     * @example
     * // Update one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSecurityEventUpdateArgs>(args: SelectSubset<T, AdminSecurityEventUpdateArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminSecurityEvents.
     * @param {AdminSecurityEventDeleteManyArgs} args - Arguments to filter AdminSecurityEvents to delete.
     * @example
     * // Delete a few AdminSecurityEvents
     * const { count } = await prisma.adminSecurityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSecurityEventDeleteManyArgs>(args?: SelectSubset<T, AdminSecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSecurityEventUpdateManyArgs>(args: SelectSubset<T, AdminSecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSecurityEvents and returns the data updated in the database.
     * @param {AdminSecurityEventUpdateManyAndReturnArgs} args - Arguments to update many AdminSecurityEvents.
     * @example
     * // Update many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminSecurityEvents and only return the `id`
     * const adminSecurityEventWithIdOnly = await prisma.adminSecurityEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminSecurityEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminSecurityEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminSecurityEvent.
     * @param {AdminSecurityEventUpsertArgs} args - Arguments to update or create a AdminSecurityEvent.
     * @example
     * // Update or create a AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.upsert({
     *   create: {
     *     // ... data to create a AdminSecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends AdminSecurityEventUpsertArgs>(args: SelectSubset<T, AdminSecurityEventUpsertArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminSecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventCountArgs} args - Arguments to filter AdminSecurityEvents to count.
     * @example
     * // Count the number of AdminSecurityEvents
     * const count = await prisma.adminSecurityEvent.count({
     *   where: {
     *     // ... the filter for the AdminSecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends AdminSecurityEventCountArgs>(
      args?: Subset<T, AdminSecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSecurityEventAggregateArgs>(args: Subset<T, AdminSecurityEventAggregateArgs>): Prisma.PrismaPromise<GetAdminSecurityEventAggregateType<T>>

    /**
     * Group by AdminSecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: AdminSecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSecurityEvent model
   */
  readonly fields: AdminSecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSecurityEvent model
   */
  interface AdminSecurityEventFieldRefs {
    readonly id: FieldRef<"AdminSecurityEvent", 'String'>
    readonly eventType: FieldRef<"AdminSecurityEvent", 'SecurityEventType'>
    readonly severity: FieldRef<"AdminSecurityEvent", 'SecuritySeverity'>
    readonly adminId: FieldRef<"AdminSecurityEvent", 'String'>
    readonly ipAddress: FieldRef<"AdminSecurityEvent", 'String'>
    readonly userAgent: FieldRef<"AdminSecurityEvent", 'String'>
    readonly description: FieldRef<"AdminSecurityEvent", 'String'>
    readonly metadata: FieldRef<"AdminSecurityEvent", 'Json'>
    readonly resolved: FieldRef<"AdminSecurityEvent", 'Boolean'>
    readonly resolvedAt: FieldRef<"AdminSecurityEvent", 'DateTime'>
    readonly resolvedBy: FieldRef<"AdminSecurityEvent", 'String'>
    readonly createdAt: FieldRef<"AdminSecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminSecurityEvent findUnique
   */
  export type AdminSecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent findUniqueOrThrow
   */
  export type AdminSecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent findFirst
   */
  export type AdminSecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSecurityEvents.
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSecurityEvents.
     */
    distinct?: AdminSecurityEventScalarFieldEnum | AdminSecurityEventScalarFieldEnum[]
  }

  /**
   * AdminSecurityEvent findFirstOrThrow
   */
  export type AdminSecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSecurityEvents.
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSecurityEvents.
     */
    distinct?: AdminSecurityEventScalarFieldEnum | AdminSecurityEventScalarFieldEnum[]
  }

  /**
   * AdminSecurityEvent findMany
   */
  export type AdminSecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvents to fetch.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSecurityEvents.
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    distinct?: AdminSecurityEventScalarFieldEnum | AdminSecurityEventScalarFieldEnum[]
  }

  /**
   * AdminSecurityEvent create
   */
  export type AdminSecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminSecurityEvent.
     */
    data: XOR<AdminSecurityEventCreateInput, AdminSecurityEventUncheckedCreateInput>
  }

  /**
   * AdminSecurityEvent createMany
   */
  export type AdminSecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSecurityEvents.
     */
    data: AdminSecurityEventCreateManyInput | AdminSecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSecurityEvent createManyAndReturn
   */
  export type AdminSecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data used to create many AdminSecurityEvents.
     */
    data: AdminSecurityEventCreateManyInput | AdminSecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSecurityEvent update
   */
  export type AdminSecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminSecurityEvent.
     */
    data: XOR<AdminSecurityEventUpdateInput, AdminSecurityEventUncheckedUpdateInput>
    /**
     * Choose, which AdminSecurityEvent to update.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent updateMany
   */
  export type AdminSecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSecurityEvents.
     */
    data: XOR<AdminSecurityEventUpdateManyMutationInput, AdminSecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminSecurityEvents to update
     */
    where?: AdminSecurityEventWhereInput
    /**
     * Limit how many AdminSecurityEvents to update.
     */
    limit?: number
  }

  /**
   * AdminSecurityEvent updateManyAndReturn
   */
  export type AdminSecurityEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data used to update AdminSecurityEvents.
     */
    data: XOR<AdminSecurityEventUpdateManyMutationInput, AdminSecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminSecurityEvents to update
     */
    where?: AdminSecurityEventWhereInput
    /**
     * Limit how many AdminSecurityEvents to update.
     */
    limit?: number
  }

  /**
   * AdminSecurityEvent upsert
   */
  export type AdminSecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminSecurityEvent to update in case it exists.
     */
    where: AdminSecurityEventWhereUniqueInput
    /**
     * In case the AdminSecurityEvent found by the `where` argument doesn't exist, create a new AdminSecurityEvent with this data.
     */
    create: XOR<AdminSecurityEventCreateInput, AdminSecurityEventUncheckedCreateInput>
    /**
     * In case the AdminSecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSecurityEventUpdateInput, AdminSecurityEventUncheckedUpdateInput>
  }

  /**
   * AdminSecurityEvent delete
   */
  export type AdminSecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter which AdminSecurityEvent to delete.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent deleteMany
   */
  export type AdminSecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSecurityEvents to delete
     */
    where?: AdminSecurityEventWhereInput
    /**
     * Limit how many AdminSecurityEvents to delete.
     */
    limit?: number
  }

  /**
   * AdminSecurityEvent without action
   */
  export type AdminSecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    credits: number | null
    monthlyCreditQuota: number | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    credits: number | null
    monthlyCreditQuota: number | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    credits: number | null
    monthlyCreditQuota: number | null
    creditResetDate: Date | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
    canInviteToWorkspace: boolean | null
    canInviteToCanvas: boolean | null
    canCreatePublicLinks: boolean | null
    canUseAdvancedModels: boolean | null
    canAccessAnalytics: boolean | null
    canExportData: boolean | null
    nextBillingDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    isByokMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    credits: number | null
    monthlyCreditQuota: number | null
    creditResetDate: Date | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
    canInviteToWorkspace: boolean | null
    canInviteToCanvas: boolean | null
    canCreatePublicLinks: boolean | null
    canUseAdvancedModels: boolean | null
    canAccessAnalytics: boolean | null
    canExportData: boolean | null
    nextBillingDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    isByokMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    workspaceId: number
    tier: number
    status: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    credits: number
    monthlyCreditQuota: number
    creditResetDate: number
    maxCanvases: number
    maxActionPodsPerCanvas: number
    maxDocumentSizeInMB: number
    maxCollaboratorsPerCanvas: number
    canInviteToWorkspace: number
    canInviteToCanvas: number
    canCreatePublicLinks: number
    canUseAdvancedModels: number
    canAccessAnalytics: number
    canExportData: number
    nextBillingDate: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    isByokMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    credits?: true
    monthlyCreditQuota?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
  }

  export type SubscriptionSumAggregateInputType = {
    credits?: true
    monthlyCreditQuota?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    credits?: true
    monthlyCreditQuota?: true
    creditResetDate?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
    canInviteToWorkspace?: true
    canInviteToCanvas?: true
    canCreatePublicLinks?: true
    canUseAdvancedModels?: true
    canAccessAnalytics?: true
    canExportData?: true
    nextBillingDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    isByokMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    credits?: true
    monthlyCreditQuota?: true
    creditResetDate?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
    canInviteToWorkspace?: true
    canInviteToCanvas?: true
    canCreatePublicLinks?: true
    canUseAdvancedModels?: true
    canAccessAnalytics?: true
    canExportData?: true
    nextBillingDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    isByokMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    credits?: true
    monthlyCreditQuota?: true
    creditResetDate?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
    canInviteToWorkspace?: true
    canInviteToCanvas?: true
    canCreatePublicLinks?: true
    canUseAdvancedModels?: true
    canAccessAnalytics?: true
    canExportData?: true
    nextBillingDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    isByokMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    workspaceId: string
    tier: $Enums.SubscriptionTier
    status: $Enums.SubscriptionStatus
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    credits: number
    monthlyCreditQuota: number
    creditResetDate: Date | null
    maxCanvases: number
    maxActionPodsPerCanvas: number
    maxDocumentSizeInMB: number
    maxCollaboratorsPerCanvas: number
    canInviteToWorkspace: boolean
    canInviteToCanvas: boolean
    canCreatePublicLinks: boolean
    canUseAdvancedModels: boolean
    canAccessAnalytics: boolean
    canExportData: boolean
    nextBillingDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    isByokMode: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    usageLogs?: boolean | Subscription$usageLogsArgs<ExtArgs>
    creditPurchases?: boolean | Subscription$creditPurchasesArgs<ExtArgs>
    creditUsage?: boolean | Subscription$creditUsageArgs<ExtArgs>
    documentProcessingCost?: boolean | Subscription$documentProcessingCostArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "tier" | "status" | "stripeCustomerId" | "stripeSubscriptionId" | "credits" | "monthlyCreditQuota" | "creditResetDate" | "maxCanvases" | "maxActionPodsPerCanvas" | "maxDocumentSizeInMB" | "maxCollaboratorsPerCanvas" | "canInviteToWorkspace" | "canInviteToCanvas" | "canCreatePublicLinks" | "canUseAdvancedModels" | "canAccessAnalytics" | "canExportData" | "nextBillingDate" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "isByokMode" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    usageLogs?: boolean | Subscription$usageLogsArgs<ExtArgs>
    creditPurchases?: boolean | Subscription$creditPurchasesArgs<ExtArgs>
    creditUsage?: boolean | Subscription$creditUsageArgs<ExtArgs>
    documentProcessingCost?: boolean | Subscription$documentProcessingCostArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      usageLogs: Prisma.$PodUsageLogPayload<ExtArgs>[]
      creditPurchases: Prisma.$CreditPurchasePayload<ExtArgs>[]
      creditUsage: Prisma.$CreditUsageLogPayload<ExtArgs>[]
      documentProcessingCost: Prisma.$DocumentProcessingCostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      tier: $Enums.SubscriptionTier
      status: $Enums.SubscriptionStatus
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      credits: number
      monthlyCreditQuota: number
      creditResetDate: Date | null
      maxCanvases: number
      maxActionPodsPerCanvas: number
      maxDocumentSizeInMB: number
      maxCollaboratorsPerCanvas: number
      canInviteToWorkspace: boolean
      canInviteToCanvas: boolean
      canCreatePublicLinks: boolean
      canUseAdvancedModels: boolean
      canAccessAnalytics: boolean
      canExportData: boolean
      nextBillingDate: Date | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      isByokMode: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usageLogs<T extends Subscription$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditPurchases<T extends Subscription$creditPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$creditPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditUsage<T extends Subscription$creditUsageArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$creditUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentProcessingCost<T extends Subscription$documentProcessingCostArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$documentProcessingCostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly workspaceId: FieldRef<"Subscription", 'String'>
    readonly tier: FieldRef<"Subscription", 'SubscriptionTier'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly credits: FieldRef<"Subscription", 'Int'>
    readonly monthlyCreditQuota: FieldRef<"Subscription", 'Int'>
    readonly creditResetDate: FieldRef<"Subscription", 'DateTime'>
    readonly maxCanvases: FieldRef<"Subscription", 'Int'>
    readonly maxActionPodsPerCanvas: FieldRef<"Subscription", 'Int'>
    readonly maxDocumentSizeInMB: FieldRef<"Subscription", 'Int'>
    readonly maxCollaboratorsPerCanvas: FieldRef<"Subscription", 'Int'>
    readonly canInviteToWorkspace: FieldRef<"Subscription", 'Boolean'>
    readonly canInviteToCanvas: FieldRef<"Subscription", 'Boolean'>
    readonly canCreatePublicLinks: FieldRef<"Subscription", 'Boolean'>
    readonly canUseAdvancedModels: FieldRef<"Subscription", 'Boolean'>
    readonly canAccessAnalytics: FieldRef<"Subscription", 'Boolean'>
    readonly canExportData: FieldRef<"Subscription", 'Boolean'>
    readonly nextBillingDate: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly isByokMode: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.usageLogs
   */
  export type Subscription$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    where?: PodUsageLogWhereInput
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    cursor?: PodUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * Subscription.creditPurchases
   */
  export type Subscription$creditPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    where?: CreditPurchaseWhereInput
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    cursor?: CreditPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * Subscription.creditUsage
   */
  export type Subscription$creditUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    where?: CreditUsageLogWhereInput
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    cursor?: CreditUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * Subscription.documentProcessingCost
   */
  export type Subscription$documentProcessingCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    where?: DocumentProcessingCostWhereInput
    orderBy?: DocumentProcessingCostOrderByWithRelationInput | DocumentProcessingCostOrderByWithRelationInput[]
    cursor?: DocumentProcessingCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentProcessingCostScalarFieldEnum | DocumentProcessingCostScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model CreditPurchase
   */

  export type AggregateCreditPurchase = {
    _count: CreditPurchaseCountAggregateOutputType | null
    _avg: CreditPurchaseAvgAggregateOutputType | null
    _sum: CreditPurchaseSumAggregateOutputType | null
    _min: CreditPurchaseMinAggregateOutputType | null
    _max: CreditPurchaseMaxAggregateOutputType | null
  }

  export type CreditPurchaseAvgAggregateOutputType = {
    creditsPurchased: number | null
    amountPaid: Decimal | null
  }

  export type CreditPurchaseSumAggregateOutputType = {
    creditsPurchased: number | null
    amountPaid: Decimal | null
  }

  export type CreditPurchaseMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    creditsPurchased: number | null
    amountPaid: Decimal | null
    currency: string | null
    stripeChargeId: string | null
    status: string | null
    purchasedAt: Date | null
  }

  export type CreditPurchaseMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    creditsPurchased: number | null
    amountPaid: Decimal | null
    currency: string | null
    stripeChargeId: string | null
    status: string | null
    purchasedAt: Date | null
  }

  export type CreditPurchaseCountAggregateOutputType = {
    id: number
    subscriptionId: number
    creditsPurchased: number
    amountPaid: number
    currency: number
    stripeChargeId: number
    status: number
    purchasedAt: number
    _all: number
  }


  export type CreditPurchaseAvgAggregateInputType = {
    creditsPurchased?: true
    amountPaid?: true
  }

  export type CreditPurchaseSumAggregateInputType = {
    creditsPurchased?: true
    amountPaid?: true
  }

  export type CreditPurchaseMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    creditsPurchased?: true
    amountPaid?: true
    currency?: true
    stripeChargeId?: true
    status?: true
    purchasedAt?: true
  }

  export type CreditPurchaseMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    creditsPurchased?: true
    amountPaid?: true
    currency?: true
    stripeChargeId?: true
    status?: true
    purchasedAt?: true
  }

  export type CreditPurchaseCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    creditsPurchased?: true
    amountPaid?: true
    currency?: true
    stripeChargeId?: true
    status?: true
    purchasedAt?: true
    _all?: true
  }

  export type CreditPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPurchase to aggregate.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditPurchases
    **/
    _count?: true | CreditPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditPurchaseMaxAggregateInputType
  }

  export type GetCreditPurchaseAggregateType<T extends CreditPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditPurchase[P]>
      : GetScalarType<T[P], AggregateCreditPurchase[P]>
  }




  export type CreditPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPurchaseWhereInput
    orderBy?: CreditPurchaseOrderByWithAggregationInput | CreditPurchaseOrderByWithAggregationInput[]
    by: CreditPurchaseScalarFieldEnum[] | CreditPurchaseScalarFieldEnum
    having?: CreditPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditPurchaseCountAggregateInputType | true
    _avg?: CreditPurchaseAvgAggregateInputType
    _sum?: CreditPurchaseSumAggregateInputType
    _min?: CreditPurchaseMinAggregateInputType
    _max?: CreditPurchaseMaxAggregateInputType
  }

  export type CreditPurchaseGroupByOutputType = {
    id: string
    subscriptionId: string
    creditsPurchased: number
    amountPaid: Decimal
    currency: string
    stripeChargeId: string
    status: string
    purchasedAt: Date
    _count: CreditPurchaseCountAggregateOutputType | null
    _avg: CreditPurchaseAvgAggregateOutputType | null
    _sum: CreditPurchaseSumAggregateOutputType | null
    _min: CreditPurchaseMinAggregateOutputType | null
    _max: CreditPurchaseMaxAggregateOutputType | null
  }

  type GetCreditPurchaseGroupByPayload<T extends CreditPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], CreditPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type CreditPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPurchase"]>

  export type CreditPurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPurchase"]>

  export type CreditPurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPurchase"]>

  export type CreditPurchaseSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
  }

  export type CreditPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "creditsPurchased" | "amountPaid" | "currency" | "stripeChargeId" | "status" | "purchasedAt", ExtArgs["result"]["creditPurchase"]>
  export type CreditPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditPurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditPurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $CreditPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditPurchase"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      creditsPurchased: number
      amountPaid: Prisma.Decimal
      currency: string
      stripeChargeId: string
      status: string
      purchasedAt: Date
    }, ExtArgs["result"]["creditPurchase"]>
    composites: {}
  }

  type CreditPurchaseGetPayload<S extends boolean | null | undefined | CreditPurchaseDefaultArgs> = $Result.GetResult<Prisma.$CreditPurchasePayload, S>

  type CreditPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditPurchaseCountAggregateInputType | true
    }

  export interface CreditPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditPurchase'], meta: { name: 'CreditPurchase' } }
    /**
     * Find zero or one CreditPurchase that matches the filter.
     * @param {CreditPurchaseFindUniqueArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditPurchaseFindUniqueArgs>(args: SelectSubset<T, CreditPurchaseFindUniqueArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditPurchaseFindUniqueOrThrowArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseFindFirstArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditPurchaseFindFirstArgs>(args?: SelectSubset<T, CreditPurchaseFindFirstArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseFindFirstOrThrowArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditPurchases
     * const creditPurchases = await prisma.creditPurchase.findMany()
     * 
     * // Get first 10 CreditPurchases
     * const creditPurchases = await prisma.creditPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditPurchaseWithIdOnly = await prisma.creditPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditPurchaseFindManyArgs>(args?: SelectSubset<T, CreditPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditPurchase.
     * @param {CreditPurchaseCreateArgs} args - Arguments to create a CreditPurchase.
     * @example
     * // Create one CreditPurchase
     * const CreditPurchase = await prisma.creditPurchase.create({
     *   data: {
     *     // ... data to create a CreditPurchase
     *   }
     * })
     * 
     */
    create<T extends CreditPurchaseCreateArgs>(args: SelectSubset<T, CreditPurchaseCreateArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditPurchases.
     * @param {CreditPurchaseCreateManyArgs} args - Arguments to create many CreditPurchases.
     * @example
     * // Create many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditPurchaseCreateManyArgs>(args?: SelectSubset<T, CreditPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditPurchases and returns the data saved in the database.
     * @param {CreditPurchaseCreateManyAndReturnArgs} args - Arguments to create many CreditPurchases.
     * @example
     * // Create many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditPurchases and only return the `id`
     * const creditPurchaseWithIdOnly = await prisma.creditPurchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditPurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditPurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditPurchase.
     * @param {CreditPurchaseDeleteArgs} args - Arguments to delete one CreditPurchase.
     * @example
     * // Delete one CreditPurchase
     * const CreditPurchase = await prisma.creditPurchase.delete({
     *   where: {
     *     // ... filter to delete one CreditPurchase
     *   }
     * })
     * 
     */
    delete<T extends CreditPurchaseDeleteArgs>(args: SelectSubset<T, CreditPurchaseDeleteArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditPurchase.
     * @param {CreditPurchaseUpdateArgs} args - Arguments to update one CreditPurchase.
     * @example
     * // Update one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditPurchaseUpdateArgs>(args: SelectSubset<T, CreditPurchaseUpdateArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditPurchases.
     * @param {CreditPurchaseDeleteManyArgs} args - Arguments to filter CreditPurchases to delete.
     * @example
     * // Delete a few CreditPurchases
     * const { count } = await prisma.creditPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditPurchaseDeleteManyArgs>(args?: SelectSubset<T, CreditPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditPurchaseUpdateManyArgs>(args: SelectSubset<T, CreditPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditPurchases and returns the data updated in the database.
     * @param {CreditPurchaseUpdateManyAndReturnArgs} args - Arguments to update many CreditPurchases.
     * @example
     * // Update many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditPurchases and only return the `id`
     * const creditPurchaseWithIdOnly = await prisma.creditPurchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditPurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditPurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditPurchase.
     * @param {CreditPurchaseUpsertArgs} args - Arguments to update or create a CreditPurchase.
     * @example
     * // Update or create a CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.upsert({
     *   create: {
     *     // ... data to create a CreditPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditPurchase we want to update
     *   }
     * })
     */
    upsert<T extends CreditPurchaseUpsertArgs>(args: SelectSubset<T, CreditPurchaseUpsertArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseCountArgs} args - Arguments to filter CreditPurchases to count.
     * @example
     * // Count the number of CreditPurchases
     * const count = await prisma.creditPurchase.count({
     *   where: {
     *     // ... the filter for the CreditPurchases we want to count
     *   }
     * })
    **/
    count<T extends CreditPurchaseCountArgs>(
      args?: Subset<T, CreditPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditPurchaseAggregateArgs>(args: Subset<T, CreditPurchaseAggregateArgs>): Prisma.PrismaPromise<GetCreditPurchaseAggregateType<T>>

    /**
     * Group by CreditPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: CreditPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditPurchase model
   */
  readonly fields: CreditPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditPurchase model
   */
  interface CreditPurchaseFieldRefs {
    readonly id: FieldRef<"CreditPurchase", 'String'>
    readonly subscriptionId: FieldRef<"CreditPurchase", 'String'>
    readonly creditsPurchased: FieldRef<"CreditPurchase", 'Int'>
    readonly amountPaid: FieldRef<"CreditPurchase", 'Decimal'>
    readonly currency: FieldRef<"CreditPurchase", 'String'>
    readonly stripeChargeId: FieldRef<"CreditPurchase", 'String'>
    readonly status: FieldRef<"CreditPurchase", 'String'>
    readonly purchasedAt: FieldRef<"CreditPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditPurchase findUnique
   */
  export type CreditPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase findUniqueOrThrow
   */
  export type CreditPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase findFirst
   */
  export type CreditPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPurchases.
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPurchases.
     */
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * CreditPurchase findFirstOrThrow
   */
  export type CreditPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPurchases.
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPurchases.
     */
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * CreditPurchase findMany
   */
  export type CreditPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchases to fetch.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditPurchases.
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * CreditPurchase create
   */
  export type CreditPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditPurchase.
     */
    data: XOR<CreditPurchaseCreateInput, CreditPurchaseUncheckedCreateInput>
  }

  /**
   * CreditPurchase createMany
   */
  export type CreditPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditPurchases.
     */
    data: CreditPurchaseCreateManyInput | CreditPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditPurchase createManyAndReturn
   */
  export type CreditPurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many CreditPurchases.
     */
    data: CreditPurchaseCreateManyInput | CreditPurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditPurchase update
   */
  export type CreditPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditPurchase.
     */
    data: XOR<CreditPurchaseUpdateInput, CreditPurchaseUncheckedUpdateInput>
    /**
     * Choose, which CreditPurchase to update.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase updateMany
   */
  export type CreditPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditPurchases.
     */
    data: XOR<CreditPurchaseUpdateManyMutationInput, CreditPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which CreditPurchases to update
     */
    where?: CreditPurchaseWhereInput
    /**
     * Limit how many CreditPurchases to update.
     */
    limit?: number
  }

  /**
   * CreditPurchase updateManyAndReturn
   */
  export type CreditPurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * The data used to update CreditPurchases.
     */
    data: XOR<CreditPurchaseUpdateManyMutationInput, CreditPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which CreditPurchases to update
     */
    where?: CreditPurchaseWhereInput
    /**
     * Limit how many CreditPurchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditPurchase upsert
   */
  export type CreditPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditPurchase to update in case it exists.
     */
    where: CreditPurchaseWhereUniqueInput
    /**
     * In case the CreditPurchase found by the `where` argument doesn't exist, create a new CreditPurchase with this data.
     */
    create: XOR<CreditPurchaseCreateInput, CreditPurchaseUncheckedCreateInput>
    /**
     * In case the CreditPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditPurchaseUpdateInput, CreditPurchaseUncheckedUpdateInput>
  }

  /**
   * CreditPurchase delete
   */
  export type CreditPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter which CreditPurchase to delete.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase deleteMany
   */
  export type CreditPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPurchases to delete
     */
    where?: CreditPurchaseWhereInput
    /**
     * Limit how many CreditPurchases to delete.
     */
    limit?: number
  }

  /**
   * CreditPurchase without action
   */
  export type CreditPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model CreditUsageLog
   */

  export type AggregateCreditUsageLog = {
    _count: CreditUsageLogCountAggregateOutputType | null
    _avg: CreditUsageLogAvgAggregateOutputType | null
    _sum: CreditUsageLogSumAggregateOutputType | null
    _min: CreditUsageLogMinAggregateOutputType | null
    _max: CreditUsageLogMaxAggregateOutputType | null
  }

  export type CreditUsageLogAvgAggregateOutputType = {
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type CreditUsageLogSumAggregateOutputType = {
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type CreditUsageLogMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    workspaceId: string | null
    canvasId: string | null
    podId: string | null
    executionId: string | null
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type CreditUsageLogMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    workspaceId: string | null
    canvasId: string | null
    podId: string | null
    executionId: string | null
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type CreditUsageLogCountAggregateOutputType = {
    id: number
    subscriptionId: number
    workspaceId: number
    canvasId: number
    podId: number
    executionId: number
    creditsUsed: number
    balanceBefore: number
    balanceAfter: number
    provider: number
    modelId: number
    modelName: number
    createdAt: number
    _all: number
  }


  export type CreditUsageLogAvgAggregateInputType = {
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type CreditUsageLogSumAggregateInputType = {
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type CreditUsageLogMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    workspaceId?: true
    canvasId?: true
    podId?: true
    executionId?: true
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
    provider?: true
    modelId?: true
    modelName?: true
    createdAt?: true
  }

  export type CreditUsageLogMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    workspaceId?: true
    canvasId?: true
    podId?: true
    executionId?: true
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
    provider?: true
    modelId?: true
    modelName?: true
    createdAt?: true
  }

  export type CreditUsageLogCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    workspaceId?: true
    canvasId?: true
    podId?: true
    executionId?: true
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
    provider?: true
    modelId?: true
    modelName?: true
    createdAt?: true
    _all?: true
  }

  export type CreditUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditUsageLog to aggregate.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditUsageLogs
    **/
    _count?: true | CreditUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditUsageLogMaxAggregateInputType
  }

  export type GetCreditUsageLogAggregateType<T extends CreditUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditUsageLog[P]>
      : GetScalarType<T[P], AggregateCreditUsageLog[P]>
  }




  export type CreditUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditUsageLogWhereInput
    orderBy?: CreditUsageLogOrderByWithAggregationInput | CreditUsageLogOrderByWithAggregationInput[]
    by: CreditUsageLogScalarFieldEnum[] | CreditUsageLogScalarFieldEnum
    having?: CreditUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditUsageLogCountAggregateInputType | true
    _avg?: CreditUsageLogAvgAggregateInputType
    _sum?: CreditUsageLogSumAggregateInputType
    _min?: CreditUsageLogMinAggregateInputType
    _max?: CreditUsageLogMaxAggregateInputType
  }

  export type CreditUsageLogGroupByOutputType = {
    id: string
    subscriptionId: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName: string | null
    createdAt: Date
    _count: CreditUsageLogCountAggregateOutputType | null
    _avg: CreditUsageLogAvgAggregateOutputType | null
    _sum: CreditUsageLogSumAggregateOutputType | null
    _min: CreditUsageLogMinAggregateOutputType | null
    _max: CreditUsageLogMaxAggregateOutputType | null
  }

  type GetCreditUsageLogGroupByPayload<T extends CreditUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], CreditUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type CreditUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditUsageLog"]>

  export type CreditUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditUsageLog"]>

  export type CreditUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditUsageLog"]>

  export type CreditUsageLogSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
  }

  export type CreditUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "workspaceId" | "canvasId" | "podId" | "executionId" | "creditsUsed" | "balanceBefore" | "balanceAfter" | "provider" | "modelId" | "modelName" | "createdAt", ExtArgs["result"]["creditUsageLog"]>
  export type CreditUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $CreditUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditUsageLog"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      workspaceId: string
      canvasId: string
      podId: string
      executionId: string
      creditsUsed: number
      balanceBefore: number
      balanceAfter: number
      provider: $Enums.LLMProvider
      modelId: string
      modelName: string | null
      createdAt: Date
    }, ExtArgs["result"]["creditUsageLog"]>
    composites: {}
  }

  type CreditUsageLogGetPayload<S extends boolean | null | undefined | CreditUsageLogDefaultArgs> = $Result.GetResult<Prisma.$CreditUsageLogPayload, S>

  type CreditUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditUsageLogCountAggregateInputType | true
    }

  export interface CreditUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditUsageLog'], meta: { name: 'CreditUsageLog' } }
    /**
     * Find zero or one CreditUsageLog that matches the filter.
     * @param {CreditUsageLogFindUniqueArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditUsageLogFindUniqueArgs>(args: SelectSubset<T, CreditUsageLogFindUniqueArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditUsageLogFindUniqueOrThrowArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogFindFirstArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditUsageLogFindFirstArgs>(args?: SelectSubset<T, CreditUsageLogFindFirstArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogFindFirstOrThrowArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditUsageLogs
     * const creditUsageLogs = await prisma.creditUsageLog.findMany()
     * 
     * // Get first 10 CreditUsageLogs
     * const creditUsageLogs = await prisma.creditUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditUsageLogWithIdOnly = await prisma.creditUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditUsageLogFindManyArgs>(args?: SelectSubset<T, CreditUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditUsageLog.
     * @param {CreditUsageLogCreateArgs} args - Arguments to create a CreditUsageLog.
     * @example
     * // Create one CreditUsageLog
     * const CreditUsageLog = await prisma.creditUsageLog.create({
     *   data: {
     *     // ... data to create a CreditUsageLog
     *   }
     * })
     * 
     */
    create<T extends CreditUsageLogCreateArgs>(args: SelectSubset<T, CreditUsageLogCreateArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditUsageLogs.
     * @param {CreditUsageLogCreateManyArgs} args - Arguments to create many CreditUsageLogs.
     * @example
     * // Create many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditUsageLogCreateManyArgs>(args?: SelectSubset<T, CreditUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditUsageLogs and returns the data saved in the database.
     * @param {CreditUsageLogCreateManyAndReturnArgs} args - Arguments to create many CreditUsageLogs.
     * @example
     * // Create many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditUsageLogs and only return the `id`
     * const creditUsageLogWithIdOnly = await prisma.creditUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditUsageLog.
     * @param {CreditUsageLogDeleteArgs} args - Arguments to delete one CreditUsageLog.
     * @example
     * // Delete one CreditUsageLog
     * const CreditUsageLog = await prisma.creditUsageLog.delete({
     *   where: {
     *     // ... filter to delete one CreditUsageLog
     *   }
     * })
     * 
     */
    delete<T extends CreditUsageLogDeleteArgs>(args: SelectSubset<T, CreditUsageLogDeleteArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditUsageLog.
     * @param {CreditUsageLogUpdateArgs} args - Arguments to update one CreditUsageLog.
     * @example
     * // Update one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditUsageLogUpdateArgs>(args: SelectSubset<T, CreditUsageLogUpdateArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditUsageLogs.
     * @param {CreditUsageLogDeleteManyArgs} args - Arguments to filter CreditUsageLogs to delete.
     * @example
     * // Delete a few CreditUsageLogs
     * const { count } = await prisma.creditUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditUsageLogDeleteManyArgs>(args?: SelectSubset<T, CreditUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditUsageLogUpdateManyArgs>(args: SelectSubset<T, CreditUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditUsageLogs and returns the data updated in the database.
     * @param {CreditUsageLogUpdateManyAndReturnArgs} args - Arguments to update many CreditUsageLogs.
     * @example
     * // Update many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditUsageLogs and only return the `id`
     * const creditUsageLogWithIdOnly = await prisma.creditUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditUsageLog.
     * @param {CreditUsageLogUpsertArgs} args - Arguments to update or create a CreditUsageLog.
     * @example
     * // Update or create a CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.upsert({
     *   create: {
     *     // ... data to create a CreditUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends CreditUsageLogUpsertArgs>(args: SelectSubset<T, CreditUsageLogUpsertArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogCountArgs} args - Arguments to filter CreditUsageLogs to count.
     * @example
     * // Count the number of CreditUsageLogs
     * const count = await prisma.creditUsageLog.count({
     *   where: {
     *     // ... the filter for the CreditUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends CreditUsageLogCountArgs>(
      args?: Subset<T, CreditUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditUsageLogAggregateArgs>(args: Subset<T, CreditUsageLogAggregateArgs>): Prisma.PrismaPromise<GetCreditUsageLogAggregateType<T>>

    /**
     * Group by CreditUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: CreditUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditUsageLog model
   */
  readonly fields: CreditUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditUsageLog model
   */
  interface CreditUsageLogFieldRefs {
    readonly id: FieldRef<"CreditUsageLog", 'String'>
    readonly subscriptionId: FieldRef<"CreditUsageLog", 'String'>
    readonly workspaceId: FieldRef<"CreditUsageLog", 'String'>
    readonly canvasId: FieldRef<"CreditUsageLog", 'String'>
    readonly podId: FieldRef<"CreditUsageLog", 'String'>
    readonly executionId: FieldRef<"CreditUsageLog", 'String'>
    readonly creditsUsed: FieldRef<"CreditUsageLog", 'Int'>
    readonly balanceBefore: FieldRef<"CreditUsageLog", 'Int'>
    readonly balanceAfter: FieldRef<"CreditUsageLog", 'Int'>
    readonly provider: FieldRef<"CreditUsageLog", 'LLMProvider'>
    readonly modelId: FieldRef<"CreditUsageLog", 'String'>
    readonly modelName: FieldRef<"CreditUsageLog", 'String'>
    readonly createdAt: FieldRef<"CreditUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditUsageLog findUnique
   */
  export type CreditUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog findUniqueOrThrow
   */
  export type CreditUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog findFirst
   */
  export type CreditUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditUsageLogs.
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditUsageLogs.
     */
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * CreditUsageLog findFirstOrThrow
   */
  export type CreditUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditUsageLogs.
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditUsageLogs.
     */
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * CreditUsageLog findMany
   */
  export type CreditUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLogs to fetch.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditUsageLogs.
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * CreditUsageLog create
   */
  export type CreditUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditUsageLog.
     */
    data: XOR<CreditUsageLogCreateInput, CreditUsageLogUncheckedCreateInput>
  }

  /**
   * CreditUsageLog createMany
   */
  export type CreditUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditUsageLogs.
     */
    data: CreditUsageLogCreateManyInput | CreditUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditUsageLog createManyAndReturn
   */
  export type CreditUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many CreditUsageLogs.
     */
    data: CreditUsageLogCreateManyInput | CreditUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditUsageLog update
   */
  export type CreditUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditUsageLog.
     */
    data: XOR<CreditUsageLogUpdateInput, CreditUsageLogUncheckedUpdateInput>
    /**
     * Choose, which CreditUsageLog to update.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog updateMany
   */
  export type CreditUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditUsageLogs.
     */
    data: XOR<CreditUsageLogUpdateManyMutationInput, CreditUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which CreditUsageLogs to update
     */
    where?: CreditUsageLogWhereInput
    /**
     * Limit how many CreditUsageLogs to update.
     */
    limit?: number
  }

  /**
   * CreditUsageLog updateManyAndReturn
   */
  export type CreditUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update CreditUsageLogs.
     */
    data: XOR<CreditUsageLogUpdateManyMutationInput, CreditUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which CreditUsageLogs to update
     */
    where?: CreditUsageLogWhereInput
    /**
     * Limit how many CreditUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditUsageLog upsert
   */
  export type CreditUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditUsageLog to update in case it exists.
     */
    where: CreditUsageLogWhereUniqueInput
    /**
     * In case the CreditUsageLog found by the `where` argument doesn't exist, create a new CreditUsageLog with this data.
     */
    create: XOR<CreditUsageLogCreateInput, CreditUsageLogUncheckedCreateInput>
    /**
     * In case the CreditUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditUsageLogUpdateInput, CreditUsageLogUncheckedUpdateInput>
  }

  /**
   * CreditUsageLog delete
   */
  export type CreditUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter which CreditUsageLog to delete.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog deleteMany
   */
  export type CreditUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditUsageLogs to delete
     */
    where?: CreditUsageLogWhereInput
    /**
     * Limit how many CreditUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * CreditUsageLog without action
   */
  export type CreditUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ModelPricingTier
   */

  export type AggregateModelPricingTier = {
    _count: ModelPricingTierCountAggregateOutputType | null
    _avg: ModelPricingTierAvgAggregateOutputType | null
    _sum: ModelPricingTierSumAggregateOutputType | null
    _min: ModelPricingTierMinAggregateOutputType | null
    _max: ModelPricingTierMaxAggregateOutputType | null
  }

  export type ModelPricingTierAvgAggregateOutputType = {
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
  }

  export type ModelPricingTierSumAggregateOutputType = {
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
  }

  export type ModelPricingTierMinAggregateOutputType = {
    id: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    category: $Enums.ModelCategory | null
    displayName: string | null
    description: string | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
    supportsStreaming: boolean | null
    supportsVision: boolean | null
    supportsAudio: boolean | null
    supportsVideo: boolean | null
    supportsFunctions: boolean | null
    supportsJsonMode: boolean | null
    supportsSystemPrompt: boolean | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelPricingTierMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    category: $Enums.ModelCategory | null
    displayName: string | null
    description: string | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
    supportsStreaming: boolean | null
    supportsVision: boolean | null
    supportsAudio: boolean | null
    supportsVideo: boolean | null
    supportsFunctions: boolean | null
    supportsJsonMode: boolean | null
    supportsSystemPrompt: boolean | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelPricingTierCountAggregateOutputType = {
    id: number
    provider: number
    modelId: number
    category: number
    displayName: number
    description: number
    inputTokenCost: number
    outputTokenCost: number
    reasoningTokenCost: number
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens: number
    maxTokens: number
    maxOutputTokens: number
    supportsStreaming: number
    supportsVision: number
    supportsAudio: number
    supportsVideo: number
    supportsFunctions: number
    supportsJsonMode: number
    supportsSystemPrompt: number
    providerConfig: number
    isActive: number
    effectiveFrom: number
    effectiveUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelPricingTierAvgAggregateInputType = {
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
  }

  export type ModelPricingTierSumAggregateInputType = {
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
  }

  export type ModelPricingTierMinAggregateInputType = {
    id?: true
    provider?: true
    modelId?: true
    category?: true
    displayName?: true
    description?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
    supportsStreaming?: true
    supportsVision?: true
    supportsAudio?: true
    supportsVideo?: true
    supportsFunctions?: true
    supportsJsonMode?: true
    supportsSystemPrompt?: true
    isActive?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelPricingTierMaxAggregateInputType = {
    id?: true
    provider?: true
    modelId?: true
    category?: true
    displayName?: true
    description?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
    supportsStreaming?: true
    supportsVision?: true
    supportsAudio?: true
    supportsVideo?: true
    supportsFunctions?: true
    supportsJsonMode?: true
    supportsSystemPrompt?: true
    isActive?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelPricingTierCountAggregateInputType = {
    id?: true
    provider?: true
    modelId?: true
    category?: true
    displayName?: true
    description?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
    supportsStreaming?: true
    supportsVision?: true
    supportsAudio?: true
    supportsVideo?: true
    supportsFunctions?: true
    supportsJsonMode?: true
    supportsSystemPrompt?: true
    providerConfig?: true
    isActive?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelPricingTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelPricingTier to aggregate.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelPricingTiers
    **/
    _count?: true | ModelPricingTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelPricingTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelPricingTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelPricingTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelPricingTierMaxAggregateInputType
  }

  export type GetModelPricingTierAggregateType<T extends ModelPricingTierAggregateArgs> = {
        [P in keyof T & keyof AggregateModelPricingTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelPricingTier[P]>
      : GetScalarType<T[P], AggregateModelPricingTier[P]>
  }




  export type ModelPricingTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelPricingTierWhereInput
    orderBy?: ModelPricingTierOrderByWithAggregationInput | ModelPricingTierOrderByWithAggregationInput[]
    by: ModelPricingTierScalarFieldEnum[] | ModelPricingTierScalarFieldEnum
    having?: ModelPricingTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelPricingTierCountAggregateInputType | true
    _avg?: ModelPricingTierAvgAggregateInputType
    _sum?: ModelPricingTierSumAggregateInputType
    _min?: ModelPricingTierMinAggregateInputType
    _max?: ModelPricingTierMaxAggregateInputType
  }

  export type ModelPricingTierGroupByOutputType = {
    id: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description: string | null
    inputTokenCost: Decimal
    outputTokenCost: Decimal
    reasoningTokenCost: Decimal
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens: number
    maxTokens: number | null
    maxOutputTokens: number | null
    supportsStreaming: boolean
    supportsVision: boolean
    supportsAudio: boolean
    supportsVideo: boolean
    supportsFunctions: boolean
    supportsJsonMode: boolean
    supportsSystemPrompt: boolean
    providerConfig: JsonValue | null
    isActive: boolean
    effectiveFrom: Date
    effectiveUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ModelPricingTierCountAggregateOutputType | null
    _avg: ModelPricingTierAvgAggregateOutputType | null
    _sum: ModelPricingTierSumAggregateOutputType | null
    _min: ModelPricingTierMinAggregateOutputType | null
    _max: ModelPricingTierMaxAggregateOutputType | null
  }

  type GetModelPricingTierGroupByPayload<T extends ModelPricingTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelPricingTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelPricingTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelPricingTierGroupByOutputType[P]>
            : GetScalarType<T[P], ModelPricingTierGroupByOutputType[P]>
        }
      >
    >


  export type ModelPricingTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelPricingTier"]>

  export type ModelPricingTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelPricingTier"]>

  export type ModelPricingTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelPricingTier"]>

  export type ModelPricingTierSelectScalar = {
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelPricingTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "modelId" | "category" | "displayName" | "description" | "inputTokenCost" | "outputTokenCost" | "reasoningTokenCost" | "creditsPerMillionInputTokens" | "creditsPerMillionOutputTokens" | "creditsPerMillionReasoningTokens" | "maxTokens" | "maxOutputTokens" | "supportsStreaming" | "supportsVision" | "supportsAudio" | "supportsVideo" | "supportsFunctions" | "supportsJsonMode" | "supportsSystemPrompt" | "providerConfig" | "isActive" | "effectiveFrom" | "effectiveUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["modelPricingTier"]>

  export type $ModelPricingTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelPricingTier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.LLMProvider
      modelId: string
      category: $Enums.ModelCategory
      displayName: string
      description: string | null
      inputTokenCost: Prisma.Decimal
      outputTokenCost: Prisma.Decimal
      reasoningTokenCost: Prisma.Decimal
      creditsPerMillionInputTokens: number
      creditsPerMillionOutputTokens: number
      creditsPerMillionReasoningTokens: number
      maxTokens: number | null
      maxOutputTokens: number | null
      supportsStreaming: boolean
      supportsVision: boolean
      supportsAudio: boolean
      supportsVideo: boolean
      supportsFunctions: boolean
      supportsJsonMode: boolean
      supportsSystemPrompt: boolean
      providerConfig: Prisma.JsonValue | null
      isActive: boolean
      effectiveFrom: Date
      effectiveUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modelPricingTier"]>
    composites: {}
  }

  type ModelPricingTierGetPayload<S extends boolean | null | undefined | ModelPricingTierDefaultArgs> = $Result.GetResult<Prisma.$ModelPricingTierPayload, S>

  type ModelPricingTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelPricingTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelPricingTierCountAggregateInputType | true
    }

  export interface ModelPricingTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelPricingTier'], meta: { name: 'ModelPricingTier' } }
    /**
     * Find zero or one ModelPricingTier that matches the filter.
     * @param {ModelPricingTierFindUniqueArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelPricingTierFindUniqueArgs>(args: SelectSubset<T, ModelPricingTierFindUniqueArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelPricingTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelPricingTierFindUniqueOrThrowArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelPricingTierFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelPricingTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelPricingTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierFindFirstArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelPricingTierFindFirstArgs>(args?: SelectSubset<T, ModelPricingTierFindFirstArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelPricingTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierFindFirstOrThrowArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelPricingTierFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelPricingTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelPricingTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelPricingTiers
     * const modelPricingTiers = await prisma.modelPricingTier.findMany()
     * 
     * // Get first 10 ModelPricingTiers
     * const modelPricingTiers = await prisma.modelPricingTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelPricingTierWithIdOnly = await prisma.modelPricingTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelPricingTierFindManyArgs>(args?: SelectSubset<T, ModelPricingTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelPricingTier.
     * @param {ModelPricingTierCreateArgs} args - Arguments to create a ModelPricingTier.
     * @example
     * // Create one ModelPricingTier
     * const ModelPricingTier = await prisma.modelPricingTier.create({
     *   data: {
     *     // ... data to create a ModelPricingTier
     *   }
     * })
     * 
     */
    create<T extends ModelPricingTierCreateArgs>(args: SelectSubset<T, ModelPricingTierCreateArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelPricingTiers.
     * @param {ModelPricingTierCreateManyArgs} args - Arguments to create many ModelPricingTiers.
     * @example
     * // Create many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelPricingTierCreateManyArgs>(args?: SelectSubset<T, ModelPricingTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelPricingTiers and returns the data saved in the database.
     * @param {ModelPricingTierCreateManyAndReturnArgs} args - Arguments to create many ModelPricingTiers.
     * @example
     * // Create many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelPricingTiers and only return the `id`
     * const modelPricingTierWithIdOnly = await prisma.modelPricingTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelPricingTierCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelPricingTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModelPricingTier.
     * @param {ModelPricingTierDeleteArgs} args - Arguments to delete one ModelPricingTier.
     * @example
     * // Delete one ModelPricingTier
     * const ModelPricingTier = await prisma.modelPricingTier.delete({
     *   where: {
     *     // ... filter to delete one ModelPricingTier
     *   }
     * })
     * 
     */
    delete<T extends ModelPricingTierDeleteArgs>(args: SelectSubset<T, ModelPricingTierDeleteArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelPricingTier.
     * @param {ModelPricingTierUpdateArgs} args - Arguments to update one ModelPricingTier.
     * @example
     * // Update one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelPricingTierUpdateArgs>(args: SelectSubset<T, ModelPricingTierUpdateArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelPricingTiers.
     * @param {ModelPricingTierDeleteManyArgs} args - Arguments to filter ModelPricingTiers to delete.
     * @example
     * // Delete a few ModelPricingTiers
     * const { count } = await prisma.modelPricingTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelPricingTierDeleteManyArgs>(args?: SelectSubset<T, ModelPricingTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelPricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelPricingTierUpdateManyArgs>(args: SelectSubset<T, ModelPricingTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelPricingTiers and returns the data updated in the database.
     * @param {ModelPricingTierUpdateManyAndReturnArgs} args - Arguments to update many ModelPricingTiers.
     * @example
     * // Update many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelPricingTiers and only return the `id`
     * const modelPricingTierWithIdOnly = await prisma.modelPricingTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelPricingTierUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelPricingTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModelPricingTier.
     * @param {ModelPricingTierUpsertArgs} args - Arguments to update or create a ModelPricingTier.
     * @example
     * // Update or create a ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.upsert({
     *   create: {
     *     // ... data to create a ModelPricingTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelPricingTier we want to update
     *   }
     * })
     */
    upsert<T extends ModelPricingTierUpsertArgs>(args: SelectSubset<T, ModelPricingTierUpsertArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelPricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierCountArgs} args - Arguments to filter ModelPricingTiers to count.
     * @example
     * // Count the number of ModelPricingTiers
     * const count = await prisma.modelPricingTier.count({
     *   where: {
     *     // ... the filter for the ModelPricingTiers we want to count
     *   }
     * })
    **/
    count<T extends ModelPricingTierCountArgs>(
      args?: Subset<T, ModelPricingTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelPricingTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelPricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelPricingTierAggregateArgs>(args: Subset<T, ModelPricingTierAggregateArgs>): Prisma.PrismaPromise<GetModelPricingTierAggregateType<T>>

    /**
     * Group by ModelPricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelPricingTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelPricingTierGroupByArgs['orderBy'] }
        : { orderBy?: ModelPricingTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelPricingTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelPricingTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelPricingTier model
   */
  readonly fields: ModelPricingTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelPricingTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelPricingTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelPricingTier model
   */
  interface ModelPricingTierFieldRefs {
    readonly id: FieldRef<"ModelPricingTier", 'String'>
    readonly provider: FieldRef<"ModelPricingTier", 'LLMProvider'>
    readonly modelId: FieldRef<"ModelPricingTier", 'String'>
    readonly category: FieldRef<"ModelPricingTier", 'ModelCategory'>
    readonly displayName: FieldRef<"ModelPricingTier", 'String'>
    readonly description: FieldRef<"ModelPricingTier", 'String'>
    readonly inputTokenCost: FieldRef<"ModelPricingTier", 'Decimal'>
    readonly outputTokenCost: FieldRef<"ModelPricingTier", 'Decimal'>
    readonly reasoningTokenCost: FieldRef<"ModelPricingTier", 'Decimal'>
    readonly creditsPerMillionInputTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly creditsPerMillionOutputTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly creditsPerMillionReasoningTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly maxTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly maxOutputTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly supportsStreaming: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsVision: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsAudio: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsVideo: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsFunctions: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsJsonMode: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsSystemPrompt: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly providerConfig: FieldRef<"ModelPricingTier", 'Json'>
    readonly isActive: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly effectiveFrom: FieldRef<"ModelPricingTier", 'DateTime'>
    readonly effectiveUntil: FieldRef<"ModelPricingTier", 'DateTime'>
    readonly createdAt: FieldRef<"ModelPricingTier", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelPricingTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelPricingTier findUnique
   */
  export type ModelPricingTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier findUniqueOrThrow
   */
  export type ModelPricingTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier findFirst
   */
  export type ModelPricingTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelPricingTiers.
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelPricingTiers.
     */
    distinct?: ModelPricingTierScalarFieldEnum | ModelPricingTierScalarFieldEnum[]
  }

  /**
   * ModelPricingTier findFirstOrThrow
   */
  export type ModelPricingTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelPricingTiers.
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelPricingTiers.
     */
    distinct?: ModelPricingTierScalarFieldEnum | ModelPricingTierScalarFieldEnum[]
  }

  /**
   * ModelPricingTier findMany
   */
  export type ModelPricingTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTiers to fetch.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelPricingTiers.
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    distinct?: ModelPricingTierScalarFieldEnum | ModelPricingTierScalarFieldEnum[]
  }

  /**
   * ModelPricingTier create
   */
  export type ModelPricingTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data needed to create a ModelPricingTier.
     */
    data: XOR<ModelPricingTierCreateInput, ModelPricingTierUncheckedCreateInput>
  }

  /**
   * ModelPricingTier createMany
   */
  export type ModelPricingTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelPricingTiers.
     */
    data: ModelPricingTierCreateManyInput | ModelPricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelPricingTier createManyAndReturn
   */
  export type ModelPricingTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data used to create many ModelPricingTiers.
     */
    data: ModelPricingTierCreateManyInput | ModelPricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelPricingTier update
   */
  export type ModelPricingTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data needed to update a ModelPricingTier.
     */
    data: XOR<ModelPricingTierUpdateInput, ModelPricingTierUncheckedUpdateInput>
    /**
     * Choose, which ModelPricingTier to update.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier updateMany
   */
  export type ModelPricingTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelPricingTiers.
     */
    data: XOR<ModelPricingTierUpdateManyMutationInput, ModelPricingTierUncheckedUpdateManyInput>
    /**
     * Filter which ModelPricingTiers to update
     */
    where?: ModelPricingTierWhereInput
    /**
     * Limit how many ModelPricingTiers to update.
     */
    limit?: number
  }

  /**
   * ModelPricingTier updateManyAndReturn
   */
  export type ModelPricingTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data used to update ModelPricingTiers.
     */
    data: XOR<ModelPricingTierUpdateManyMutationInput, ModelPricingTierUncheckedUpdateManyInput>
    /**
     * Filter which ModelPricingTiers to update
     */
    where?: ModelPricingTierWhereInput
    /**
     * Limit how many ModelPricingTiers to update.
     */
    limit?: number
  }

  /**
   * ModelPricingTier upsert
   */
  export type ModelPricingTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The filter to search for the ModelPricingTier to update in case it exists.
     */
    where: ModelPricingTierWhereUniqueInput
    /**
     * In case the ModelPricingTier found by the `where` argument doesn't exist, create a new ModelPricingTier with this data.
     */
    create: XOR<ModelPricingTierCreateInput, ModelPricingTierUncheckedCreateInput>
    /**
     * In case the ModelPricingTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelPricingTierUpdateInput, ModelPricingTierUncheckedUpdateInput>
  }

  /**
   * ModelPricingTier delete
   */
  export type ModelPricingTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter which ModelPricingTier to delete.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier deleteMany
   */
  export type ModelPricingTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelPricingTiers to delete
     */
    where?: ModelPricingTierWhereInput
    /**
     * Limit how many ModelPricingTiers to delete.
     */
    limit?: number
  }

  /**
   * ModelPricingTier without action
   */
  export type ModelPricingTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
  }


  /**
   * Model Space
   */

  export type AggregateSpace = {
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  export type SpaceMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    customInstructions: string | null
    icon: string | null
    color: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpaceMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    customInstructions: string | null
    icon: string | null
    color: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpaceCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    customInstructions: number
    icon: number
    color: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpaceMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    customInstructions?: true
    icon?: true
    color?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpaceMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    customInstructions?: true
    icon?: true
    color?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpaceCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    customInstructions?: true
    icon?: true
    color?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Space to aggregate.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spaces
    **/
    _count?: true | SpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMaxAggregateInputType
  }

  export type GetSpaceAggregateType<T extends SpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpace[P]>
      : GetScalarType<T[P], AggregateSpace[P]>
  }




  export type SpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithAggregationInput | SpaceOrderByWithAggregationInput[]
    by: SpaceScalarFieldEnum[] | SpaceScalarFieldEnum
    having?: SpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceCountAggregateInputType | true
    _min?: SpaceMinAggregateInputType
    _max?: SpaceMaxAggregateInputType
  }

  export type SpaceGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    customInstructions: string | null
    icon: string | null
    color: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  type GetSpaceGroupByPayload<T extends SpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceGroupByOutputType[P]>
        }
      >
    >


  export type SpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    customInstructions?: boolean
    icon?: boolean
    color?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    flows?: boolean | Space$flowsArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    customInstructions?: boolean
    icon?: boolean
    color?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    customInstructions?: boolean
    icon?: boolean
    color?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    customInstructions?: boolean
    icon?: boolean
    color?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "customInstructions" | "icon" | "color" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["space"]>
  export type SpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    flows?: boolean | Space$flowsArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SpaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $SpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Space"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      flows: Prisma.$FlowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      customInstructions: string | null
      icon: string | null
      color: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["space"]>
    composites: {}
  }

  type SpaceGetPayload<S extends boolean | null | undefined | SpaceDefaultArgs> = $Result.GetResult<Prisma.$SpacePayload, S>

  type SpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpaceCountAggregateInputType | true
    }

  export interface SpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Space'], meta: { name: 'Space' } }
    /**
     * Find zero or one Space that matches the filter.
     * @param {SpaceFindUniqueArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceFindUniqueArgs>(args: SelectSubset<T, SpaceFindUniqueArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Space that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaceFindUniqueOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Space that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceFindFirstArgs>(args?: SelectSubset<T, SpaceFindFirstArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Space that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spaces
     * const spaces = await prisma.space.findMany()
     * 
     * // Get first 10 Spaces
     * const spaces = await prisma.space.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceWithIdOnly = await prisma.space.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceFindManyArgs>(args?: SelectSubset<T, SpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Space.
     * @param {SpaceCreateArgs} args - Arguments to create a Space.
     * @example
     * // Create one Space
     * const Space = await prisma.space.create({
     *   data: {
     *     // ... data to create a Space
     *   }
     * })
     * 
     */
    create<T extends SpaceCreateArgs>(args: SelectSubset<T, SpaceCreateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spaces.
     * @param {SpaceCreateManyArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceCreateManyArgs>(args?: SelectSubset<T, SpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spaces and returns the data saved in the database.
     * @param {SpaceCreateManyAndReturnArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Space.
     * @param {SpaceDeleteArgs} args - Arguments to delete one Space.
     * @example
     * // Delete one Space
     * const Space = await prisma.space.delete({
     *   where: {
     *     // ... filter to delete one Space
     *   }
     * })
     * 
     */
    delete<T extends SpaceDeleteArgs>(args: SelectSubset<T, SpaceDeleteArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Space.
     * @param {SpaceUpdateArgs} args - Arguments to update one Space.
     * @example
     * // Update one Space
     * const space = await prisma.space.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceUpdateArgs>(args: SelectSubset<T, SpaceUpdateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spaces.
     * @param {SpaceDeleteManyArgs} args - Arguments to filter Spaces to delete.
     * @example
     * // Delete a few Spaces
     * const { count } = await prisma.space.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceDeleteManyArgs>(args?: SelectSubset<T, SpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceUpdateManyArgs>(args: SelectSubset<T, SpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces and returns the data updated in the database.
     * @param {SpaceUpdateManyAndReturnArgs} args - Arguments to update many Spaces.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaceUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Space.
     * @param {SpaceUpsertArgs} args - Arguments to update or create a Space.
     * @example
     * // Update or create a Space
     * const space = await prisma.space.upsert({
     *   create: {
     *     // ... data to create a Space
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Space we want to update
     *   }
     * })
     */
    upsert<T extends SpaceUpsertArgs>(args: SelectSubset<T, SpaceUpsertArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceCountArgs} args - Arguments to filter Spaces to count.
     * @example
     * // Count the number of Spaces
     * const count = await prisma.space.count({
     *   where: {
     *     // ... the filter for the Spaces we want to count
     *   }
     * })
    **/
    count<T extends SpaceCountArgs>(
      args?: Subset<T, SpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAggregateArgs>(args: Subset<T, SpaceAggregateArgs>): Prisma.PrismaPromise<GetSpaceAggregateType<T>>

    /**
     * Group by Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceGroupByArgs['orderBy'] }
        : { orderBy?: SpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Space model
   */
  readonly fields: SpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Space.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flows<T extends Space$flowsArgs<ExtArgs> = {}>(args?: Subset<T, Space$flowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Space model
   */
  interface SpaceFieldRefs {
    readonly id: FieldRef<"Space", 'String'>
    readonly workspaceId: FieldRef<"Space", 'String'>
    readonly name: FieldRef<"Space", 'String'>
    readonly description: FieldRef<"Space", 'String'>
    readonly customInstructions: FieldRef<"Space", 'String'>
    readonly icon: FieldRef<"Space", 'String'>
    readonly color: FieldRef<"Space", 'String'>
    readonly createdBy: FieldRef<"Space", 'String'>
    readonly createdAt: FieldRef<"Space", 'DateTime'>
    readonly updatedAt: FieldRef<"Space", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Space findUnique
   */
  export type SpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findUniqueOrThrow
   */
  export type SpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findFirst
   */
  export type SpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findFirstOrThrow
   */
  export type SpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findMany
   */
  export type SpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Spaces to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space create
   */
  export type SpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Space.
     */
    data: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
  }

  /**
   * Space createMany
   */
  export type SpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Space createManyAndReturn
   */
  export type SpaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Space update
   */
  export type SpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Space.
     */
    data: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
    /**
     * Choose, which Space to update.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space updateMany
   */
  export type SpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to update.
     */
    limit?: number
  }

  /**
   * Space updateManyAndReturn
   */
  export type SpaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Space upsert
   */
  export type SpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Space to update in case it exists.
     */
    where: SpaceWhereUniqueInput
    /**
     * In case the Space found by the `where` argument doesn't exist, create a new Space with this data.
     */
    create: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
    /**
     * In case the Space was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
  }

  /**
   * Space delete
   */
  export type SpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter which Space to delete.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space deleteMany
   */
  export type SpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spaces to delete
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to delete.
     */
    limit?: number
  }

  /**
   * Space.flows
   */
  export type Space$flowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    where?: FlowWhereInput
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    cursor?: FlowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Space without action
   */
  export type SpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
  }


  /**
   * Model Flow
   */

  export type AggregateFlow = {
    _count: FlowCountAggregateOutputType | null
    _avg: FlowAvgAggregateOutputType | null
    _sum: FlowSumAggregateOutputType | null
    _min: FlowMinAggregateOutputType | null
    _max: FlowMaxAggregateOutputType | null
  }

  export type FlowAvgAggregateOutputType = {
    version: number | null
  }

  export type FlowSumAggregateOutputType = {
    version: number | null
  }

  export type FlowMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    spaceId: string | null
    name: string | null
    description: string | null
    version: number | null
    visibility: $Enums.FlowVisibility | null
    createdBy: string | null
    thumbnailS3Key: string | null
    thumbnailGeneratedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlowMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    spaceId: string | null
    name: string | null
    description: string | null
    version: number | null
    visibility: $Enums.FlowVisibility | null
    createdBy: string | null
    thumbnailS3Key: string | null
    thumbnailGeneratedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlowCountAggregateOutputType = {
    id: number
    workspaceId: number
    spaceId: number
    name: number
    description: number
    version: number
    visibility: number
    createdBy: number
    thumbnailS3Key: number
    thumbnailGeneratedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlowAvgAggregateInputType = {
    version?: true
  }

  export type FlowSumAggregateInputType = {
    version?: true
  }

  export type FlowMinAggregateInputType = {
    id?: true
    workspaceId?: true
    spaceId?: true
    name?: true
    description?: true
    version?: true
    visibility?: true
    createdBy?: true
    thumbnailS3Key?: true
    thumbnailGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlowMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    spaceId?: true
    name?: true
    description?: true
    version?: true
    visibility?: true
    createdBy?: true
    thumbnailS3Key?: true
    thumbnailGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlowCountAggregateInputType = {
    id?: true
    workspaceId?: true
    spaceId?: true
    name?: true
    description?: true
    version?: true
    visibility?: true
    createdBy?: true
    thumbnailS3Key?: true
    thumbnailGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flow to aggregate.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flows
    **/
    _count?: true | FlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowMaxAggregateInputType
  }

  export type GetFlowAggregateType<T extends FlowAggregateArgs> = {
        [P in keyof T & keyof AggregateFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlow[P]>
      : GetScalarType<T[P], AggregateFlow[P]>
  }




  export type FlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowWhereInput
    orderBy?: FlowOrderByWithAggregationInput | FlowOrderByWithAggregationInput[]
    by: FlowScalarFieldEnum[] | FlowScalarFieldEnum
    having?: FlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowCountAggregateInputType | true
    _avg?: FlowAvgAggregateInputType
    _sum?: FlowSumAggregateInputType
    _min?: FlowMinAggregateInputType
    _max?: FlowMaxAggregateInputType
  }

  export type FlowGroupByOutputType = {
    id: string
    workspaceId: string
    spaceId: string | null
    name: string
    description: string | null
    version: number
    visibility: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key: string | null
    thumbnailGeneratedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FlowCountAggregateOutputType | null
    _avg: FlowAvgAggregateOutputType | null
    _sum: FlowSumAggregateOutputType | null
    _min: FlowMinAggregateOutputType | null
    _max: FlowMaxAggregateOutputType | null
  }

  type GetFlowGroupByPayload<T extends FlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowGroupByOutputType[P]>
            : GetScalarType<T[P], FlowGroupByOutputType[P]>
        }
      >
    >


  export type FlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    spaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    space?: boolean | Flow$spaceArgs<ExtArgs>
    pods?: boolean | Flow$podsArgs<ExtArgs>
    edges?: boolean | Flow$edgesArgs<ExtArgs>
    contextualPods?: boolean | Flow$contextualPodsArgs<ExtArgs>
    contextModules?: boolean | Flow$contextModulesArgs<ExtArgs>
    collaborators?: boolean | Flow$collaboratorsArgs<ExtArgs>
    invitations?: boolean | Flow$invitationsArgs<ExtArgs>
    sessions?: boolean | Flow$sessionsArgs<ExtArgs>
    activityLog?: boolean | Flow$activityLogArgs<ExtArgs>
    comments?: boolean | Flow$commentsArgs<ExtArgs>
    _count?: boolean | FlowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flow"]>

  export type FlowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    spaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    space?: boolean | Flow$spaceArgs<ExtArgs>
  }, ExtArgs["result"]["flow"]>

  export type FlowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    spaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    space?: boolean | Flow$spaceArgs<ExtArgs>
  }, ExtArgs["result"]["flow"]>

  export type FlowSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    spaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "spaceId" | "name" | "description" | "version" | "visibility" | "createdBy" | "thumbnailS3Key" | "thumbnailGeneratedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["flow"]>
  export type FlowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    space?: boolean | Flow$spaceArgs<ExtArgs>
    pods?: boolean | Flow$podsArgs<ExtArgs>
    edges?: boolean | Flow$edgesArgs<ExtArgs>
    contextualPods?: boolean | Flow$contextualPodsArgs<ExtArgs>
    contextModules?: boolean | Flow$contextModulesArgs<ExtArgs>
    collaborators?: boolean | Flow$collaboratorsArgs<ExtArgs>
    invitations?: boolean | Flow$invitationsArgs<ExtArgs>
    sessions?: boolean | Flow$sessionsArgs<ExtArgs>
    activityLog?: boolean | Flow$activityLogArgs<ExtArgs>
    comments?: boolean | Flow$commentsArgs<ExtArgs>
    _count?: boolean | FlowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    space?: boolean | Flow$spaceArgs<ExtArgs>
  }
  export type FlowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    space?: boolean | Flow$spaceArgs<ExtArgs>
  }

  export type $FlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flow"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      space: Prisma.$SpacePayload<ExtArgs> | null
      pods: Prisma.$PodPayload<ExtArgs>[]
      edges: Prisma.$EdgePayload<ExtArgs>[]
      contextualPods: Prisma.$PodPayload<ExtArgs>[]
      contextModules: Prisma.$ContextModulePayload<ExtArgs>[]
      collaborators: Prisma.$FlowCollaboratorPayload<ExtArgs>[]
      invitations: Prisma.$FlowInvitationPayload<ExtArgs>[]
      sessions: Prisma.$FlowSessionPayload<ExtArgs>[]
      activityLog: Prisma.$FlowActivityLogPayload<ExtArgs>[]
      comments: Prisma.$FlowCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      spaceId: string | null
      name: string
      description: string | null
      version: number
      visibility: $Enums.FlowVisibility
      createdBy: string
      thumbnailS3Key: string | null
      thumbnailGeneratedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flow"]>
    composites: {}
  }

  type FlowGetPayload<S extends boolean | null | undefined | FlowDefaultArgs> = $Result.GetResult<Prisma.$FlowPayload, S>

  type FlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowCountAggregateInputType | true
    }

  export interface FlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flow'], meta: { name: 'Flow' } }
    /**
     * Find zero or one Flow that matches the filter.
     * @param {FlowFindUniqueArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowFindUniqueArgs>(args: SelectSubset<T, FlowFindUniqueArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowFindUniqueOrThrowArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowFindFirstArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowFindFirstArgs>(args?: SelectSubset<T, FlowFindFirstArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowFindFirstOrThrowArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flows
     * const flows = await prisma.flow.findMany()
     * 
     * // Get first 10 Flows
     * const flows = await prisma.flow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowWithIdOnly = await prisma.flow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowFindManyArgs>(args?: SelectSubset<T, FlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flow.
     * @param {FlowCreateArgs} args - Arguments to create a Flow.
     * @example
     * // Create one Flow
     * const Flow = await prisma.flow.create({
     *   data: {
     *     // ... data to create a Flow
     *   }
     * })
     * 
     */
    create<T extends FlowCreateArgs>(args: SelectSubset<T, FlowCreateArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flows.
     * @param {FlowCreateManyArgs} args - Arguments to create many Flows.
     * @example
     * // Create many Flows
     * const flow = await prisma.flow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowCreateManyArgs>(args?: SelectSubset<T, FlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flows and returns the data saved in the database.
     * @param {FlowCreateManyAndReturnArgs} args - Arguments to create many Flows.
     * @example
     * // Create many Flows
     * const flow = await prisma.flow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flows and only return the `id`
     * const flowWithIdOnly = await prisma.flow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flow.
     * @param {FlowDeleteArgs} args - Arguments to delete one Flow.
     * @example
     * // Delete one Flow
     * const Flow = await prisma.flow.delete({
     *   where: {
     *     // ... filter to delete one Flow
     *   }
     * })
     * 
     */
    delete<T extends FlowDeleteArgs>(args: SelectSubset<T, FlowDeleteArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flow.
     * @param {FlowUpdateArgs} args - Arguments to update one Flow.
     * @example
     * // Update one Flow
     * const flow = await prisma.flow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowUpdateArgs>(args: SelectSubset<T, FlowUpdateArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flows.
     * @param {FlowDeleteManyArgs} args - Arguments to filter Flows to delete.
     * @example
     * // Delete a few Flows
     * const { count } = await prisma.flow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowDeleteManyArgs>(args?: SelectSubset<T, FlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flows
     * const flow = await prisma.flow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowUpdateManyArgs>(args: SelectSubset<T, FlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flows and returns the data updated in the database.
     * @param {FlowUpdateManyAndReturnArgs} args - Arguments to update many Flows.
     * @example
     * // Update many Flows
     * const flow = await prisma.flow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flows and only return the `id`
     * const flowWithIdOnly = await prisma.flow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flow.
     * @param {FlowUpsertArgs} args - Arguments to update or create a Flow.
     * @example
     * // Update or create a Flow
     * const flow = await prisma.flow.upsert({
     *   create: {
     *     // ... data to create a Flow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flow we want to update
     *   }
     * })
     */
    upsert<T extends FlowUpsertArgs>(args: SelectSubset<T, FlowUpsertArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCountArgs} args - Arguments to filter Flows to count.
     * @example
     * // Count the number of Flows
     * const count = await prisma.flow.count({
     *   where: {
     *     // ... the filter for the Flows we want to count
     *   }
     * })
    **/
    count<T extends FlowCountArgs>(
      args?: Subset<T, FlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowAggregateArgs>(args: Subset<T, FlowAggregateArgs>): Prisma.PrismaPromise<GetFlowAggregateType<T>>

    /**
     * Group by Flow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowGroupByArgs['orderBy'] }
        : { orderBy?: FlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flow model
   */
  readonly fields: FlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    space<T extends Flow$spaceArgs<ExtArgs> = {}>(args?: Subset<T, Flow$spaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pods<T extends Flow$podsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$podsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    edges<T extends Flow$edgesArgs<ExtArgs> = {}>(args?: Subset<T, Flow$edgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contextualPods<T extends Flow$contextualPodsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$contextualPodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contextModules<T extends Flow$contextModulesArgs<ExtArgs> = {}>(args?: Subset<T, Flow$contextModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collaborators<T extends Flow$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Flow$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Flow$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLog<T extends Flow$activityLogArgs<ExtArgs> = {}>(args?: Subset<T, Flow$activityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Flow$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flow model
   */
  interface FlowFieldRefs {
    readonly id: FieldRef<"Flow", 'String'>
    readonly workspaceId: FieldRef<"Flow", 'String'>
    readonly spaceId: FieldRef<"Flow", 'String'>
    readonly name: FieldRef<"Flow", 'String'>
    readonly description: FieldRef<"Flow", 'String'>
    readonly version: FieldRef<"Flow", 'Int'>
    readonly visibility: FieldRef<"Flow", 'FlowVisibility'>
    readonly createdBy: FieldRef<"Flow", 'String'>
    readonly thumbnailS3Key: FieldRef<"Flow", 'String'>
    readonly thumbnailGeneratedAt: FieldRef<"Flow", 'DateTime'>
    readonly createdAt: FieldRef<"Flow", 'DateTime'>
    readonly updatedAt: FieldRef<"Flow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flow findUnique
   */
  export type FlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow findUniqueOrThrow
   */
  export type FlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow findFirst
   */
  export type FlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flows.
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flows.
     */
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Flow findFirstOrThrow
   */
  export type FlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flows.
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flows.
     */
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Flow findMany
   */
  export type FlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flows to fetch.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flows.
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Flow create
   */
  export type FlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * The data needed to create a Flow.
     */
    data: XOR<FlowCreateInput, FlowUncheckedCreateInput>
  }

  /**
   * Flow createMany
   */
  export type FlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flows.
     */
    data: FlowCreateManyInput | FlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flow createManyAndReturn
   */
  export type FlowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * The data used to create many Flows.
     */
    data: FlowCreateManyInput | FlowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flow update
   */
  export type FlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * The data needed to update a Flow.
     */
    data: XOR<FlowUpdateInput, FlowUncheckedUpdateInput>
    /**
     * Choose, which Flow to update.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow updateMany
   */
  export type FlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flows.
     */
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyInput>
    /**
     * Filter which Flows to update
     */
    where?: FlowWhereInput
    /**
     * Limit how many Flows to update.
     */
    limit?: number
  }

  /**
   * Flow updateManyAndReturn
   */
  export type FlowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * The data used to update Flows.
     */
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyInput>
    /**
     * Filter which Flows to update
     */
    where?: FlowWhereInput
    /**
     * Limit how many Flows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flow upsert
   */
  export type FlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * The filter to search for the Flow to update in case it exists.
     */
    where: FlowWhereUniqueInput
    /**
     * In case the Flow found by the `where` argument doesn't exist, create a new Flow with this data.
     */
    create: XOR<FlowCreateInput, FlowUncheckedCreateInput>
    /**
     * In case the Flow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowUpdateInput, FlowUncheckedUpdateInput>
  }

  /**
   * Flow delete
   */
  export type FlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter which Flow to delete.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow deleteMany
   */
  export type FlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flows to delete
     */
    where?: FlowWhereInput
    /**
     * Limit how many Flows to delete.
     */
    limit?: number
  }

  /**
   * Flow.space
   */
  export type Flow$spaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * Flow.pods
   */
  export type Flow$podsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    where?: PodWhereInput
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    cursor?: PodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Flow.edges
   */
  export type Flow$edgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    cursor?: EdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Flow.contextualPods
   */
  export type Flow$contextualPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    where?: PodWhereInput
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    cursor?: PodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Flow.contextModules
   */
  export type Flow$contextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    where?: ContextModuleWhereInput
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    cursor?: ContextModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * Flow.collaborators
   */
  export type Flow$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    where?: FlowCollaboratorWhereInput
    orderBy?: FlowCollaboratorOrderByWithRelationInput | FlowCollaboratorOrderByWithRelationInput[]
    cursor?: FlowCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowCollaboratorScalarFieldEnum | FlowCollaboratorScalarFieldEnum[]
  }

  /**
   * Flow.invitations
   */
  export type Flow$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    where?: FlowInvitationWhereInput
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    cursor?: FlowInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowInvitationScalarFieldEnum | FlowInvitationScalarFieldEnum[]
  }

  /**
   * Flow.sessions
   */
  export type Flow$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    where?: FlowSessionWhereInput
    orderBy?: FlowSessionOrderByWithRelationInput | FlowSessionOrderByWithRelationInput[]
    cursor?: FlowSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowSessionScalarFieldEnum | FlowSessionScalarFieldEnum[]
  }

  /**
   * Flow.activityLog
   */
  export type Flow$activityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    where?: FlowActivityLogWhereInput
    orderBy?: FlowActivityLogOrderByWithRelationInput | FlowActivityLogOrderByWithRelationInput[]
    cursor?: FlowActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowActivityLogScalarFieldEnum | FlowActivityLogScalarFieldEnum[]
  }

  /**
   * Flow.comments
   */
  export type Flow$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    where?: FlowCommentWhereInput
    orderBy?: FlowCommentOrderByWithRelationInput | FlowCommentOrderByWithRelationInput[]
    cursor?: FlowCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowCommentScalarFieldEnum | FlowCommentScalarFieldEnum[]
  }

  /**
   * Flow without action
   */
  export type FlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
  }


  /**
   * Model FlowInvitation
   */

  export type AggregateFlowInvitation = {
    _count: FlowInvitationCountAggregateOutputType | null
    _min: FlowInvitationMinAggregateOutputType | null
    _max: FlowInvitationMaxAggregateOutputType | null
  }

  export type FlowInvitationMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    email: string | null
    accessLevel: $Enums.FlowAccessLevel | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type FlowInvitationMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    email: string | null
    accessLevel: $Enums.FlowAccessLevel | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type FlowInvitationCountAggregateOutputType = {
    id: number
    flowId: number
    email: number
    accessLevel: number
    permissions: number
    invitedBy: number
    invitedUserId: number
    token: number
    status: number
    createdAt: number
    expiresAt: number
    acceptedAt: number
    _all: number
  }


  export type FlowInvitationMinAggregateInputType = {
    id?: true
    flowId?: true
    email?: true
    accessLevel?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type FlowInvitationMaxAggregateInputType = {
    id?: true
    flowId?: true
    email?: true
    accessLevel?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type FlowInvitationCountAggregateInputType = {
    id?: true
    flowId?: true
    email?: true
    accessLevel?: true
    permissions?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type FlowInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowInvitation to aggregate.
     */
    where?: FlowInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowInvitations to fetch.
     */
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowInvitations
    **/
    _count?: true | FlowInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowInvitationMaxAggregateInputType
  }

  export type GetFlowInvitationAggregateType<T extends FlowInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowInvitation[P]>
      : GetScalarType<T[P], AggregateFlowInvitation[P]>
  }




  export type FlowInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowInvitationWhereInput
    orderBy?: FlowInvitationOrderByWithAggregationInput | FlowInvitationOrderByWithAggregationInput[]
    by: FlowInvitationScalarFieldEnum[] | FlowInvitationScalarFieldEnum
    having?: FlowInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowInvitationCountAggregateInputType | true
    _min?: FlowInvitationMinAggregateInputType
    _max?: FlowInvitationMaxAggregateInputType
  }

  export type FlowInvitationGroupByOutputType = {
    id: string
    flowId: string
    email: string
    accessLevel: $Enums.FlowAccessLevel
    permissions: JsonValue | null
    invitedBy: string
    invitedUserId: string | null
    token: string
    status: $Enums.InvitationStatus
    createdAt: Date
    expiresAt: Date
    acceptedAt: Date | null
    _count: FlowInvitationCountAggregateOutputType | null
    _min: FlowInvitationMinAggregateOutputType | null
    _max: FlowInvitationMaxAggregateOutputType | null
  }

  type GetFlowInvitationGroupByPayload<T extends FlowInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], FlowInvitationGroupByOutputType[P]>
        }
      >
    >


  export type FlowInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | FlowInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["flowInvitation"]>

  export type FlowInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | FlowInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["flowInvitation"]>

  export type FlowInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | FlowInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["flowInvitation"]>

  export type FlowInvitationSelectScalar = {
    id?: boolean
    flowId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
  }

  export type FlowInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "email" | "accessLevel" | "permissions" | "invitedBy" | "invitedUserId" | "token" | "status" | "createdAt" | "expiresAt" | "acceptedAt", ExtArgs["result"]["flowInvitation"]>
  export type FlowInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | FlowInvitation$invitedUserArgs<ExtArgs>
  }
  export type FlowInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | FlowInvitation$invitedUserArgs<ExtArgs>
  }
  export type FlowInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | FlowInvitation$invitedUserArgs<ExtArgs>
  }

  export type $FlowInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowInvitation"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      invitedUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      email: string
      accessLevel: $Enums.FlowAccessLevel
      permissions: Prisma.JsonValue | null
      invitedBy: string
      invitedUserId: string | null
      token: string
      status: $Enums.InvitationStatus
      createdAt: Date
      expiresAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["flowInvitation"]>
    composites: {}
  }

  type FlowInvitationGetPayload<S extends boolean | null | undefined | FlowInvitationDefaultArgs> = $Result.GetResult<Prisma.$FlowInvitationPayload, S>

  type FlowInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowInvitationCountAggregateInputType | true
    }

  export interface FlowInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowInvitation'], meta: { name: 'FlowInvitation' } }
    /**
     * Find zero or one FlowInvitation that matches the filter.
     * @param {FlowInvitationFindUniqueArgs} args - Arguments to find a FlowInvitation
     * @example
     * // Get one FlowInvitation
     * const flowInvitation = await prisma.flowInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowInvitationFindUniqueArgs>(args: SelectSubset<T, FlowInvitationFindUniqueArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlowInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowInvitationFindUniqueOrThrowArgs} args - Arguments to find a FlowInvitation
     * @example
     * // Get one FlowInvitation
     * const flowInvitation = await prisma.flowInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationFindFirstArgs} args - Arguments to find a FlowInvitation
     * @example
     * // Get one FlowInvitation
     * const flowInvitation = await prisma.flowInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowInvitationFindFirstArgs>(args?: SelectSubset<T, FlowInvitationFindFirstArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationFindFirstOrThrowArgs} args - Arguments to find a FlowInvitation
     * @example
     * // Get one FlowInvitation
     * const flowInvitation = await prisma.flowInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlowInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowInvitations
     * const flowInvitations = await prisma.flowInvitation.findMany()
     * 
     * // Get first 10 FlowInvitations
     * const flowInvitations = await prisma.flowInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowInvitationWithIdOnly = await prisma.flowInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowInvitationFindManyArgs>(args?: SelectSubset<T, FlowInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlowInvitation.
     * @param {FlowInvitationCreateArgs} args - Arguments to create a FlowInvitation.
     * @example
     * // Create one FlowInvitation
     * const FlowInvitation = await prisma.flowInvitation.create({
     *   data: {
     *     // ... data to create a FlowInvitation
     *   }
     * })
     * 
     */
    create<T extends FlowInvitationCreateArgs>(args: SelectSubset<T, FlowInvitationCreateArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlowInvitations.
     * @param {FlowInvitationCreateManyArgs} args - Arguments to create many FlowInvitations.
     * @example
     * // Create many FlowInvitations
     * const flowInvitation = await prisma.flowInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowInvitationCreateManyArgs>(args?: SelectSubset<T, FlowInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlowInvitations and returns the data saved in the database.
     * @param {FlowInvitationCreateManyAndReturnArgs} args - Arguments to create many FlowInvitations.
     * @example
     * // Create many FlowInvitations
     * const flowInvitation = await prisma.flowInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlowInvitations and only return the `id`
     * const flowInvitationWithIdOnly = await prisma.flowInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlowInvitation.
     * @param {FlowInvitationDeleteArgs} args - Arguments to delete one FlowInvitation.
     * @example
     * // Delete one FlowInvitation
     * const FlowInvitation = await prisma.flowInvitation.delete({
     *   where: {
     *     // ... filter to delete one FlowInvitation
     *   }
     * })
     * 
     */
    delete<T extends FlowInvitationDeleteArgs>(args: SelectSubset<T, FlowInvitationDeleteArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlowInvitation.
     * @param {FlowInvitationUpdateArgs} args - Arguments to update one FlowInvitation.
     * @example
     * // Update one FlowInvitation
     * const flowInvitation = await prisma.flowInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowInvitationUpdateArgs>(args: SelectSubset<T, FlowInvitationUpdateArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlowInvitations.
     * @param {FlowInvitationDeleteManyArgs} args - Arguments to filter FlowInvitations to delete.
     * @example
     * // Delete a few FlowInvitations
     * const { count } = await prisma.flowInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowInvitationDeleteManyArgs>(args?: SelectSubset<T, FlowInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowInvitations
     * const flowInvitation = await prisma.flowInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowInvitationUpdateManyArgs>(args: SelectSubset<T, FlowInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowInvitations and returns the data updated in the database.
     * @param {FlowInvitationUpdateManyAndReturnArgs} args - Arguments to update many FlowInvitations.
     * @example
     * // Update many FlowInvitations
     * const flowInvitation = await prisma.flowInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlowInvitations and only return the `id`
     * const flowInvitationWithIdOnly = await prisma.flowInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlowInvitation.
     * @param {FlowInvitationUpsertArgs} args - Arguments to update or create a FlowInvitation.
     * @example
     * // Update or create a FlowInvitation
     * const flowInvitation = await prisma.flowInvitation.upsert({
     *   create: {
     *     // ... data to create a FlowInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowInvitation we want to update
     *   }
     * })
     */
    upsert<T extends FlowInvitationUpsertArgs>(args: SelectSubset<T, FlowInvitationUpsertArgs<ExtArgs>>): Prisma__FlowInvitationClient<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlowInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationCountArgs} args - Arguments to filter FlowInvitations to count.
     * @example
     * // Count the number of FlowInvitations
     * const count = await prisma.flowInvitation.count({
     *   where: {
     *     // ... the filter for the FlowInvitations we want to count
     *   }
     * })
    **/
    count<T extends FlowInvitationCountArgs>(
      args?: Subset<T, FlowInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowInvitationAggregateArgs>(args: Subset<T, FlowInvitationAggregateArgs>): Prisma.PrismaPromise<GetFlowInvitationAggregateType<T>>

    /**
     * Group by FlowInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowInvitationGroupByArgs['orderBy'] }
        : { orderBy?: FlowInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowInvitation model
   */
  readonly fields: FlowInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitedUser<T extends FlowInvitation$invitedUserArgs<ExtArgs> = {}>(args?: Subset<T, FlowInvitation$invitedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowInvitation model
   */
  interface FlowInvitationFieldRefs {
    readonly id: FieldRef<"FlowInvitation", 'String'>
    readonly flowId: FieldRef<"FlowInvitation", 'String'>
    readonly email: FieldRef<"FlowInvitation", 'String'>
    readonly accessLevel: FieldRef<"FlowInvitation", 'FlowAccessLevel'>
    readonly permissions: FieldRef<"FlowInvitation", 'Json'>
    readonly invitedBy: FieldRef<"FlowInvitation", 'String'>
    readonly invitedUserId: FieldRef<"FlowInvitation", 'String'>
    readonly token: FieldRef<"FlowInvitation", 'String'>
    readonly status: FieldRef<"FlowInvitation", 'InvitationStatus'>
    readonly createdAt: FieldRef<"FlowInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"FlowInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"FlowInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlowInvitation findUnique
   */
  export type FlowInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * Filter, which FlowInvitation to fetch.
     */
    where: FlowInvitationWhereUniqueInput
  }

  /**
   * FlowInvitation findUniqueOrThrow
   */
  export type FlowInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * Filter, which FlowInvitation to fetch.
     */
    where: FlowInvitationWhereUniqueInput
  }

  /**
   * FlowInvitation findFirst
   */
  export type FlowInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * Filter, which FlowInvitation to fetch.
     */
    where?: FlowInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowInvitations to fetch.
     */
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowInvitations.
     */
    cursor?: FlowInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowInvitations.
     */
    distinct?: FlowInvitationScalarFieldEnum | FlowInvitationScalarFieldEnum[]
  }

  /**
   * FlowInvitation findFirstOrThrow
   */
  export type FlowInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * Filter, which FlowInvitation to fetch.
     */
    where?: FlowInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowInvitations to fetch.
     */
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowInvitations.
     */
    cursor?: FlowInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowInvitations.
     */
    distinct?: FlowInvitationScalarFieldEnum | FlowInvitationScalarFieldEnum[]
  }

  /**
   * FlowInvitation findMany
   */
  export type FlowInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * Filter, which FlowInvitations to fetch.
     */
    where?: FlowInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowInvitations to fetch.
     */
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowInvitations.
     */
    cursor?: FlowInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowInvitations.
     */
    skip?: number
    distinct?: FlowInvitationScalarFieldEnum | FlowInvitationScalarFieldEnum[]
  }

  /**
   * FlowInvitation create
   */
  export type FlowInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowInvitation.
     */
    data: XOR<FlowInvitationCreateInput, FlowInvitationUncheckedCreateInput>
  }

  /**
   * FlowInvitation createMany
   */
  export type FlowInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowInvitations.
     */
    data: FlowInvitationCreateManyInput | FlowInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlowInvitation createManyAndReturn
   */
  export type FlowInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many FlowInvitations.
     */
    data: FlowInvitationCreateManyInput | FlowInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowInvitation update
   */
  export type FlowInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowInvitation.
     */
    data: XOR<FlowInvitationUpdateInput, FlowInvitationUncheckedUpdateInput>
    /**
     * Choose, which FlowInvitation to update.
     */
    where: FlowInvitationWhereUniqueInput
  }

  /**
   * FlowInvitation updateMany
   */
  export type FlowInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowInvitations.
     */
    data: XOR<FlowInvitationUpdateManyMutationInput, FlowInvitationUncheckedUpdateManyInput>
    /**
     * Filter which FlowInvitations to update
     */
    where?: FlowInvitationWhereInput
    /**
     * Limit how many FlowInvitations to update.
     */
    limit?: number
  }

  /**
   * FlowInvitation updateManyAndReturn
   */
  export type FlowInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * The data used to update FlowInvitations.
     */
    data: XOR<FlowInvitationUpdateManyMutationInput, FlowInvitationUncheckedUpdateManyInput>
    /**
     * Filter which FlowInvitations to update
     */
    where?: FlowInvitationWhereInput
    /**
     * Limit how many FlowInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowInvitation upsert
   */
  export type FlowInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowInvitation to update in case it exists.
     */
    where: FlowInvitationWhereUniqueInput
    /**
     * In case the FlowInvitation found by the `where` argument doesn't exist, create a new FlowInvitation with this data.
     */
    create: XOR<FlowInvitationCreateInput, FlowInvitationUncheckedCreateInput>
    /**
     * In case the FlowInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowInvitationUpdateInput, FlowInvitationUncheckedUpdateInput>
  }

  /**
   * FlowInvitation delete
   */
  export type FlowInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    /**
     * Filter which FlowInvitation to delete.
     */
    where: FlowInvitationWhereUniqueInput
  }

  /**
   * FlowInvitation deleteMany
   */
  export type FlowInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowInvitations to delete
     */
    where?: FlowInvitationWhereInput
    /**
     * Limit how many FlowInvitations to delete.
     */
    limit?: number
  }

  /**
   * FlowInvitation.invitedUser
   */
  export type FlowInvitation$invitedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FlowInvitation without action
   */
  export type FlowInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
  }


  /**
   * Model FlowCollaborator
   */

  export type AggregateFlowCollaborator = {
    _count: FlowCollaboratorCountAggregateOutputType | null
    _min: FlowCollaboratorMinAggregateOutputType | null
    _max: FlowCollaboratorMaxAggregateOutputType | null
  }

  export type FlowCollaboratorMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    accessLevel: $Enums.FlowAccessLevel | null
    canEdit: boolean | null
    canExecute: boolean | null
    canDelete: boolean | null
    canShare: boolean | null
    canInvite: boolean | null
    invitedBy: string | null
    invitedAt: Date | null
    lastViewedAt: Date | null
  }

  export type FlowCollaboratorMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    accessLevel: $Enums.FlowAccessLevel | null
    canEdit: boolean | null
    canExecute: boolean | null
    canDelete: boolean | null
    canShare: boolean | null
    canInvite: boolean | null
    invitedBy: string | null
    invitedAt: Date | null
    lastViewedAt: Date | null
  }

  export type FlowCollaboratorCountAggregateOutputType = {
    id: number
    flowId: number
    userId: number
    accessLevel: number
    canEdit: number
    canExecute: number
    canDelete: number
    canShare: number
    canInvite: number
    invitedBy: number
    invitedAt: number
    lastViewedAt: number
    _all: number
  }


  export type FlowCollaboratorMinAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    accessLevel?: true
    canEdit?: true
    canExecute?: true
    canDelete?: true
    canShare?: true
    canInvite?: true
    invitedBy?: true
    invitedAt?: true
    lastViewedAt?: true
  }

  export type FlowCollaboratorMaxAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    accessLevel?: true
    canEdit?: true
    canExecute?: true
    canDelete?: true
    canShare?: true
    canInvite?: true
    invitedBy?: true
    invitedAt?: true
    lastViewedAt?: true
  }

  export type FlowCollaboratorCountAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    accessLevel?: true
    canEdit?: true
    canExecute?: true
    canDelete?: true
    canShare?: true
    canInvite?: true
    invitedBy?: true
    invitedAt?: true
    lastViewedAt?: true
    _all?: true
  }

  export type FlowCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowCollaborator to aggregate.
     */
    where?: FlowCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowCollaborators to fetch.
     */
    orderBy?: FlowCollaboratorOrderByWithRelationInput | FlowCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowCollaborators
    **/
    _count?: true | FlowCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowCollaboratorMaxAggregateInputType
  }

  export type GetFlowCollaboratorAggregateType<T extends FlowCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowCollaborator[P]>
      : GetScalarType<T[P], AggregateFlowCollaborator[P]>
  }




  export type FlowCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowCollaboratorWhereInput
    orderBy?: FlowCollaboratorOrderByWithAggregationInput | FlowCollaboratorOrderByWithAggregationInput[]
    by: FlowCollaboratorScalarFieldEnum[] | FlowCollaboratorScalarFieldEnum
    having?: FlowCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowCollaboratorCountAggregateInputType | true
    _min?: FlowCollaboratorMinAggregateInputType
    _max?: FlowCollaboratorMaxAggregateInputType
  }

  export type FlowCollaboratorGroupByOutputType = {
    id: string
    flowId: string
    userId: string
    accessLevel: $Enums.FlowAccessLevel
    canEdit: boolean
    canExecute: boolean
    canDelete: boolean
    canShare: boolean
    canInvite: boolean
    invitedBy: string | null
    invitedAt: Date
    lastViewedAt: Date | null
    _count: FlowCollaboratorCountAggregateOutputType | null
    _min: FlowCollaboratorMinAggregateOutputType | null
    _max: FlowCollaboratorMaxAggregateOutputType | null
  }

  type GetFlowCollaboratorGroupByPayload<T extends FlowCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], FlowCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type FlowCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowCollaborator"]>

  export type FlowCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowCollaborator"]>

  export type FlowCollaboratorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowCollaborator"]>

  export type FlowCollaboratorSelectScalar = {
    id?: boolean
    flowId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
  }

  export type FlowCollaboratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "userId" | "accessLevel" | "canEdit" | "canExecute" | "canDelete" | "canShare" | "canInvite" | "invitedBy" | "invitedAt" | "lastViewedAt", ExtArgs["result"]["flowCollaborator"]>
  export type FlowCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlowCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlowCollaboratorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlowCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowCollaborator"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      userId: string
      accessLevel: $Enums.FlowAccessLevel
      canEdit: boolean
      canExecute: boolean
      canDelete: boolean
      canShare: boolean
      canInvite: boolean
      invitedBy: string | null
      invitedAt: Date
      lastViewedAt: Date | null
    }, ExtArgs["result"]["flowCollaborator"]>
    composites: {}
  }

  type FlowCollaboratorGetPayload<S extends boolean | null | undefined | FlowCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$FlowCollaboratorPayload, S>

  type FlowCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowCollaboratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowCollaboratorCountAggregateInputType | true
    }

  export interface FlowCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowCollaborator'], meta: { name: 'FlowCollaborator' } }
    /**
     * Find zero or one FlowCollaborator that matches the filter.
     * @param {FlowCollaboratorFindUniqueArgs} args - Arguments to find a FlowCollaborator
     * @example
     * // Get one FlowCollaborator
     * const flowCollaborator = await prisma.flowCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowCollaboratorFindUniqueArgs>(args: SelectSubset<T, FlowCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlowCollaborator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a FlowCollaborator
     * @example
     * // Get one FlowCollaborator
     * const flowCollaborator = await prisma.flowCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorFindFirstArgs} args - Arguments to find a FlowCollaborator
     * @example
     * // Get one FlowCollaborator
     * const flowCollaborator = await prisma.flowCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowCollaboratorFindFirstArgs>(args?: SelectSubset<T, FlowCollaboratorFindFirstArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorFindFirstOrThrowArgs} args - Arguments to find a FlowCollaborator
     * @example
     * // Get one FlowCollaborator
     * const flowCollaborator = await prisma.flowCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlowCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowCollaborators
     * const flowCollaborators = await prisma.flowCollaborator.findMany()
     * 
     * // Get first 10 FlowCollaborators
     * const flowCollaborators = await prisma.flowCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowCollaboratorWithIdOnly = await prisma.flowCollaborator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowCollaboratorFindManyArgs>(args?: SelectSubset<T, FlowCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlowCollaborator.
     * @param {FlowCollaboratorCreateArgs} args - Arguments to create a FlowCollaborator.
     * @example
     * // Create one FlowCollaborator
     * const FlowCollaborator = await prisma.flowCollaborator.create({
     *   data: {
     *     // ... data to create a FlowCollaborator
     *   }
     * })
     * 
     */
    create<T extends FlowCollaboratorCreateArgs>(args: SelectSubset<T, FlowCollaboratorCreateArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlowCollaborators.
     * @param {FlowCollaboratorCreateManyArgs} args - Arguments to create many FlowCollaborators.
     * @example
     * // Create many FlowCollaborators
     * const flowCollaborator = await prisma.flowCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowCollaboratorCreateManyArgs>(args?: SelectSubset<T, FlowCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlowCollaborators and returns the data saved in the database.
     * @param {FlowCollaboratorCreateManyAndReturnArgs} args - Arguments to create many FlowCollaborators.
     * @example
     * // Create many FlowCollaborators
     * const flowCollaborator = await prisma.flowCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlowCollaborators and only return the `id`
     * const flowCollaboratorWithIdOnly = await prisma.flowCollaborator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlowCollaborator.
     * @param {FlowCollaboratorDeleteArgs} args - Arguments to delete one FlowCollaborator.
     * @example
     * // Delete one FlowCollaborator
     * const FlowCollaborator = await prisma.flowCollaborator.delete({
     *   where: {
     *     // ... filter to delete one FlowCollaborator
     *   }
     * })
     * 
     */
    delete<T extends FlowCollaboratorDeleteArgs>(args: SelectSubset<T, FlowCollaboratorDeleteArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlowCollaborator.
     * @param {FlowCollaboratorUpdateArgs} args - Arguments to update one FlowCollaborator.
     * @example
     * // Update one FlowCollaborator
     * const flowCollaborator = await prisma.flowCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowCollaboratorUpdateArgs>(args: SelectSubset<T, FlowCollaboratorUpdateArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlowCollaborators.
     * @param {FlowCollaboratorDeleteManyArgs} args - Arguments to filter FlowCollaborators to delete.
     * @example
     * // Delete a few FlowCollaborators
     * const { count } = await prisma.flowCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowCollaboratorDeleteManyArgs>(args?: SelectSubset<T, FlowCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowCollaborators
     * const flowCollaborator = await prisma.flowCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowCollaboratorUpdateManyArgs>(args: SelectSubset<T, FlowCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowCollaborators and returns the data updated in the database.
     * @param {FlowCollaboratorUpdateManyAndReturnArgs} args - Arguments to update many FlowCollaborators.
     * @example
     * // Update many FlowCollaborators
     * const flowCollaborator = await prisma.flowCollaborator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlowCollaborators and only return the `id`
     * const flowCollaboratorWithIdOnly = await prisma.flowCollaborator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowCollaboratorUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowCollaboratorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlowCollaborator.
     * @param {FlowCollaboratorUpsertArgs} args - Arguments to update or create a FlowCollaborator.
     * @example
     * // Update or create a FlowCollaborator
     * const flowCollaborator = await prisma.flowCollaborator.upsert({
     *   create: {
     *     // ... data to create a FlowCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends FlowCollaboratorUpsertArgs>(args: SelectSubset<T, FlowCollaboratorUpsertArgs<ExtArgs>>): Prisma__FlowCollaboratorClient<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlowCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorCountArgs} args - Arguments to filter FlowCollaborators to count.
     * @example
     * // Count the number of FlowCollaborators
     * const count = await prisma.flowCollaborator.count({
     *   where: {
     *     // ... the filter for the FlowCollaborators we want to count
     *   }
     * })
    **/
    count<T extends FlowCollaboratorCountArgs>(
      args?: Subset<T, FlowCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowCollaboratorAggregateArgs>(args: Subset<T, FlowCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetFlowCollaboratorAggregateType<T>>

    /**
     * Group by FlowCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: FlowCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowCollaborator model
   */
  readonly fields: FlowCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowCollaborator model
   */
  interface FlowCollaboratorFieldRefs {
    readonly id: FieldRef<"FlowCollaborator", 'String'>
    readonly flowId: FieldRef<"FlowCollaborator", 'String'>
    readonly userId: FieldRef<"FlowCollaborator", 'String'>
    readonly accessLevel: FieldRef<"FlowCollaborator", 'FlowAccessLevel'>
    readonly canEdit: FieldRef<"FlowCollaborator", 'Boolean'>
    readonly canExecute: FieldRef<"FlowCollaborator", 'Boolean'>
    readonly canDelete: FieldRef<"FlowCollaborator", 'Boolean'>
    readonly canShare: FieldRef<"FlowCollaborator", 'Boolean'>
    readonly canInvite: FieldRef<"FlowCollaborator", 'Boolean'>
    readonly invitedBy: FieldRef<"FlowCollaborator", 'String'>
    readonly invitedAt: FieldRef<"FlowCollaborator", 'DateTime'>
    readonly lastViewedAt: FieldRef<"FlowCollaborator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlowCollaborator findUnique
   */
  export type FlowCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which FlowCollaborator to fetch.
     */
    where: FlowCollaboratorWhereUniqueInput
  }

  /**
   * FlowCollaborator findUniqueOrThrow
   */
  export type FlowCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which FlowCollaborator to fetch.
     */
    where: FlowCollaboratorWhereUniqueInput
  }

  /**
   * FlowCollaborator findFirst
   */
  export type FlowCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which FlowCollaborator to fetch.
     */
    where?: FlowCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowCollaborators to fetch.
     */
    orderBy?: FlowCollaboratorOrderByWithRelationInput | FlowCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowCollaborators.
     */
    cursor?: FlowCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowCollaborators.
     */
    distinct?: FlowCollaboratorScalarFieldEnum | FlowCollaboratorScalarFieldEnum[]
  }

  /**
   * FlowCollaborator findFirstOrThrow
   */
  export type FlowCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which FlowCollaborator to fetch.
     */
    where?: FlowCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowCollaborators to fetch.
     */
    orderBy?: FlowCollaboratorOrderByWithRelationInput | FlowCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowCollaborators.
     */
    cursor?: FlowCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowCollaborators.
     */
    distinct?: FlowCollaboratorScalarFieldEnum | FlowCollaboratorScalarFieldEnum[]
  }

  /**
   * FlowCollaborator findMany
   */
  export type FlowCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which FlowCollaborators to fetch.
     */
    where?: FlowCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowCollaborators to fetch.
     */
    orderBy?: FlowCollaboratorOrderByWithRelationInput | FlowCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowCollaborators.
     */
    cursor?: FlowCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowCollaborators.
     */
    skip?: number
    distinct?: FlowCollaboratorScalarFieldEnum | FlowCollaboratorScalarFieldEnum[]
  }

  /**
   * FlowCollaborator create
   */
  export type FlowCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowCollaborator.
     */
    data: XOR<FlowCollaboratorCreateInput, FlowCollaboratorUncheckedCreateInput>
  }

  /**
   * FlowCollaborator createMany
   */
  export type FlowCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowCollaborators.
     */
    data: FlowCollaboratorCreateManyInput | FlowCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlowCollaborator createManyAndReturn
   */
  export type FlowCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * The data used to create many FlowCollaborators.
     */
    data: FlowCollaboratorCreateManyInput | FlowCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowCollaborator update
   */
  export type FlowCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowCollaborator.
     */
    data: XOR<FlowCollaboratorUpdateInput, FlowCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which FlowCollaborator to update.
     */
    where: FlowCollaboratorWhereUniqueInput
  }

  /**
   * FlowCollaborator updateMany
   */
  export type FlowCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowCollaborators.
     */
    data: XOR<FlowCollaboratorUpdateManyMutationInput, FlowCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which FlowCollaborators to update
     */
    where?: FlowCollaboratorWhereInput
    /**
     * Limit how many FlowCollaborators to update.
     */
    limit?: number
  }

  /**
   * FlowCollaborator updateManyAndReturn
   */
  export type FlowCollaboratorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * The data used to update FlowCollaborators.
     */
    data: XOR<FlowCollaboratorUpdateManyMutationInput, FlowCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which FlowCollaborators to update
     */
    where?: FlowCollaboratorWhereInput
    /**
     * Limit how many FlowCollaborators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowCollaborator upsert
   */
  export type FlowCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowCollaborator to update in case it exists.
     */
    where: FlowCollaboratorWhereUniqueInput
    /**
     * In case the FlowCollaborator found by the `where` argument doesn't exist, create a new FlowCollaborator with this data.
     */
    create: XOR<FlowCollaboratorCreateInput, FlowCollaboratorUncheckedCreateInput>
    /**
     * In case the FlowCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowCollaboratorUpdateInput, FlowCollaboratorUncheckedUpdateInput>
  }

  /**
   * FlowCollaborator delete
   */
  export type FlowCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which FlowCollaborator to delete.
     */
    where: FlowCollaboratorWhereUniqueInput
  }

  /**
   * FlowCollaborator deleteMany
   */
  export type FlowCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowCollaborators to delete
     */
    where?: FlowCollaboratorWhereInput
    /**
     * Limit how many FlowCollaborators to delete.
     */
    limit?: number
  }

  /**
   * FlowCollaborator without action
   */
  export type FlowCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model FlowSession
   */

  export type AggregateFlowSession = {
    _count: FlowSessionCountAggregateOutputType | null
    _min: FlowSessionMinAggregateOutputType | null
    _max: FlowSessionMaxAggregateOutputType | null
  }

  export type FlowSessionMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    anonymousName: string | null
    sessionToken: string | null
    socketId: string | null
    userColor: string | null
    userAgent: string | null
    ipAddress: string | null
    connectedAt: Date | null
    lastHeartbeatAt: Date | null
    disconnectedAt: Date | null
  }

  export type FlowSessionMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    anonymousName: string | null
    sessionToken: string | null
    socketId: string | null
    userColor: string | null
    userAgent: string | null
    ipAddress: string | null
    connectedAt: Date | null
    lastHeartbeatAt: Date | null
    disconnectedAt: Date | null
  }

  export type FlowSessionCountAggregateOutputType = {
    id: number
    flowId: number
    userId: number
    anonymousName: number
    sessionToken: number
    socketId: number
    cursorPosition: number
    selectedPodIds: number
    viewportState: number
    userColor: number
    userAgent: number
    ipAddress: number
    connectedAt: number
    lastHeartbeatAt: number
    disconnectedAt: number
    _all: number
  }


  export type FlowSessionMinAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    anonymousName?: true
    sessionToken?: true
    socketId?: true
    userColor?: true
    userAgent?: true
    ipAddress?: true
    connectedAt?: true
    lastHeartbeatAt?: true
    disconnectedAt?: true
  }

  export type FlowSessionMaxAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    anonymousName?: true
    sessionToken?: true
    socketId?: true
    userColor?: true
    userAgent?: true
    ipAddress?: true
    connectedAt?: true
    lastHeartbeatAt?: true
    disconnectedAt?: true
  }

  export type FlowSessionCountAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    anonymousName?: true
    sessionToken?: true
    socketId?: true
    cursorPosition?: true
    selectedPodIds?: true
    viewportState?: true
    userColor?: true
    userAgent?: true
    ipAddress?: true
    connectedAt?: true
    lastHeartbeatAt?: true
    disconnectedAt?: true
    _all?: true
  }

  export type FlowSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowSession to aggregate.
     */
    where?: FlowSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowSessions to fetch.
     */
    orderBy?: FlowSessionOrderByWithRelationInput | FlowSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowSessions
    **/
    _count?: true | FlowSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowSessionMaxAggregateInputType
  }

  export type GetFlowSessionAggregateType<T extends FlowSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowSession[P]>
      : GetScalarType<T[P], AggregateFlowSession[P]>
  }




  export type FlowSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowSessionWhereInput
    orderBy?: FlowSessionOrderByWithAggregationInput | FlowSessionOrderByWithAggregationInput[]
    by: FlowSessionScalarFieldEnum[] | FlowSessionScalarFieldEnum
    having?: FlowSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowSessionCountAggregateInputType | true
    _min?: FlowSessionMinAggregateInputType
    _max?: FlowSessionMaxAggregateInputType
  }

  export type FlowSessionGroupByOutputType = {
    id: string
    flowId: string
    userId: string | null
    anonymousName: string | null
    sessionToken: string | null
    socketId: string | null
    cursorPosition: JsonValue | null
    selectedPodIds: JsonValue | null
    viewportState: JsonValue | null
    userColor: string | null
    userAgent: string | null
    ipAddress: string | null
    connectedAt: Date
    lastHeartbeatAt: Date
    disconnectedAt: Date | null
    _count: FlowSessionCountAggregateOutputType | null
    _min: FlowSessionMinAggregateOutputType | null
    _max: FlowSessionMaxAggregateOutputType | null
  }

  type GetFlowSessionGroupByPayload<T extends FlowSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowSessionGroupByOutputType[P]>
            : GetScalarType<T[P], FlowSessionGroupByOutputType[P]>
        }
      >
    >


  export type FlowSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowSession"]>

  export type FlowSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowSession"]>

  export type FlowSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowSession"]>

  export type FlowSessionSelectScalar = {
    id?: boolean
    flowId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
  }

  export type FlowSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "userId" | "anonymousName" | "sessionToken" | "socketId" | "cursorPosition" | "selectedPodIds" | "viewportState" | "userColor" | "userAgent" | "ipAddress" | "connectedAt" | "lastHeartbeatAt" | "disconnectedAt", ExtArgs["result"]["flowSession"]>
  export type FlowSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type FlowSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type FlowSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }

  export type $FlowSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowSession"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      userId: string | null
      anonymousName: string | null
      sessionToken: string | null
      socketId: string | null
      cursorPosition: Prisma.JsonValue | null
      selectedPodIds: Prisma.JsonValue | null
      viewportState: Prisma.JsonValue | null
      userColor: string | null
      userAgent: string | null
      ipAddress: string | null
      connectedAt: Date
      lastHeartbeatAt: Date
      disconnectedAt: Date | null
    }, ExtArgs["result"]["flowSession"]>
    composites: {}
  }

  type FlowSessionGetPayload<S extends boolean | null | undefined | FlowSessionDefaultArgs> = $Result.GetResult<Prisma.$FlowSessionPayload, S>

  type FlowSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowSessionCountAggregateInputType | true
    }

  export interface FlowSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowSession'], meta: { name: 'FlowSession' } }
    /**
     * Find zero or one FlowSession that matches the filter.
     * @param {FlowSessionFindUniqueArgs} args - Arguments to find a FlowSession
     * @example
     * // Get one FlowSession
     * const flowSession = await prisma.flowSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowSessionFindUniqueArgs>(args: SelectSubset<T, FlowSessionFindUniqueArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlowSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowSessionFindUniqueOrThrowArgs} args - Arguments to find a FlowSession
     * @example
     * // Get one FlowSession
     * const flowSession = await prisma.flowSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionFindFirstArgs} args - Arguments to find a FlowSession
     * @example
     * // Get one FlowSession
     * const flowSession = await prisma.flowSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowSessionFindFirstArgs>(args?: SelectSubset<T, FlowSessionFindFirstArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionFindFirstOrThrowArgs} args - Arguments to find a FlowSession
     * @example
     * // Get one FlowSession
     * const flowSession = await prisma.flowSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlowSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowSessions
     * const flowSessions = await prisma.flowSession.findMany()
     * 
     * // Get first 10 FlowSessions
     * const flowSessions = await prisma.flowSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowSessionWithIdOnly = await prisma.flowSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowSessionFindManyArgs>(args?: SelectSubset<T, FlowSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlowSession.
     * @param {FlowSessionCreateArgs} args - Arguments to create a FlowSession.
     * @example
     * // Create one FlowSession
     * const FlowSession = await prisma.flowSession.create({
     *   data: {
     *     // ... data to create a FlowSession
     *   }
     * })
     * 
     */
    create<T extends FlowSessionCreateArgs>(args: SelectSubset<T, FlowSessionCreateArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlowSessions.
     * @param {FlowSessionCreateManyArgs} args - Arguments to create many FlowSessions.
     * @example
     * // Create many FlowSessions
     * const flowSession = await prisma.flowSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowSessionCreateManyArgs>(args?: SelectSubset<T, FlowSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlowSessions and returns the data saved in the database.
     * @param {FlowSessionCreateManyAndReturnArgs} args - Arguments to create many FlowSessions.
     * @example
     * // Create many FlowSessions
     * const flowSession = await prisma.flowSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlowSessions and only return the `id`
     * const flowSessionWithIdOnly = await prisma.flowSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlowSession.
     * @param {FlowSessionDeleteArgs} args - Arguments to delete one FlowSession.
     * @example
     * // Delete one FlowSession
     * const FlowSession = await prisma.flowSession.delete({
     *   where: {
     *     // ... filter to delete one FlowSession
     *   }
     * })
     * 
     */
    delete<T extends FlowSessionDeleteArgs>(args: SelectSubset<T, FlowSessionDeleteArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlowSession.
     * @param {FlowSessionUpdateArgs} args - Arguments to update one FlowSession.
     * @example
     * // Update one FlowSession
     * const flowSession = await prisma.flowSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowSessionUpdateArgs>(args: SelectSubset<T, FlowSessionUpdateArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlowSessions.
     * @param {FlowSessionDeleteManyArgs} args - Arguments to filter FlowSessions to delete.
     * @example
     * // Delete a few FlowSessions
     * const { count } = await prisma.flowSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowSessionDeleteManyArgs>(args?: SelectSubset<T, FlowSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowSessions
     * const flowSession = await prisma.flowSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowSessionUpdateManyArgs>(args: SelectSubset<T, FlowSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowSessions and returns the data updated in the database.
     * @param {FlowSessionUpdateManyAndReturnArgs} args - Arguments to update many FlowSessions.
     * @example
     * // Update many FlowSessions
     * const flowSession = await prisma.flowSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlowSessions and only return the `id`
     * const flowSessionWithIdOnly = await prisma.flowSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlowSession.
     * @param {FlowSessionUpsertArgs} args - Arguments to update or create a FlowSession.
     * @example
     * // Update or create a FlowSession
     * const flowSession = await prisma.flowSession.upsert({
     *   create: {
     *     // ... data to create a FlowSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowSession we want to update
     *   }
     * })
     */
    upsert<T extends FlowSessionUpsertArgs>(args: SelectSubset<T, FlowSessionUpsertArgs<ExtArgs>>): Prisma__FlowSessionClient<$Result.GetResult<Prisma.$FlowSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlowSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionCountArgs} args - Arguments to filter FlowSessions to count.
     * @example
     * // Count the number of FlowSessions
     * const count = await prisma.flowSession.count({
     *   where: {
     *     // ... the filter for the FlowSessions we want to count
     *   }
     * })
    **/
    count<T extends FlowSessionCountArgs>(
      args?: Subset<T, FlowSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowSessionAggregateArgs>(args: Subset<T, FlowSessionAggregateArgs>): Prisma.PrismaPromise<GetFlowSessionAggregateType<T>>

    /**
     * Group by FlowSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowSessionGroupByArgs['orderBy'] }
        : { orderBy?: FlowSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowSession model
   */
  readonly fields: FlowSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowSession model
   */
  interface FlowSessionFieldRefs {
    readonly id: FieldRef<"FlowSession", 'String'>
    readonly flowId: FieldRef<"FlowSession", 'String'>
    readonly userId: FieldRef<"FlowSession", 'String'>
    readonly anonymousName: FieldRef<"FlowSession", 'String'>
    readonly sessionToken: FieldRef<"FlowSession", 'String'>
    readonly socketId: FieldRef<"FlowSession", 'String'>
    readonly cursorPosition: FieldRef<"FlowSession", 'Json'>
    readonly selectedPodIds: FieldRef<"FlowSession", 'Json'>
    readonly viewportState: FieldRef<"FlowSession", 'Json'>
    readonly userColor: FieldRef<"FlowSession", 'String'>
    readonly userAgent: FieldRef<"FlowSession", 'String'>
    readonly ipAddress: FieldRef<"FlowSession", 'String'>
    readonly connectedAt: FieldRef<"FlowSession", 'DateTime'>
    readonly lastHeartbeatAt: FieldRef<"FlowSession", 'DateTime'>
    readonly disconnectedAt: FieldRef<"FlowSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlowSession findUnique
   */
  export type FlowSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * Filter, which FlowSession to fetch.
     */
    where: FlowSessionWhereUniqueInput
  }

  /**
   * FlowSession findUniqueOrThrow
   */
  export type FlowSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * Filter, which FlowSession to fetch.
     */
    where: FlowSessionWhereUniqueInput
  }

  /**
   * FlowSession findFirst
   */
  export type FlowSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * Filter, which FlowSession to fetch.
     */
    where?: FlowSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowSessions to fetch.
     */
    orderBy?: FlowSessionOrderByWithRelationInput | FlowSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowSessions.
     */
    cursor?: FlowSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowSessions.
     */
    distinct?: FlowSessionScalarFieldEnum | FlowSessionScalarFieldEnum[]
  }

  /**
   * FlowSession findFirstOrThrow
   */
  export type FlowSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * Filter, which FlowSession to fetch.
     */
    where?: FlowSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowSessions to fetch.
     */
    orderBy?: FlowSessionOrderByWithRelationInput | FlowSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowSessions.
     */
    cursor?: FlowSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowSessions.
     */
    distinct?: FlowSessionScalarFieldEnum | FlowSessionScalarFieldEnum[]
  }

  /**
   * FlowSession findMany
   */
  export type FlowSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * Filter, which FlowSessions to fetch.
     */
    where?: FlowSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowSessions to fetch.
     */
    orderBy?: FlowSessionOrderByWithRelationInput | FlowSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowSessions.
     */
    cursor?: FlowSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowSessions.
     */
    skip?: number
    distinct?: FlowSessionScalarFieldEnum | FlowSessionScalarFieldEnum[]
  }

  /**
   * FlowSession create
   */
  export type FlowSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowSession.
     */
    data: XOR<FlowSessionCreateInput, FlowSessionUncheckedCreateInput>
  }

  /**
   * FlowSession createMany
   */
  export type FlowSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowSessions.
     */
    data: FlowSessionCreateManyInput | FlowSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlowSession createManyAndReturn
   */
  export type FlowSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * The data used to create many FlowSessions.
     */
    data: FlowSessionCreateManyInput | FlowSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowSession update
   */
  export type FlowSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowSession.
     */
    data: XOR<FlowSessionUpdateInput, FlowSessionUncheckedUpdateInput>
    /**
     * Choose, which FlowSession to update.
     */
    where: FlowSessionWhereUniqueInput
  }

  /**
   * FlowSession updateMany
   */
  export type FlowSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowSessions.
     */
    data: XOR<FlowSessionUpdateManyMutationInput, FlowSessionUncheckedUpdateManyInput>
    /**
     * Filter which FlowSessions to update
     */
    where?: FlowSessionWhereInput
    /**
     * Limit how many FlowSessions to update.
     */
    limit?: number
  }

  /**
   * FlowSession updateManyAndReturn
   */
  export type FlowSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * The data used to update FlowSessions.
     */
    data: XOR<FlowSessionUpdateManyMutationInput, FlowSessionUncheckedUpdateManyInput>
    /**
     * Filter which FlowSessions to update
     */
    where?: FlowSessionWhereInput
    /**
     * Limit how many FlowSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowSession upsert
   */
  export type FlowSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowSession to update in case it exists.
     */
    where: FlowSessionWhereUniqueInput
    /**
     * In case the FlowSession found by the `where` argument doesn't exist, create a new FlowSession with this data.
     */
    create: XOR<FlowSessionCreateInput, FlowSessionUncheckedCreateInput>
    /**
     * In case the FlowSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowSessionUpdateInput, FlowSessionUncheckedUpdateInput>
  }

  /**
   * FlowSession delete
   */
  export type FlowSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
    /**
     * Filter which FlowSession to delete.
     */
    where: FlowSessionWhereUniqueInput
  }

  /**
   * FlowSession deleteMany
   */
  export type FlowSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowSessions to delete
     */
    where?: FlowSessionWhereInput
    /**
     * Limit how many FlowSessions to delete.
     */
    limit?: number
  }

  /**
   * FlowSession without action
   */
  export type FlowSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowSession
     */
    select?: FlowSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowSession
     */
    omit?: FlowSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowSessionInclude<ExtArgs> | null
  }


  /**
   * Model FlowActivityLog
   */

  export type AggregateFlowActivityLog = {
    _count: FlowActivityLogCountAggregateOutputType | null
    _min: FlowActivityLogMinAggregateOutputType | null
    _max: FlowActivityLogMaxAggregateOutputType | null
  }

  export type FlowActivityLogMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    action: $Enums.FlowActivityAction | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type FlowActivityLogMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    action: $Enums.FlowActivityAction | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type FlowActivityLogCountAggregateOutputType = {
    id: number
    flowId: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changeData: number
    createdAt: number
    _all: number
  }


  export type FlowActivityLogMinAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type FlowActivityLogMaxAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type FlowActivityLogCountAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changeData?: true
    createdAt?: true
    _all?: true
  }

  export type FlowActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowActivityLog to aggregate.
     */
    where?: FlowActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowActivityLogs to fetch.
     */
    orderBy?: FlowActivityLogOrderByWithRelationInput | FlowActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowActivityLogs
    **/
    _count?: true | FlowActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowActivityLogMaxAggregateInputType
  }

  export type GetFlowActivityLogAggregateType<T extends FlowActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowActivityLog[P]>
      : GetScalarType<T[P], AggregateFlowActivityLog[P]>
  }




  export type FlowActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowActivityLogWhereInput
    orderBy?: FlowActivityLogOrderByWithAggregationInput | FlowActivityLogOrderByWithAggregationInput[]
    by: FlowActivityLogScalarFieldEnum[] | FlowActivityLogScalarFieldEnum
    having?: FlowActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowActivityLogCountAggregateInputType | true
    _min?: FlowActivityLogMinAggregateInputType
    _max?: FlowActivityLogMaxAggregateInputType
  }

  export type FlowActivityLogGroupByOutputType = {
    id: string
    flowId: string
    userId: string | null
    action: $Enums.FlowActivityAction
    entityType: string | null
    entityId: string | null
    changeData: JsonValue | null
    createdAt: Date
    _count: FlowActivityLogCountAggregateOutputType | null
    _min: FlowActivityLogMinAggregateOutputType | null
    _max: FlowActivityLogMaxAggregateOutputType | null
  }

  type GetFlowActivityLogGroupByPayload<T extends FlowActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], FlowActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type FlowActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowActivityLog"]>

  export type FlowActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowActivityLog"]>

  export type FlowActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowActivityLog"]>

  export type FlowActivityLogSelectScalar = {
    id?: boolean
    flowId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
  }

  export type FlowActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "userId" | "action" | "entityType" | "entityId" | "changeData" | "createdAt", ExtArgs["result"]["flowActivityLog"]>
  export type FlowActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type FlowActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type FlowActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }

  export type $FlowActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowActivityLog"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      userId: string | null
      action: $Enums.FlowActivityAction
      entityType: string | null
      entityId: string | null
      changeData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["flowActivityLog"]>
    composites: {}
  }

  type FlowActivityLogGetPayload<S extends boolean | null | undefined | FlowActivityLogDefaultArgs> = $Result.GetResult<Prisma.$FlowActivityLogPayload, S>

  type FlowActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowActivityLogCountAggregateInputType | true
    }

  export interface FlowActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowActivityLog'], meta: { name: 'FlowActivityLog' } }
    /**
     * Find zero or one FlowActivityLog that matches the filter.
     * @param {FlowActivityLogFindUniqueArgs} args - Arguments to find a FlowActivityLog
     * @example
     * // Get one FlowActivityLog
     * const flowActivityLog = await prisma.flowActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowActivityLogFindUniqueArgs>(args: SelectSubset<T, FlowActivityLogFindUniqueArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlowActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowActivityLogFindUniqueOrThrowArgs} args - Arguments to find a FlowActivityLog
     * @example
     * // Get one FlowActivityLog
     * const flowActivityLog = await prisma.flowActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogFindFirstArgs} args - Arguments to find a FlowActivityLog
     * @example
     * // Get one FlowActivityLog
     * const flowActivityLog = await prisma.flowActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowActivityLogFindFirstArgs>(args?: SelectSubset<T, FlowActivityLogFindFirstArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogFindFirstOrThrowArgs} args - Arguments to find a FlowActivityLog
     * @example
     * // Get one FlowActivityLog
     * const flowActivityLog = await prisma.flowActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlowActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowActivityLogs
     * const flowActivityLogs = await prisma.flowActivityLog.findMany()
     * 
     * // Get first 10 FlowActivityLogs
     * const flowActivityLogs = await prisma.flowActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowActivityLogWithIdOnly = await prisma.flowActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowActivityLogFindManyArgs>(args?: SelectSubset<T, FlowActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlowActivityLog.
     * @param {FlowActivityLogCreateArgs} args - Arguments to create a FlowActivityLog.
     * @example
     * // Create one FlowActivityLog
     * const FlowActivityLog = await prisma.flowActivityLog.create({
     *   data: {
     *     // ... data to create a FlowActivityLog
     *   }
     * })
     * 
     */
    create<T extends FlowActivityLogCreateArgs>(args: SelectSubset<T, FlowActivityLogCreateArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlowActivityLogs.
     * @param {FlowActivityLogCreateManyArgs} args - Arguments to create many FlowActivityLogs.
     * @example
     * // Create many FlowActivityLogs
     * const flowActivityLog = await prisma.flowActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowActivityLogCreateManyArgs>(args?: SelectSubset<T, FlowActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlowActivityLogs and returns the data saved in the database.
     * @param {FlowActivityLogCreateManyAndReturnArgs} args - Arguments to create many FlowActivityLogs.
     * @example
     * // Create many FlowActivityLogs
     * const flowActivityLog = await prisma.flowActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlowActivityLogs and only return the `id`
     * const flowActivityLogWithIdOnly = await prisma.flowActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlowActivityLog.
     * @param {FlowActivityLogDeleteArgs} args - Arguments to delete one FlowActivityLog.
     * @example
     * // Delete one FlowActivityLog
     * const FlowActivityLog = await prisma.flowActivityLog.delete({
     *   where: {
     *     // ... filter to delete one FlowActivityLog
     *   }
     * })
     * 
     */
    delete<T extends FlowActivityLogDeleteArgs>(args: SelectSubset<T, FlowActivityLogDeleteArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlowActivityLog.
     * @param {FlowActivityLogUpdateArgs} args - Arguments to update one FlowActivityLog.
     * @example
     * // Update one FlowActivityLog
     * const flowActivityLog = await prisma.flowActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowActivityLogUpdateArgs>(args: SelectSubset<T, FlowActivityLogUpdateArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlowActivityLogs.
     * @param {FlowActivityLogDeleteManyArgs} args - Arguments to filter FlowActivityLogs to delete.
     * @example
     * // Delete a few FlowActivityLogs
     * const { count } = await prisma.flowActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowActivityLogDeleteManyArgs>(args?: SelectSubset<T, FlowActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowActivityLogs
     * const flowActivityLog = await prisma.flowActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowActivityLogUpdateManyArgs>(args: SelectSubset<T, FlowActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowActivityLogs and returns the data updated in the database.
     * @param {FlowActivityLogUpdateManyAndReturnArgs} args - Arguments to update many FlowActivityLogs.
     * @example
     * // Update many FlowActivityLogs
     * const flowActivityLog = await prisma.flowActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlowActivityLogs and only return the `id`
     * const flowActivityLogWithIdOnly = await prisma.flowActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlowActivityLog.
     * @param {FlowActivityLogUpsertArgs} args - Arguments to update or create a FlowActivityLog.
     * @example
     * // Update or create a FlowActivityLog
     * const flowActivityLog = await prisma.flowActivityLog.upsert({
     *   create: {
     *     // ... data to create a FlowActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends FlowActivityLogUpsertArgs>(args: SelectSubset<T, FlowActivityLogUpsertArgs<ExtArgs>>): Prisma__FlowActivityLogClient<$Result.GetResult<Prisma.$FlowActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlowActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogCountArgs} args - Arguments to filter FlowActivityLogs to count.
     * @example
     * // Count the number of FlowActivityLogs
     * const count = await prisma.flowActivityLog.count({
     *   where: {
     *     // ... the filter for the FlowActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends FlowActivityLogCountArgs>(
      args?: Subset<T, FlowActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowActivityLogAggregateArgs>(args: Subset<T, FlowActivityLogAggregateArgs>): Prisma.PrismaPromise<GetFlowActivityLogAggregateType<T>>

    /**
     * Group by FlowActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: FlowActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowActivityLog model
   */
  readonly fields: FlowActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowActivityLog model
   */
  interface FlowActivityLogFieldRefs {
    readonly id: FieldRef<"FlowActivityLog", 'String'>
    readonly flowId: FieldRef<"FlowActivityLog", 'String'>
    readonly userId: FieldRef<"FlowActivityLog", 'String'>
    readonly action: FieldRef<"FlowActivityLog", 'FlowActivityAction'>
    readonly entityType: FieldRef<"FlowActivityLog", 'String'>
    readonly entityId: FieldRef<"FlowActivityLog", 'String'>
    readonly changeData: FieldRef<"FlowActivityLog", 'Json'>
    readonly createdAt: FieldRef<"FlowActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlowActivityLog findUnique
   */
  export type FlowActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which FlowActivityLog to fetch.
     */
    where: FlowActivityLogWhereUniqueInput
  }

  /**
   * FlowActivityLog findUniqueOrThrow
   */
  export type FlowActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which FlowActivityLog to fetch.
     */
    where: FlowActivityLogWhereUniqueInput
  }

  /**
   * FlowActivityLog findFirst
   */
  export type FlowActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which FlowActivityLog to fetch.
     */
    where?: FlowActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowActivityLogs to fetch.
     */
    orderBy?: FlowActivityLogOrderByWithRelationInput | FlowActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowActivityLogs.
     */
    cursor?: FlowActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowActivityLogs.
     */
    distinct?: FlowActivityLogScalarFieldEnum | FlowActivityLogScalarFieldEnum[]
  }

  /**
   * FlowActivityLog findFirstOrThrow
   */
  export type FlowActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which FlowActivityLog to fetch.
     */
    where?: FlowActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowActivityLogs to fetch.
     */
    orderBy?: FlowActivityLogOrderByWithRelationInput | FlowActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowActivityLogs.
     */
    cursor?: FlowActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowActivityLogs.
     */
    distinct?: FlowActivityLogScalarFieldEnum | FlowActivityLogScalarFieldEnum[]
  }

  /**
   * FlowActivityLog findMany
   */
  export type FlowActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which FlowActivityLogs to fetch.
     */
    where?: FlowActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowActivityLogs to fetch.
     */
    orderBy?: FlowActivityLogOrderByWithRelationInput | FlowActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowActivityLogs.
     */
    cursor?: FlowActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowActivityLogs.
     */
    skip?: number
    distinct?: FlowActivityLogScalarFieldEnum | FlowActivityLogScalarFieldEnum[]
  }

  /**
   * FlowActivityLog create
   */
  export type FlowActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowActivityLog.
     */
    data: XOR<FlowActivityLogCreateInput, FlowActivityLogUncheckedCreateInput>
  }

  /**
   * FlowActivityLog createMany
   */
  export type FlowActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowActivityLogs.
     */
    data: FlowActivityLogCreateManyInput | FlowActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlowActivityLog createManyAndReturn
   */
  export type FlowActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many FlowActivityLogs.
     */
    data: FlowActivityLogCreateManyInput | FlowActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowActivityLog update
   */
  export type FlowActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowActivityLog.
     */
    data: XOR<FlowActivityLogUpdateInput, FlowActivityLogUncheckedUpdateInput>
    /**
     * Choose, which FlowActivityLog to update.
     */
    where: FlowActivityLogWhereUniqueInput
  }

  /**
   * FlowActivityLog updateMany
   */
  export type FlowActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowActivityLogs.
     */
    data: XOR<FlowActivityLogUpdateManyMutationInput, FlowActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which FlowActivityLogs to update
     */
    where?: FlowActivityLogWhereInput
    /**
     * Limit how many FlowActivityLogs to update.
     */
    limit?: number
  }

  /**
   * FlowActivityLog updateManyAndReturn
   */
  export type FlowActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update FlowActivityLogs.
     */
    data: XOR<FlowActivityLogUpdateManyMutationInput, FlowActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which FlowActivityLogs to update
     */
    where?: FlowActivityLogWhereInput
    /**
     * Limit how many FlowActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowActivityLog upsert
   */
  export type FlowActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowActivityLog to update in case it exists.
     */
    where: FlowActivityLogWhereUniqueInput
    /**
     * In case the FlowActivityLog found by the `where` argument doesn't exist, create a new FlowActivityLog with this data.
     */
    create: XOR<FlowActivityLogCreateInput, FlowActivityLogUncheckedCreateInput>
    /**
     * In case the FlowActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowActivityLogUpdateInput, FlowActivityLogUncheckedUpdateInput>
  }

  /**
   * FlowActivityLog delete
   */
  export type FlowActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
    /**
     * Filter which FlowActivityLog to delete.
     */
    where: FlowActivityLogWhereUniqueInput
  }

  /**
   * FlowActivityLog deleteMany
   */
  export type FlowActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowActivityLogs to delete
     */
    where?: FlowActivityLogWhereInput
    /**
     * Limit how many FlowActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * FlowActivityLog without action
   */
  export type FlowActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowActivityLog
     */
    select?: FlowActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowActivityLog
     */
    omit?: FlowActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model FlowComment
   */

  export type AggregateFlowComment = {
    _count: FlowCommentCountAggregateOutputType | null
    _min: FlowCommentMinAggregateOutputType | null
    _max: FlowCommentMaxAggregateOutputType | null
  }

  export type FlowCommentMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    content: string | null
    podId: string | null
    parentId: string | null
    isResolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlowCommentMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    userId: string | null
    content: string | null
    podId: string | null
    parentId: string | null
    isResolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlowCommentCountAggregateOutputType = {
    id: number
    flowId: number
    userId: number
    content: number
    position: number
    podId: number
    parentId: number
    isResolved: number
    resolvedBy: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlowCommentMinAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    content?: true
    podId?: true
    parentId?: true
    isResolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlowCommentMaxAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    content?: true
    podId?: true
    parentId?: true
    isResolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlowCommentCountAggregateInputType = {
    id?: true
    flowId?: true
    userId?: true
    content?: true
    position?: true
    podId?: true
    parentId?: true
    isResolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlowCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowComment to aggregate.
     */
    where?: FlowCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowComments to fetch.
     */
    orderBy?: FlowCommentOrderByWithRelationInput | FlowCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowComments
    **/
    _count?: true | FlowCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowCommentMaxAggregateInputType
  }

  export type GetFlowCommentAggregateType<T extends FlowCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowComment[P]>
      : GetScalarType<T[P], AggregateFlowComment[P]>
  }




  export type FlowCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowCommentWhereInput
    orderBy?: FlowCommentOrderByWithAggregationInput | FlowCommentOrderByWithAggregationInput[]
    by: FlowCommentScalarFieldEnum[] | FlowCommentScalarFieldEnum
    having?: FlowCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowCommentCountAggregateInputType | true
    _min?: FlowCommentMinAggregateInputType
    _max?: FlowCommentMaxAggregateInputType
  }

  export type FlowCommentGroupByOutputType = {
    id: string
    flowId: string
    userId: string | null
    content: string
    position: JsonValue | null
    podId: string | null
    parentId: string | null
    isResolved: boolean
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FlowCommentCountAggregateOutputType | null
    _min: FlowCommentMinAggregateOutputType | null
    _max: FlowCommentMaxAggregateOutputType | null
  }

  type GetFlowCommentGroupByPayload<T extends FlowCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowCommentGroupByOutputType[P]>
            : GetScalarType<T[P], FlowCommentGroupByOutputType[P]>
        }
      >
    >


  export type FlowCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowComment"]>

  export type FlowCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowComment"]>

  export type FlowCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowComment"]>

  export type FlowCommentSelectScalar = {
    id?: boolean
    flowId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlowCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "userId" | "content" | "position" | "podId" | "parentId" | "isResolved" | "resolvedBy" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["flowComment"]>
  export type FlowCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type FlowCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type FlowCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }

  export type $FlowCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowComment"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      userId: string | null
      content: string
      position: Prisma.JsonValue | null
      podId: string | null
      parentId: string | null
      isResolved: boolean
      resolvedBy: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flowComment"]>
    composites: {}
  }

  type FlowCommentGetPayload<S extends boolean | null | undefined | FlowCommentDefaultArgs> = $Result.GetResult<Prisma.$FlowCommentPayload, S>

  type FlowCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowCommentCountAggregateInputType | true
    }

  export interface FlowCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowComment'], meta: { name: 'FlowComment' } }
    /**
     * Find zero or one FlowComment that matches the filter.
     * @param {FlowCommentFindUniqueArgs} args - Arguments to find a FlowComment
     * @example
     * // Get one FlowComment
     * const flowComment = await prisma.flowComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowCommentFindUniqueArgs>(args: SelectSubset<T, FlowCommentFindUniqueArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlowComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowCommentFindUniqueOrThrowArgs} args - Arguments to find a FlowComment
     * @example
     * // Get one FlowComment
     * const flowComment = await prisma.flowComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentFindFirstArgs} args - Arguments to find a FlowComment
     * @example
     * // Get one FlowComment
     * const flowComment = await prisma.flowComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowCommentFindFirstArgs>(args?: SelectSubset<T, FlowCommentFindFirstArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlowComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentFindFirstOrThrowArgs} args - Arguments to find a FlowComment
     * @example
     * // Get one FlowComment
     * const flowComment = await prisma.flowComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlowComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowComments
     * const flowComments = await prisma.flowComment.findMany()
     * 
     * // Get first 10 FlowComments
     * const flowComments = await prisma.flowComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowCommentWithIdOnly = await prisma.flowComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowCommentFindManyArgs>(args?: SelectSubset<T, FlowCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlowComment.
     * @param {FlowCommentCreateArgs} args - Arguments to create a FlowComment.
     * @example
     * // Create one FlowComment
     * const FlowComment = await prisma.flowComment.create({
     *   data: {
     *     // ... data to create a FlowComment
     *   }
     * })
     * 
     */
    create<T extends FlowCommentCreateArgs>(args: SelectSubset<T, FlowCommentCreateArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlowComments.
     * @param {FlowCommentCreateManyArgs} args - Arguments to create many FlowComments.
     * @example
     * // Create many FlowComments
     * const flowComment = await prisma.flowComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowCommentCreateManyArgs>(args?: SelectSubset<T, FlowCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlowComments and returns the data saved in the database.
     * @param {FlowCommentCreateManyAndReturnArgs} args - Arguments to create many FlowComments.
     * @example
     * // Create many FlowComments
     * const flowComment = await prisma.flowComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlowComments and only return the `id`
     * const flowCommentWithIdOnly = await prisma.flowComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlowComment.
     * @param {FlowCommentDeleteArgs} args - Arguments to delete one FlowComment.
     * @example
     * // Delete one FlowComment
     * const FlowComment = await prisma.flowComment.delete({
     *   where: {
     *     // ... filter to delete one FlowComment
     *   }
     * })
     * 
     */
    delete<T extends FlowCommentDeleteArgs>(args: SelectSubset<T, FlowCommentDeleteArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlowComment.
     * @param {FlowCommentUpdateArgs} args - Arguments to update one FlowComment.
     * @example
     * // Update one FlowComment
     * const flowComment = await prisma.flowComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowCommentUpdateArgs>(args: SelectSubset<T, FlowCommentUpdateArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlowComments.
     * @param {FlowCommentDeleteManyArgs} args - Arguments to filter FlowComments to delete.
     * @example
     * // Delete a few FlowComments
     * const { count } = await prisma.flowComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowCommentDeleteManyArgs>(args?: SelectSubset<T, FlowCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowComments
     * const flowComment = await prisma.flowComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowCommentUpdateManyArgs>(args: SelectSubset<T, FlowCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowComments and returns the data updated in the database.
     * @param {FlowCommentUpdateManyAndReturnArgs} args - Arguments to update many FlowComments.
     * @example
     * // Update many FlowComments
     * const flowComment = await prisma.flowComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlowComments and only return the `id`
     * const flowCommentWithIdOnly = await prisma.flowComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlowComment.
     * @param {FlowCommentUpsertArgs} args - Arguments to update or create a FlowComment.
     * @example
     * // Update or create a FlowComment
     * const flowComment = await prisma.flowComment.upsert({
     *   create: {
     *     // ... data to create a FlowComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowComment we want to update
     *   }
     * })
     */
    upsert<T extends FlowCommentUpsertArgs>(args: SelectSubset<T, FlowCommentUpsertArgs<ExtArgs>>): Prisma__FlowCommentClient<$Result.GetResult<Prisma.$FlowCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlowComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentCountArgs} args - Arguments to filter FlowComments to count.
     * @example
     * // Count the number of FlowComments
     * const count = await prisma.flowComment.count({
     *   where: {
     *     // ... the filter for the FlowComments we want to count
     *   }
     * })
    **/
    count<T extends FlowCommentCountArgs>(
      args?: Subset<T, FlowCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowCommentAggregateArgs>(args: Subset<T, FlowCommentAggregateArgs>): Prisma.PrismaPromise<GetFlowCommentAggregateType<T>>

    /**
     * Group by FlowComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowCommentGroupByArgs['orderBy'] }
        : { orderBy?: FlowCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowComment model
   */
  readonly fields: FlowCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowComment model
   */
  interface FlowCommentFieldRefs {
    readonly id: FieldRef<"FlowComment", 'String'>
    readonly flowId: FieldRef<"FlowComment", 'String'>
    readonly userId: FieldRef<"FlowComment", 'String'>
    readonly content: FieldRef<"FlowComment", 'String'>
    readonly position: FieldRef<"FlowComment", 'Json'>
    readonly podId: FieldRef<"FlowComment", 'String'>
    readonly parentId: FieldRef<"FlowComment", 'String'>
    readonly isResolved: FieldRef<"FlowComment", 'Boolean'>
    readonly resolvedBy: FieldRef<"FlowComment", 'String'>
    readonly resolvedAt: FieldRef<"FlowComment", 'DateTime'>
    readonly createdAt: FieldRef<"FlowComment", 'DateTime'>
    readonly updatedAt: FieldRef<"FlowComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlowComment findUnique
   */
  export type FlowCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * Filter, which FlowComment to fetch.
     */
    where: FlowCommentWhereUniqueInput
  }

  /**
   * FlowComment findUniqueOrThrow
   */
  export type FlowCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * Filter, which FlowComment to fetch.
     */
    where: FlowCommentWhereUniqueInput
  }

  /**
   * FlowComment findFirst
   */
  export type FlowCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * Filter, which FlowComment to fetch.
     */
    where?: FlowCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowComments to fetch.
     */
    orderBy?: FlowCommentOrderByWithRelationInput | FlowCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowComments.
     */
    cursor?: FlowCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowComments.
     */
    distinct?: FlowCommentScalarFieldEnum | FlowCommentScalarFieldEnum[]
  }

  /**
   * FlowComment findFirstOrThrow
   */
  export type FlowCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * Filter, which FlowComment to fetch.
     */
    where?: FlowCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowComments to fetch.
     */
    orderBy?: FlowCommentOrderByWithRelationInput | FlowCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowComments.
     */
    cursor?: FlowCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowComments.
     */
    distinct?: FlowCommentScalarFieldEnum | FlowCommentScalarFieldEnum[]
  }

  /**
   * FlowComment findMany
   */
  export type FlowCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * Filter, which FlowComments to fetch.
     */
    where?: FlowCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowComments to fetch.
     */
    orderBy?: FlowCommentOrderByWithRelationInput | FlowCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowComments.
     */
    cursor?: FlowCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowComments.
     */
    skip?: number
    distinct?: FlowCommentScalarFieldEnum | FlowCommentScalarFieldEnum[]
  }

  /**
   * FlowComment create
   */
  export type FlowCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowComment.
     */
    data: XOR<FlowCommentCreateInput, FlowCommentUncheckedCreateInput>
  }

  /**
   * FlowComment createMany
   */
  export type FlowCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowComments.
     */
    data: FlowCommentCreateManyInput | FlowCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlowComment createManyAndReturn
   */
  export type FlowCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * The data used to create many FlowComments.
     */
    data: FlowCommentCreateManyInput | FlowCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowComment update
   */
  export type FlowCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowComment.
     */
    data: XOR<FlowCommentUpdateInput, FlowCommentUncheckedUpdateInput>
    /**
     * Choose, which FlowComment to update.
     */
    where: FlowCommentWhereUniqueInput
  }

  /**
   * FlowComment updateMany
   */
  export type FlowCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowComments.
     */
    data: XOR<FlowCommentUpdateManyMutationInput, FlowCommentUncheckedUpdateManyInput>
    /**
     * Filter which FlowComments to update
     */
    where?: FlowCommentWhereInput
    /**
     * Limit how many FlowComments to update.
     */
    limit?: number
  }

  /**
   * FlowComment updateManyAndReturn
   */
  export type FlowCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * The data used to update FlowComments.
     */
    data: XOR<FlowCommentUpdateManyMutationInput, FlowCommentUncheckedUpdateManyInput>
    /**
     * Filter which FlowComments to update
     */
    where?: FlowCommentWhereInput
    /**
     * Limit how many FlowComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlowComment upsert
   */
  export type FlowCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowComment to update in case it exists.
     */
    where: FlowCommentWhereUniqueInput
    /**
     * In case the FlowComment found by the `where` argument doesn't exist, create a new FlowComment with this data.
     */
    create: XOR<FlowCommentCreateInput, FlowCommentUncheckedCreateInput>
    /**
     * In case the FlowComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowCommentUpdateInput, FlowCommentUncheckedUpdateInput>
  }

  /**
   * FlowComment delete
   */
  export type FlowCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
    /**
     * Filter which FlowComment to delete.
     */
    where: FlowCommentWhereUniqueInput
  }

  /**
   * FlowComment deleteMany
   */
  export type FlowCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowComments to delete
     */
    where?: FlowCommentWhereInput
    /**
     * Limit how many FlowComments to delete.
     */
    limit?: number
  }

  /**
   * FlowComment without action
   */
  export type FlowCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowComment
     */
    select?: FlowCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowComment
     */
    omit?: FlowCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCommentInclude<ExtArgs> | null
  }


  /**
   * Model Pod
   */

  export type AggregatePod = {
    _count: PodCountAggregateOutputType | null
    _min: PodMinAggregateOutputType | null
    _max: PodMaxAggregateOutputType | null
  }

  export type PodMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    type: $Enums.PodType | null
    executionStatus: $Enums.PodExecutionStatus | null
    lastExecutionId: string | null
    contextFlowId: string | null
    documentId: string | null
    lockedBy: string | null
    lockedAt: Date | null
    dynamoPartitionKey: string | null
    dynamoSortKey: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PodMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    type: $Enums.PodType | null
    executionStatus: $Enums.PodExecutionStatus | null
    lastExecutionId: string | null
    contextFlowId: string | null
    documentId: string | null
    lockedBy: string | null
    lockedAt: Date | null
    dynamoPartitionKey: string | null
    dynamoSortKey: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PodCountAggregateOutputType = {
    id: number
    flowId: number
    type: number
    position: number
    executionStatus: number
    lastExecutionId: number
    contextFlowId: number
    documentId: number
    lockedBy: number
    lockedAt: number
    dynamoPartitionKey: number
    dynamoSortKey: number
    s3VectorBucket: number
    s3VectorKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PodMinAggregateInputType = {
    id?: true
    flowId?: true
    type?: true
    executionStatus?: true
    lastExecutionId?: true
    contextFlowId?: true
    documentId?: true
    lockedBy?: true
    lockedAt?: true
    dynamoPartitionKey?: true
    dynamoSortKey?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PodMaxAggregateInputType = {
    id?: true
    flowId?: true
    type?: true
    executionStatus?: true
    lastExecutionId?: true
    contextFlowId?: true
    documentId?: true
    lockedBy?: true
    lockedAt?: true
    dynamoPartitionKey?: true
    dynamoSortKey?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PodCountAggregateInputType = {
    id?: true
    flowId?: true
    type?: true
    position?: true
    executionStatus?: true
    lastExecutionId?: true
    contextFlowId?: true
    documentId?: true
    lockedBy?: true
    lockedAt?: true
    dynamoPartitionKey?: true
    dynamoSortKey?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pod to aggregate.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pods
    **/
    _count?: true | PodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodMaxAggregateInputType
  }

  export type GetPodAggregateType<T extends PodAggregateArgs> = {
        [P in keyof T & keyof AggregatePod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod[P]>
      : GetScalarType<T[P], AggregatePod[P]>
  }




  export type PodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodWhereInput
    orderBy?: PodOrderByWithAggregationInput | PodOrderByWithAggregationInput[]
    by: PodScalarFieldEnum[] | PodScalarFieldEnum
    having?: PodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodCountAggregateInputType | true
    _min?: PodMinAggregateInputType
    _max?: PodMaxAggregateInputType
  }

  export type PodGroupByOutputType = {
    id: string
    flowId: string
    type: $Enums.PodType
    position: JsonValue
    executionStatus: $Enums.PodExecutionStatus
    lastExecutionId: string | null
    contextFlowId: string | null
    documentId: string | null
    lockedBy: string | null
    lockedAt: Date | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket: string | null
    s3VectorKey: string | null
    createdAt: Date
    updatedAt: Date
    _count: PodCountAggregateOutputType | null
    _min: PodMinAggregateOutputType | null
    _max: PodMaxAggregateOutputType | null
  }

  type GetPodGroupByPayload<T extends PodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodGroupByOutputType[P]>
            : GetScalarType<T[P], PodGroupByOutputType[P]>
        }
      >
    >


  export type PodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextFlowId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    contextFlow?: boolean | Pod$contextFlowArgs<ExtArgs>
    document?: boolean | Pod$documentArgs<ExtArgs>
    sourceEdges?: boolean | Pod$sourceEdgesArgs<ExtArgs>
    targetEdges?: boolean | Pod$targetEdgesArgs<ExtArgs>
    executions?: boolean | Pod$executionsArgs<ExtArgs>
    usageLogs?: boolean | Pod$usageLogsArgs<ExtArgs>
    _count?: boolean | PodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pod"]>

  export type PodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextFlowId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    contextFlow?: boolean | Pod$contextFlowArgs<ExtArgs>
    document?: boolean | Pod$documentArgs<ExtArgs>
  }, ExtArgs["result"]["pod"]>

  export type PodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextFlowId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    contextFlow?: boolean | Pod$contextFlowArgs<ExtArgs>
    document?: boolean | Pod$documentArgs<ExtArgs>
  }, ExtArgs["result"]["pod"]>

  export type PodSelectScalar = {
    id?: boolean
    flowId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextFlowId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "type" | "position" | "executionStatus" | "lastExecutionId" | "contextFlowId" | "documentId" | "lockedBy" | "lockedAt" | "dynamoPartitionKey" | "dynamoSortKey" | "s3VectorBucket" | "s3VectorKey" | "createdAt" | "updatedAt", ExtArgs["result"]["pod"]>
  export type PodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    contextFlow?: boolean | Pod$contextFlowArgs<ExtArgs>
    document?: boolean | Pod$documentArgs<ExtArgs>
    sourceEdges?: boolean | Pod$sourceEdgesArgs<ExtArgs>
    targetEdges?: boolean | Pod$targetEdgesArgs<ExtArgs>
    executions?: boolean | Pod$executionsArgs<ExtArgs>
    usageLogs?: boolean | Pod$usageLogsArgs<ExtArgs>
    _count?: boolean | PodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    contextFlow?: boolean | Pod$contextFlowArgs<ExtArgs>
    document?: boolean | Pod$documentArgs<ExtArgs>
  }
  export type PodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    contextFlow?: boolean | Pod$contextFlowArgs<ExtArgs>
    document?: boolean | Pod$documentArgs<ExtArgs>
  }

  export type $PodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pod"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
      contextFlow: Prisma.$FlowPayload<ExtArgs> | null
      document: Prisma.$DocumentPayload<ExtArgs> | null
      sourceEdges: Prisma.$EdgePayload<ExtArgs>[]
      targetEdges: Prisma.$EdgePayload<ExtArgs>[]
      executions: Prisma.$PodExecutionPayload<ExtArgs>[]
      usageLogs: Prisma.$PodUsageLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      type: $Enums.PodType
      position: Prisma.JsonValue
      executionStatus: $Enums.PodExecutionStatus
      lastExecutionId: string | null
      contextFlowId: string | null
      documentId: string | null
      lockedBy: string | null
      lockedAt: Date | null
      dynamoPartitionKey: string
      dynamoSortKey: string
      s3VectorBucket: string | null
      s3VectorKey: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pod"]>
    composites: {}
  }

  type PodGetPayload<S extends boolean | null | undefined | PodDefaultArgs> = $Result.GetResult<Prisma.$PodPayload, S>

  type PodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodCountAggregateInputType | true
    }

  export interface PodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pod'], meta: { name: 'Pod' } }
    /**
     * Find zero or one Pod that matches the filter.
     * @param {PodFindUniqueArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodFindUniqueArgs>(args: SelectSubset<T, PodFindUniqueArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodFindUniqueOrThrowArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodFindUniqueOrThrowArgs>(args: SelectSubset<T, PodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodFindFirstArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodFindFirstArgs>(args?: SelectSubset<T, PodFindFirstArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodFindFirstOrThrowArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodFindFirstOrThrowArgs>(args?: SelectSubset<T, PodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pods
     * const pods = await prisma.pod.findMany()
     * 
     * // Get first 10 Pods
     * const pods = await prisma.pod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const podWithIdOnly = await prisma.pod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PodFindManyArgs>(args?: SelectSubset<T, PodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pod.
     * @param {PodCreateArgs} args - Arguments to create a Pod.
     * @example
     * // Create one Pod
     * const Pod = await prisma.pod.create({
     *   data: {
     *     // ... data to create a Pod
     *   }
     * })
     * 
     */
    create<T extends PodCreateArgs>(args: SelectSubset<T, PodCreateArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pods.
     * @param {PodCreateManyArgs} args - Arguments to create many Pods.
     * @example
     * // Create many Pods
     * const pod = await prisma.pod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodCreateManyArgs>(args?: SelectSubset<T, PodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pods and returns the data saved in the database.
     * @param {PodCreateManyAndReturnArgs} args - Arguments to create many Pods.
     * @example
     * // Create many Pods
     * const pod = await prisma.pod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pods and only return the `id`
     * const podWithIdOnly = await prisma.pod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodCreateManyAndReturnArgs>(args?: SelectSubset<T, PodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pod.
     * @param {PodDeleteArgs} args - Arguments to delete one Pod.
     * @example
     * // Delete one Pod
     * const Pod = await prisma.pod.delete({
     *   where: {
     *     // ... filter to delete one Pod
     *   }
     * })
     * 
     */
    delete<T extends PodDeleteArgs>(args: SelectSubset<T, PodDeleteArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pod.
     * @param {PodUpdateArgs} args - Arguments to update one Pod.
     * @example
     * // Update one Pod
     * const pod = await prisma.pod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodUpdateArgs>(args: SelectSubset<T, PodUpdateArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pods.
     * @param {PodDeleteManyArgs} args - Arguments to filter Pods to delete.
     * @example
     * // Delete a few Pods
     * const { count } = await prisma.pod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodDeleteManyArgs>(args?: SelectSubset<T, PodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pods
     * const pod = await prisma.pod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodUpdateManyArgs>(args: SelectSubset<T, PodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pods and returns the data updated in the database.
     * @param {PodUpdateManyAndReturnArgs} args - Arguments to update many Pods.
     * @example
     * // Update many Pods
     * const pod = await prisma.pod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pods and only return the `id`
     * const podWithIdOnly = await prisma.pod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodUpdateManyAndReturnArgs>(args: SelectSubset<T, PodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pod.
     * @param {PodUpsertArgs} args - Arguments to update or create a Pod.
     * @example
     * // Update or create a Pod
     * const pod = await prisma.pod.upsert({
     *   create: {
     *     // ... data to create a Pod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod we want to update
     *   }
     * })
     */
    upsert<T extends PodUpsertArgs>(args: SelectSubset<T, PodUpsertArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodCountArgs} args - Arguments to filter Pods to count.
     * @example
     * // Count the number of Pods
     * const count = await prisma.pod.count({
     *   where: {
     *     // ... the filter for the Pods we want to count
     *   }
     * })
    **/
    count<T extends PodCountArgs>(
      args?: Subset<T, PodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodAggregateArgs>(args: Subset<T, PodAggregateArgs>): Prisma.PrismaPromise<GetPodAggregateType<T>>

    /**
     * Group by Pod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodGroupByArgs['orderBy'] }
        : { orderBy?: PodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pod model
   */
  readonly fields: PodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contextFlow<T extends Pod$contextFlowArgs<ExtArgs> = {}>(args?: Subset<T, Pod$contextFlowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    document<T extends Pod$documentArgs<ExtArgs> = {}>(args?: Subset<T, Pod$documentArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceEdges<T extends Pod$sourceEdgesArgs<ExtArgs> = {}>(args?: Subset<T, Pod$sourceEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetEdges<T extends Pod$targetEdgesArgs<ExtArgs> = {}>(args?: Subset<T, Pod$targetEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executions<T extends Pod$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Pod$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends Pod$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Pod$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pod model
   */
  interface PodFieldRefs {
    readonly id: FieldRef<"Pod", 'String'>
    readonly flowId: FieldRef<"Pod", 'String'>
    readonly type: FieldRef<"Pod", 'PodType'>
    readonly position: FieldRef<"Pod", 'Json'>
    readonly executionStatus: FieldRef<"Pod", 'PodExecutionStatus'>
    readonly lastExecutionId: FieldRef<"Pod", 'String'>
    readonly contextFlowId: FieldRef<"Pod", 'String'>
    readonly documentId: FieldRef<"Pod", 'String'>
    readonly lockedBy: FieldRef<"Pod", 'String'>
    readonly lockedAt: FieldRef<"Pod", 'DateTime'>
    readonly dynamoPartitionKey: FieldRef<"Pod", 'String'>
    readonly dynamoSortKey: FieldRef<"Pod", 'String'>
    readonly s3VectorBucket: FieldRef<"Pod", 'String'>
    readonly s3VectorKey: FieldRef<"Pod", 'String'>
    readonly createdAt: FieldRef<"Pod", 'DateTime'>
    readonly updatedAt: FieldRef<"Pod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pod findUnique
   */
  export type PodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod findUniqueOrThrow
   */
  export type PodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod findFirst
   */
  export type PodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pods.
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pods.
     */
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Pod findFirstOrThrow
   */
  export type PodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pods.
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pods.
     */
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Pod findMany
   */
  export type PodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pods to fetch.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pods.
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Pod create
   */
  export type PodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * The data needed to create a Pod.
     */
    data: XOR<PodCreateInput, PodUncheckedCreateInput>
  }

  /**
   * Pod createMany
   */
  export type PodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pods.
     */
    data: PodCreateManyInput | PodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pod createManyAndReturn
   */
  export type PodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * The data used to create many Pods.
     */
    data: PodCreateManyInput | PodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pod update
   */
  export type PodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * The data needed to update a Pod.
     */
    data: XOR<PodUpdateInput, PodUncheckedUpdateInput>
    /**
     * Choose, which Pod to update.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod updateMany
   */
  export type PodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pods.
     */
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyInput>
    /**
     * Filter which Pods to update
     */
    where?: PodWhereInput
    /**
     * Limit how many Pods to update.
     */
    limit?: number
  }

  /**
   * Pod updateManyAndReturn
   */
  export type PodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * The data used to update Pods.
     */
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyInput>
    /**
     * Filter which Pods to update
     */
    where?: PodWhereInput
    /**
     * Limit how many Pods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pod upsert
   */
  export type PodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * The filter to search for the Pod to update in case it exists.
     */
    where: PodWhereUniqueInput
    /**
     * In case the Pod found by the `where` argument doesn't exist, create a new Pod with this data.
     */
    create: XOR<PodCreateInput, PodUncheckedCreateInput>
    /**
     * In case the Pod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodUpdateInput, PodUncheckedUpdateInput>
  }

  /**
   * Pod delete
   */
  export type PodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter which Pod to delete.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod deleteMany
   */
  export type PodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pods to delete
     */
    where?: PodWhereInput
    /**
     * Limit how many Pods to delete.
     */
    limit?: number
  }

  /**
   * Pod.contextFlow
   */
  export type Pod$contextFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    where?: FlowWhereInput
  }

  /**
   * Pod.document
   */
  export type Pod$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }

  /**
   * Pod.sourceEdges
   */
  export type Pod$sourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    cursor?: EdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Pod.targetEdges
   */
  export type Pod$targetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    cursor?: EdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Pod.executions
   */
  export type Pod$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    where?: PodExecutionWhereInput
    orderBy?: PodExecutionOrderByWithRelationInput | PodExecutionOrderByWithRelationInput[]
    cursor?: PodExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodExecutionScalarFieldEnum | PodExecutionScalarFieldEnum[]
  }

  /**
   * Pod.usageLogs
   */
  export type Pod$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    where?: PodUsageLogWhereInput
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    cursor?: PodUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * Pod without action
   */
  export type PodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
  }


  /**
   * Model Edge
   */

  export type AggregateEdge = {
    _count: EdgeCountAggregateOutputType | null
    _min: EdgeMinAggregateOutputType | null
    _max: EdgeMaxAggregateOutputType | null
  }

  export type EdgeMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    sourcePodId: string | null
    targetPodId: string | null
    sourceHandle: string | null
    targetHandle: string | null
    animated: boolean | null
    createdAt: Date | null
  }

  export type EdgeMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    sourcePodId: string | null
    targetPodId: string | null
    sourceHandle: string | null
    targetHandle: string | null
    animated: boolean | null
    createdAt: Date | null
  }

  export type EdgeCountAggregateOutputType = {
    id: number
    flowId: number
    sourcePodId: number
    targetPodId: number
    sourceHandle: number
    targetHandle: number
    animated: number
    createdAt: number
    _all: number
  }


  export type EdgeMinAggregateInputType = {
    id?: true
    flowId?: true
    sourcePodId?: true
    targetPodId?: true
    sourceHandle?: true
    targetHandle?: true
    animated?: true
    createdAt?: true
  }

  export type EdgeMaxAggregateInputType = {
    id?: true
    flowId?: true
    sourcePodId?: true
    targetPodId?: true
    sourceHandle?: true
    targetHandle?: true
    animated?: true
    createdAt?: true
  }

  export type EdgeCountAggregateInputType = {
    id?: true
    flowId?: true
    sourcePodId?: true
    targetPodId?: true
    sourceHandle?: true
    targetHandle?: true
    animated?: true
    createdAt?: true
    _all?: true
  }

  export type EdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Edge to aggregate.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Edges
    **/
    _count?: true | EdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeMaxAggregateInputType
  }

  export type GetEdgeAggregateType<T extends EdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdge[P]>
      : GetScalarType<T[P], AggregateEdge[P]>
  }




  export type EdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithAggregationInput | EdgeOrderByWithAggregationInput[]
    by: EdgeScalarFieldEnum[] | EdgeScalarFieldEnum
    having?: EdgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeCountAggregateInputType | true
    _min?: EdgeMinAggregateInputType
    _max?: EdgeMaxAggregateInputType
  }

  export type EdgeGroupByOutputType = {
    id: string
    flowId: string
    sourcePodId: string
    targetPodId: string
    sourceHandle: string | null
    targetHandle: string | null
    animated: boolean
    createdAt: Date
    _count: EdgeCountAggregateOutputType | null
    _min: EdgeMinAggregateOutputType | null
    _max: EdgeMaxAggregateOutputType | null
  }

  type GetEdgeGroupByPayload<T extends EdgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeGroupByOutputType[P]>
        }
      >
    >


  export type EdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    sourcePod?: boolean | PodDefaultArgs<ExtArgs>
    targetPod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type EdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    sourcePod?: boolean | PodDefaultArgs<ExtArgs>
    targetPod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type EdgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    sourcePod?: boolean | PodDefaultArgs<ExtArgs>
    targetPod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type EdgeSelectScalar = {
    id?: boolean
    flowId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
  }

  export type EdgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "sourcePodId" | "targetPodId" | "sourceHandle" | "targetHandle" | "animated" | "createdAt", ExtArgs["result"]["edge"]>
  export type EdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    sourcePod?: boolean | PodDefaultArgs<ExtArgs>
    targetPod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type EdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    sourcePod?: boolean | PodDefaultArgs<ExtArgs>
    targetPod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type EdgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    sourcePod?: boolean | PodDefaultArgs<ExtArgs>
    targetPod?: boolean | PodDefaultArgs<ExtArgs>
  }

  export type $EdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Edge"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
      sourcePod: Prisma.$PodPayload<ExtArgs>
      targetPod: Prisma.$PodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      sourcePodId: string
      targetPodId: string
      sourceHandle: string | null
      targetHandle: string | null
      animated: boolean
      createdAt: Date
    }, ExtArgs["result"]["edge"]>
    composites: {}
  }

  type EdgeGetPayload<S extends boolean | null | undefined | EdgeDefaultArgs> = $Result.GetResult<Prisma.$EdgePayload, S>

  type EdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EdgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EdgeCountAggregateInputType | true
    }

  export interface EdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Edge'], meta: { name: 'Edge' } }
    /**
     * Find zero or one Edge that matches the filter.
     * @param {EdgeFindUniqueArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EdgeFindUniqueArgs>(args: SelectSubset<T, EdgeFindUniqueArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Edge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EdgeFindUniqueOrThrowArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EdgeFindUniqueOrThrowArgs>(args: SelectSubset<T, EdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeFindFirstArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EdgeFindFirstArgs>(args?: SelectSubset<T, EdgeFindFirstArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeFindFirstOrThrowArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EdgeFindFirstOrThrowArgs>(args?: SelectSubset<T, EdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Edges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Edges
     * const edges = await prisma.edge.findMany()
     * 
     * // Get first 10 Edges
     * const edges = await prisma.edge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeWithIdOnly = await prisma.edge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EdgeFindManyArgs>(args?: SelectSubset<T, EdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Edge.
     * @param {EdgeCreateArgs} args - Arguments to create a Edge.
     * @example
     * // Create one Edge
     * const Edge = await prisma.edge.create({
     *   data: {
     *     // ... data to create a Edge
     *   }
     * })
     * 
     */
    create<T extends EdgeCreateArgs>(args: SelectSubset<T, EdgeCreateArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Edges.
     * @param {EdgeCreateManyArgs} args - Arguments to create many Edges.
     * @example
     * // Create many Edges
     * const edge = await prisma.edge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EdgeCreateManyArgs>(args?: SelectSubset<T, EdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Edges and returns the data saved in the database.
     * @param {EdgeCreateManyAndReturnArgs} args - Arguments to create many Edges.
     * @example
     * // Create many Edges
     * const edge = await prisma.edge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Edges and only return the `id`
     * const edgeWithIdOnly = await prisma.edge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EdgeCreateManyAndReturnArgs>(args?: SelectSubset<T, EdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Edge.
     * @param {EdgeDeleteArgs} args - Arguments to delete one Edge.
     * @example
     * // Delete one Edge
     * const Edge = await prisma.edge.delete({
     *   where: {
     *     // ... filter to delete one Edge
     *   }
     * })
     * 
     */
    delete<T extends EdgeDeleteArgs>(args: SelectSubset<T, EdgeDeleteArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Edge.
     * @param {EdgeUpdateArgs} args - Arguments to update one Edge.
     * @example
     * // Update one Edge
     * const edge = await prisma.edge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EdgeUpdateArgs>(args: SelectSubset<T, EdgeUpdateArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Edges.
     * @param {EdgeDeleteManyArgs} args - Arguments to filter Edges to delete.
     * @example
     * // Delete a few Edges
     * const { count } = await prisma.edge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EdgeDeleteManyArgs>(args?: SelectSubset<T, EdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Edges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Edges
     * const edge = await prisma.edge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EdgeUpdateManyArgs>(args: SelectSubset<T, EdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Edges and returns the data updated in the database.
     * @param {EdgeUpdateManyAndReturnArgs} args - Arguments to update many Edges.
     * @example
     * // Update many Edges
     * const edge = await prisma.edge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Edges and only return the `id`
     * const edgeWithIdOnly = await prisma.edge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EdgeUpdateManyAndReturnArgs>(args: SelectSubset<T, EdgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Edge.
     * @param {EdgeUpsertArgs} args - Arguments to update or create a Edge.
     * @example
     * // Update or create a Edge
     * const edge = await prisma.edge.upsert({
     *   create: {
     *     // ... data to create a Edge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Edge we want to update
     *   }
     * })
     */
    upsert<T extends EdgeUpsertArgs>(args: SelectSubset<T, EdgeUpsertArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Edges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeCountArgs} args - Arguments to filter Edges to count.
     * @example
     * // Count the number of Edges
     * const count = await prisma.edge.count({
     *   where: {
     *     // ... the filter for the Edges we want to count
     *   }
     * })
    **/
    count<T extends EdgeCountArgs>(
      args?: Subset<T, EdgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Edge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeAggregateArgs>(args: Subset<T, EdgeAggregateArgs>): Prisma.PrismaPromise<GetEdgeAggregateType<T>>

    /**
     * Group by Edge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EdgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EdgeGroupByArgs['orderBy'] }
        : { orderBy?: EdgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Edge model
   */
  readonly fields: EdgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Edge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sourcePod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetPod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Edge model
   */
  interface EdgeFieldRefs {
    readonly id: FieldRef<"Edge", 'String'>
    readonly flowId: FieldRef<"Edge", 'String'>
    readonly sourcePodId: FieldRef<"Edge", 'String'>
    readonly targetPodId: FieldRef<"Edge", 'String'>
    readonly sourceHandle: FieldRef<"Edge", 'String'>
    readonly targetHandle: FieldRef<"Edge", 'String'>
    readonly animated: FieldRef<"Edge", 'Boolean'>
    readonly createdAt: FieldRef<"Edge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Edge findUnique
   */
  export type EdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge findUniqueOrThrow
   */
  export type EdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge findFirst
   */
  export type EdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Edges.
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Edges.
     */
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Edge findFirstOrThrow
   */
  export type EdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Edges.
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Edges.
     */
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Edge findMany
   */
  export type EdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edges to fetch.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Edges.
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Edge create
   */
  export type EdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Edge.
     */
    data: XOR<EdgeCreateInput, EdgeUncheckedCreateInput>
  }

  /**
   * Edge createMany
   */
  export type EdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Edges.
     */
    data: EdgeCreateManyInput | EdgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Edge createManyAndReturn
   */
  export type EdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * The data used to create many Edges.
     */
    data: EdgeCreateManyInput | EdgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Edge update
   */
  export type EdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Edge.
     */
    data: XOR<EdgeUpdateInput, EdgeUncheckedUpdateInput>
    /**
     * Choose, which Edge to update.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge updateMany
   */
  export type EdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Edges.
     */
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyInput>
    /**
     * Filter which Edges to update
     */
    where?: EdgeWhereInput
    /**
     * Limit how many Edges to update.
     */
    limit?: number
  }

  /**
   * Edge updateManyAndReturn
   */
  export type EdgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * The data used to update Edges.
     */
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyInput>
    /**
     * Filter which Edges to update
     */
    where?: EdgeWhereInput
    /**
     * Limit how many Edges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Edge upsert
   */
  export type EdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Edge to update in case it exists.
     */
    where: EdgeWhereUniqueInput
    /**
     * In case the Edge found by the `where` argument doesn't exist, create a new Edge with this data.
     */
    create: XOR<EdgeCreateInput, EdgeUncheckedCreateInput>
    /**
     * In case the Edge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EdgeUpdateInput, EdgeUncheckedUpdateInput>
  }

  /**
   * Edge delete
   */
  export type EdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter which Edge to delete.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge deleteMany
   */
  export type EdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Edges to delete
     */
    where?: EdgeWhereInput
    /**
     * Limit how many Edges to delete.
     */
    limit?: number
  }

  /**
   * Edge without action
   */
  export type EdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
  }


  /**
   * Model PodExecution
   */

  export type AggregatePodExecution = {
    _count: PodExecutionCountAggregateOutputType | null
    _avg: PodExecutionAvgAggregateOutputType | null
    _sum: PodExecutionSumAggregateOutputType | null
    _min: PodExecutionMinAggregateOutputType | null
    _max: PodExecutionMaxAggregateOutputType | null
  }

  export type PodExecutionAvgAggregateOutputType = {
    runtimeInMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type PodExecutionSumAggregateOutputType = {
    runtimeInMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type PodExecutionMinAggregateOutputType = {
    id: string | null
    podId: string | null
    flowId: string | null
    workspaceId: string | null
    status: $Enums.PodExecutionStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    runtimeInMs: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    errorMessage: string | null
    errorCode: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type PodExecutionMaxAggregateOutputType = {
    id: string | null
    podId: string | null
    flowId: string | null
    workspaceId: string | null
    status: $Enums.PodExecutionStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    runtimeInMs: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    errorMessage: string | null
    errorCode: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type PodExecutionCountAggregateOutputType = {
    id: number
    podId: number
    flowId: number
    workspaceId: number
    status: number
    startedAt: number
    finishedAt: number
    runtimeInMs: number
    provider: number
    modelId: number
    modelName: number
    providerMetadata: number
    requestMetadata: number
    responseMetadata: number
    errorMessage: number
    errorCode: number
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    costInUsd: number
    _all: number
  }


  export type PodExecutionAvgAggregateInputType = {
    runtimeInMs?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type PodExecutionSumAggregateInputType = {
    runtimeInMs?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type PodExecutionMinAggregateInputType = {
    id?: true
    podId?: true
    flowId?: true
    workspaceId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    runtimeInMs?: true
    provider?: true
    modelId?: true
    modelName?: true
    errorMessage?: true
    errorCode?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type PodExecutionMaxAggregateInputType = {
    id?: true
    podId?: true
    flowId?: true
    workspaceId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    runtimeInMs?: true
    provider?: true
    modelId?: true
    modelName?: true
    errorMessage?: true
    errorCode?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type PodExecutionCountAggregateInputType = {
    id?: true
    podId?: true
    flowId?: true
    workspaceId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    runtimeInMs?: true
    provider?: true
    modelId?: true
    modelName?: true
    providerMetadata?: true
    requestMetadata?: true
    responseMetadata?: true
    errorMessage?: true
    errorCode?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
    _all?: true
  }

  export type PodExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodExecution to aggregate.
     */
    where?: PodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodExecutions to fetch.
     */
    orderBy?: PodExecutionOrderByWithRelationInput | PodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodExecutions
    **/
    _count?: true | PodExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodExecutionMaxAggregateInputType
  }

  export type GetPodExecutionAggregateType<T extends PodExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregatePodExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodExecution[P]>
      : GetScalarType<T[P], AggregatePodExecution[P]>
  }




  export type PodExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodExecutionWhereInput
    orderBy?: PodExecutionOrderByWithAggregationInput | PodExecutionOrderByWithAggregationInput[]
    by: PodExecutionScalarFieldEnum[] | PodExecutionScalarFieldEnum
    having?: PodExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodExecutionCountAggregateInputType | true
    _avg?: PodExecutionAvgAggregateInputType
    _sum?: PodExecutionSumAggregateInputType
    _min?: PodExecutionMinAggregateInputType
    _max?: PodExecutionMaxAggregateInputType
  }

  export type PodExecutionGroupByOutputType = {
    id: string
    podId: string
    flowId: string
    workspaceId: string
    status: $Enums.PodExecutionStatus
    startedAt: Date
    finishedAt: Date | null
    runtimeInMs: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName: string | null
    providerMetadata: JsonValue | null
    requestMetadata: JsonValue | null
    responseMetadata: JsonValue | null
    errorMessage: string | null
    errorCode: string | null
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    costInUsd: Decimal | null
    _count: PodExecutionCountAggregateOutputType | null
    _avg: PodExecutionAvgAggregateOutputType | null
    _sum: PodExecutionSumAggregateOutputType | null
    _min: PodExecutionMinAggregateOutputType | null
    _max: PodExecutionMaxAggregateOutputType | null
  }

  type GetPodExecutionGroupByPayload<T extends PodExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], PodExecutionGroupByOutputType[P]>
        }
      >
    >


  export type PodExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podExecution"]>

  export type PodExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podExecution"]>

  export type PodExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podExecution"]>

  export type PodExecutionSelectScalar = {
    id?: boolean
    podId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
  }

  export type PodExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "podId" | "flowId" | "workspaceId" | "status" | "startedAt" | "finishedAt" | "runtimeInMs" | "provider" | "modelId" | "modelName" | "providerMetadata" | "requestMetadata" | "responseMetadata" | "errorMessage" | "errorCode" | "inputTokens" | "outputTokens" | "reasoningTokens" | "creditsConsumed" | "costInUsd", ExtArgs["result"]["podExecution"]>
  export type PodExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PodExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PodExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }

  export type $PodExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodExecution"
    objects: {
      pod: Prisma.$PodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      podId: string
      flowId: string
      workspaceId: string
      status: $Enums.PodExecutionStatus
      startedAt: Date
      finishedAt: Date | null
      runtimeInMs: number | null
      provider: $Enums.LLMProvider
      modelId: string
      modelName: string | null
      providerMetadata: Prisma.JsonValue | null
      requestMetadata: Prisma.JsonValue | null
      responseMetadata: Prisma.JsonValue | null
      errorMessage: string | null
      errorCode: string | null
      inputTokens: number
      outputTokens: number
      reasoningTokens: number
      creditsConsumed: number
      costInUsd: Prisma.Decimal | null
    }, ExtArgs["result"]["podExecution"]>
    composites: {}
  }

  type PodExecutionGetPayload<S extends boolean | null | undefined | PodExecutionDefaultArgs> = $Result.GetResult<Prisma.$PodExecutionPayload, S>

  type PodExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodExecutionCountAggregateInputType | true
    }

  export interface PodExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodExecution'], meta: { name: 'PodExecution' } }
    /**
     * Find zero or one PodExecution that matches the filter.
     * @param {PodExecutionFindUniqueArgs} args - Arguments to find a PodExecution
     * @example
     * // Get one PodExecution
     * const podExecution = await prisma.podExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodExecutionFindUniqueArgs>(args: SelectSubset<T, PodExecutionFindUniqueArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodExecutionFindUniqueOrThrowArgs} args - Arguments to find a PodExecution
     * @example
     * // Get one PodExecution
     * const podExecution = await prisma.podExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, PodExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionFindFirstArgs} args - Arguments to find a PodExecution
     * @example
     * // Get one PodExecution
     * const podExecution = await prisma.podExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodExecutionFindFirstArgs>(args?: SelectSubset<T, PodExecutionFindFirstArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionFindFirstOrThrowArgs} args - Arguments to find a PodExecution
     * @example
     * // Get one PodExecution
     * const podExecution = await prisma.podExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, PodExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodExecutions
     * const podExecutions = await prisma.podExecution.findMany()
     * 
     * // Get first 10 PodExecutions
     * const podExecutions = await prisma.podExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const podExecutionWithIdOnly = await prisma.podExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PodExecutionFindManyArgs>(args?: SelectSubset<T, PodExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodExecution.
     * @param {PodExecutionCreateArgs} args - Arguments to create a PodExecution.
     * @example
     * // Create one PodExecution
     * const PodExecution = await prisma.podExecution.create({
     *   data: {
     *     // ... data to create a PodExecution
     *   }
     * })
     * 
     */
    create<T extends PodExecutionCreateArgs>(args: SelectSubset<T, PodExecutionCreateArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodExecutions.
     * @param {PodExecutionCreateManyArgs} args - Arguments to create many PodExecutions.
     * @example
     * // Create many PodExecutions
     * const podExecution = await prisma.podExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodExecutionCreateManyArgs>(args?: SelectSubset<T, PodExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodExecutions and returns the data saved in the database.
     * @param {PodExecutionCreateManyAndReturnArgs} args - Arguments to create many PodExecutions.
     * @example
     * // Create many PodExecutions
     * const podExecution = await prisma.podExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodExecutions and only return the `id`
     * const podExecutionWithIdOnly = await prisma.podExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, PodExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodExecution.
     * @param {PodExecutionDeleteArgs} args - Arguments to delete one PodExecution.
     * @example
     * // Delete one PodExecution
     * const PodExecution = await prisma.podExecution.delete({
     *   where: {
     *     // ... filter to delete one PodExecution
     *   }
     * })
     * 
     */
    delete<T extends PodExecutionDeleteArgs>(args: SelectSubset<T, PodExecutionDeleteArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodExecution.
     * @param {PodExecutionUpdateArgs} args - Arguments to update one PodExecution.
     * @example
     * // Update one PodExecution
     * const podExecution = await prisma.podExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodExecutionUpdateArgs>(args: SelectSubset<T, PodExecutionUpdateArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodExecutions.
     * @param {PodExecutionDeleteManyArgs} args - Arguments to filter PodExecutions to delete.
     * @example
     * // Delete a few PodExecutions
     * const { count } = await prisma.podExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodExecutionDeleteManyArgs>(args?: SelectSubset<T, PodExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodExecutions
     * const podExecution = await prisma.podExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodExecutionUpdateManyArgs>(args: SelectSubset<T, PodExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodExecutions and returns the data updated in the database.
     * @param {PodExecutionUpdateManyAndReturnArgs} args - Arguments to update many PodExecutions.
     * @example
     * // Update many PodExecutions
     * const podExecution = await prisma.podExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodExecutions and only return the `id`
     * const podExecutionWithIdOnly = await prisma.podExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, PodExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodExecution.
     * @param {PodExecutionUpsertArgs} args - Arguments to update or create a PodExecution.
     * @example
     * // Update or create a PodExecution
     * const podExecution = await prisma.podExecution.upsert({
     *   create: {
     *     // ... data to create a PodExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodExecution we want to update
     *   }
     * })
     */
    upsert<T extends PodExecutionUpsertArgs>(args: SelectSubset<T, PodExecutionUpsertArgs<ExtArgs>>): Prisma__PodExecutionClient<$Result.GetResult<Prisma.$PodExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionCountArgs} args - Arguments to filter PodExecutions to count.
     * @example
     * // Count the number of PodExecutions
     * const count = await prisma.podExecution.count({
     *   where: {
     *     // ... the filter for the PodExecutions we want to count
     *   }
     * })
    **/
    count<T extends PodExecutionCountArgs>(
      args?: Subset<T, PodExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodExecutionAggregateArgs>(args: Subset<T, PodExecutionAggregateArgs>): Prisma.PrismaPromise<GetPodExecutionAggregateType<T>>

    /**
     * Group by PodExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodExecutionGroupByArgs['orderBy'] }
        : { orderBy?: PodExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodExecution model
   */
  readonly fields: PodExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodExecution model
   */
  interface PodExecutionFieldRefs {
    readonly id: FieldRef<"PodExecution", 'String'>
    readonly podId: FieldRef<"PodExecution", 'String'>
    readonly flowId: FieldRef<"PodExecution", 'String'>
    readonly workspaceId: FieldRef<"PodExecution", 'String'>
    readonly status: FieldRef<"PodExecution", 'PodExecutionStatus'>
    readonly startedAt: FieldRef<"PodExecution", 'DateTime'>
    readonly finishedAt: FieldRef<"PodExecution", 'DateTime'>
    readonly runtimeInMs: FieldRef<"PodExecution", 'Int'>
    readonly provider: FieldRef<"PodExecution", 'LLMProvider'>
    readonly modelId: FieldRef<"PodExecution", 'String'>
    readonly modelName: FieldRef<"PodExecution", 'String'>
    readonly providerMetadata: FieldRef<"PodExecution", 'Json'>
    readonly requestMetadata: FieldRef<"PodExecution", 'Json'>
    readonly responseMetadata: FieldRef<"PodExecution", 'Json'>
    readonly errorMessage: FieldRef<"PodExecution", 'String'>
    readonly errorCode: FieldRef<"PodExecution", 'String'>
    readonly inputTokens: FieldRef<"PodExecution", 'Int'>
    readonly outputTokens: FieldRef<"PodExecution", 'Int'>
    readonly reasoningTokens: FieldRef<"PodExecution", 'Int'>
    readonly creditsConsumed: FieldRef<"PodExecution", 'Int'>
    readonly costInUsd: FieldRef<"PodExecution", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PodExecution findUnique
   */
  export type PodExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PodExecution to fetch.
     */
    where: PodExecutionWhereUniqueInput
  }

  /**
   * PodExecution findUniqueOrThrow
   */
  export type PodExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PodExecution to fetch.
     */
    where: PodExecutionWhereUniqueInput
  }

  /**
   * PodExecution findFirst
   */
  export type PodExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PodExecution to fetch.
     */
    where?: PodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodExecutions to fetch.
     */
    orderBy?: PodExecutionOrderByWithRelationInput | PodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodExecutions.
     */
    cursor?: PodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodExecutions.
     */
    distinct?: PodExecutionScalarFieldEnum | PodExecutionScalarFieldEnum[]
  }

  /**
   * PodExecution findFirstOrThrow
   */
  export type PodExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PodExecution to fetch.
     */
    where?: PodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodExecutions to fetch.
     */
    orderBy?: PodExecutionOrderByWithRelationInput | PodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodExecutions.
     */
    cursor?: PodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodExecutions.
     */
    distinct?: PodExecutionScalarFieldEnum | PodExecutionScalarFieldEnum[]
  }

  /**
   * PodExecution findMany
   */
  export type PodExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PodExecutions to fetch.
     */
    where?: PodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodExecutions to fetch.
     */
    orderBy?: PodExecutionOrderByWithRelationInput | PodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodExecutions.
     */
    cursor?: PodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodExecutions.
     */
    skip?: number
    distinct?: PodExecutionScalarFieldEnum | PodExecutionScalarFieldEnum[]
  }

  /**
   * PodExecution create
   */
  export type PodExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a PodExecution.
     */
    data: XOR<PodExecutionCreateInput, PodExecutionUncheckedCreateInput>
  }

  /**
   * PodExecution createMany
   */
  export type PodExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodExecutions.
     */
    data: PodExecutionCreateManyInput | PodExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodExecution createManyAndReturn
   */
  export type PodExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many PodExecutions.
     */
    data: PodExecutionCreateManyInput | PodExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodExecution update
   */
  export type PodExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a PodExecution.
     */
    data: XOR<PodExecutionUpdateInput, PodExecutionUncheckedUpdateInput>
    /**
     * Choose, which PodExecution to update.
     */
    where: PodExecutionWhereUniqueInput
  }

  /**
   * PodExecution updateMany
   */
  export type PodExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodExecutions.
     */
    data: XOR<PodExecutionUpdateManyMutationInput, PodExecutionUncheckedUpdateManyInput>
    /**
     * Filter which PodExecutions to update
     */
    where?: PodExecutionWhereInput
    /**
     * Limit how many PodExecutions to update.
     */
    limit?: number
  }

  /**
   * PodExecution updateManyAndReturn
   */
  export type PodExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * The data used to update PodExecutions.
     */
    data: XOR<PodExecutionUpdateManyMutationInput, PodExecutionUncheckedUpdateManyInput>
    /**
     * Filter which PodExecutions to update
     */
    where?: PodExecutionWhereInput
    /**
     * Limit how many PodExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodExecution upsert
   */
  export type PodExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the PodExecution to update in case it exists.
     */
    where: PodExecutionWhereUniqueInput
    /**
     * In case the PodExecution found by the `where` argument doesn't exist, create a new PodExecution with this data.
     */
    create: XOR<PodExecutionCreateInput, PodExecutionUncheckedCreateInput>
    /**
     * In case the PodExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodExecutionUpdateInput, PodExecutionUncheckedUpdateInput>
  }

  /**
   * PodExecution delete
   */
  export type PodExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
    /**
     * Filter which PodExecution to delete.
     */
    where: PodExecutionWhereUniqueInput
  }

  /**
   * PodExecution deleteMany
   */
  export type PodExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodExecutions to delete
     */
    where?: PodExecutionWhereInput
    /**
     * Limit how many PodExecutions to delete.
     */
    limit?: number
  }

  /**
   * PodExecution without action
   */
  export type PodExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodExecution
     */
    select?: PodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodExecution
     */
    omit?: PodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodExecutionInclude<ExtArgs> | null
  }


  /**
   * Model PodUsageLog
   */

  export type AggregatePodUsageLog = {
    _count: PodUsageLogCountAggregateOutputType | null
    _avg: PodUsageLogAvgAggregateOutputType | null
    _sum: PodUsageLogSumAggregateOutputType | null
    _min: PodUsageLogMinAggregateOutputType | null
    _max: PodUsageLogMaxAggregateOutputType | null
  }

  export type PodUsageLogAvgAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
  }

  export type PodUsageLogSumAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
  }

  export type PodUsageLogMinAggregateOutputType = {
    id: string | null
    podId: string | null
    executionId: string | null
    flowId: string | null
    workspaceId: string | null
    subscriptionId: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
    executedAt: Date | null
  }

  export type PodUsageLogMaxAggregateOutputType = {
    id: string | null
    podId: string | null
    executionId: string | null
    flowId: string | null
    workspaceId: string | null
    subscriptionId: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
    executedAt: Date | null
  }

  export type PodUsageLogCountAggregateOutputType = {
    id: number
    podId: number
    executionId: number
    flowId: number
    workspaceId: number
    subscriptionId: number
    provider: number
    modelId: number
    modelName: number
    providerMetadata: number
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    runtimeInMs: number
    inputTokenCost: number
    outputTokenCost: number
    reasoningTokenCost: number
    totalCostInUsd: number
    executedAt: number
    _all: number
  }


  export type PodUsageLogAvgAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
  }

  export type PodUsageLogSumAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
  }

  export type PodUsageLogMinAggregateInputType = {
    id?: true
    podId?: true
    executionId?: true
    flowId?: true
    workspaceId?: true
    subscriptionId?: true
    provider?: true
    modelId?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
    executedAt?: true
  }

  export type PodUsageLogMaxAggregateInputType = {
    id?: true
    podId?: true
    executionId?: true
    flowId?: true
    workspaceId?: true
    subscriptionId?: true
    provider?: true
    modelId?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
    executedAt?: true
  }

  export type PodUsageLogCountAggregateInputType = {
    id?: true
    podId?: true
    executionId?: true
    flowId?: true
    workspaceId?: true
    subscriptionId?: true
    provider?: true
    modelId?: true
    modelName?: true
    providerMetadata?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
    executedAt?: true
    _all?: true
  }

  export type PodUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodUsageLog to aggregate.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodUsageLogs
    **/
    _count?: true | PodUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodUsageLogMaxAggregateInputType
  }

  export type GetPodUsageLogAggregateType<T extends PodUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePodUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodUsageLog[P]>
      : GetScalarType<T[P], AggregatePodUsageLog[P]>
  }




  export type PodUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodUsageLogWhereInput
    orderBy?: PodUsageLogOrderByWithAggregationInput | PodUsageLogOrderByWithAggregationInput[]
    by: PodUsageLogScalarFieldEnum[] | PodUsageLogScalarFieldEnum
    having?: PodUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodUsageLogCountAggregateInputType | true
    _avg?: PodUsageLogAvgAggregateInputType
    _sum?: PodUsageLogSumAggregateInputType
    _min?: PodUsageLogMinAggregateInputType
    _max?: PodUsageLogMaxAggregateInputType
  }

  export type PodUsageLogGroupByOutputType = {
    id: string
    podId: string
    executionId: string
    flowId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName: string | null
    providerMetadata: JsonValue | null
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    runtimeInMs: number | null
    inputTokenCost: Decimal
    outputTokenCost: Decimal
    reasoningTokenCost: Decimal
    totalCostInUsd: Decimal
    executedAt: Date
    _count: PodUsageLogCountAggregateOutputType | null
    _avg: PodUsageLogAvgAggregateOutputType | null
    _sum: PodUsageLogSumAggregateOutputType | null
    _min: PodUsageLogMinAggregateOutputType | null
    _max: PodUsageLogMaxAggregateOutputType | null
  }

  type GetPodUsageLogGroupByPayload<T extends PodUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], PodUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type PodUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    executionId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podUsageLog"]>

  export type PodUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    executionId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podUsageLog"]>

  export type PodUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    executionId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podUsageLog"]>

  export type PodUsageLogSelectScalar = {
    id?: boolean
    podId?: boolean
    executionId?: boolean
    flowId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
  }

  export type PodUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "podId" | "executionId" | "flowId" | "workspaceId" | "subscriptionId" | "provider" | "modelId" | "modelName" | "providerMetadata" | "inputTokens" | "outputTokens" | "reasoningTokens" | "creditsConsumed" | "runtimeInMs" | "inputTokenCost" | "outputTokenCost" | "reasoningTokenCost" | "totalCostInUsd" | "executedAt", ExtArgs["result"]["podUsageLog"]>
  export type PodUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PodUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PodUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PodUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodUsageLog"
    objects: {
      pod: Prisma.$PodPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      podId: string
      executionId: string
      flowId: string
      workspaceId: string
      subscriptionId: string
      provider: $Enums.LLMProvider
      modelId: string
      modelName: string | null
      providerMetadata: Prisma.JsonValue | null
      inputTokens: number
      outputTokens: number
      reasoningTokens: number
      creditsConsumed: number
      runtimeInMs: number | null
      inputTokenCost: Prisma.Decimal
      outputTokenCost: Prisma.Decimal
      reasoningTokenCost: Prisma.Decimal
      totalCostInUsd: Prisma.Decimal
      executedAt: Date
    }, ExtArgs["result"]["podUsageLog"]>
    composites: {}
  }

  type PodUsageLogGetPayload<S extends boolean | null | undefined | PodUsageLogDefaultArgs> = $Result.GetResult<Prisma.$PodUsageLogPayload, S>

  type PodUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodUsageLogCountAggregateInputType | true
    }

  export interface PodUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodUsageLog'], meta: { name: 'PodUsageLog' } }
    /**
     * Find zero or one PodUsageLog that matches the filter.
     * @param {PodUsageLogFindUniqueArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodUsageLogFindUniqueArgs>(args: SelectSubset<T, PodUsageLogFindUniqueArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodUsageLogFindUniqueOrThrowArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PodUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogFindFirstArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodUsageLogFindFirstArgs>(args?: SelectSubset<T, PodUsageLogFindFirstArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogFindFirstOrThrowArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PodUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodUsageLogs
     * const podUsageLogs = await prisma.podUsageLog.findMany()
     * 
     * // Get first 10 PodUsageLogs
     * const podUsageLogs = await prisma.podUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const podUsageLogWithIdOnly = await prisma.podUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PodUsageLogFindManyArgs>(args?: SelectSubset<T, PodUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodUsageLog.
     * @param {PodUsageLogCreateArgs} args - Arguments to create a PodUsageLog.
     * @example
     * // Create one PodUsageLog
     * const PodUsageLog = await prisma.podUsageLog.create({
     *   data: {
     *     // ... data to create a PodUsageLog
     *   }
     * })
     * 
     */
    create<T extends PodUsageLogCreateArgs>(args: SelectSubset<T, PodUsageLogCreateArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodUsageLogs.
     * @param {PodUsageLogCreateManyArgs} args - Arguments to create many PodUsageLogs.
     * @example
     * // Create many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodUsageLogCreateManyArgs>(args?: SelectSubset<T, PodUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodUsageLogs and returns the data saved in the database.
     * @param {PodUsageLogCreateManyAndReturnArgs} args - Arguments to create many PodUsageLogs.
     * @example
     * // Create many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodUsageLogs and only return the `id`
     * const podUsageLogWithIdOnly = await prisma.podUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PodUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodUsageLog.
     * @param {PodUsageLogDeleteArgs} args - Arguments to delete one PodUsageLog.
     * @example
     * // Delete one PodUsageLog
     * const PodUsageLog = await prisma.podUsageLog.delete({
     *   where: {
     *     // ... filter to delete one PodUsageLog
     *   }
     * })
     * 
     */
    delete<T extends PodUsageLogDeleteArgs>(args: SelectSubset<T, PodUsageLogDeleteArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodUsageLog.
     * @param {PodUsageLogUpdateArgs} args - Arguments to update one PodUsageLog.
     * @example
     * // Update one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodUsageLogUpdateArgs>(args: SelectSubset<T, PodUsageLogUpdateArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodUsageLogs.
     * @param {PodUsageLogDeleteManyArgs} args - Arguments to filter PodUsageLogs to delete.
     * @example
     * // Delete a few PodUsageLogs
     * const { count } = await prisma.podUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodUsageLogDeleteManyArgs>(args?: SelectSubset<T, PodUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodUsageLogUpdateManyArgs>(args: SelectSubset<T, PodUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodUsageLogs and returns the data updated in the database.
     * @param {PodUsageLogUpdateManyAndReturnArgs} args - Arguments to update many PodUsageLogs.
     * @example
     * // Update many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodUsageLogs and only return the `id`
     * const podUsageLogWithIdOnly = await prisma.podUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PodUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodUsageLog.
     * @param {PodUsageLogUpsertArgs} args - Arguments to update or create a PodUsageLog.
     * @example
     * // Update or create a PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.upsert({
     *   create: {
     *     // ... data to create a PodUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends PodUsageLogUpsertArgs>(args: SelectSubset<T, PodUsageLogUpsertArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogCountArgs} args - Arguments to filter PodUsageLogs to count.
     * @example
     * // Count the number of PodUsageLogs
     * const count = await prisma.podUsageLog.count({
     *   where: {
     *     // ... the filter for the PodUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends PodUsageLogCountArgs>(
      args?: Subset<T, PodUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodUsageLogAggregateArgs>(args: Subset<T, PodUsageLogAggregateArgs>): Prisma.PrismaPromise<GetPodUsageLogAggregateType<T>>

    /**
     * Group by PodUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: PodUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodUsageLog model
   */
  readonly fields: PodUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodUsageLog model
   */
  interface PodUsageLogFieldRefs {
    readonly id: FieldRef<"PodUsageLog", 'String'>
    readonly podId: FieldRef<"PodUsageLog", 'String'>
    readonly executionId: FieldRef<"PodUsageLog", 'String'>
    readonly flowId: FieldRef<"PodUsageLog", 'String'>
    readonly workspaceId: FieldRef<"PodUsageLog", 'String'>
    readonly subscriptionId: FieldRef<"PodUsageLog", 'String'>
    readonly provider: FieldRef<"PodUsageLog", 'LLMProvider'>
    readonly modelId: FieldRef<"PodUsageLog", 'String'>
    readonly modelName: FieldRef<"PodUsageLog", 'String'>
    readonly providerMetadata: FieldRef<"PodUsageLog", 'Json'>
    readonly inputTokens: FieldRef<"PodUsageLog", 'Int'>
    readonly outputTokens: FieldRef<"PodUsageLog", 'Int'>
    readonly reasoningTokens: FieldRef<"PodUsageLog", 'Int'>
    readonly creditsConsumed: FieldRef<"PodUsageLog", 'Int'>
    readonly runtimeInMs: FieldRef<"PodUsageLog", 'Int'>
    readonly inputTokenCost: FieldRef<"PodUsageLog", 'Decimal'>
    readonly outputTokenCost: FieldRef<"PodUsageLog", 'Decimal'>
    readonly reasoningTokenCost: FieldRef<"PodUsageLog", 'Decimal'>
    readonly totalCostInUsd: FieldRef<"PodUsageLog", 'Decimal'>
    readonly executedAt: FieldRef<"PodUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PodUsageLog findUnique
   */
  export type PodUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog findUniqueOrThrow
   */
  export type PodUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog findFirst
   */
  export type PodUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodUsageLogs.
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodUsageLogs.
     */
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * PodUsageLog findFirstOrThrow
   */
  export type PodUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodUsageLogs.
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodUsageLogs.
     */
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * PodUsageLog findMany
   */
  export type PodUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLogs to fetch.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodUsageLogs.
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * PodUsageLog create
   */
  export type PodUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PodUsageLog.
     */
    data: XOR<PodUsageLogCreateInput, PodUsageLogUncheckedCreateInput>
  }

  /**
   * PodUsageLog createMany
   */
  export type PodUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodUsageLogs.
     */
    data: PodUsageLogCreateManyInput | PodUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodUsageLog createManyAndReturn
   */
  export type PodUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many PodUsageLogs.
     */
    data: PodUsageLogCreateManyInput | PodUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodUsageLog update
   */
  export type PodUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PodUsageLog.
     */
    data: XOR<PodUsageLogUpdateInput, PodUsageLogUncheckedUpdateInput>
    /**
     * Choose, which PodUsageLog to update.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog updateMany
   */
  export type PodUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodUsageLogs.
     */
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which PodUsageLogs to update
     */
    where?: PodUsageLogWhereInput
    /**
     * Limit how many PodUsageLogs to update.
     */
    limit?: number
  }

  /**
   * PodUsageLog updateManyAndReturn
   */
  export type PodUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update PodUsageLogs.
     */
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which PodUsageLogs to update
     */
    where?: PodUsageLogWhereInput
    /**
     * Limit how many PodUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodUsageLog upsert
   */
  export type PodUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PodUsageLog to update in case it exists.
     */
    where: PodUsageLogWhereUniqueInput
    /**
     * In case the PodUsageLog found by the `where` argument doesn't exist, create a new PodUsageLog with this data.
     */
    create: XOR<PodUsageLogCreateInput, PodUsageLogUncheckedCreateInput>
    /**
     * In case the PodUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodUsageLogUpdateInput, PodUsageLogUncheckedUpdateInput>
  }

  /**
   * PodUsageLog delete
   */
  export type PodUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter which PodUsageLog to delete.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog deleteMany
   */
  export type PodUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodUsageLogs to delete
     */
    where?: PodUsageLogWhereInput
    /**
     * Limit how many PodUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * PodUsageLog without action
   */
  export type PodUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ContextModule
   */

  export type AggregateContextModule = {
    _count: ContextModuleCountAggregateOutputType | null
    _avg: ContextModuleAvgAggregateOutputType | null
    _sum: ContextModuleSumAggregateOutputType | null
    _min: ContextModuleMinAggregateOutputType | null
    _max: ContextModuleMaxAggregateOutputType | null
  }

  export type ContextModuleAvgAggregateOutputType = {
    version: number | null
  }

  export type ContextModuleSumAggregateOutputType = {
    version: number | null
  }

  export type ContextModuleMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    originalFlowId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextModuleMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    originalFlowId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextModuleCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    definitionJson: number
    originalFlowId: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContextModuleAvgAggregateInputType = {
    version?: true
  }

  export type ContextModuleSumAggregateInputType = {
    version?: true
  }

  export type ContextModuleMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    originalFlowId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextModuleMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    originalFlowId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextModuleCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    definitionJson?: true
    originalFlowId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContextModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextModule to aggregate.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextModules
    **/
    _count?: true | ContextModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextModuleMaxAggregateInputType
  }

  export type GetContextModuleAggregateType<T extends ContextModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateContextModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextModule[P]>
      : GetScalarType<T[P], AggregateContextModule[P]>
  }




  export type ContextModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextModuleWhereInput
    orderBy?: ContextModuleOrderByWithAggregationInput | ContextModuleOrderByWithAggregationInput[]
    by: ContextModuleScalarFieldEnum[] | ContextModuleScalarFieldEnum
    having?: ContextModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextModuleCountAggregateInputType | true
    _avg?: ContextModuleAvgAggregateInputType
    _sum?: ContextModuleSumAggregateInputType
    _min?: ContextModuleMinAggregateInputType
    _max?: ContextModuleMaxAggregateInputType
  }

  export type ContextModuleGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    definitionJson: JsonValue
    originalFlowId: string | null
    version: number
    createdAt: Date
    updatedAt: Date
    _count: ContextModuleCountAggregateOutputType | null
    _avg: ContextModuleAvgAggregateOutputType | null
    _sum: ContextModuleSumAggregateOutputType | null
    _min: ContextModuleMinAggregateOutputType | null
    _max: ContextModuleMaxAggregateOutputType | null
  }

  type GetContextModuleGroupByPayload<T extends ContextModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ContextModuleGroupByOutputType[P]>
        }
      >
    >


  export type ContextModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalFlowId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalFlow?: boolean | ContextModule$originalFlowArgs<ExtArgs>
  }, ExtArgs["result"]["contextModule"]>

  export type ContextModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalFlowId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalFlow?: boolean | ContextModule$originalFlowArgs<ExtArgs>
  }, ExtArgs["result"]["contextModule"]>

  export type ContextModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalFlowId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalFlow?: boolean | ContextModule$originalFlowArgs<ExtArgs>
  }, ExtArgs["result"]["contextModule"]>

  export type ContextModuleSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalFlowId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContextModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "definitionJson" | "originalFlowId" | "version" | "createdAt" | "updatedAt", ExtArgs["result"]["contextModule"]>
  export type ContextModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalFlow?: boolean | ContextModule$originalFlowArgs<ExtArgs>
  }
  export type ContextModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalFlow?: boolean | ContextModule$originalFlowArgs<ExtArgs>
  }
  export type ContextModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalFlow?: boolean | ContextModule$originalFlowArgs<ExtArgs>
  }

  export type $ContextModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContextModule"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      originalFlow: Prisma.$FlowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      definitionJson: Prisma.JsonValue
      originalFlowId: string | null
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contextModule"]>
    composites: {}
  }

  type ContextModuleGetPayload<S extends boolean | null | undefined | ContextModuleDefaultArgs> = $Result.GetResult<Prisma.$ContextModulePayload, S>

  type ContextModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContextModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContextModuleCountAggregateInputType | true
    }

  export interface ContextModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextModule'], meta: { name: 'ContextModule' } }
    /**
     * Find zero or one ContextModule that matches the filter.
     * @param {ContextModuleFindUniqueArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContextModuleFindUniqueArgs>(args: SelectSubset<T, ContextModuleFindUniqueArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContextModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContextModuleFindUniqueOrThrowArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContextModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ContextModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContextModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleFindFirstArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContextModuleFindFirstArgs>(args?: SelectSubset<T, ContextModuleFindFirstArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContextModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleFindFirstOrThrowArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContextModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ContextModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContextModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextModules
     * const contextModules = await prisma.contextModule.findMany()
     * 
     * // Get first 10 ContextModules
     * const contextModules = await prisma.contextModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextModuleWithIdOnly = await prisma.contextModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContextModuleFindManyArgs>(args?: SelectSubset<T, ContextModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContextModule.
     * @param {ContextModuleCreateArgs} args - Arguments to create a ContextModule.
     * @example
     * // Create one ContextModule
     * const ContextModule = await prisma.contextModule.create({
     *   data: {
     *     // ... data to create a ContextModule
     *   }
     * })
     * 
     */
    create<T extends ContextModuleCreateArgs>(args: SelectSubset<T, ContextModuleCreateArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContextModules.
     * @param {ContextModuleCreateManyArgs} args - Arguments to create many ContextModules.
     * @example
     * // Create many ContextModules
     * const contextModule = await prisma.contextModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContextModuleCreateManyArgs>(args?: SelectSubset<T, ContextModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContextModules and returns the data saved in the database.
     * @param {ContextModuleCreateManyAndReturnArgs} args - Arguments to create many ContextModules.
     * @example
     * // Create many ContextModules
     * const contextModule = await prisma.contextModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContextModules and only return the `id`
     * const contextModuleWithIdOnly = await prisma.contextModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContextModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ContextModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContextModule.
     * @param {ContextModuleDeleteArgs} args - Arguments to delete one ContextModule.
     * @example
     * // Delete one ContextModule
     * const ContextModule = await prisma.contextModule.delete({
     *   where: {
     *     // ... filter to delete one ContextModule
     *   }
     * })
     * 
     */
    delete<T extends ContextModuleDeleteArgs>(args: SelectSubset<T, ContextModuleDeleteArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContextModule.
     * @param {ContextModuleUpdateArgs} args - Arguments to update one ContextModule.
     * @example
     * // Update one ContextModule
     * const contextModule = await prisma.contextModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContextModuleUpdateArgs>(args: SelectSubset<T, ContextModuleUpdateArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContextModules.
     * @param {ContextModuleDeleteManyArgs} args - Arguments to filter ContextModules to delete.
     * @example
     * // Delete a few ContextModules
     * const { count } = await prisma.contextModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContextModuleDeleteManyArgs>(args?: SelectSubset<T, ContextModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextModules
     * const contextModule = await prisma.contextModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContextModuleUpdateManyArgs>(args: SelectSubset<T, ContextModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextModules and returns the data updated in the database.
     * @param {ContextModuleUpdateManyAndReturnArgs} args - Arguments to update many ContextModules.
     * @example
     * // Update many ContextModules
     * const contextModule = await prisma.contextModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContextModules and only return the `id`
     * const contextModuleWithIdOnly = await prisma.contextModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContextModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ContextModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContextModule.
     * @param {ContextModuleUpsertArgs} args - Arguments to update or create a ContextModule.
     * @example
     * // Update or create a ContextModule
     * const contextModule = await prisma.contextModule.upsert({
     *   create: {
     *     // ... data to create a ContextModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextModule we want to update
     *   }
     * })
     */
    upsert<T extends ContextModuleUpsertArgs>(args: SelectSubset<T, ContextModuleUpsertArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContextModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleCountArgs} args - Arguments to filter ContextModules to count.
     * @example
     * // Count the number of ContextModules
     * const count = await prisma.contextModule.count({
     *   where: {
     *     // ... the filter for the ContextModules we want to count
     *   }
     * })
    **/
    count<T extends ContextModuleCountArgs>(
      args?: Subset<T, ContextModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextModuleAggregateArgs>(args: Subset<T, ContextModuleAggregateArgs>): Prisma.PrismaPromise<GetContextModuleAggregateType<T>>

    /**
     * Group by ContextModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextModuleGroupByArgs['orderBy'] }
        : { orderBy?: ContextModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextModule model
   */
  readonly fields: ContextModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContextModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    originalFlow<T extends ContextModule$originalFlowArgs<ExtArgs> = {}>(args?: Subset<T, ContextModule$originalFlowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContextModule model
   */
  interface ContextModuleFieldRefs {
    readonly id: FieldRef<"ContextModule", 'String'>
    readonly workspaceId: FieldRef<"ContextModule", 'String'>
    readonly name: FieldRef<"ContextModule", 'String'>
    readonly description: FieldRef<"ContextModule", 'String'>
    readonly definitionJson: FieldRef<"ContextModule", 'Json'>
    readonly originalFlowId: FieldRef<"ContextModule", 'String'>
    readonly version: FieldRef<"ContextModule", 'Int'>
    readonly createdAt: FieldRef<"ContextModule", 'DateTime'>
    readonly updatedAt: FieldRef<"ContextModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContextModule findUnique
   */
  export type ContextModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule findUniqueOrThrow
   */
  export type ContextModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule findFirst
   */
  export type ContextModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextModules.
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextModules.
     */
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * ContextModule findFirstOrThrow
   */
  export type ContextModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextModules.
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextModules.
     */
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * ContextModule findMany
   */
  export type ContextModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModules to fetch.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextModules.
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * ContextModule create
   */
  export type ContextModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextModule.
     */
    data: XOR<ContextModuleCreateInput, ContextModuleUncheckedCreateInput>
  }

  /**
   * ContextModule createMany
   */
  export type ContextModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextModules.
     */
    data: ContextModuleCreateManyInput | ContextModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContextModule createManyAndReturn
   */
  export type ContextModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * The data used to create many ContextModules.
     */
    data: ContextModuleCreateManyInput | ContextModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContextModule update
   */
  export type ContextModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextModule.
     */
    data: XOR<ContextModuleUpdateInput, ContextModuleUncheckedUpdateInput>
    /**
     * Choose, which ContextModule to update.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule updateMany
   */
  export type ContextModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextModules.
     */
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyInput>
    /**
     * Filter which ContextModules to update
     */
    where?: ContextModuleWhereInput
    /**
     * Limit how many ContextModules to update.
     */
    limit?: number
  }

  /**
   * ContextModule updateManyAndReturn
   */
  export type ContextModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * The data used to update ContextModules.
     */
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyInput>
    /**
     * Filter which ContextModules to update
     */
    where?: ContextModuleWhereInput
    /**
     * Limit how many ContextModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContextModule upsert
   */
  export type ContextModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextModule to update in case it exists.
     */
    where: ContextModuleWhereUniqueInput
    /**
     * In case the ContextModule found by the `where` argument doesn't exist, create a new ContextModule with this data.
     */
    create: XOR<ContextModuleCreateInput, ContextModuleUncheckedCreateInput>
    /**
     * In case the ContextModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextModuleUpdateInput, ContextModuleUncheckedUpdateInput>
  }

  /**
   * ContextModule delete
   */
  export type ContextModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter which ContextModule to delete.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule deleteMany
   */
  export type ContextModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextModules to delete
     */
    where?: ContextModuleWhereInput
    /**
     * Limit how many ContextModules to delete.
     */
    limit?: number
  }

  /**
   * ContextModule.originalFlow
   */
  export type ContextModule$originalFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    where?: FlowWhereInput
  }

  /**
   * ContextModule without action
   */
  export type ContextModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    hash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    hash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    image: number
    hash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    hash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    hash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    hash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    image: string | null
    hash: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    flowCollaborations?: boolean | User$flowCollaborationsArgs<ExtArgs>
    sentWorkspaceInvites?: boolean | User$sentWorkspaceInvitesArgs<ExtArgs>
    receivedWorkspaceInvites?: boolean | User$receivedWorkspaceInvitesArgs<ExtArgs>
    sentFlowInvites?: boolean | User$sentFlowInvitesArgs<ExtArgs>
    receivedFlowInvites?: boolean | User$receivedFlowInvitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "image" | "hash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    flowCollaborations?: boolean | User$flowCollaborationsArgs<ExtArgs>
    sentWorkspaceInvites?: boolean | User$sentWorkspaceInvitesArgs<ExtArgs>
    receivedWorkspaceInvites?: boolean | User$receivedWorkspaceInvitesArgs<ExtArgs>
    sentFlowInvites?: boolean | User$sentFlowInvitesArgs<ExtArgs>
    receivedFlowInvites?: boolean | User$receivedFlowInvitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      workspaces: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      flowCollaborations: Prisma.$FlowCollaboratorPayload<ExtArgs>[]
      sentWorkspaceInvites: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      receivedWorkspaceInvites: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      sentFlowInvites: Prisma.$FlowInvitationPayload<ExtArgs>[]
      receivedFlowInvites: Prisma.$FlowInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      image: string | null
      hash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flowCollaborations<T extends User$flowCollaborationsArgs<ExtArgs> = {}>(args?: Subset<T, User$flowCollaborationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentWorkspaceInvites<T extends User$sentWorkspaceInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentWorkspaceInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedWorkspaceInvites<T extends User$receivedWorkspaceInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedWorkspaceInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentFlowInvites<T extends User$sentFlowInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentFlowInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedFlowInvites<T extends User$receivedFlowInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedFlowInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly hash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.flowCollaborations
   */
  export type User$flowCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCollaborator
     */
    select?: FlowCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowCollaborator
     */
    omit?: FlowCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowCollaboratorInclude<ExtArgs> | null
    where?: FlowCollaboratorWhereInput
    orderBy?: FlowCollaboratorOrderByWithRelationInput | FlowCollaboratorOrderByWithRelationInput[]
    cursor?: FlowCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowCollaboratorScalarFieldEnum | FlowCollaboratorScalarFieldEnum[]
  }

  /**
   * User.sentWorkspaceInvites
   */
  export type User$sentWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * User.receivedWorkspaceInvites
   */
  export type User$receivedWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * User.sentFlowInvites
   */
  export type User$sentFlowInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    where?: FlowInvitationWhereInput
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    cursor?: FlowInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowInvitationScalarFieldEnum | FlowInvitationScalarFieldEnum[]
  }

  /**
   * User.receivedFlowInvites
   */
  export type User$receivedFlowInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowInvitation
     */
    select?: FlowInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowInvitation
     */
    omit?: FlowInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInvitationInclude<ExtArgs> | null
    where?: FlowInvitationWhereInput
    orderBy?: FlowInvitationOrderByWithRelationInput | FlowInvitationOrderByWithRelationInput[]
    cursor?: FlowInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowInvitationScalarFieldEnum | FlowInvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    deviceName: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    deviceName: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    deviceName: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    deviceName?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    deviceName?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    deviceName?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    deviceName: string
    userId: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "deviceName" | "userId" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      deviceName: string
      userId: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly deviceName: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.AuthProvider | null
    providerAccountId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.AuthProvider | null
    providerAccountId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerAccountId: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerAccountId" | "accessToken" | "refreshToken" | "expiresAt" | "createdAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: $Enums.AuthProvider
      providerAccountId: string
      accessToken: string | null
      refreshToken: string | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'AuthProvider'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.WorkspaceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.WorkspaceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    type: $Enums.WorkspaceType
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Workspace$membersArgs<ExtArgs>
    spaces?: boolean | Workspace$spacesArgs<ExtArgs>
    flows?: boolean | Workspace$flowsArgs<ExtArgs>
    documents?: boolean | Workspace$documentsArgs<ExtArgs>
    documentFolders?: boolean | Workspace$documentFoldersArgs<ExtArgs>
    subscription?: boolean | Workspace$subscriptionArgs<ExtArgs>
    contextModules?: boolean | Workspace$contextModulesArgs<ExtArgs>
    shareLinks?: boolean | Workspace$shareLinksArgs<ExtArgs>
    apiKeys?: boolean | Workspace$apiKeysArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Workspace$membersArgs<ExtArgs>
    spaces?: boolean | Workspace$spacesArgs<ExtArgs>
    flows?: boolean | Workspace$flowsArgs<ExtArgs>
    documents?: boolean | Workspace$documentsArgs<ExtArgs>
    documentFolders?: boolean | Workspace$documentFoldersArgs<ExtArgs>
    subscription?: boolean | Workspace$subscriptionArgs<ExtArgs>
    contextModules?: boolean | Workspace$contextModulesArgs<ExtArgs>
    shareLinks?: boolean | Workspace$shareLinksArgs<ExtArgs>
    apiKeys?: boolean | Workspace$apiKeysArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      members: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      spaces: Prisma.$SpacePayload<ExtArgs>[]
      flows: Prisma.$FlowPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      documentFolders: Prisma.$DocumentFolderPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      contextModules: Prisma.$ContextModulePayload<ExtArgs>[]
      shareLinks: Prisma.$ShareLinkPayload<ExtArgs>[]
      apiKeys: Prisma.$ProviderAPIKeyPayload<ExtArgs>[]
      invitations: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.WorkspaceType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Workspace$membersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spaces<T extends Workspace$spacesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$spacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flows<T extends Workspace$flowsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$flowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Workspace$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentFolders<T extends Workspace$documentFoldersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$documentFoldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Workspace$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contextModules<T extends Workspace$contextModulesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$contextModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareLinks<T extends Workspace$shareLinksArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$shareLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends Workspace$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Workspace$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly type: FieldRef<"Workspace", 'WorkspaceType'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.members
   */
  export type Workspace$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * Workspace.spaces
   */
  export type Workspace$spacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    cursor?: SpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Workspace.flows
   */
  export type Workspace$flowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    where?: FlowWhereInput
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    cursor?: FlowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Workspace.documents
   */
  export type Workspace$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Workspace.documentFolders
   */
  export type Workspace$documentFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    where?: DocumentFolderWhereInput
    orderBy?: DocumentFolderOrderByWithRelationInput | DocumentFolderOrderByWithRelationInput[]
    cursor?: DocumentFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentFolderScalarFieldEnum | DocumentFolderScalarFieldEnum[]
  }

  /**
   * Workspace.subscription
   */
  export type Workspace$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Workspace.contextModules
   */
  export type Workspace$contextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    where?: ContextModuleWhereInput
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    cursor?: ContextModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * Workspace.shareLinks
   */
  export type Workspace$shareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    cursor?: ShareLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * Workspace.apiKeys
   */
  export type Workspace$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    where?: ProviderAPIKeyWhereInput
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    cursor?: ProviderAPIKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * Workspace.invitations
   */
  export type Workspace$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUser
   */

  export type AggregateWorkspaceUser = {
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  export type WorkspaceUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: $Enums.WorkspaceRole | null
    canCreateCanvas: boolean | null
    canDeleteCanvas: boolean | null
    canManageBilling: boolean | null
    canInviteMembers: boolean | null
    canManageMembers: boolean | null
    canManageApiKeys: boolean | null
    joinedAt: Date | null
    invitedBy: string | null
  }

  export type WorkspaceUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: $Enums.WorkspaceRole | null
    canCreateCanvas: boolean | null
    canDeleteCanvas: boolean | null
    canManageBilling: boolean | null
    canInviteMembers: boolean | null
    canManageMembers: boolean | null
    canManageApiKeys: boolean | null
    joinedAt: Date | null
    invitedBy: string | null
  }

  export type WorkspaceUserCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    role: number
    canCreateCanvas: number
    canDeleteCanvas: number
    canManageBilling: number
    canInviteMembers: number
    canManageMembers: number
    canManageApiKeys: number
    joinedAt: number
    invitedBy: number
    _all: number
  }


  export type WorkspaceUserMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    canCreateCanvas?: true
    canDeleteCanvas?: true
    canManageBilling?: true
    canInviteMembers?: true
    canManageMembers?: true
    canManageApiKeys?: true
    joinedAt?: true
    invitedBy?: true
  }

  export type WorkspaceUserMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    canCreateCanvas?: true
    canDeleteCanvas?: true
    canManageBilling?: true
    canInviteMembers?: true
    canManageMembers?: true
    canManageApiKeys?: true
    joinedAt?: true
    invitedBy?: true
  }

  export type WorkspaceUserCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    canCreateCanvas?: true
    canDeleteCanvas?: true
    canManageBilling?: true
    canInviteMembers?: true
    canManageMembers?: true
    canManageApiKeys?: true
    joinedAt?: true
    invitedBy?: true
    _all?: true
  }

  export type WorkspaceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUser to aggregate.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUsers
    **/
    _count?: true | WorkspaceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type GetWorkspaceUserAggregateType<T extends WorkspaceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUser[P]>
      : GetScalarType<T[P], AggregateWorkspaceUser[P]>
  }




  export type WorkspaceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithAggregationInput | WorkspaceUserOrderByWithAggregationInput[]
    by: WorkspaceUserScalarFieldEnum[] | WorkspaceUserScalarFieldEnum
    having?: WorkspaceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceUserCountAggregateInputType | true
    _min?: WorkspaceUserMinAggregateInputType
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type WorkspaceUserGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    role: $Enums.WorkspaceRole
    canCreateCanvas: boolean
    canDeleteCanvas: boolean
    canManageBilling: boolean
    canInviteMembers: boolean
    canManageMembers: boolean
    canManageApiKeys: boolean
    joinedAt: Date
    invitedBy: string | null
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  type GetWorkspaceUserGroupByPayload<T extends WorkspaceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
  }

  export type WorkspaceUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "workspaceId" | "role" | "canCreateCanvas" | "canDeleteCanvas" | "canManageBilling" | "canInviteMembers" | "canManageMembers" | "canManageApiKeys" | "joinedAt" | "invitedBy", ExtArgs["result"]["workspaceUser"]>
  export type WorkspaceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      role: $Enums.WorkspaceRole
      canCreateCanvas: boolean
      canDeleteCanvas: boolean
      canManageBilling: boolean
      canInviteMembers: boolean
      canManageMembers: boolean
      canManageApiKeys: boolean
      joinedAt: Date
      invitedBy: string | null
    }, ExtArgs["result"]["workspaceUser"]>
    composites: {}
  }

  type WorkspaceUserGetPayload<S extends boolean | null | undefined | WorkspaceUserDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserPayload, S>

  type WorkspaceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceUserCountAggregateInputType | true
    }

  export interface WorkspaceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUser'], meta: { name: 'WorkspaceUser' } }
    /**
     * Find zero or one WorkspaceUser that matches the filter.
     * @param {WorkspaceUserFindUniqueArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceUserFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany()
     * 
     * // Get first 10 WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserFindManyArgs>(args?: SelectSubset<T, WorkspaceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceUser.
     * @param {WorkspaceUserCreateArgs} args - Arguments to create a WorkspaceUser.
     * @example
     * // Create one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.create({
     *   data: {
     *     // ... data to create a WorkspaceUser
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserCreateArgs>(args: SelectSubset<T, WorkspaceUserCreateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceUsers.
     * @param {WorkspaceUserCreateManyArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUsers and returns the data saved in the database.
     * @param {WorkspaceUserCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceUser.
     * @param {WorkspaceUserDeleteArgs} args - Arguments to delete one WorkspaceUser.
     * @example
     * // Delete one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUser
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserDeleteArgs>(args: SelectSubset<T, WorkspaceUserDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceUser.
     * @param {WorkspaceUserUpdateArgs} args - Arguments to update one WorkspaceUser.
     * @example
     * // Update one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserUpdateArgs>(args: SelectSubset<T, WorkspaceUserUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceUsers.
     * @param {WorkspaceUserDeleteManyArgs} args - Arguments to filter WorkspaceUsers to delete.
     * @example
     * // Delete a few WorkspaceUsers
     * const { count } = await prisma.workspaceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers and returns the data updated in the database.
     * @param {WorkspaceUserUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceUsers.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUserUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceUser.
     * @param {WorkspaceUserUpsertArgs} args - Arguments to update or create a WorkspaceUser.
     * @example
     * // Update or create a WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUser we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserUpsertArgs>(args: SelectSubset<T, WorkspaceUserUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserCountArgs} args - Arguments to filter WorkspaceUsers to count.
     * @example
     * // Count the number of WorkspaceUsers
     * const count = await prisma.workspaceUser.count({
     *   where: {
     *     // ... the filter for the WorkspaceUsers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserCountArgs>(
      args?: Subset<T, WorkspaceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserAggregateArgs>(args: Subset<T, WorkspaceUserAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserAggregateType<T>>

    /**
     * Group by WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUser model
   */
  readonly fields: WorkspaceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUser model
   */
  interface WorkspaceUserFieldRefs {
    readonly id: FieldRef<"WorkspaceUser", 'String'>
    readonly userId: FieldRef<"WorkspaceUser", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceUser", 'String'>
    readonly role: FieldRef<"WorkspaceUser", 'WorkspaceRole'>
    readonly canCreateCanvas: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canDeleteCanvas: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canManageBilling: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canInviteMembers: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canManageMembers: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canManageApiKeys: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly joinedAt: FieldRef<"WorkspaceUser", 'DateTime'>
    readonly invitedBy: FieldRef<"WorkspaceUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUser findUnique
   */
  export type WorkspaceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findUniqueOrThrow
   */
  export type WorkspaceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findFirst
   */
  export type WorkspaceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findFirstOrThrow
   */
  export type WorkspaceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findMany
   */
  export type WorkspaceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUsers to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser create
   */
  export type WorkspaceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUser.
     */
    data: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
  }

  /**
   * WorkspaceUser createMany
   */
  export type WorkspaceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceUser createManyAndReturn
   */
  export type WorkspaceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser update
   */
  export type WorkspaceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUser.
     */
    data: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUser to update.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser updateMany
   */
  export type WorkspaceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to update.
     */
    limit?: number
  }

  /**
   * WorkspaceUser updateManyAndReturn
   */
  export type WorkspaceUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser upsert
   */
  export type WorkspaceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUser to update in case it exists.
     */
    where: WorkspaceUserWhereUniqueInput
    /**
     * In case the WorkspaceUser found by the `where` argument doesn't exist, create a new WorkspaceUser with this data.
     */
    create: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
    /**
     * In case the WorkspaceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
  }

  /**
   * WorkspaceUser delete
   */
  export type WorkspaceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUser to delete.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser deleteMany
   */
  export type WorkspaceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUsers to delete
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceUser without action
   */
  export type WorkspaceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceInvitation
   */

  export type AggregateWorkspaceInvitation = {
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  export type WorkspaceInvitationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: $Enums.WorkspaceRole | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type WorkspaceInvitationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: $Enums.WorkspaceRole | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type WorkspaceInvitationCountAggregateOutputType = {
    id: number
    workspaceId: number
    email: number
    role: number
    permissions: number
    invitedBy: number
    invitedUserId: number
    token: number
    status: number
    createdAt: number
    expiresAt: number
    acceptedAt: number
    _all: number
  }


  export type WorkspaceInvitationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type WorkspaceInvitationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type WorkspaceInvitationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    permissions?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type WorkspaceInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitation to aggregate.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceInvitations
    **/
    _count?: true | WorkspaceInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type GetWorkspaceInvitationAggregateType<T extends WorkspaceInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
      : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
  }




  export type WorkspaceInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithAggregationInput | WorkspaceInvitationOrderByWithAggregationInput[]
    by: WorkspaceInvitationScalarFieldEnum[] | WorkspaceInvitationScalarFieldEnum
    having?: WorkspaceInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceInvitationCountAggregateInputType | true
    _min?: WorkspaceInvitationMinAggregateInputType
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type WorkspaceInvitationGroupByOutputType = {
    id: string
    workspaceId: string
    email: string
    role: $Enums.WorkspaceRole
    permissions: JsonValue | null
    invitedBy: string
    invitedUserId: string | null
    token: string
    status: $Enums.InvitationStatus
    createdAt: Date
    expiresAt: Date
    acceptedAt: Date | null
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  type GetWorkspaceInvitationGroupByPayload<T extends WorkspaceInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
  }

  export type WorkspaceInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "email" | "role" | "permissions" | "invitedBy" | "invitedUserId" | "token" | "status" | "createdAt" | "expiresAt" | "acceptedAt", ExtArgs["result"]["workspaceInvitation"]>
  export type WorkspaceInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }

  export type $WorkspaceInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceInvitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      invitedUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      email: string
      role: $Enums.WorkspaceRole
      permissions: Prisma.JsonValue | null
      invitedBy: string
      invitedUserId: string | null
      token: string
      status: $Enums.InvitationStatus
      createdAt: Date
      expiresAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["workspaceInvitation"]>
    composites: {}
  }

  type WorkspaceInvitationGetPayload<S extends boolean | null | undefined | WorkspaceInvitationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceInvitationPayload, S>

  type WorkspaceInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceInvitationCountAggregateInputType | true
    }

  export interface WorkspaceInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceInvitation'], meta: { name: 'WorkspaceInvitation' } }
    /**
     * Find zero or one WorkspaceInvitation that matches the filter.
     * @param {WorkspaceInvitationFindUniqueArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceInvitationFindUniqueArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceInvitationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceInvitationFindFirstArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
     * 
     * // Get first 10 WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceInvitationFindManyArgs>(args?: SelectSubset<T, WorkspaceInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceInvitation.
     * @param {WorkspaceInvitationCreateArgs} args - Arguments to create a WorkspaceInvitation.
     * @example
     * // Create one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.create({
     *   data: {
     *     // ... data to create a WorkspaceInvitation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceInvitationCreateArgs>(args: SelectSubset<T, WorkspaceInvitationCreateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceInvitations.
     * @param {WorkspaceInvitationCreateManyArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceInvitationCreateManyArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceInvitations and returns the data saved in the database.
     * @param {WorkspaceInvitationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceInvitation.
     * @param {WorkspaceInvitationDeleteArgs} args - Arguments to delete one WorkspaceInvitation.
     * @example
     * // Delete one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceInvitation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceInvitationDeleteArgs>(args: SelectSubset<T, WorkspaceInvitationDeleteArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpdateArgs} args - Arguments to update one WorkspaceInvitation.
     * @example
     * // Update one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceInvitationUpdateArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceInvitations.
     * @param {WorkspaceInvitationDeleteManyArgs} args - Arguments to filter WorkspaceInvitations to delete.
     * @example
     * // Delete a few WorkspaceInvitations
     * const { count } = await prisma.workspaceInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceInvitationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceInvitationUpdateManyArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations and returns the data updated in the database.
     * @param {WorkspaceInvitationUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceInvitations.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpsertArgs} args - Arguments to update or create a WorkspaceInvitation.
     * @example
     * // Update or create a WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceInvitation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceInvitationUpsertArgs>(args: SelectSubset<T, WorkspaceInvitationUpsertArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationCountArgs} args - Arguments to filter WorkspaceInvitations to count.
     * @example
     * // Count the number of WorkspaceInvitations
     * const count = await prisma.workspaceInvitation.count({
     *   where: {
     *     // ... the filter for the WorkspaceInvitations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceInvitationCountArgs>(
      args?: Subset<T, WorkspaceInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceInvitationAggregateArgs>(args: Subset<T, WorkspaceInvitationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceInvitationAggregateType<T>>

    /**
     * Group by WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceInvitationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceInvitation model
   */
  readonly fields: WorkspaceInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitedUser<T extends WorkspaceInvitation$invitedUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceInvitation$invitedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceInvitation model
   */
  interface WorkspaceInvitationFieldRefs {
    readonly id: FieldRef<"WorkspaceInvitation", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceInvitation", 'String'>
    readonly email: FieldRef<"WorkspaceInvitation", 'String'>
    readonly role: FieldRef<"WorkspaceInvitation", 'WorkspaceRole'>
    readonly permissions: FieldRef<"WorkspaceInvitation", 'Json'>
    readonly invitedBy: FieldRef<"WorkspaceInvitation", 'String'>
    readonly invitedUserId: FieldRef<"WorkspaceInvitation", 'String'>
    readonly token: FieldRef<"WorkspaceInvitation", 'String'>
    readonly status: FieldRef<"WorkspaceInvitation", 'InvitationStatus'>
    readonly createdAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceInvitation findUnique
   */
  export type WorkspaceInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findUniqueOrThrow
   */
  export type WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findFirst
   */
  export type WorkspaceInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findFirstOrThrow
   */
  export type WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findMany
   */
  export type WorkspaceInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitations to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation create
   */
  export type WorkspaceInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
  }

  /**
   * WorkspaceInvitation createMany
   */
  export type WorkspaceInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceInvitation createManyAndReturn
   */
  export type WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation update
   */
  export type WorkspaceInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceInvitation to update.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation updateMany
   */
  export type WorkspaceInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to update.
     */
    limit?: number
  }

  /**
   * WorkspaceInvitation updateManyAndReturn
   */
  export type WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation upsert
   */
  export type WorkspaceInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceInvitation to update in case it exists.
     */
    where: WorkspaceInvitationWhereUniqueInput
    /**
     * In case the WorkspaceInvitation found by the `where` argument doesn't exist, create a new WorkspaceInvitation with this data.
     */
    create: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
    /**
     * In case the WorkspaceInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
  }

  /**
   * WorkspaceInvitation delete
   */
  export type WorkspaceInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceInvitation to delete.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation deleteMany
   */
  export type WorkspaceInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitations to delete
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceInvitation.invitedUser
   */
  export type WorkspaceInvitation$invitedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkspaceInvitation without action
   */
  export type WorkspaceInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
  }


  /**
   * Model ProviderAPIKey
   */

  export type AggregateProviderAPIKey = {
    _count: ProviderAPIKeyCountAggregateOutputType | null
    _min: ProviderAPIKeyMinAggregateOutputType | null
    _max: ProviderAPIKeyMaxAggregateOutputType | null
  }

  export type ProviderAPIKeyMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    provider: $Enums.LLMProvider | null
    displayName: string | null
    keyHash: string | null
    endpoint: string | null
    authType: $Enums.AuthType | null
    isActive: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ProviderAPIKeyMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    provider: $Enums.LLMProvider | null
    displayName: string | null
    keyHash: string | null
    endpoint: string | null
    authType: $Enums.AuthType | null
    isActive: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ProviderAPIKeyCountAggregateOutputType = {
    id: number
    workspaceId: number
    provider: number
    displayName: number
    keyHash: number
    providerConfig: number
    endpoint: number
    authType: number
    isActive: number
    lastUsedAt: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type ProviderAPIKeyMinAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    displayName?: true
    keyHash?: true
    endpoint?: true
    authType?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ProviderAPIKeyMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    displayName?: true
    keyHash?: true
    endpoint?: true
    authType?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ProviderAPIKeyCountAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    displayName?: true
    keyHash?: true
    providerConfig?: true
    endpoint?: true
    authType?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ProviderAPIKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderAPIKey to aggregate.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderAPIKeys
    **/
    _count?: true | ProviderAPIKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderAPIKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderAPIKeyMaxAggregateInputType
  }

  export type GetProviderAPIKeyAggregateType<T extends ProviderAPIKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderAPIKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderAPIKey[P]>
      : GetScalarType<T[P], AggregateProviderAPIKey[P]>
  }




  export type ProviderAPIKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderAPIKeyWhereInput
    orderBy?: ProviderAPIKeyOrderByWithAggregationInput | ProviderAPIKeyOrderByWithAggregationInput[]
    by: ProviderAPIKeyScalarFieldEnum[] | ProviderAPIKeyScalarFieldEnum
    having?: ProviderAPIKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderAPIKeyCountAggregateInputType | true
    _min?: ProviderAPIKeyMinAggregateInputType
    _max?: ProviderAPIKeyMaxAggregateInputType
  }

  export type ProviderAPIKeyGroupByOutputType = {
    id: string
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig: JsonValue | null
    endpoint: string | null
    authType: $Enums.AuthType
    isActive: boolean
    lastUsedAt: Date | null
    createdAt: Date
    expiresAt: Date | null
    _count: ProviderAPIKeyCountAggregateOutputType | null
    _min: ProviderAPIKeyMinAggregateOutputType | null
    _max: ProviderAPIKeyMaxAggregateOutputType | null
  }

  type GetProviderAPIKeyGroupByPayload<T extends ProviderAPIKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderAPIKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderAPIKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderAPIKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderAPIKeyGroupByOutputType[P]>
        }
      >
    >


  export type ProviderAPIKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerAPIKey"]>

  export type ProviderAPIKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerAPIKey"]>

  export type ProviderAPIKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerAPIKey"]>

  export type ProviderAPIKeySelectScalar = {
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type ProviderAPIKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "provider" | "displayName" | "keyHash" | "providerConfig" | "endpoint" | "authType" | "isActive" | "lastUsedAt" | "createdAt" | "expiresAt", ExtArgs["result"]["providerAPIKey"]>
  export type ProviderAPIKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProviderAPIKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProviderAPIKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ProviderAPIKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderAPIKey"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      provider: $Enums.LLMProvider
      displayName: string
      keyHash: string
      providerConfig: Prisma.JsonValue | null
      endpoint: string | null
      authType: $Enums.AuthType
      isActive: boolean
      lastUsedAt: Date | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["providerAPIKey"]>
    composites: {}
  }

  type ProviderAPIKeyGetPayload<S extends boolean | null | undefined | ProviderAPIKeyDefaultArgs> = $Result.GetResult<Prisma.$ProviderAPIKeyPayload, S>

  type ProviderAPIKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderAPIKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderAPIKeyCountAggregateInputType | true
    }

  export interface ProviderAPIKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderAPIKey'], meta: { name: 'ProviderAPIKey' } }
    /**
     * Find zero or one ProviderAPIKey that matches the filter.
     * @param {ProviderAPIKeyFindUniqueArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderAPIKeyFindUniqueArgs>(args: SelectSubset<T, ProviderAPIKeyFindUniqueArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderAPIKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderAPIKeyFindUniqueOrThrowArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderAPIKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderAPIKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderAPIKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyFindFirstArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderAPIKeyFindFirstArgs>(args?: SelectSubset<T, ProviderAPIKeyFindFirstArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderAPIKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyFindFirstOrThrowArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderAPIKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderAPIKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderAPIKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderAPIKeys
     * const providerAPIKeys = await prisma.providerAPIKey.findMany()
     * 
     * // Get first 10 ProviderAPIKeys
     * const providerAPIKeys = await prisma.providerAPIKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerAPIKeyWithIdOnly = await prisma.providerAPIKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderAPIKeyFindManyArgs>(args?: SelectSubset<T, ProviderAPIKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderAPIKey.
     * @param {ProviderAPIKeyCreateArgs} args - Arguments to create a ProviderAPIKey.
     * @example
     * // Create one ProviderAPIKey
     * const ProviderAPIKey = await prisma.providerAPIKey.create({
     *   data: {
     *     // ... data to create a ProviderAPIKey
     *   }
     * })
     * 
     */
    create<T extends ProviderAPIKeyCreateArgs>(args: SelectSubset<T, ProviderAPIKeyCreateArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderAPIKeys.
     * @param {ProviderAPIKeyCreateManyArgs} args - Arguments to create many ProviderAPIKeys.
     * @example
     * // Create many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderAPIKeyCreateManyArgs>(args?: SelectSubset<T, ProviderAPIKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderAPIKeys and returns the data saved in the database.
     * @param {ProviderAPIKeyCreateManyAndReturnArgs} args - Arguments to create many ProviderAPIKeys.
     * @example
     * // Create many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderAPIKeys and only return the `id`
     * const providerAPIKeyWithIdOnly = await prisma.providerAPIKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderAPIKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderAPIKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderAPIKey.
     * @param {ProviderAPIKeyDeleteArgs} args - Arguments to delete one ProviderAPIKey.
     * @example
     * // Delete one ProviderAPIKey
     * const ProviderAPIKey = await prisma.providerAPIKey.delete({
     *   where: {
     *     // ... filter to delete one ProviderAPIKey
     *   }
     * })
     * 
     */
    delete<T extends ProviderAPIKeyDeleteArgs>(args: SelectSubset<T, ProviderAPIKeyDeleteArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderAPIKey.
     * @param {ProviderAPIKeyUpdateArgs} args - Arguments to update one ProviderAPIKey.
     * @example
     * // Update one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderAPIKeyUpdateArgs>(args: SelectSubset<T, ProviderAPIKeyUpdateArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderAPIKeys.
     * @param {ProviderAPIKeyDeleteManyArgs} args - Arguments to filter ProviderAPIKeys to delete.
     * @example
     * // Delete a few ProviderAPIKeys
     * const { count } = await prisma.providerAPIKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderAPIKeyDeleteManyArgs>(args?: SelectSubset<T, ProviderAPIKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderAPIKeyUpdateManyArgs>(args: SelectSubset<T, ProviderAPIKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderAPIKeys and returns the data updated in the database.
     * @param {ProviderAPIKeyUpdateManyAndReturnArgs} args - Arguments to update many ProviderAPIKeys.
     * @example
     * // Update many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderAPIKeys and only return the `id`
     * const providerAPIKeyWithIdOnly = await prisma.providerAPIKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderAPIKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderAPIKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderAPIKey.
     * @param {ProviderAPIKeyUpsertArgs} args - Arguments to update or create a ProviderAPIKey.
     * @example
     * // Update or create a ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.upsert({
     *   create: {
     *     // ... data to create a ProviderAPIKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderAPIKey we want to update
     *   }
     * })
     */
    upsert<T extends ProviderAPIKeyUpsertArgs>(args: SelectSubset<T, ProviderAPIKeyUpsertArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyCountArgs} args - Arguments to filter ProviderAPIKeys to count.
     * @example
     * // Count the number of ProviderAPIKeys
     * const count = await prisma.providerAPIKey.count({
     *   where: {
     *     // ... the filter for the ProviderAPIKeys we want to count
     *   }
     * })
    **/
    count<T extends ProviderAPIKeyCountArgs>(
      args?: Subset<T, ProviderAPIKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderAPIKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAPIKeyAggregateArgs>(args: Subset<T, ProviderAPIKeyAggregateArgs>): Prisma.PrismaPromise<GetProviderAPIKeyAggregateType<T>>

    /**
     * Group by ProviderAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderAPIKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderAPIKeyGroupByArgs['orderBy'] }
        : { orderBy?: ProviderAPIKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderAPIKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderAPIKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderAPIKey model
   */
  readonly fields: ProviderAPIKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderAPIKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderAPIKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderAPIKey model
   */
  interface ProviderAPIKeyFieldRefs {
    readonly id: FieldRef<"ProviderAPIKey", 'String'>
    readonly workspaceId: FieldRef<"ProviderAPIKey", 'String'>
    readonly provider: FieldRef<"ProviderAPIKey", 'LLMProvider'>
    readonly displayName: FieldRef<"ProviderAPIKey", 'String'>
    readonly keyHash: FieldRef<"ProviderAPIKey", 'String'>
    readonly providerConfig: FieldRef<"ProviderAPIKey", 'Json'>
    readonly endpoint: FieldRef<"ProviderAPIKey", 'String'>
    readonly authType: FieldRef<"ProviderAPIKey", 'AuthType'>
    readonly isActive: FieldRef<"ProviderAPIKey", 'Boolean'>
    readonly lastUsedAt: FieldRef<"ProviderAPIKey", 'DateTime'>
    readonly createdAt: FieldRef<"ProviderAPIKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ProviderAPIKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderAPIKey findUnique
   */
  export type ProviderAPIKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey findUniqueOrThrow
   */
  export type ProviderAPIKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey findFirst
   */
  export type ProviderAPIKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderAPIKeys.
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderAPIKeys.
     */
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * ProviderAPIKey findFirstOrThrow
   */
  export type ProviderAPIKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderAPIKeys.
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderAPIKeys.
     */
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * ProviderAPIKey findMany
   */
  export type ProviderAPIKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKeys to fetch.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderAPIKeys.
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * ProviderAPIKey create
   */
  export type ProviderAPIKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderAPIKey.
     */
    data: XOR<ProviderAPIKeyCreateInput, ProviderAPIKeyUncheckedCreateInput>
  }

  /**
   * ProviderAPIKey createMany
   */
  export type ProviderAPIKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderAPIKeys.
     */
    data: ProviderAPIKeyCreateManyInput | ProviderAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderAPIKey createManyAndReturn
   */
  export type ProviderAPIKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderAPIKeys.
     */
    data: ProviderAPIKeyCreateManyInput | ProviderAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderAPIKey update
   */
  export type ProviderAPIKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderAPIKey.
     */
    data: XOR<ProviderAPIKeyUpdateInput, ProviderAPIKeyUncheckedUpdateInput>
    /**
     * Choose, which ProviderAPIKey to update.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey updateMany
   */
  export type ProviderAPIKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderAPIKeys.
     */
    data: XOR<ProviderAPIKeyUpdateManyMutationInput, ProviderAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderAPIKeys to update
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * Limit how many ProviderAPIKeys to update.
     */
    limit?: number
  }

  /**
   * ProviderAPIKey updateManyAndReturn
   */
  export type ProviderAPIKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to update ProviderAPIKeys.
     */
    data: XOR<ProviderAPIKeyUpdateManyMutationInput, ProviderAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderAPIKeys to update
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * Limit how many ProviderAPIKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderAPIKey upsert
   */
  export type ProviderAPIKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderAPIKey to update in case it exists.
     */
    where: ProviderAPIKeyWhereUniqueInput
    /**
     * In case the ProviderAPIKey found by the `where` argument doesn't exist, create a new ProviderAPIKey with this data.
     */
    create: XOR<ProviderAPIKeyCreateInput, ProviderAPIKeyUncheckedCreateInput>
    /**
     * In case the ProviderAPIKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderAPIKeyUpdateInput, ProviderAPIKeyUncheckedUpdateInput>
  }

  /**
   * ProviderAPIKey delete
   */
  export type ProviderAPIKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter which ProviderAPIKey to delete.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey deleteMany
   */
  export type ProviderAPIKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderAPIKeys to delete
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * Limit how many ProviderAPIKeys to delete.
     */
    limit?: number
  }

  /**
   * ProviderAPIKey without action
   */
  export type ProviderAPIKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
  }


  /**
   * Model ShareLink
   */

  export type AggregateShareLink = {
    _count: ShareLinkCountAggregateOutputType | null
    _avg: ShareLinkAvgAggregateOutputType | null
    _sum: ShareLinkSumAggregateOutputType | null
    _min: ShareLinkMinAggregateOutputType | null
    _max: ShareLinkMaxAggregateOutputType | null
  }

  export type ShareLinkAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type ShareLinkSumAggregateOutputType = {
    viewCount: number | null
  }

  export type ShareLinkMinAggregateOutputType = {
    id: string | null
    publicToken: string | null
    assetType: $Enums.ShareableAssetType | null
    assetId: string | null
    workspaceId: string | null
    createdBy: string | null
    accessLevel: $Enums.ShareAccessLevel | null
    password: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ShareLinkMaxAggregateOutputType = {
    id: string | null
    publicToken: string | null
    assetType: $Enums.ShareableAssetType | null
    assetId: string | null
    workspaceId: string | null
    createdBy: string | null
    accessLevel: $Enums.ShareAccessLevel | null
    password: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ShareLinkCountAggregateOutputType = {
    id: number
    publicToken: number
    assetType: number
    assetId: number
    workspaceId: number
    createdBy: number
    accessLevel: number
    password: number
    viewCount: number
    lastViewedAt: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type ShareLinkAvgAggregateInputType = {
    viewCount?: true
  }

  export type ShareLinkSumAggregateInputType = {
    viewCount?: true
  }

  export type ShareLinkMinAggregateInputType = {
    id?: true
    publicToken?: true
    assetType?: true
    assetId?: true
    workspaceId?: true
    createdBy?: true
    accessLevel?: true
    password?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ShareLinkMaxAggregateInputType = {
    id?: true
    publicToken?: true
    assetType?: true
    assetId?: true
    workspaceId?: true
    createdBy?: true
    accessLevel?: true
    password?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ShareLinkCountAggregateInputType = {
    id?: true
    publicToken?: true
    assetType?: true
    assetId?: true
    workspaceId?: true
    createdBy?: true
    accessLevel?: true
    password?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ShareLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareLink to aggregate.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareLinks
    **/
    _count?: true | ShareLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareLinkMaxAggregateInputType
  }

  export type GetShareLinkAggregateType<T extends ShareLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateShareLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareLink[P]>
      : GetScalarType<T[P], AggregateShareLink[P]>
  }




  export type ShareLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithAggregationInput | ShareLinkOrderByWithAggregationInput[]
    by: ShareLinkScalarFieldEnum[] | ShareLinkScalarFieldEnum
    having?: ShareLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareLinkCountAggregateInputType | true
    _avg?: ShareLinkAvgAggregateInputType
    _sum?: ShareLinkSumAggregateInputType
    _min?: ShareLinkMinAggregateInputType
    _max?: ShareLinkMaxAggregateInputType
  }

  export type ShareLinkGroupByOutputType = {
    id: string
    publicToken: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    workspaceId: string
    createdBy: string
    accessLevel: $Enums.ShareAccessLevel
    password: string | null
    viewCount: number
    lastViewedAt: Date | null
    createdAt: Date
    expiresAt: Date | null
    _count: ShareLinkCountAggregateOutputType | null
    _avg: ShareLinkAvgAggregateOutputType | null
    _sum: ShareLinkSumAggregateOutputType | null
    _min: ShareLinkMinAggregateOutputType | null
    _max: ShareLinkMaxAggregateOutputType | null
  }

  type GetShareLinkGroupByPayload<T extends ShareLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
        }
      >
    >


  export type ShareLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectScalar = {
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type ShareLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicToken" | "assetType" | "assetId" | "workspaceId" | "createdBy" | "accessLevel" | "password" | "viewCount" | "lastViewedAt" | "createdAt" | "expiresAt", ExtArgs["result"]["shareLink"]>
  export type ShareLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ShareLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ShareLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ShareLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareLink"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publicToken: string
      assetType: $Enums.ShareableAssetType
      assetId: string
      workspaceId: string
      createdBy: string
      accessLevel: $Enums.ShareAccessLevel
      password: string | null
      viewCount: number
      lastViewedAt: Date | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["shareLink"]>
    composites: {}
  }

  type ShareLinkGetPayload<S extends boolean | null | undefined | ShareLinkDefaultArgs> = $Result.GetResult<Prisma.$ShareLinkPayload, S>

  type ShareLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareLinkCountAggregateInputType | true
    }

  export interface ShareLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareLink'], meta: { name: 'ShareLink' } }
    /**
     * Find zero or one ShareLink that matches the filter.
     * @param {ShareLinkFindUniqueArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareLinkFindUniqueArgs>(args: SelectSubset<T, ShareLinkFindUniqueArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShareLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareLinkFindUniqueOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareLinkFindFirstArgs>(args?: SelectSubset<T, ShareLinkFindFirstArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShareLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareLinks
     * const shareLinks = await prisma.shareLink.findMany()
     * 
     * // Get first 10 ShareLinks
     * const shareLinks = await prisma.shareLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareLinkFindManyArgs>(args?: SelectSubset<T, ShareLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShareLink.
     * @param {ShareLinkCreateArgs} args - Arguments to create a ShareLink.
     * @example
     * // Create one ShareLink
     * const ShareLink = await prisma.shareLink.create({
     *   data: {
     *     // ... data to create a ShareLink
     *   }
     * })
     * 
     */
    create<T extends ShareLinkCreateArgs>(args: SelectSubset<T, ShareLinkCreateArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShareLinks.
     * @param {ShareLinkCreateManyArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareLinkCreateManyArgs>(args?: SelectSubset<T, ShareLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShareLinks and returns the data saved in the database.
     * @param {ShareLinkCreateManyAndReturnArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShareLink.
     * @param {ShareLinkDeleteArgs} args - Arguments to delete one ShareLink.
     * @example
     * // Delete one ShareLink
     * const ShareLink = await prisma.shareLink.delete({
     *   where: {
     *     // ... filter to delete one ShareLink
     *   }
     * })
     * 
     */
    delete<T extends ShareLinkDeleteArgs>(args: SelectSubset<T, ShareLinkDeleteArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShareLink.
     * @param {ShareLinkUpdateArgs} args - Arguments to update one ShareLink.
     * @example
     * // Update one ShareLink
     * const shareLink = await prisma.shareLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareLinkUpdateArgs>(args: SelectSubset<T, ShareLinkUpdateArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShareLinks.
     * @param {ShareLinkDeleteManyArgs} args - Arguments to filter ShareLinks to delete.
     * @example
     * // Delete a few ShareLinks
     * const { count } = await prisma.shareLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareLinkDeleteManyArgs>(args?: SelectSubset<T, ShareLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareLinkUpdateManyArgs>(args: SelectSubset<T, ShareLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareLinks and returns the data updated in the database.
     * @param {ShareLinkUpdateManyAndReturnArgs} args - Arguments to update many ShareLinks.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShareLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, ShareLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShareLink.
     * @param {ShareLinkUpsertArgs} args - Arguments to update or create a ShareLink.
     * @example
     * // Update or create a ShareLink
     * const shareLink = await prisma.shareLink.upsert({
     *   create: {
     *     // ... data to create a ShareLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareLink we want to update
     *   }
     * })
     */
    upsert<T extends ShareLinkUpsertArgs>(args: SelectSubset<T, ShareLinkUpsertArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkCountArgs} args - Arguments to filter ShareLinks to count.
     * @example
     * // Count the number of ShareLinks
     * const count = await prisma.shareLink.count({
     *   where: {
     *     // ... the filter for the ShareLinks we want to count
     *   }
     * })
    **/
    count<T extends ShareLinkCountArgs>(
      args?: Subset<T, ShareLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareLinkAggregateArgs>(args: Subset<T, ShareLinkAggregateArgs>): Prisma.PrismaPromise<GetShareLinkAggregateType<T>>

    /**
     * Group by ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareLinkGroupByArgs['orderBy'] }
        : { orderBy?: ShareLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareLink model
   */
  readonly fields: ShareLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareLink model
   */
  interface ShareLinkFieldRefs {
    readonly id: FieldRef<"ShareLink", 'String'>
    readonly publicToken: FieldRef<"ShareLink", 'String'>
    readonly assetType: FieldRef<"ShareLink", 'ShareableAssetType'>
    readonly assetId: FieldRef<"ShareLink", 'String'>
    readonly workspaceId: FieldRef<"ShareLink", 'String'>
    readonly createdBy: FieldRef<"ShareLink", 'String'>
    readonly accessLevel: FieldRef<"ShareLink", 'ShareAccessLevel'>
    readonly password: FieldRef<"ShareLink", 'String'>
    readonly viewCount: FieldRef<"ShareLink", 'Int'>
    readonly lastViewedAt: FieldRef<"ShareLink", 'DateTime'>
    readonly createdAt: FieldRef<"ShareLink", 'DateTime'>
    readonly expiresAt: FieldRef<"ShareLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareLink findUnique
   */
  export type ShareLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink findUniqueOrThrow
   */
  export type ShareLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink findFirst
   */
  export type ShareLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink findFirstOrThrow
   */
  export type ShareLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink findMany
   */
  export type ShareLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLinks to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink create
   */
  export type ShareLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareLink.
     */
    data: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>
  }

  /**
   * ShareLink createMany
   */
  export type ShareLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShareLink createManyAndReturn
   */
  export type ShareLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareLink update
   */
  export type ShareLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareLink.
     */
    data: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>
    /**
     * Choose, which ShareLink to update.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink updateMany
   */
  export type ShareLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number
  }

  /**
   * ShareLink updateManyAndReturn
   */
  export type ShareLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareLink upsert
   */
  export type ShareLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareLink to update in case it exists.
     */
    where: ShareLinkWhereUniqueInput
    /**
     * In case the ShareLink found by the `where` argument doesn't exist, create a new ShareLink with this data.
     */
    create: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>
    /**
     * In case the ShareLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>
  }

  /**
   * ShareLink delete
   */
  export type ShareLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter which ShareLink to delete.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink deleteMany
   */
  export type ShareLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareLinks to delete
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to delete.
     */
    limit?: number
  }

  /**
   * ShareLink without action
   */
  export type ShareLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
  }


  /**
   * Model DocumentFolder
   */

  export type AggregateDocumentFolder = {
    _count: DocumentFolderCountAggregateOutputType | null
    _avg: DocumentFolderAvgAggregateOutputType | null
    _sum: DocumentFolderSumAggregateOutputType | null
    _min: DocumentFolderMinAggregateOutputType | null
    _max: DocumentFolderMaxAggregateOutputType | null
  }

  export type DocumentFolderAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type DocumentFolderSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type DocumentFolderMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    parentId: string | null
    icon: string | null
    color: string | null
    sortOrder: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentFolderMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    parentId: string | null
    icon: string | null
    color: string | null
    sortOrder: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentFolderCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    parentId: number
    icon: number
    color: number
    sortOrder: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentFolderAvgAggregateInputType = {
    sortOrder?: true
  }

  export type DocumentFolderSumAggregateInputType = {
    sortOrder?: true
  }

  export type DocumentFolderMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    parentId?: true
    icon?: true
    color?: true
    sortOrder?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentFolderMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    parentId?: true
    icon?: true
    color?: true
    sortOrder?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentFolderCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    parentId?: true
    icon?: true
    color?: true
    sortOrder?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentFolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentFolder to aggregate.
     */
    where?: DocumentFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFolders to fetch.
     */
    orderBy?: DocumentFolderOrderByWithRelationInput | DocumentFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentFolders
    **/
    _count?: true | DocumentFolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentFolderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentFolderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentFolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentFolderMaxAggregateInputType
  }

  export type GetDocumentFolderAggregateType<T extends DocumentFolderAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentFolder[P]>
      : GetScalarType<T[P], AggregateDocumentFolder[P]>
  }




  export type DocumentFolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentFolderWhereInput
    orderBy?: DocumentFolderOrderByWithAggregationInput | DocumentFolderOrderByWithAggregationInput[]
    by: DocumentFolderScalarFieldEnum[] | DocumentFolderScalarFieldEnum
    having?: DocumentFolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentFolderCountAggregateInputType | true
    _avg?: DocumentFolderAvgAggregateInputType
    _sum?: DocumentFolderSumAggregateInputType
    _min?: DocumentFolderMinAggregateInputType
    _max?: DocumentFolderMaxAggregateInputType
  }

  export type DocumentFolderGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    parentId: string | null
    icon: string | null
    color: string | null
    sortOrder: number
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentFolderCountAggregateOutputType | null
    _avg: DocumentFolderAvgAggregateOutputType | null
    _sum: DocumentFolderSumAggregateOutputType | null
    _min: DocumentFolderMinAggregateOutputType | null
    _max: DocumentFolderMaxAggregateOutputType | null
  }

  type GetDocumentFolderGroupByPayload<T extends DocumentFolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentFolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentFolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentFolderGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentFolderGroupByOutputType[P]>
        }
      >
    >


  export type DocumentFolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    parentId?: boolean
    icon?: boolean
    color?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | DocumentFolder$parentArgs<ExtArgs>
    children?: boolean | DocumentFolder$childrenArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    documents?: boolean | DocumentFolder$documentsArgs<ExtArgs>
    _count?: boolean | DocumentFolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentFolder"]>

  export type DocumentFolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    parentId?: boolean
    icon?: boolean
    color?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | DocumentFolder$parentArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentFolder"]>

  export type DocumentFolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    parentId?: boolean
    icon?: boolean
    color?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | DocumentFolder$parentArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentFolder"]>

  export type DocumentFolderSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    parentId?: boolean
    icon?: boolean
    color?: boolean
    sortOrder?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentFolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "parentId" | "icon" | "color" | "sortOrder" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["documentFolder"]>
  export type DocumentFolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | DocumentFolder$parentArgs<ExtArgs>
    children?: boolean | DocumentFolder$childrenArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    documents?: boolean | DocumentFolder$documentsArgs<ExtArgs>
    _count?: boolean | DocumentFolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentFolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | DocumentFolder$parentArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type DocumentFolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | DocumentFolder$parentArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $DocumentFolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentFolder"
    objects: {
      parent: Prisma.$DocumentFolderPayload<ExtArgs> | null
      children: Prisma.$DocumentFolderPayload<ExtArgs>[]
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      parentId: string | null
      icon: string | null
      color: string | null
      sortOrder: number
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentFolder"]>
    composites: {}
  }

  type DocumentFolderGetPayload<S extends boolean | null | undefined | DocumentFolderDefaultArgs> = $Result.GetResult<Prisma.$DocumentFolderPayload, S>

  type DocumentFolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentFolderCountAggregateInputType | true
    }

  export interface DocumentFolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentFolder'], meta: { name: 'DocumentFolder' } }
    /**
     * Find zero or one DocumentFolder that matches the filter.
     * @param {DocumentFolderFindUniqueArgs} args - Arguments to find a DocumentFolder
     * @example
     * // Get one DocumentFolder
     * const documentFolder = await prisma.documentFolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFolderFindUniqueArgs>(args: SelectSubset<T, DocumentFolderFindUniqueArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentFolder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFolderFindUniqueOrThrowArgs} args - Arguments to find a DocumentFolder
     * @example
     * // Get one DocumentFolder
     * const documentFolder = await prisma.documentFolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFolderFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentFolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderFindFirstArgs} args - Arguments to find a DocumentFolder
     * @example
     * // Get one DocumentFolder
     * const documentFolder = await prisma.documentFolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFolderFindFirstArgs>(args?: SelectSubset<T, DocumentFolderFindFirstArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentFolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderFindFirstOrThrowArgs} args - Arguments to find a DocumentFolder
     * @example
     * // Get one DocumentFolder
     * const documentFolder = await prisma.documentFolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFolderFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentFolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentFolders
     * const documentFolders = await prisma.documentFolder.findMany()
     * 
     * // Get first 10 DocumentFolders
     * const documentFolders = await prisma.documentFolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentFolderWithIdOnly = await prisma.documentFolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFolderFindManyArgs>(args?: SelectSubset<T, DocumentFolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentFolder.
     * @param {DocumentFolderCreateArgs} args - Arguments to create a DocumentFolder.
     * @example
     * // Create one DocumentFolder
     * const DocumentFolder = await prisma.documentFolder.create({
     *   data: {
     *     // ... data to create a DocumentFolder
     *   }
     * })
     * 
     */
    create<T extends DocumentFolderCreateArgs>(args: SelectSubset<T, DocumentFolderCreateArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentFolders.
     * @param {DocumentFolderCreateManyArgs} args - Arguments to create many DocumentFolders.
     * @example
     * // Create many DocumentFolders
     * const documentFolder = await prisma.documentFolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentFolderCreateManyArgs>(args?: SelectSubset<T, DocumentFolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentFolders and returns the data saved in the database.
     * @param {DocumentFolderCreateManyAndReturnArgs} args - Arguments to create many DocumentFolders.
     * @example
     * // Create many DocumentFolders
     * const documentFolder = await prisma.documentFolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentFolders and only return the `id`
     * const documentFolderWithIdOnly = await prisma.documentFolder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentFolderCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentFolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentFolder.
     * @param {DocumentFolderDeleteArgs} args - Arguments to delete one DocumentFolder.
     * @example
     * // Delete one DocumentFolder
     * const DocumentFolder = await prisma.documentFolder.delete({
     *   where: {
     *     // ... filter to delete one DocumentFolder
     *   }
     * })
     * 
     */
    delete<T extends DocumentFolderDeleteArgs>(args: SelectSubset<T, DocumentFolderDeleteArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentFolder.
     * @param {DocumentFolderUpdateArgs} args - Arguments to update one DocumentFolder.
     * @example
     * // Update one DocumentFolder
     * const documentFolder = await prisma.documentFolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentFolderUpdateArgs>(args: SelectSubset<T, DocumentFolderUpdateArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentFolders.
     * @param {DocumentFolderDeleteManyArgs} args - Arguments to filter DocumentFolders to delete.
     * @example
     * // Delete a few DocumentFolders
     * const { count } = await prisma.documentFolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentFolderDeleteManyArgs>(args?: SelectSubset<T, DocumentFolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentFolders
     * const documentFolder = await prisma.documentFolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentFolderUpdateManyArgs>(args: SelectSubset<T, DocumentFolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentFolders and returns the data updated in the database.
     * @param {DocumentFolderUpdateManyAndReturnArgs} args - Arguments to update many DocumentFolders.
     * @example
     * // Update many DocumentFolders
     * const documentFolder = await prisma.documentFolder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentFolders and only return the `id`
     * const documentFolderWithIdOnly = await prisma.documentFolder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentFolderUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentFolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentFolder.
     * @param {DocumentFolderUpsertArgs} args - Arguments to update or create a DocumentFolder.
     * @example
     * // Update or create a DocumentFolder
     * const documentFolder = await prisma.documentFolder.upsert({
     *   create: {
     *     // ... data to create a DocumentFolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentFolder we want to update
     *   }
     * })
     */
    upsert<T extends DocumentFolderUpsertArgs>(args: SelectSubset<T, DocumentFolderUpsertArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderCountArgs} args - Arguments to filter DocumentFolders to count.
     * @example
     * // Count the number of DocumentFolders
     * const count = await prisma.documentFolder.count({
     *   where: {
     *     // ... the filter for the DocumentFolders we want to count
     *   }
     * })
    **/
    count<T extends DocumentFolderCountArgs>(
      args?: Subset<T, DocumentFolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentFolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentFolderAggregateArgs>(args: Subset<T, DocumentFolderAggregateArgs>): Prisma.PrismaPromise<GetDocumentFolderAggregateType<T>>

    /**
     * Group by DocumentFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentFolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentFolderGroupByArgs['orderBy'] }
        : { orderBy?: DocumentFolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentFolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentFolder model
   */
  readonly fields: DocumentFolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentFolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentFolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends DocumentFolder$parentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentFolder$parentArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends DocumentFolder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, DocumentFolder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends DocumentFolder$documentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentFolder$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentFolder model
   */
  interface DocumentFolderFieldRefs {
    readonly id: FieldRef<"DocumentFolder", 'String'>
    readonly workspaceId: FieldRef<"DocumentFolder", 'String'>
    readonly name: FieldRef<"DocumentFolder", 'String'>
    readonly parentId: FieldRef<"DocumentFolder", 'String'>
    readonly icon: FieldRef<"DocumentFolder", 'String'>
    readonly color: FieldRef<"DocumentFolder", 'String'>
    readonly sortOrder: FieldRef<"DocumentFolder", 'Int'>
    readonly createdBy: FieldRef<"DocumentFolder", 'String'>
    readonly createdAt: FieldRef<"DocumentFolder", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentFolder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentFolder findUnique
   */
  export type DocumentFolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFolder to fetch.
     */
    where: DocumentFolderWhereUniqueInput
  }

  /**
   * DocumentFolder findUniqueOrThrow
   */
  export type DocumentFolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFolder to fetch.
     */
    where: DocumentFolderWhereUniqueInput
  }

  /**
   * DocumentFolder findFirst
   */
  export type DocumentFolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFolder to fetch.
     */
    where?: DocumentFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFolders to fetch.
     */
    orderBy?: DocumentFolderOrderByWithRelationInput | DocumentFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentFolders.
     */
    cursor?: DocumentFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentFolders.
     */
    distinct?: DocumentFolderScalarFieldEnum | DocumentFolderScalarFieldEnum[]
  }

  /**
   * DocumentFolder findFirstOrThrow
   */
  export type DocumentFolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFolder to fetch.
     */
    where?: DocumentFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFolders to fetch.
     */
    orderBy?: DocumentFolderOrderByWithRelationInput | DocumentFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentFolders.
     */
    cursor?: DocumentFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentFolders.
     */
    distinct?: DocumentFolderScalarFieldEnum | DocumentFolderScalarFieldEnum[]
  }

  /**
   * DocumentFolder findMany
   */
  export type DocumentFolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFolders to fetch.
     */
    where?: DocumentFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFolders to fetch.
     */
    orderBy?: DocumentFolderOrderByWithRelationInput | DocumentFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentFolders.
     */
    cursor?: DocumentFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFolders.
     */
    skip?: number
    distinct?: DocumentFolderScalarFieldEnum | DocumentFolderScalarFieldEnum[]
  }

  /**
   * DocumentFolder create
   */
  export type DocumentFolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentFolder.
     */
    data: XOR<DocumentFolderCreateInput, DocumentFolderUncheckedCreateInput>
  }

  /**
   * DocumentFolder createMany
   */
  export type DocumentFolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentFolders.
     */
    data: DocumentFolderCreateManyInput | DocumentFolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentFolder createManyAndReturn
   */
  export type DocumentFolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentFolders.
     */
    data: DocumentFolderCreateManyInput | DocumentFolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentFolder update
   */
  export type DocumentFolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentFolder.
     */
    data: XOR<DocumentFolderUpdateInput, DocumentFolderUncheckedUpdateInput>
    /**
     * Choose, which DocumentFolder to update.
     */
    where: DocumentFolderWhereUniqueInput
  }

  /**
   * DocumentFolder updateMany
   */
  export type DocumentFolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentFolders.
     */
    data: XOR<DocumentFolderUpdateManyMutationInput, DocumentFolderUncheckedUpdateManyInput>
    /**
     * Filter which DocumentFolders to update
     */
    where?: DocumentFolderWhereInput
    /**
     * Limit how many DocumentFolders to update.
     */
    limit?: number
  }

  /**
   * DocumentFolder updateManyAndReturn
   */
  export type DocumentFolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * The data used to update DocumentFolders.
     */
    data: XOR<DocumentFolderUpdateManyMutationInput, DocumentFolderUncheckedUpdateManyInput>
    /**
     * Filter which DocumentFolders to update
     */
    where?: DocumentFolderWhereInput
    /**
     * Limit how many DocumentFolders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentFolder upsert
   */
  export type DocumentFolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentFolder to update in case it exists.
     */
    where: DocumentFolderWhereUniqueInput
    /**
     * In case the DocumentFolder found by the `where` argument doesn't exist, create a new DocumentFolder with this data.
     */
    create: XOR<DocumentFolderCreateInput, DocumentFolderUncheckedCreateInput>
    /**
     * In case the DocumentFolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentFolderUpdateInput, DocumentFolderUncheckedUpdateInput>
  }

  /**
   * DocumentFolder delete
   */
  export type DocumentFolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    /**
     * Filter which DocumentFolder to delete.
     */
    where: DocumentFolderWhereUniqueInput
  }

  /**
   * DocumentFolder deleteMany
   */
  export type DocumentFolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentFolders to delete
     */
    where?: DocumentFolderWhereInput
    /**
     * Limit how many DocumentFolders to delete.
     */
    limit?: number
  }

  /**
   * DocumentFolder.parent
   */
  export type DocumentFolder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    where?: DocumentFolderWhereInput
  }

  /**
   * DocumentFolder.children
   */
  export type DocumentFolder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    where?: DocumentFolderWhereInput
    orderBy?: DocumentFolderOrderByWithRelationInput | DocumentFolderOrderByWithRelationInput[]
    cursor?: DocumentFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentFolderScalarFieldEnum | DocumentFolderScalarFieldEnum[]
  }

  /**
   * DocumentFolder.documents
   */
  export type DocumentFolder$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * DocumentFolder without action
   */
  export type DocumentFolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    sizeInBytes: number | null
  }

  export type DocumentSumAggregateOutputType = {
    sizeInBytes: bigint | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    folderId: string | null
    name: string | null
    sourceType: $Enums.DocumentSourceType | null
    storageKey: string | null
    s3Bucket: string | null
    externalUrl: string | null
    externalProvider: string | null
    externalFileId: string | null
    fileType: string | null
    mimeType: string | null
    sizeInBytes: bigint | null
    status: $Enums.DocumentStatus | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    folderId: string | null
    name: string | null
    sourceType: $Enums.DocumentSourceType | null
    storageKey: string | null
    s3Bucket: string | null
    externalUrl: string | null
    externalProvider: string | null
    externalFileId: string | null
    fileType: string | null
    mimeType: string | null
    sizeInBytes: bigint | null
    status: $Enums.DocumentStatus | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    workspaceId: number
    folderId: number
    name: number
    sourceType: number
    storageKey: number
    s3Bucket: number
    externalUrl: number
    externalProvider: number
    externalFileId: number
    fileType: number
    mimeType: number
    sizeInBytes: number
    status: number
    uploadedBy: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    sizeInBytes?: true
  }

  export type DocumentSumAggregateInputType = {
    sizeInBytes?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    workspaceId?: true
    folderId?: true
    name?: true
    sourceType?: true
    storageKey?: true
    s3Bucket?: true
    externalUrl?: true
    externalProvider?: true
    externalFileId?: true
    fileType?: true
    mimeType?: true
    sizeInBytes?: true
    status?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    folderId?: true
    name?: true
    sourceType?: true
    storageKey?: true
    s3Bucket?: true
    externalUrl?: true
    externalProvider?: true
    externalFileId?: true
    fileType?: true
    mimeType?: true
    sizeInBytes?: true
    status?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    workspaceId?: true
    folderId?: true
    name?: true
    sourceType?: true
    storageKey?: true
    s3Bucket?: true
    externalUrl?: true
    externalProvider?: true
    externalFileId?: true
    fileType?: true
    mimeType?: true
    sizeInBytes?: true
    status?: true
    uploadedBy?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    workspaceId: string
    folderId: string | null
    name: string
    sourceType: $Enums.DocumentSourceType
    storageKey: string | null
    s3Bucket: string | null
    externalUrl: string | null
    externalProvider: string | null
    externalFileId: string | null
    fileType: string
    mimeType: string | null
    sizeInBytes: bigint | null
    status: $Enums.DocumentStatus
    uploadedBy: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    folderId?: boolean
    name?: boolean
    sourceType?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    externalUrl?: boolean
    externalProvider?: boolean
    externalFileId?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    embeddings?: boolean | Document$embeddingsArgs<ExtArgs>
    pods?: boolean | Document$podsArgs<ExtArgs>
    processingCostRecords?: boolean | Document$processingCostRecordsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    folderId?: boolean
    name?: boolean
    sourceType?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    externalUrl?: boolean
    externalProvider?: boolean
    externalFileId?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    folderId?: boolean
    name?: boolean
    sourceType?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    externalUrl?: boolean
    externalProvider?: boolean
    externalFileId?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    folderId?: boolean
    name?: boolean
    sourceType?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    externalUrl?: boolean
    externalProvider?: boolean
    externalFileId?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "folderId" | "name" | "sourceType" | "storageKey" | "s3Bucket" | "externalUrl" | "externalProvider" | "externalFileId" | "fileType" | "mimeType" | "sizeInBytes" | "status" | "uploadedBy" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    embeddings?: boolean | Document$embeddingsArgs<ExtArgs>
    pods?: boolean | Document$podsArgs<ExtArgs>
    processingCostRecords?: boolean | Document$processingCostRecordsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      folder: Prisma.$DocumentFolderPayload<ExtArgs> | null
      embeddings: Prisma.$EmbeddingPayload<ExtArgs>[]
      pods: Prisma.$PodPayload<ExtArgs>[]
      processingCostRecords: Prisma.$DocumentProcessingCostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      folderId: string | null
      name: string
      sourceType: $Enums.DocumentSourceType
      storageKey: string | null
      s3Bucket: string | null
      externalUrl: string | null
      externalProvider: string | null
      externalFileId: string | null
      fileType: string
      mimeType: string | null
      sizeInBytes: bigint | null
      status: $Enums.DocumentStatus
      uploadedBy: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends Document$folderArgs<ExtArgs> = {}>(args?: Subset<T, Document$folderArgs<ExtArgs>>): Prisma__DocumentFolderClient<$Result.GetResult<Prisma.$DocumentFolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    embeddings<T extends Document$embeddingsArgs<ExtArgs> = {}>(args?: Subset<T, Document$embeddingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pods<T extends Document$podsArgs<ExtArgs> = {}>(args?: Subset<T, Document$podsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processingCostRecords<T extends Document$processingCostRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Document$processingCostRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly workspaceId: FieldRef<"Document", 'String'>
    readonly folderId: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly sourceType: FieldRef<"Document", 'DocumentSourceType'>
    readonly storageKey: FieldRef<"Document", 'String'>
    readonly s3Bucket: FieldRef<"Document", 'String'>
    readonly externalUrl: FieldRef<"Document", 'String'>
    readonly externalProvider: FieldRef<"Document", 'String'>
    readonly externalFileId: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly sizeInBytes: FieldRef<"Document", 'BigInt'>
    readonly status: FieldRef<"Document", 'DocumentStatus'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly metadata: FieldRef<"Document", 'Json'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.folder
   */
  export type Document$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFolder
     */
    select?: DocumentFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFolder
     */
    omit?: DocumentFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFolderInclude<ExtArgs> | null
    where?: DocumentFolderWhereInput
  }

  /**
   * Document.embeddings
   */
  export type Document$embeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    where?: EmbeddingWhereInput
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    cursor?: EmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Document.pods
   */
  export type Document$podsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    where?: PodWhereInput
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    cursor?: PodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Document.processingCostRecords
   */
  export type Document$processingCostRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    where?: DocumentProcessingCostWhereInput
    orderBy?: DocumentProcessingCostOrderByWithRelationInput | DocumentProcessingCostOrderByWithRelationInput[]
    cursor?: DocumentProcessingCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentProcessingCostScalarFieldEnum | DocumentProcessingCostScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Embedding
   */

  export type AggregateEmbedding = {
    _count: EmbeddingCountAggregateOutputType | null
    _avg: EmbeddingAvgAggregateOutputType | null
    _sum: EmbeddingSumAggregateOutputType | null
    _min: EmbeddingMinAggregateOutputType | null
    _max: EmbeddingMaxAggregateOutputType | null
  }

  export type EmbeddingAvgAggregateOutputType = {
    chunkIndex: number | null
    vectorDimension: number | null
  }

  export type EmbeddingSumAggregateOutputType = {
    chunkIndex: number | null
    vectorDimension: number | null
  }

  export type EmbeddingMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    model: string | null
    chunkIndex: number | null
    chunkText: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    vectorDimension: number | null
    createdAt: Date | null
  }

  export type EmbeddingMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    model: string | null
    chunkIndex: number | null
    chunkText: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    vectorDimension: number | null
    createdAt: Date | null
  }

  export type EmbeddingCountAggregateOutputType = {
    id: number
    documentId: number
    model: number
    chunkIndex: number
    chunkText: number
    s3VectorBucket: number
    s3VectorKey: number
    vectorDimension: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type EmbeddingAvgAggregateInputType = {
    chunkIndex?: true
    vectorDimension?: true
  }

  export type EmbeddingSumAggregateInputType = {
    chunkIndex?: true
    vectorDimension?: true
  }

  export type EmbeddingMinAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    chunkIndex?: true
    chunkText?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    vectorDimension?: true
    createdAt?: true
  }

  export type EmbeddingMaxAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    chunkIndex?: true
    chunkText?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    vectorDimension?: true
    createdAt?: true
  }

  export type EmbeddingCountAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    chunkIndex?: true
    chunkText?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    vectorDimension?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type EmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Embedding to aggregate.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Embeddings
    **/
    _count?: true | EmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmbeddingMaxAggregateInputType
  }

  export type GetEmbeddingAggregateType<T extends EmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmbedding[P]>
      : GetScalarType<T[P], AggregateEmbedding[P]>
  }




  export type EmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbeddingWhereInput
    orderBy?: EmbeddingOrderByWithAggregationInput | EmbeddingOrderByWithAggregationInput[]
    by: EmbeddingScalarFieldEnum[] | EmbeddingScalarFieldEnum
    having?: EmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmbeddingCountAggregateInputType | true
    _avg?: EmbeddingAvgAggregateInputType
    _sum?: EmbeddingSumAggregateInputType
    _min?: EmbeddingMinAggregateInputType
    _max?: EmbeddingMaxAggregateInputType
  }

  export type EmbeddingGroupByOutputType = {
    id: string
    documentId: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension: number
    metadata: JsonValue | null
    createdAt: Date
    _count: EmbeddingCountAggregateOutputType | null
    _avg: EmbeddingAvgAggregateOutputType | null
    _sum: EmbeddingSumAggregateOutputType | null
    _min: EmbeddingMinAggregateOutputType | null
    _max: EmbeddingMaxAggregateOutputType | null
  }

  type GetEmbeddingGroupByPayload<T extends EmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], EmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type EmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectScalar = {
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type EmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "model" | "chunkIndex" | "chunkText" | "s3VectorBucket" | "s3VectorKey" | "vectorDimension" | "metadata" | "createdAt", ExtArgs["result"]["embedding"]>
  export type EmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type EmbeddingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type EmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $EmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Embedding"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      model: string
      chunkIndex: number
      chunkText: string
      s3VectorBucket: string
      s3VectorKey: string
      vectorDimension: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["embedding"]>
    composites: {}
  }

  type EmbeddingGetPayload<S extends boolean | null | undefined | EmbeddingDefaultArgs> = $Result.GetResult<Prisma.$EmbeddingPayload, S>

  type EmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmbeddingCountAggregateInputType | true
    }

  export interface EmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Embedding'], meta: { name: 'Embedding' } }
    /**
     * Find zero or one Embedding that matches the filter.
     * @param {EmbeddingFindUniqueArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmbeddingFindUniqueArgs>(args: SelectSubset<T, EmbeddingFindUniqueArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Embedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmbeddingFindUniqueOrThrowArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, EmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Embedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindFirstArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmbeddingFindFirstArgs>(args?: SelectSubset<T, EmbeddingFindFirstArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Embedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindFirstOrThrowArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, EmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Embeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Embeddings
     * const embeddings = await prisma.embedding.findMany()
     * 
     * // Get first 10 Embeddings
     * const embeddings = await prisma.embedding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const embeddingWithIdOnly = await prisma.embedding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmbeddingFindManyArgs>(args?: SelectSubset<T, EmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Embedding.
     * @param {EmbeddingCreateArgs} args - Arguments to create a Embedding.
     * @example
     * // Create one Embedding
     * const Embedding = await prisma.embedding.create({
     *   data: {
     *     // ... data to create a Embedding
     *   }
     * })
     * 
     */
    create<T extends EmbeddingCreateArgs>(args: SelectSubset<T, EmbeddingCreateArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Embeddings.
     * @param {EmbeddingCreateManyArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embedding = await prisma.embedding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmbeddingCreateManyArgs>(args?: SelectSubset<T, EmbeddingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Embeddings and returns the data saved in the database.
     * @param {EmbeddingCreateManyAndReturnArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embedding = await prisma.embedding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Embeddings and only return the `id`
     * const embeddingWithIdOnly = await prisma.embedding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmbeddingCreateManyAndReturnArgs>(args?: SelectSubset<T, EmbeddingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Embedding.
     * @param {EmbeddingDeleteArgs} args - Arguments to delete one Embedding.
     * @example
     * // Delete one Embedding
     * const Embedding = await prisma.embedding.delete({
     *   where: {
     *     // ... filter to delete one Embedding
     *   }
     * })
     * 
     */
    delete<T extends EmbeddingDeleteArgs>(args: SelectSubset<T, EmbeddingDeleteArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Embedding.
     * @param {EmbeddingUpdateArgs} args - Arguments to update one Embedding.
     * @example
     * // Update one Embedding
     * const embedding = await prisma.embedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmbeddingUpdateArgs>(args: SelectSubset<T, EmbeddingUpdateArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Embeddings.
     * @param {EmbeddingDeleteManyArgs} args - Arguments to filter Embeddings to delete.
     * @example
     * // Delete a few Embeddings
     * const { count } = await prisma.embedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmbeddingDeleteManyArgs>(args?: SelectSubset<T, EmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Embeddings
     * const embedding = await prisma.embedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmbeddingUpdateManyArgs>(args: SelectSubset<T, EmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings and returns the data updated in the database.
     * @param {EmbeddingUpdateManyAndReturnArgs} args - Arguments to update many Embeddings.
     * @example
     * // Update many Embeddings
     * const embedding = await prisma.embedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Embeddings and only return the `id`
     * const embeddingWithIdOnly = await prisma.embedding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, EmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Embedding.
     * @param {EmbeddingUpsertArgs} args - Arguments to update or create a Embedding.
     * @example
     * // Update or create a Embedding
     * const embedding = await prisma.embedding.upsert({
     *   create: {
     *     // ... data to create a Embedding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Embedding we want to update
     *   }
     * })
     */
    upsert<T extends EmbeddingUpsertArgs>(args: SelectSubset<T, EmbeddingUpsertArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingCountArgs} args - Arguments to filter Embeddings to count.
     * @example
     * // Count the number of Embeddings
     * const count = await prisma.embedding.count({
     *   where: {
     *     // ... the filter for the Embeddings we want to count
     *   }
     * })
    **/
    count<T extends EmbeddingCountArgs>(
      args?: Subset<T, EmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Embedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmbeddingAggregateArgs>(args: Subset<T, EmbeddingAggregateArgs>): Prisma.PrismaPromise<GetEmbeddingAggregateType<T>>

    /**
     * Group by Embedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: EmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Embedding model
   */
  readonly fields: EmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Embedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Embedding model
   */
  interface EmbeddingFieldRefs {
    readonly id: FieldRef<"Embedding", 'String'>
    readonly documentId: FieldRef<"Embedding", 'String'>
    readonly model: FieldRef<"Embedding", 'String'>
    readonly chunkIndex: FieldRef<"Embedding", 'Int'>
    readonly chunkText: FieldRef<"Embedding", 'String'>
    readonly s3VectorBucket: FieldRef<"Embedding", 'String'>
    readonly s3VectorKey: FieldRef<"Embedding", 'String'>
    readonly vectorDimension: FieldRef<"Embedding", 'Int'>
    readonly metadata: FieldRef<"Embedding", 'Json'>
    readonly createdAt: FieldRef<"Embedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Embedding findUnique
   */
  export type EmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding findUniqueOrThrow
   */
  export type EmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding findFirst
   */
  export type EmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Embeddings.
     */
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding findFirstOrThrow
   */
  export type EmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Embeddings.
     */
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding findMany
   */
  export type EmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embeddings to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding create
   */
  export type EmbeddingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to create a Embedding.
     */
    data: XOR<EmbeddingCreateInput, EmbeddingUncheckedCreateInput>
  }

  /**
   * Embedding createMany
   */
  export type EmbeddingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Embeddings.
     */
    data: EmbeddingCreateManyInput | EmbeddingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Embedding createManyAndReturn
   */
  export type EmbeddingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * The data used to create many Embeddings.
     */
    data: EmbeddingCreateManyInput | EmbeddingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Embedding update
   */
  export type EmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a Embedding.
     */
    data: XOR<EmbeddingUpdateInput, EmbeddingUncheckedUpdateInput>
    /**
     * Choose, which Embedding to update.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding updateMany
   */
  export type EmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Embeddings.
     */
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which Embeddings to update
     */
    where?: EmbeddingWhereInput
    /**
     * Limit how many Embeddings to update.
     */
    limit?: number
  }

  /**
   * Embedding updateManyAndReturn
   */
  export type EmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update Embeddings.
     */
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which Embeddings to update
     */
    where?: EmbeddingWhereInput
    /**
     * Limit how many Embeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Embedding upsert
   */
  export type EmbeddingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The filter to search for the Embedding to update in case it exists.
     */
    where: EmbeddingWhereUniqueInput
    /**
     * In case the Embedding found by the `where` argument doesn't exist, create a new Embedding with this data.
     */
    create: XOR<EmbeddingCreateInput, EmbeddingUncheckedCreateInput>
    /**
     * In case the Embedding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmbeddingUpdateInput, EmbeddingUncheckedUpdateInput>
  }

  /**
   * Embedding delete
   */
  export type EmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter which Embedding to delete.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding deleteMany
   */
  export type EmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Embeddings to delete
     */
    where?: EmbeddingWhereInput
    /**
     * Limit how many Embeddings to delete.
     */
    limit?: number
  }

  /**
   * Embedding without action
   */
  export type EmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model DocumentProcessingCost
   */

  export type AggregateDocumentProcessingCost = {
    _count: DocumentProcessingCostCountAggregateOutputType | null
    _avg: DocumentProcessingCostAvgAggregateOutputType | null
    _sum: DocumentProcessingCostSumAggregateOutputType | null
    _min: DocumentProcessingCostMinAggregateOutputType | null
    _max: DocumentProcessingCostMaxAggregateOutputType | null
  }

  export type DocumentProcessingCostAvgAggregateOutputType = {
    creditsConsumed: number | null
    extractionCost: Decimal | null
    embeddingCost: Decimal | null
    totalCostInUsd: Decimal | null
    chunkCount: number | null
    processingTimeMs: number | null
    tokensProcessed: number | null
  }

  export type DocumentProcessingCostSumAggregateOutputType = {
    creditsConsumed: number | null
    extractionCost: Decimal | null
    embeddingCost: Decimal | null
    totalCostInUsd: Decimal | null
    chunkCount: number | null
    processingTimeMs: number | null
    tokensProcessed: number | null
  }

  export type DocumentProcessingCostMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    workspaceId: string | null
    subscriptionId: string | null
    processingType: $Enums.DocumentProcessingType | null
    creditsConsumed: number | null
    extractionCost: Decimal | null
    embeddingCost: Decimal | null
    totalCostInUsd: Decimal | null
    chunkCount: number | null
    embeddingModel: string | null
    processingTimeMs: number | null
    tokensProcessed: number | null
    processedAt: Date | null
  }

  export type DocumentProcessingCostMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    workspaceId: string | null
    subscriptionId: string | null
    processingType: $Enums.DocumentProcessingType | null
    creditsConsumed: number | null
    extractionCost: Decimal | null
    embeddingCost: Decimal | null
    totalCostInUsd: Decimal | null
    chunkCount: number | null
    embeddingModel: string | null
    processingTimeMs: number | null
    tokensProcessed: number | null
    processedAt: Date | null
  }

  export type DocumentProcessingCostCountAggregateOutputType = {
    id: number
    documentId: number
    workspaceId: number
    subscriptionId: number
    processingType: number
    creditsConsumed: number
    extractionCost: number
    embeddingCost: number
    totalCostInUsd: number
    chunkCount: number
    embeddingModel: number
    processingTimeMs: number
    tokensProcessed: number
    processedAt: number
    _all: number
  }


  export type DocumentProcessingCostAvgAggregateInputType = {
    creditsConsumed?: true
    extractionCost?: true
    embeddingCost?: true
    totalCostInUsd?: true
    chunkCount?: true
    processingTimeMs?: true
    tokensProcessed?: true
  }

  export type DocumentProcessingCostSumAggregateInputType = {
    creditsConsumed?: true
    extractionCost?: true
    embeddingCost?: true
    totalCostInUsd?: true
    chunkCount?: true
    processingTimeMs?: true
    tokensProcessed?: true
  }

  export type DocumentProcessingCostMinAggregateInputType = {
    id?: true
    documentId?: true
    workspaceId?: true
    subscriptionId?: true
    processingType?: true
    creditsConsumed?: true
    extractionCost?: true
    embeddingCost?: true
    totalCostInUsd?: true
    chunkCount?: true
    embeddingModel?: true
    processingTimeMs?: true
    tokensProcessed?: true
    processedAt?: true
  }

  export type DocumentProcessingCostMaxAggregateInputType = {
    id?: true
    documentId?: true
    workspaceId?: true
    subscriptionId?: true
    processingType?: true
    creditsConsumed?: true
    extractionCost?: true
    embeddingCost?: true
    totalCostInUsd?: true
    chunkCount?: true
    embeddingModel?: true
    processingTimeMs?: true
    tokensProcessed?: true
    processedAt?: true
  }

  export type DocumentProcessingCostCountAggregateInputType = {
    id?: true
    documentId?: true
    workspaceId?: true
    subscriptionId?: true
    processingType?: true
    creditsConsumed?: true
    extractionCost?: true
    embeddingCost?: true
    totalCostInUsd?: true
    chunkCount?: true
    embeddingModel?: true
    processingTimeMs?: true
    tokensProcessed?: true
    processedAt?: true
    _all?: true
  }

  export type DocumentProcessingCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentProcessingCost to aggregate.
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentProcessingCosts to fetch.
     */
    orderBy?: DocumentProcessingCostOrderByWithRelationInput | DocumentProcessingCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentProcessingCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentProcessingCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentProcessingCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentProcessingCosts
    **/
    _count?: true | DocumentProcessingCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentProcessingCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentProcessingCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentProcessingCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentProcessingCostMaxAggregateInputType
  }

  export type GetDocumentProcessingCostAggregateType<T extends DocumentProcessingCostAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentProcessingCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentProcessingCost[P]>
      : GetScalarType<T[P], AggregateDocumentProcessingCost[P]>
  }




  export type DocumentProcessingCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentProcessingCostWhereInput
    orderBy?: DocumentProcessingCostOrderByWithAggregationInput | DocumentProcessingCostOrderByWithAggregationInput[]
    by: DocumentProcessingCostScalarFieldEnum[] | DocumentProcessingCostScalarFieldEnum
    having?: DocumentProcessingCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentProcessingCostCountAggregateInputType | true
    _avg?: DocumentProcessingCostAvgAggregateInputType
    _sum?: DocumentProcessingCostSumAggregateInputType
    _min?: DocumentProcessingCostMinAggregateInputType
    _max?: DocumentProcessingCostMaxAggregateInputType
  }

  export type DocumentProcessingCostGroupByOutputType = {
    id: string
    documentId: string
    workspaceId: string
    subscriptionId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed: number
    extractionCost: Decimal
    embeddingCost: Decimal
    totalCostInUsd: Decimal
    chunkCount: number | null
    embeddingModel: string | null
    processingTimeMs: number | null
    tokensProcessed: number
    processedAt: Date
    _count: DocumentProcessingCostCountAggregateOutputType | null
    _avg: DocumentProcessingCostAvgAggregateOutputType | null
    _sum: DocumentProcessingCostSumAggregateOutputType | null
    _min: DocumentProcessingCostMinAggregateOutputType | null
    _max: DocumentProcessingCostMaxAggregateOutputType | null
  }

  type GetDocumentProcessingCostGroupByPayload<T extends DocumentProcessingCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentProcessingCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentProcessingCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentProcessingCostGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentProcessingCostGroupByOutputType[P]>
        }
      >
    >


  export type DocumentProcessingCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    processingType?: boolean
    creditsConsumed?: boolean
    extractionCost?: boolean
    embeddingCost?: boolean
    totalCostInUsd?: boolean
    chunkCount?: boolean
    embeddingModel?: boolean
    processingTimeMs?: boolean
    tokensProcessed?: boolean
    processedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentProcessingCost"]>

  export type DocumentProcessingCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    processingType?: boolean
    creditsConsumed?: boolean
    extractionCost?: boolean
    embeddingCost?: boolean
    totalCostInUsd?: boolean
    chunkCount?: boolean
    embeddingModel?: boolean
    processingTimeMs?: boolean
    tokensProcessed?: boolean
    processedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentProcessingCost"]>

  export type DocumentProcessingCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    processingType?: boolean
    creditsConsumed?: boolean
    extractionCost?: boolean
    embeddingCost?: boolean
    totalCostInUsd?: boolean
    chunkCount?: boolean
    embeddingModel?: boolean
    processingTimeMs?: boolean
    tokensProcessed?: boolean
    processedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentProcessingCost"]>

  export type DocumentProcessingCostSelectScalar = {
    id?: boolean
    documentId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    processingType?: boolean
    creditsConsumed?: boolean
    extractionCost?: boolean
    embeddingCost?: boolean
    totalCostInUsd?: boolean
    chunkCount?: boolean
    embeddingModel?: boolean
    processingTimeMs?: boolean
    tokensProcessed?: boolean
    processedAt?: boolean
  }

  export type DocumentProcessingCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "workspaceId" | "subscriptionId" | "processingType" | "creditsConsumed" | "extractionCost" | "embeddingCost" | "totalCostInUsd" | "chunkCount" | "embeddingModel" | "processingTimeMs" | "tokensProcessed" | "processedAt", ExtArgs["result"]["documentProcessingCost"]>
  export type DocumentProcessingCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type DocumentProcessingCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type DocumentProcessingCostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $DocumentProcessingCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentProcessingCost"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      workspaceId: string
      subscriptionId: string
      processingType: $Enums.DocumentProcessingType
      creditsConsumed: number
      extractionCost: Prisma.Decimal
      embeddingCost: Prisma.Decimal
      totalCostInUsd: Prisma.Decimal
      chunkCount: number | null
      embeddingModel: string | null
      processingTimeMs: number | null
      tokensProcessed: number
      processedAt: Date
    }, ExtArgs["result"]["documentProcessingCost"]>
    composites: {}
  }

  type DocumentProcessingCostGetPayload<S extends boolean | null | undefined | DocumentProcessingCostDefaultArgs> = $Result.GetResult<Prisma.$DocumentProcessingCostPayload, S>

  type DocumentProcessingCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentProcessingCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentProcessingCostCountAggregateInputType | true
    }

  export interface DocumentProcessingCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentProcessingCost'], meta: { name: 'DocumentProcessingCost' } }
    /**
     * Find zero or one DocumentProcessingCost that matches the filter.
     * @param {DocumentProcessingCostFindUniqueArgs} args - Arguments to find a DocumentProcessingCost
     * @example
     * // Get one DocumentProcessingCost
     * const documentProcessingCost = await prisma.documentProcessingCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentProcessingCostFindUniqueArgs>(args: SelectSubset<T, DocumentProcessingCostFindUniqueArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentProcessingCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentProcessingCostFindUniqueOrThrowArgs} args - Arguments to find a DocumentProcessingCost
     * @example
     * // Get one DocumentProcessingCost
     * const documentProcessingCost = await prisma.documentProcessingCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentProcessingCostFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentProcessingCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentProcessingCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostFindFirstArgs} args - Arguments to find a DocumentProcessingCost
     * @example
     * // Get one DocumentProcessingCost
     * const documentProcessingCost = await prisma.documentProcessingCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentProcessingCostFindFirstArgs>(args?: SelectSubset<T, DocumentProcessingCostFindFirstArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentProcessingCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostFindFirstOrThrowArgs} args - Arguments to find a DocumentProcessingCost
     * @example
     * // Get one DocumentProcessingCost
     * const documentProcessingCost = await prisma.documentProcessingCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentProcessingCostFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentProcessingCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentProcessingCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentProcessingCosts
     * const documentProcessingCosts = await prisma.documentProcessingCost.findMany()
     * 
     * // Get first 10 DocumentProcessingCosts
     * const documentProcessingCosts = await prisma.documentProcessingCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentProcessingCostWithIdOnly = await prisma.documentProcessingCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentProcessingCostFindManyArgs>(args?: SelectSubset<T, DocumentProcessingCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentProcessingCost.
     * @param {DocumentProcessingCostCreateArgs} args - Arguments to create a DocumentProcessingCost.
     * @example
     * // Create one DocumentProcessingCost
     * const DocumentProcessingCost = await prisma.documentProcessingCost.create({
     *   data: {
     *     // ... data to create a DocumentProcessingCost
     *   }
     * })
     * 
     */
    create<T extends DocumentProcessingCostCreateArgs>(args: SelectSubset<T, DocumentProcessingCostCreateArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentProcessingCosts.
     * @param {DocumentProcessingCostCreateManyArgs} args - Arguments to create many DocumentProcessingCosts.
     * @example
     * // Create many DocumentProcessingCosts
     * const documentProcessingCost = await prisma.documentProcessingCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentProcessingCostCreateManyArgs>(args?: SelectSubset<T, DocumentProcessingCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentProcessingCosts and returns the data saved in the database.
     * @param {DocumentProcessingCostCreateManyAndReturnArgs} args - Arguments to create many DocumentProcessingCosts.
     * @example
     * // Create many DocumentProcessingCosts
     * const documentProcessingCost = await prisma.documentProcessingCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentProcessingCosts and only return the `id`
     * const documentProcessingCostWithIdOnly = await prisma.documentProcessingCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentProcessingCostCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentProcessingCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentProcessingCost.
     * @param {DocumentProcessingCostDeleteArgs} args - Arguments to delete one DocumentProcessingCost.
     * @example
     * // Delete one DocumentProcessingCost
     * const DocumentProcessingCost = await prisma.documentProcessingCost.delete({
     *   where: {
     *     // ... filter to delete one DocumentProcessingCost
     *   }
     * })
     * 
     */
    delete<T extends DocumentProcessingCostDeleteArgs>(args: SelectSubset<T, DocumentProcessingCostDeleteArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentProcessingCost.
     * @param {DocumentProcessingCostUpdateArgs} args - Arguments to update one DocumentProcessingCost.
     * @example
     * // Update one DocumentProcessingCost
     * const documentProcessingCost = await prisma.documentProcessingCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentProcessingCostUpdateArgs>(args: SelectSubset<T, DocumentProcessingCostUpdateArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentProcessingCosts.
     * @param {DocumentProcessingCostDeleteManyArgs} args - Arguments to filter DocumentProcessingCosts to delete.
     * @example
     * // Delete a few DocumentProcessingCosts
     * const { count } = await prisma.documentProcessingCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentProcessingCostDeleteManyArgs>(args?: SelectSubset<T, DocumentProcessingCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentProcessingCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentProcessingCosts
     * const documentProcessingCost = await prisma.documentProcessingCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentProcessingCostUpdateManyArgs>(args: SelectSubset<T, DocumentProcessingCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentProcessingCosts and returns the data updated in the database.
     * @param {DocumentProcessingCostUpdateManyAndReturnArgs} args - Arguments to update many DocumentProcessingCosts.
     * @example
     * // Update many DocumentProcessingCosts
     * const documentProcessingCost = await prisma.documentProcessingCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentProcessingCosts and only return the `id`
     * const documentProcessingCostWithIdOnly = await prisma.documentProcessingCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentProcessingCostUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentProcessingCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentProcessingCost.
     * @param {DocumentProcessingCostUpsertArgs} args - Arguments to update or create a DocumentProcessingCost.
     * @example
     * // Update or create a DocumentProcessingCost
     * const documentProcessingCost = await prisma.documentProcessingCost.upsert({
     *   create: {
     *     // ... data to create a DocumentProcessingCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentProcessingCost we want to update
     *   }
     * })
     */
    upsert<T extends DocumentProcessingCostUpsertArgs>(args: SelectSubset<T, DocumentProcessingCostUpsertArgs<ExtArgs>>): Prisma__DocumentProcessingCostClient<$Result.GetResult<Prisma.$DocumentProcessingCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentProcessingCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostCountArgs} args - Arguments to filter DocumentProcessingCosts to count.
     * @example
     * // Count the number of DocumentProcessingCosts
     * const count = await prisma.documentProcessingCost.count({
     *   where: {
     *     // ... the filter for the DocumentProcessingCosts we want to count
     *   }
     * })
    **/
    count<T extends DocumentProcessingCostCountArgs>(
      args?: Subset<T, DocumentProcessingCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentProcessingCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentProcessingCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentProcessingCostAggregateArgs>(args: Subset<T, DocumentProcessingCostAggregateArgs>): Prisma.PrismaPromise<GetDocumentProcessingCostAggregateType<T>>

    /**
     * Group by DocumentProcessingCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentProcessingCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentProcessingCostGroupByArgs['orderBy'] }
        : { orderBy?: DocumentProcessingCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentProcessingCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentProcessingCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentProcessingCost model
   */
  readonly fields: DocumentProcessingCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentProcessingCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentProcessingCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentProcessingCost model
   */
  interface DocumentProcessingCostFieldRefs {
    readonly id: FieldRef<"DocumentProcessingCost", 'String'>
    readonly documentId: FieldRef<"DocumentProcessingCost", 'String'>
    readonly workspaceId: FieldRef<"DocumentProcessingCost", 'String'>
    readonly subscriptionId: FieldRef<"DocumentProcessingCost", 'String'>
    readonly processingType: FieldRef<"DocumentProcessingCost", 'DocumentProcessingType'>
    readonly creditsConsumed: FieldRef<"DocumentProcessingCost", 'Int'>
    readonly extractionCost: FieldRef<"DocumentProcessingCost", 'Decimal'>
    readonly embeddingCost: FieldRef<"DocumentProcessingCost", 'Decimal'>
    readonly totalCostInUsd: FieldRef<"DocumentProcessingCost", 'Decimal'>
    readonly chunkCount: FieldRef<"DocumentProcessingCost", 'Int'>
    readonly embeddingModel: FieldRef<"DocumentProcessingCost", 'String'>
    readonly processingTimeMs: FieldRef<"DocumentProcessingCost", 'Int'>
    readonly tokensProcessed: FieldRef<"DocumentProcessingCost", 'Int'>
    readonly processedAt: FieldRef<"DocumentProcessingCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentProcessingCost findUnique
   */
  export type DocumentProcessingCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * Filter, which DocumentProcessingCost to fetch.
     */
    where: DocumentProcessingCostWhereUniqueInput
  }

  /**
   * DocumentProcessingCost findUniqueOrThrow
   */
  export type DocumentProcessingCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * Filter, which DocumentProcessingCost to fetch.
     */
    where: DocumentProcessingCostWhereUniqueInput
  }

  /**
   * DocumentProcessingCost findFirst
   */
  export type DocumentProcessingCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * Filter, which DocumentProcessingCost to fetch.
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentProcessingCosts to fetch.
     */
    orderBy?: DocumentProcessingCostOrderByWithRelationInput | DocumentProcessingCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentProcessingCosts.
     */
    cursor?: DocumentProcessingCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentProcessingCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentProcessingCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentProcessingCosts.
     */
    distinct?: DocumentProcessingCostScalarFieldEnum | DocumentProcessingCostScalarFieldEnum[]
  }

  /**
   * DocumentProcessingCost findFirstOrThrow
   */
  export type DocumentProcessingCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * Filter, which DocumentProcessingCost to fetch.
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentProcessingCosts to fetch.
     */
    orderBy?: DocumentProcessingCostOrderByWithRelationInput | DocumentProcessingCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentProcessingCosts.
     */
    cursor?: DocumentProcessingCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentProcessingCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentProcessingCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentProcessingCosts.
     */
    distinct?: DocumentProcessingCostScalarFieldEnum | DocumentProcessingCostScalarFieldEnum[]
  }

  /**
   * DocumentProcessingCost findMany
   */
  export type DocumentProcessingCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * Filter, which DocumentProcessingCosts to fetch.
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentProcessingCosts to fetch.
     */
    orderBy?: DocumentProcessingCostOrderByWithRelationInput | DocumentProcessingCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentProcessingCosts.
     */
    cursor?: DocumentProcessingCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentProcessingCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentProcessingCosts.
     */
    skip?: number
    distinct?: DocumentProcessingCostScalarFieldEnum | DocumentProcessingCostScalarFieldEnum[]
  }

  /**
   * DocumentProcessingCost create
   */
  export type DocumentProcessingCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentProcessingCost.
     */
    data: XOR<DocumentProcessingCostCreateInput, DocumentProcessingCostUncheckedCreateInput>
  }

  /**
   * DocumentProcessingCost createMany
   */
  export type DocumentProcessingCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentProcessingCosts.
     */
    data: DocumentProcessingCostCreateManyInput | DocumentProcessingCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentProcessingCost createManyAndReturn
   */
  export type DocumentProcessingCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentProcessingCosts.
     */
    data: DocumentProcessingCostCreateManyInput | DocumentProcessingCostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentProcessingCost update
   */
  export type DocumentProcessingCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentProcessingCost.
     */
    data: XOR<DocumentProcessingCostUpdateInput, DocumentProcessingCostUncheckedUpdateInput>
    /**
     * Choose, which DocumentProcessingCost to update.
     */
    where: DocumentProcessingCostWhereUniqueInput
  }

  /**
   * DocumentProcessingCost updateMany
   */
  export type DocumentProcessingCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentProcessingCosts.
     */
    data: XOR<DocumentProcessingCostUpdateManyMutationInput, DocumentProcessingCostUncheckedUpdateManyInput>
    /**
     * Filter which DocumentProcessingCosts to update
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * Limit how many DocumentProcessingCosts to update.
     */
    limit?: number
  }

  /**
   * DocumentProcessingCost updateManyAndReturn
   */
  export type DocumentProcessingCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * The data used to update DocumentProcessingCosts.
     */
    data: XOR<DocumentProcessingCostUpdateManyMutationInput, DocumentProcessingCostUncheckedUpdateManyInput>
    /**
     * Filter which DocumentProcessingCosts to update
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * Limit how many DocumentProcessingCosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentProcessingCost upsert
   */
  export type DocumentProcessingCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentProcessingCost to update in case it exists.
     */
    where: DocumentProcessingCostWhereUniqueInput
    /**
     * In case the DocumentProcessingCost found by the `where` argument doesn't exist, create a new DocumentProcessingCost with this data.
     */
    create: XOR<DocumentProcessingCostCreateInput, DocumentProcessingCostUncheckedCreateInput>
    /**
     * In case the DocumentProcessingCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentProcessingCostUpdateInput, DocumentProcessingCostUncheckedUpdateInput>
  }

  /**
   * DocumentProcessingCost delete
   */
  export type DocumentProcessingCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
    /**
     * Filter which DocumentProcessingCost to delete.
     */
    where: DocumentProcessingCostWhereUniqueInput
  }

  /**
   * DocumentProcessingCost deleteMany
   */
  export type DocumentProcessingCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentProcessingCosts to delete
     */
    where?: DocumentProcessingCostWhereInput
    /**
     * Limit how many DocumentProcessingCosts to delete.
     */
    limit?: number
  }

  /**
   * DocumentProcessingCost without action
   */
  export type DocumentProcessingCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentProcessingCost
     */
    select?: DocumentProcessingCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentProcessingCost
     */
    omit?: DocumentProcessingCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingCostInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    status: 'status',
    isSuperAdmin: 'isSuperAdmin',
    requiresMfa: 'requiresMfa',
    mfaSecret: 'mfaSecret',
    mfaBackupCodes: 'mfaBackupCodes',
    mfaVerifiedAt: 'mfaVerifiedAt',
    allowedIpAddresses: 'allowedIpAddresses',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    passwordChangedAt: 'passwordChangedAt',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpiry: 'passwordResetExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    deactivatedAt: 'deactivatedAt',
    deactivatedBy: 'deactivatedBy'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminSessionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    lastActivityAt: 'lastActivityAt',
    revokedAt: 'revokedAt',
    revokedReason: 'revokedReason'
  };

  export type AdminSessionScalarFieldEnum = (typeof AdminSessionScalarFieldEnum)[keyof typeof AdminSessionScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    method: 'method',
    endpoint: 'endpoint',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    changesBefore: 'changesBefore',
    changesAfter: 'changesAfter',
    status: 'status',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    executionTimeMs: 'executionTimeMs',
    createdAt: 'createdAt'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const AdminPermissionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    permission: 'permission',
    resource: 'resource',
    grantedAt: 'grantedAt',
    grantedBy: 'grantedBy',
    expiresAt: 'expiresAt'
  };

  export type AdminPermissionScalarFieldEnum = (typeof AdminPermissionScalarFieldEnum)[keyof typeof AdminPermissionScalarFieldEnum]


  export const AdminAPIKeyScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    name: 'name',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix',
    scopes: 'scopes',
    rateLimit: 'rateLimit',
    allowedIps: 'allowedIps',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt'
  };

  export type AdminAPIKeyScalarFieldEnum = (typeof AdminAPIKeyScalarFieldEnum)[keyof typeof AdminAPIKeyScalarFieldEnum]


  export const AdminInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    role: 'role',
    token: 'token',
    invitedBy: 'invitedBy',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt'
  };

  export type AdminInvitationScalarFieldEnum = (typeof AdminInvitationScalarFieldEnum)[keyof typeof AdminInvitationScalarFieldEnum]


  export const AdminSecurityEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    severity: 'severity',
    adminId: 'adminId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    description: 'description',
    metadata: 'metadata',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt'
  };

  export type AdminSecurityEventScalarFieldEnum = (typeof AdminSecurityEventScalarFieldEnum)[keyof typeof AdminSecurityEventScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    tier: 'tier',
    status: 'status',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    credits: 'credits',
    monthlyCreditQuota: 'monthlyCreditQuota',
    creditResetDate: 'creditResetDate',
    maxCanvases: 'maxCanvases',
    maxActionPodsPerCanvas: 'maxActionPodsPerCanvas',
    maxDocumentSizeInMB: 'maxDocumentSizeInMB',
    maxCollaboratorsPerCanvas: 'maxCollaboratorsPerCanvas',
    canInviteToWorkspace: 'canInviteToWorkspace',
    canInviteToCanvas: 'canInviteToCanvas',
    canCreatePublicLinks: 'canCreatePublicLinks',
    canUseAdvancedModels: 'canUseAdvancedModels',
    canAccessAnalytics: 'canAccessAnalytics',
    canExportData: 'canExportData',
    nextBillingDate: 'nextBillingDate',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    isByokMode: 'isByokMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const CreditPurchaseScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    creditsPurchased: 'creditsPurchased',
    amountPaid: 'amountPaid',
    currency: 'currency',
    stripeChargeId: 'stripeChargeId',
    status: 'status',
    purchasedAt: 'purchasedAt'
  };

  export type CreditPurchaseScalarFieldEnum = (typeof CreditPurchaseScalarFieldEnum)[keyof typeof CreditPurchaseScalarFieldEnum]


  export const CreditUsageLogScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    workspaceId: 'workspaceId',
    canvasId: 'canvasId',
    podId: 'podId',
    executionId: 'executionId',
    creditsUsed: 'creditsUsed',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    provider: 'provider',
    modelId: 'modelId',
    modelName: 'modelName',
    createdAt: 'createdAt'
  };

  export type CreditUsageLogScalarFieldEnum = (typeof CreditUsageLogScalarFieldEnum)[keyof typeof CreditUsageLogScalarFieldEnum]


  export const ModelPricingTierScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    modelId: 'modelId',
    category: 'category',
    displayName: 'displayName',
    description: 'description',
    inputTokenCost: 'inputTokenCost',
    outputTokenCost: 'outputTokenCost',
    reasoningTokenCost: 'reasoningTokenCost',
    creditsPerMillionInputTokens: 'creditsPerMillionInputTokens',
    creditsPerMillionOutputTokens: 'creditsPerMillionOutputTokens',
    creditsPerMillionReasoningTokens: 'creditsPerMillionReasoningTokens',
    maxTokens: 'maxTokens',
    maxOutputTokens: 'maxOutputTokens',
    supportsStreaming: 'supportsStreaming',
    supportsVision: 'supportsVision',
    supportsAudio: 'supportsAudio',
    supportsVideo: 'supportsVideo',
    supportsFunctions: 'supportsFunctions',
    supportsJsonMode: 'supportsJsonMode',
    supportsSystemPrompt: 'supportsSystemPrompt',
    providerConfig: 'providerConfig',
    isActive: 'isActive',
    effectiveFrom: 'effectiveFrom',
    effectiveUntil: 'effectiveUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelPricingTierScalarFieldEnum = (typeof ModelPricingTierScalarFieldEnum)[keyof typeof ModelPricingTierScalarFieldEnum]


  export const SpaceScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    customInstructions: 'customInstructions',
    icon: 'icon',
    color: 'color',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpaceScalarFieldEnum = (typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum]


  export const FlowScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    spaceId: 'spaceId',
    name: 'name',
    description: 'description',
    version: 'version',
    visibility: 'visibility',
    createdBy: 'createdBy',
    thumbnailS3Key: 'thumbnailS3Key',
    thumbnailGeneratedAt: 'thumbnailGeneratedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlowScalarFieldEnum = (typeof FlowScalarFieldEnum)[keyof typeof FlowScalarFieldEnum]


  export const FlowInvitationScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    email: 'email',
    accessLevel: 'accessLevel',
    permissions: 'permissions',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token',
    status: 'status',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt'
  };

  export type FlowInvitationScalarFieldEnum = (typeof FlowInvitationScalarFieldEnum)[keyof typeof FlowInvitationScalarFieldEnum]


  export const FlowCollaboratorScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    accessLevel: 'accessLevel',
    canEdit: 'canEdit',
    canExecute: 'canExecute',
    canDelete: 'canDelete',
    canShare: 'canShare',
    canInvite: 'canInvite',
    invitedBy: 'invitedBy',
    invitedAt: 'invitedAt',
    lastViewedAt: 'lastViewedAt'
  };

  export type FlowCollaboratorScalarFieldEnum = (typeof FlowCollaboratorScalarFieldEnum)[keyof typeof FlowCollaboratorScalarFieldEnum]


  export const FlowSessionScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    anonymousName: 'anonymousName',
    sessionToken: 'sessionToken',
    socketId: 'socketId',
    cursorPosition: 'cursorPosition',
    selectedPodIds: 'selectedPodIds',
    viewportState: 'viewportState',
    userColor: 'userColor',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    connectedAt: 'connectedAt',
    lastHeartbeatAt: 'lastHeartbeatAt',
    disconnectedAt: 'disconnectedAt'
  };

  export type FlowSessionScalarFieldEnum = (typeof FlowSessionScalarFieldEnum)[keyof typeof FlowSessionScalarFieldEnum]


  export const FlowActivityLogScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changeData: 'changeData',
    createdAt: 'createdAt'
  };

  export type FlowActivityLogScalarFieldEnum = (typeof FlowActivityLogScalarFieldEnum)[keyof typeof FlowActivityLogScalarFieldEnum]


  export const FlowCommentScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    content: 'content',
    position: 'position',
    podId: 'podId',
    parentId: 'parentId',
    isResolved: 'isResolved',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlowCommentScalarFieldEnum = (typeof FlowCommentScalarFieldEnum)[keyof typeof FlowCommentScalarFieldEnum]


  export const PodScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    type: 'type',
    position: 'position',
    executionStatus: 'executionStatus',
    lastExecutionId: 'lastExecutionId',
    contextFlowId: 'contextFlowId',
    documentId: 'documentId',
    lockedBy: 'lockedBy',
    lockedAt: 'lockedAt',
    dynamoPartitionKey: 'dynamoPartitionKey',
    dynamoSortKey: 'dynamoSortKey',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PodScalarFieldEnum = (typeof PodScalarFieldEnum)[keyof typeof PodScalarFieldEnum]


  export const EdgeScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    sourcePodId: 'sourcePodId',
    targetPodId: 'targetPodId',
    sourceHandle: 'sourceHandle',
    targetHandle: 'targetHandle',
    animated: 'animated',
    createdAt: 'createdAt'
  };

  export type EdgeScalarFieldEnum = (typeof EdgeScalarFieldEnum)[keyof typeof EdgeScalarFieldEnum]


  export const PodExecutionScalarFieldEnum: {
    id: 'id',
    podId: 'podId',
    flowId: 'flowId',
    workspaceId: 'workspaceId',
    status: 'status',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    runtimeInMs: 'runtimeInMs',
    provider: 'provider',
    modelId: 'modelId',
    modelName: 'modelName',
    providerMetadata: 'providerMetadata',
    requestMetadata: 'requestMetadata',
    responseMetadata: 'responseMetadata',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    reasoningTokens: 'reasoningTokens',
    creditsConsumed: 'creditsConsumed',
    costInUsd: 'costInUsd'
  };

  export type PodExecutionScalarFieldEnum = (typeof PodExecutionScalarFieldEnum)[keyof typeof PodExecutionScalarFieldEnum]


  export const PodUsageLogScalarFieldEnum: {
    id: 'id',
    podId: 'podId',
    executionId: 'executionId',
    flowId: 'flowId',
    workspaceId: 'workspaceId',
    subscriptionId: 'subscriptionId',
    provider: 'provider',
    modelId: 'modelId',
    modelName: 'modelName',
    providerMetadata: 'providerMetadata',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    reasoningTokens: 'reasoningTokens',
    creditsConsumed: 'creditsConsumed',
    runtimeInMs: 'runtimeInMs',
    inputTokenCost: 'inputTokenCost',
    outputTokenCost: 'outputTokenCost',
    reasoningTokenCost: 'reasoningTokenCost',
    totalCostInUsd: 'totalCostInUsd',
    executedAt: 'executedAt'
  };

  export type PodUsageLogScalarFieldEnum = (typeof PodUsageLogScalarFieldEnum)[keyof typeof PodUsageLogScalarFieldEnum]


  export const ContextModuleScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    definitionJson: 'definitionJson',
    originalFlowId: 'originalFlowId',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContextModuleScalarFieldEnum = (typeof ContextModuleScalarFieldEnum)[keyof typeof ContextModuleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    hash: 'hash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    deviceName: 'deviceName',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    role: 'role',
    canCreateCanvas: 'canCreateCanvas',
    canDeleteCanvas: 'canDeleteCanvas',
    canManageBilling: 'canManageBilling',
    canInviteMembers: 'canInviteMembers',
    canManageMembers: 'canManageMembers',
    canManageApiKeys: 'canManageApiKeys',
    joinedAt: 'joinedAt',
    invitedBy: 'invitedBy'
  };

  export type WorkspaceUserScalarFieldEnum = (typeof WorkspaceUserScalarFieldEnum)[keyof typeof WorkspaceUserScalarFieldEnum]


  export const WorkspaceInvitationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    role: 'role',
    permissions: 'permissions',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token',
    status: 'status',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt'
  };

  export type WorkspaceInvitationScalarFieldEnum = (typeof WorkspaceInvitationScalarFieldEnum)[keyof typeof WorkspaceInvitationScalarFieldEnum]


  export const ProviderAPIKeyScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    provider: 'provider',
    displayName: 'displayName',
    keyHash: 'keyHash',
    providerConfig: 'providerConfig',
    endpoint: 'endpoint',
    authType: 'authType',
    isActive: 'isActive',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type ProviderAPIKeyScalarFieldEnum = (typeof ProviderAPIKeyScalarFieldEnum)[keyof typeof ProviderAPIKeyScalarFieldEnum]


  export const ShareLinkScalarFieldEnum: {
    id: 'id',
    publicToken: 'publicToken',
    assetType: 'assetType',
    assetId: 'assetId',
    workspaceId: 'workspaceId',
    createdBy: 'createdBy',
    accessLevel: 'accessLevel',
    password: 'password',
    viewCount: 'viewCount',
    lastViewedAt: 'lastViewedAt',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type ShareLinkScalarFieldEnum = (typeof ShareLinkScalarFieldEnum)[keyof typeof ShareLinkScalarFieldEnum]


  export const DocumentFolderScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    parentId: 'parentId',
    icon: 'icon',
    color: 'color',
    sortOrder: 'sortOrder',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentFolderScalarFieldEnum = (typeof DocumentFolderScalarFieldEnum)[keyof typeof DocumentFolderScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    folderId: 'folderId',
    name: 'name',
    sourceType: 'sourceType',
    storageKey: 'storageKey',
    s3Bucket: 's3Bucket',
    externalUrl: 'externalUrl',
    externalProvider: 'externalProvider',
    externalFileId: 'externalFileId',
    fileType: 'fileType',
    mimeType: 'mimeType',
    sizeInBytes: 'sizeInBytes',
    status: 'status',
    uploadedBy: 'uploadedBy',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const EmbeddingScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    model: 'model',
    chunkIndex: 'chunkIndex',
    chunkText: 'chunkText',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey',
    vectorDimension: 'vectorDimension',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type EmbeddingScalarFieldEnum = (typeof EmbeddingScalarFieldEnum)[keyof typeof EmbeddingScalarFieldEnum]


  export const DocumentProcessingCostScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    workspaceId: 'workspaceId',
    subscriptionId: 'subscriptionId',
    processingType: 'processingType',
    creditsConsumed: 'creditsConsumed',
    extractionCost: 'extractionCost',
    embeddingCost: 'embeddingCost',
    totalCostInUsd: 'totalCostInUsd',
    chunkCount: 'chunkCount',
    embeddingModel: 'embeddingModel',
    processingTimeMs: 'processingTimeMs',
    tokensProcessed: 'tokensProcessed',
    processedAt: 'processedAt'
  };

  export type DocumentProcessingCostScalarFieldEnum = (typeof DocumentProcessingCostScalarFieldEnum)[keyof typeof DocumentProcessingCostScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AdminOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    mfaSecret: 'mfaSecret',
    lastLoginIp: 'lastLoginIp',
    passwordResetToken: 'passwordResetToken',
    createdBy: 'createdBy',
    deactivatedBy: 'deactivatedBy'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const AdminSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    revokedReason: 'revokedReason'
  };

  export type AdminSessionOrderByRelevanceFieldEnum = (typeof AdminSessionOrderByRelevanceFieldEnum)[keyof typeof AdminSessionOrderByRelevanceFieldEnum]


  export const AdminAuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    resourceId: 'resourceId',
    method: 'method',
    endpoint: 'endpoint',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    errorMessage: 'errorMessage'
  };

  export type AdminAuditLogOrderByRelevanceFieldEnum = (typeof AdminAuditLogOrderByRelevanceFieldEnum)[keyof typeof AdminAuditLogOrderByRelevanceFieldEnum]


  export const AdminPermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    grantedBy: 'grantedBy'
  };

  export type AdminPermissionOrderByRelevanceFieldEnum = (typeof AdminPermissionOrderByRelevanceFieldEnum)[keyof typeof AdminPermissionOrderByRelevanceFieldEnum]


  export const AdminAPIKeyOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    name: 'name',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix'
  };

  export type AdminAPIKeyOrderByRelevanceFieldEnum = (typeof AdminAPIKeyOrderByRelevanceFieldEnum)[keyof typeof AdminAPIKeyOrderByRelevanceFieldEnum]


  export const AdminInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    invitedBy: 'invitedBy'
  };

  export type AdminInvitationOrderByRelevanceFieldEnum = (typeof AdminInvitationOrderByRelevanceFieldEnum)[keyof typeof AdminInvitationOrderByRelevanceFieldEnum]


  export const AdminSecurityEventOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    description: 'description',
    resolvedBy: 'resolvedBy'
  };

  export type AdminSecurityEventOrderByRelevanceFieldEnum = (typeof AdminSecurityEventOrderByRelevanceFieldEnum)[keyof typeof AdminSecurityEventOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  export const CreditPurchaseOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    currency: 'currency',
    stripeChargeId: 'stripeChargeId',
    status: 'status'
  };

  export type CreditPurchaseOrderByRelevanceFieldEnum = (typeof CreditPurchaseOrderByRelevanceFieldEnum)[keyof typeof CreditPurchaseOrderByRelevanceFieldEnum]


  export const CreditUsageLogOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    workspaceId: 'workspaceId',
    canvasId: 'canvasId',
    podId: 'podId',
    executionId: 'executionId',
    modelId: 'modelId',
    modelName: 'modelName'
  };

  export type CreditUsageLogOrderByRelevanceFieldEnum = (typeof CreditUsageLogOrderByRelevanceFieldEnum)[keyof typeof CreditUsageLogOrderByRelevanceFieldEnum]


  export const ModelPricingTierOrderByRelevanceFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    displayName: 'displayName',
    description: 'description'
  };

  export type ModelPricingTierOrderByRelevanceFieldEnum = (typeof ModelPricingTierOrderByRelevanceFieldEnum)[keyof typeof ModelPricingTierOrderByRelevanceFieldEnum]


  export const SpaceOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    customInstructions: 'customInstructions',
    icon: 'icon',
    color: 'color',
    createdBy: 'createdBy'
  };

  export type SpaceOrderByRelevanceFieldEnum = (typeof SpaceOrderByRelevanceFieldEnum)[keyof typeof SpaceOrderByRelevanceFieldEnum]


  export const FlowOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    spaceId: 'spaceId',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    thumbnailS3Key: 'thumbnailS3Key'
  };

  export type FlowOrderByRelevanceFieldEnum = (typeof FlowOrderByRelevanceFieldEnum)[keyof typeof FlowOrderByRelevanceFieldEnum]


  export const FlowInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    email: 'email',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token'
  };

  export type FlowInvitationOrderByRelevanceFieldEnum = (typeof FlowInvitationOrderByRelevanceFieldEnum)[keyof typeof FlowInvitationOrderByRelevanceFieldEnum]


  export const FlowCollaboratorOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    invitedBy: 'invitedBy'
  };

  export type FlowCollaboratorOrderByRelevanceFieldEnum = (typeof FlowCollaboratorOrderByRelevanceFieldEnum)[keyof typeof FlowCollaboratorOrderByRelevanceFieldEnum]


  export const FlowSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    anonymousName: 'anonymousName',
    sessionToken: 'sessionToken',
    socketId: 'socketId',
    userColor: 'userColor',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress'
  };

  export type FlowSessionOrderByRelevanceFieldEnum = (typeof FlowSessionOrderByRelevanceFieldEnum)[keyof typeof FlowSessionOrderByRelevanceFieldEnum]


  export const FlowActivityLogOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    entityType: 'entityType',
    entityId: 'entityId'
  };

  export type FlowActivityLogOrderByRelevanceFieldEnum = (typeof FlowActivityLogOrderByRelevanceFieldEnum)[keyof typeof FlowActivityLogOrderByRelevanceFieldEnum]


  export const FlowCommentOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    userId: 'userId',
    content: 'content',
    podId: 'podId',
    parentId: 'parentId',
    resolvedBy: 'resolvedBy'
  };

  export type FlowCommentOrderByRelevanceFieldEnum = (typeof FlowCommentOrderByRelevanceFieldEnum)[keyof typeof FlowCommentOrderByRelevanceFieldEnum]


  export const PodOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    lastExecutionId: 'lastExecutionId',
    contextFlowId: 'contextFlowId',
    documentId: 'documentId',
    lockedBy: 'lockedBy',
    dynamoPartitionKey: 'dynamoPartitionKey',
    dynamoSortKey: 'dynamoSortKey',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey'
  };

  export type PodOrderByRelevanceFieldEnum = (typeof PodOrderByRelevanceFieldEnum)[keyof typeof PodOrderByRelevanceFieldEnum]


  export const EdgeOrderByRelevanceFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    sourcePodId: 'sourcePodId',
    targetPodId: 'targetPodId',
    sourceHandle: 'sourceHandle',
    targetHandle: 'targetHandle'
  };

  export type EdgeOrderByRelevanceFieldEnum = (typeof EdgeOrderByRelevanceFieldEnum)[keyof typeof EdgeOrderByRelevanceFieldEnum]


  export const PodExecutionOrderByRelevanceFieldEnum: {
    id: 'id',
    podId: 'podId',
    flowId: 'flowId',
    workspaceId: 'workspaceId',
    modelId: 'modelId',
    modelName: 'modelName',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode'
  };

  export type PodExecutionOrderByRelevanceFieldEnum = (typeof PodExecutionOrderByRelevanceFieldEnum)[keyof typeof PodExecutionOrderByRelevanceFieldEnum]


  export const PodUsageLogOrderByRelevanceFieldEnum: {
    id: 'id',
    podId: 'podId',
    executionId: 'executionId',
    flowId: 'flowId',
    workspaceId: 'workspaceId',
    subscriptionId: 'subscriptionId',
    modelId: 'modelId',
    modelName: 'modelName'
  };

  export type PodUsageLogOrderByRelevanceFieldEnum = (typeof PodUsageLogOrderByRelevanceFieldEnum)[keyof typeof PodUsageLogOrderByRelevanceFieldEnum]


  export const ContextModuleOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    originalFlowId: 'originalFlowId'
  };

  export type ContextModuleOrderByRelevanceFieldEnum = (typeof ContextModuleOrderByRelevanceFieldEnum)[keyof typeof ContextModuleOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    hash: 'hash'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RefreshTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    deviceName: 'deviceName',
    userId: 'userId'
  };

  export type RefreshTokenOrderByRelevanceFieldEnum = (typeof RefreshTokenOrderByRelevanceFieldEnum)[keyof typeof RefreshTokenOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    providerAccountId: 'providerAccountId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const WorkspaceOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WorkspaceOrderByRelevanceFieldEnum = (typeof WorkspaceOrderByRelevanceFieldEnum)[keyof typeof WorkspaceOrderByRelevanceFieldEnum]


  export const WorkspaceUserOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    invitedBy: 'invitedBy'
  };

  export type WorkspaceUserOrderByRelevanceFieldEnum = (typeof WorkspaceUserOrderByRelevanceFieldEnum)[keyof typeof WorkspaceUserOrderByRelevanceFieldEnum]


  export const WorkspaceInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token'
  };

  export type WorkspaceInvitationOrderByRelevanceFieldEnum = (typeof WorkspaceInvitationOrderByRelevanceFieldEnum)[keyof typeof WorkspaceInvitationOrderByRelevanceFieldEnum]


  export const ProviderAPIKeyOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    displayName: 'displayName',
    keyHash: 'keyHash',
    endpoint: 'endpoint'
  };

  export type ProviderAPIKeyOrderByRelevanceFieldEnum = (typeof ProviderAPIKeyOrderByRelevanceFieldEnum)[keyof typeof ProviderAPIKeyOrderByRelevanceFieldEnum]


  export const ShareLinkOrderByRelevanceFieldEnum: {
    id: 'id',
    publicToken: 'publicToken',
    assetId: 'assetId',
    workspaceId: 'workspaceId',
    createdBy: 'createdBy',
    password: 'password'
  };

  export type ShareLinkOrderByRelevanceFieldEnum = (typeof ShareLinkOrderByRelevanceFieldEnum)[keyof typeof ShareLinkOrderByRelevanceFieldEnum]


  export const DocumentFolderOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    parentId: 'parentId',
    icon: 'icon',
    color: 'color',
    createdBy: 'createdBy'
  };

  export type DocumentFolderOrderByRelevanceFieldEnum = (typeof DocumentFolderOrderByRelevanceFieldEnum)[keyof typeof DocumentFolderOrderByRelevanceFieldEnum]


  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    folderId: 'folderId',
    name: 'name',
    storageKey: 'storageKey',
    s3Bucket: 's3Bucket',
    externalUrl: 'externalUrl',
    externalProvider: 'externalProvider',
    externalFileId: 'externalFileId',
    fileType: 'fileType',
    mimeType: 'mimeType',
    uploadedBy: 'uploadedBy'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const EmbeddingOrderByRelevanceFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    model: 'model',
    chunkText: 'chunkText',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey'
  };

  export type EmbeddingOrderByRelevanceFieldEnum = (typeof EmbeddingOrderByRelevanceFieldEnum)[keyof typeof EmbeddingOrderByRelevanceFieldEnum]


  export const DocumentProcessingCostOrderByRelevanceFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    workspaceId: 'workspaceId',
    subscriptionId: 'subscriptionId',
    embeddingModel: 'embeddingModel'
  };

  export type DocumentProcessingCostOrderByRelevanceFieldEnum = (typeof DocumentProcessingCostOrderByRelevanceFieldEnum)[keyof typeof DocumentProcessingCostOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'AdminStatus'
   */
  export type EnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus'>
    


  /**
   * Reference to a field of type 'AdminStatus[]'
   */
  export type ListEnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AdminAction'
   */
  export type EnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction'>
    


  /**
   * Reference to a field of type 'AdminAction[]'
   */
  export type ListEnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction[]'>
    


  /**
   * Reference to a field of type 'AdminResource'
   */
  export type EnumAdminResourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminResource'>
    


  /**
   * Reference to a field of type 'AdminResource[]'
   */
  export type ListEnumAdminResourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminResource[]'>
    


  /**
   * Reference to a field of type 'SpecificPermission'
   */
  export type EnumSpecificPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpecificPermission'>
    


  /**
   * Reference to a field of type 'SpecificPermission[]'
   */
  export type ListEnumSpecificPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpecificPermission[]'>
    


  /**
   * Reference to a field of type 'SecurityEventType'
   */
  export type EnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType'>
    


  /**
   * Reference to a field of type 'SecurityEventType[]'
   */
  export type ListEnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType[]'>
    


  /**
   * Reference to a field of type 'SecuritySeverity'
   */
  export type EnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity'>
    


  /**
   * Reference to a field of type 'SecuritySeverity[]'
   */
  export type ListEnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LLMProvider'
   */
  export type EnumLLMProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LLMProvider'>
    


  /**
   * Reference to a field of type 'LLMProvider[]'
   */
  export type ListEnumLLMProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LLMProvider[]'>
    


  /**
   * Reference to a field of type 'ModelCategory'
   */
  export type EnumModelCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelCategory'>
    


  /**
   * Reference to a field of type 'ModelCategory[]'
   */
  export type ListEnumModelCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelCategory[]'>
    


  /**
   * Reference to a field of type 'FlowVisibility'
   */
  export type EnumFlowVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowVisibility'>
    


  /**
   * Reference to a field of type 'FlowVisibility[]'
   */
  export type ListEnumFlowVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowVisibility[]'>
    


  /**
   * Reference to a field of type 'FlowAccessLevel'
   */
  export type EnumFlowAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowAccessLevel'>
    


  /**
   * Reference to a field of type 'FlowAccessLevel[]'
   */
  export type ListEnumFlowAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowAccessLevel[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'FlowActivityAction'
   */
  export type EnumFlowActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowActivityAction'>
    


  /**
   * Reference to a field of type 'FlowActivityAction[]'
   */
  export type ListEnumFlowActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowActivityAction[]'>
    


  /**
   * Reference to a field of type 'PodType'
   */
  export type EnumPodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PodType'>
    


  /**
   * Reference to a field of type 'PodType[]'
   */
  export type ListEnumPodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PodType[]'>
    


  /**
   * Reference to a field of type 'PodExecutionStatus'
   */
  export type EnumPodExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PodExecutionStatus'>
    


  /**
   * Reference to a field of type 'PodExecutionStatus[]'
   */
  export type ListEnumPodExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PodExecutionStatus[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'WorkspaceType'
   */
  export type EnumWorkspaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceType'>
    


  /**
   * Reference to a field of type 'WorkspaceType[]'
   */
  export type ListEnumWorkspaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceType[]'>
    


  /**
   * Reference to a field of type 'WorkspaceRole'
   */
  export type EnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole'>
    


  /**
   * Reference to a field of type 'WorkspaceRole[]'
   */
  export type ListEnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole[]'>
    


  /**
   * Reference to a field of type 'AuthType'
   */
  export type EnumAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthType'>
    


  /**
   * Reference to a field of type 'AuthType[]'
   */
  export type ListEnumAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthType[]'>
    


  /**
   * Reference to a field of type 'ShareableAssetType'
   */
  export type EnumShareableAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareableAssetType'>
    


  /**
   * Reference to a field of type 'ShareableAssetType[]'
   */
  export type ListEnumShareableAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareableAssetType[]'>
    


  /**
   * Reference to a field of type 'ShareAccessLevel'
   */
  export type EnumShareAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareAccessLevel'>
    


  /**
   * Reference to a field of type 'ShareAccessLevel[]'
   */
  export type ListEnumShareAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareAccessLevel[]'>
    


  /**
   * Reference to a field of type 'DocumentSourceType'
   */
  export type EnumDocumentSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentSourceType'>
    


  /**
   * Reference to a field of type 'DocumentSourceType[]'
   */
  export type ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentSourceType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentProcessingType'
   */
  export type EnumDocumentProcessingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentProcessingType'>
    


  /**
   * Reference to a field of type 'DocumentProcessingType[]'
   */
  export type ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentProcessingType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    username?: StringFilter<"Admin"> | string
    passwordHash?: StringFilter<"Admin"> | string
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    isSuperAdmin?: BoolFilter<"Admin"> | boolean
    requiresMfa?: BoolFilter<"Admin"> | boolean
    mfaSecret?: StringNullableFilter<"Admin"> | string | null
    mfaBackupCodes?: JsonNullableFilter<"Admin">
    mfaVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    allowedIpAddresses?: JsonNullableFilter<"Admin">
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"Admin"> | string | null
    failedLoginAttempts?: IntFilter<"Admin"> | number
    lockedUntil?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"Admin"> | string | null
    passwordResetExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    createdBy?: StringNullableFilter<"Admin"> | string | null
    deactivatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deactivatedBy?: StringNullableFilter<"Admin"> | string | null
    sessions?: AdminSessionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    permissions?: AdminPermissionListRelationFilter
    apiKeys?: AdminAPIKeyListRelationFilter
    invitations?: AdminInvitationListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodes?: SortOrderInput | SortOrder
    mfaVerifiedAt?: SortOrderInput | SortOrder
    allowedIpAddresses?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    sessions?: AdminSessionOrderByRelationAggregateInput
    auditLogs?: AdminAuditLogOrderByRelationAggregateInput
    permissions?: AdminPermissionOrderByRelationAggregateInput
    apiKeys?: AdminAPIKeyOrderByRelationAggregateInput
    invitations?: AdminInvitationOrderByRelationAggregateInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    passwordResetToken?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    passwordHash?: StringFilter<"Admin"> | string
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    isSuperAdmin?: BoolFilter<"Admin"> | boolean
    requiresMfa?: BoolFilter<"Admin"> | boolean
    mfaSecret?: StringNullableFilter<"Admin"> | string | null
    mfaBackupCodes?: JsonNullableFilter<"Admin">
    mfaVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    allowedIpAddresses?: JsonNullableFilter<"Admin">
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"Admin"> | string | null
    failedLoginAttempts?: IntFilter<"Admin"> | number
    lockedUntil?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordResetExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    createdBy?: StringNullableFilter<"Admin"> | string | null
    deactivatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deactivatedBy?: StringNullableFilter<"Admin"> | string | null
    sessions?: AdminSessionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    permissions?: AdminPermissionListRelationFilter
    apiKeys?: AdminAPIKeyListRelationFilter
    invitations?: AdminInvitationListRelationFilter
  }, "id" | "email" | "username" | "passwordResetToken">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodes?: SortOrderInput | SortOrder
    mfaVerifiedAt?: SortOrderInput | SortOrder
    allowedIpAddresses?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    username?: StringWithAggregatesFilter<"Admin"> | string
    passwordHash?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAdminStatusWithAggregatesFilter<"Admin"> | $Enums.AdminStatus
    isSuperAdmin?: BoolWithAggregatesFilter<"Admin"> | boolean
    requiresMfa?: BoolWithAggregatesFilter<"Admin"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    mfaBackupCodes?: JsonNullableWithAggregatesFilter<"Admin">
    mfaVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    allowedIpAddresses?: JsonNullableWithAggregatesFilter<"Admin">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"Admin"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    passwordResetExpiry?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    deactivatedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    deactivatedBy?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type AdminSessionWhereInput = {
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    token?: StringFilter<"AdminSession"> | string
    refreshToken?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableFilter<"AdminSession"> | string | null
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableFilter<"AdminSession"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminSessionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminSessionOrderByRelevanceInput
  }

  export type AdminSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    adminId?: StringFilter<"AdminSession"> | string
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableFilter<"AdminSession"> | string | null
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableFilter<"AdminSession"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "token" | "refreshToken">

  export type AdminSessionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    _count?: AdminSessionCountOrderByAggregateInput
    _max?: AdminSessionMaxOrderByAggregateInput
    _min?: AdminSessionMinOrderByAggregateInput
  }

  export type AdminSessionScalarWhereWithAggregatesInput = {
    AND?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    OR?: AdminSessionScalarWhereWithAggregatesInput[]
    NOT?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSession"> | string
    adminId?: StringWithAggregatesFilter<"AdminSession"> | string
    token?: StringWithAggregatesFilter<"AdminSession"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    ipAddress?: StringWithAggregatesFilter<"AdminSession"> | string
    userAgent?: StringWithAggregatesFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringNullableFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    method?: StringFilter<"AdminAuditLog"> | string
    endpoint?: StringFilter<"AdminAuditLog"> | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableFilter<"AdminAuditLog">
    changesAfter?: JsonNullableFilter<"AdminAuditLog">
    status?: IntFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    changesBefore?: SortOrderInput | SortOrder
    changesAfter?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminAuditLogOrderByRelevanceInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    adminId?: StringNullableFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    method?: StringFilter<"AdminAuditLog"> | string
    endpoint?: StringFilter<"AdminAuditLog"> | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableFilter<"AdminAuditLog">
    changesAfter?: JsonNullableFilter<"AdminAuditLog">
    status?: IntFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    changesBefore?: SortOrderInput | SortOrder
    changesAfter?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _avg?: AdminAuditLogAvgOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
    _sum?: AdminAuditLogSumOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    adminId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionWithAggregatesFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceWithAggregatesFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    method?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    endpoint?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    ipAddress?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    changesAfter?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    status?: IntWithAggregatesFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableWithAggregatesFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminPermissionWhereInput = {
    AND?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    OR?: AdminPermissionWhereInput[]
    NOT?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    id?: StringFilter<"AdminPermission"> | string
    adminId?: StringFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableFilter<"AdminPermission"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminPermissionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminPermissionOrderByRelevanceInput
  }

  export type AdminPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId_permission_resource?: AdminPermissionAdminIdPermissionResourceCompoundUniqueInput
    AND?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    OR?: AdminPermissionWhereInput[]
    NOT?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    adminId?: StringFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableFilter<"AdminPermission"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "adminId_permission_resource">

  export type AdminPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: AdminPermissionCountOrderByAggregateInput
    _max?: AdminPermissionMaxOrderByAggregateInput
    _min?: AdminPermissionMinOrderByAggregateInput
  }

  export type AdminPermissionScalarWhereWithAggregatesInput = {
    AND?: AdminPermissionScalarWhereWithAggregatesInput | AdminPermissionScalarWhereWithAggregatesInput[]
    OR?: AdminPermissionScalarWhereWithAggregatesInput[]
    NOT?: AdminPermissionScalarWhereWithAggregatesInput | AdminPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminPermission"> | string
    adminId?: StringWithAggregatesFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionWithAggregatesFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableWithAggregatesFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeWithAggregatesFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableWithAggregatesFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AdminPermission"> | Date | string | null
  }

  export type AdminAPIKeyWhereInput = {
    AND?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    OR?: AdminAPIKeyWhereInput[]
    NOT?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    id?: StringFilter<"AdminAPIKey"> | string
    adminId?: StringFilter<"AdminAPIKey"> | string
    name?: StringFilter<"AdminAPIKey"> | string
    keyHash?: StringFilter<"AdminAPIKey"> | string
    keyPrefix?: StringFilter<"AdminAPIKey"> | string
    scopes?: JsonFilter<"AdminAPIKey">
    rateLimit?: IntNullableFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableFilter<"AdminAPIKey">
    createdAt?: DateTimeFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminAPIKeyOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    allowedIps?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminAPIKeyOrderByRelevanceInput
  }

  export type AdminAPIKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    OR?: AdminAPIKeyWhereInput[]
    NOT?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    adminId?: StringFilter<"AdminAPIKey"> | string
    name?: StringFilter<"AdminAPIKey"> | string
    keyPrefix?: StringFilter<"AdminAPIKey"> | string
    scopes?: JsonFilter<"AdminAPIKey">
    rateLimit?: IntNullableFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableFilter<"AdminAPIKey">
    createdAt?: DateTimeFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "keyHash">

  export type AdminAPIKeyOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    allowedIps?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: AdminAPIKeyCountOrderByAggregateInput
    _avg?: AdminAPIKeyAvgOrderByAggregateInput
    _max?: AdminAPIKeyMaxOrderByAggregateInput
    _min?: AdminAPIKeyMinOrderByAggregateInput
    _sum?: AdminAPIKeySumOrderByAggregateInput
  }

  export type AdminAPIKeyScalarWhereWithAggregatesInput = {
    AND?: AdminAPIKeyScalarWhereWithAggregatesInput | AdminAPIKeyScalarWhereWithAggregatesInput[]
    OR?: AdminAPIKeyScalarWhereWithAggregatesInput[]
    NOT?: AdminAPIKeyScalarWhereWithAggregatesInput | AdminAPIKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    adminId?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    name?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    keyHash?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    keyPrefix?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    scopes?: JsonWithAggregatesFilter<"AdminAPIKey">
    rateLimit?: IntNullableWithAggregatesFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableWithAggregatesFilter<"AdminAPIKey">
    createdAt?: DateTimeWithAggregatesFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"AdminAPIKey"> | Date | string | null
  }

  export type AdminInvitationWhereInput = {
    AND?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    OR?: AdminInvitationWhereInput[]
    NOT?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    id?: StringFilter<"AdminInvitation"> | string
    email?: StringFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleFilter<"AdminInvitation"> | $Enums.AdminRole
    token?: StringFilter<"AdminInvitation"> | string
    invitedBy?: StringFilter<"AdminInvitation"> | string
    createdAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"AdminInvitation"> | Date | string | null
    inviter?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminInvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    inviter?: AdminOrderByWithRelationInput
    _relevance?: AdminInvitationOrderByRelevanceInput
  }

  export type AdminInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    OR?: AdminInvitationWhereInput[]
    NOT?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    email?: StringFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleFilter<"AdminInvitation"> | $Enums.AdminRole
    invitedBy?: StringFilter<"AdminInvitation"> | string
    createdAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"AdminInvitation"> | Date | string | null
    inviter?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "token">

  export type AdminInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: AdminInvitationCountOrderByAggregateInput
    _max?: AdminInvitationMaxOrderByAggregateInput
    _min?: AdminInvitationMinOrderByAggregateInput
  }

  export type AdminInvitationScalarWhereWithAggregatesInput = {
    AND?: AdminInvitationScalarWhereWithAggregatesInput | AdminInvitationScalarWhereWithAggregatesInput[]
    OR?: AdminInvitationScalarWhereWithAggregatesInput[]
    NOT?: AdminInvitationScalarWhereWithAggregatesInput | AdminInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminInvitation"> | string
    email?: StringWithAggregatesFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"AdminInvitation"> | $Enums.AdminRole
    token?: StringWithAggregatesFilter<"AdminInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"AdminInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"AdminInvitation"> | Date | string | null
  }

  export type AdminSecurityEventWhereInput = {
    AND?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    OR?: AdminSecurityEventWhereInput[]
    NOT?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    id?: StringFilter<"AdminSecurityEvent"> | string
    eventType?: EnumSecurityEventTypeFilter<"AdminSecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"AdminSecurityEvent"> | $Enums.SecuritySeverity
    adminId?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    ipAddress?: StringFilter<"AdminSecurityEvent"> | string
    userAgent?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    description?: StringFilter<"AdminSecurityEvent"> | string
    metadata?: JsonNullableFilter<"AdminSecurityEvent">
    resolved?: BoolFilter<"AdminSecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AdminSecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"AdminSecurityEvent"> | Date | string
  }

  export type AdminSecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: AdminSecurityEventOrderByRelevanceInput
  }

  export type AdminSecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    OR?: AdminSecurityEventWhereInput[]
    NOT?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    eventType?: EnumSecurityEventTypeFilter<"AdminSecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"AdminSecurityEvent"> | $Enums.SecuritySeverity
    adminId?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    ipAddress?: StringFilter<"AdminSecurityEvent"> | string
    userAgent?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    description?: StringFilter<"AdminSecurityEvent"> | string
    metadata?: JsonNullableFilter<"AdminSecurityEvent">
    resolved?: BoolFilter<"AdminSecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AdminSecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"AdminSecurityEvent"> | Date | string
  }, "id">

  export type AdminSecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminSecurityEventCountOrderByAggregateInput
    _max?: AdminSecurityEventMaxOrderByAggregateInput
    _min?: AdminSecurityEventMinOrderByAggregateInput
  }

  export type AdminSecurityEventScalarWhereWithAggregatesInput = {
    AND?: AdminSecurityEventScalarWhereWithAggregatesInput | AdminSecurityEventScalarWhereWithAggregatesInput[]
    OR?: AdminSecurityEventScalarWhereWithAggregatesInput[]
    NOT?: AdminSecurityEventScalarWhereWithAggregatesInput | AdminSecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSecurityEvent"> | string
    eventType?: EnumSecurityEventTypeWithAggregatesFilter<"AdminSecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityWithAggregatesFilter<"AdminSecurityEvent"> | $Enums.SecuritySeverity
    adminId?: StringNullableWithAggregatesFilter<"AdminSecurityEvent"> | string | null
    ipAddress?: StringWithAggregatesFilter<"AdminSecurityEvent"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AdminSecurityEvent"> | string | null
    description?: StringWithAggregatesFilter<"AdminSecurityEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AdminSecurityEvent">
    resolved?: BoolWithAggregatesFilter<"AdminSecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"AdminSecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"AdminSecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminSecurityEvent"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    workspaceId?: StringFilter<"Subscription"> | string
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    credits?: IntFilter<"Subscription"> | number
    monthlyCreditQuota?: IntFilter<"Subscription"> | number
    creditResetDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    maxCanvases?: IntFilter<"Subscription"> | number
    maxActionPodsPerCanvas?: IntFilter<"Subscription"> | number
    maxDocumentSizeInMB?: IntFilter<"Subscription"> | number
    maxCollaboratorsPerCanvas?: IntFilter<"Subscription"> | number
    canInviteToWorkspace?: BoolFilter<"Subscription"> | boolean
    canInviteToCanvas?: BoolFilter<"Subscription"> | boolean
    canCreatePublicLinks?: BoolFilter<"Subscription"> | boolean
    canUseAdvancedModels?: BoolFilter<"Subscription"> | boolean
    canAccessAnalytics?: BoolFilter<"Subscription"> | boolean
    canExportData?: BoolFilter<"Subscription"> | boolean
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    isByokMode?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    usageLogs?: PodUsageLogListRelationFilter
    creditPurchases?: CreditPurchaseListRelationFilter
    creditUsage?: CreditUsageLogListRelationFilter
    documentProcessingCost?: DocumentProcessingCostListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrderInput | SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    usageLogs?: PodUsageLogOrderByRelationAggregateInput
    creditPurchases?: CreditPurchaseOrderByRelationAggregateInput
    creditUsage?: CreditUsageLogOrderByRelationAggregateInput
    documentProcessingCost?: DocumentProcessingCostOrderByRelationAggregateInput
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    credits?: IntFilter<"Subscription"> | number
    monthlyCreditQuota?: IntFilter<"Subscription"> | number
    creditResetDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    maxCanvases?: IntFilter<"Subscription"> | number
    maxActionPodsPerCanvas?: IntFilter<"Subscription"> | number
    maxDocumentSizeInMB?: IntFilter<"Subscription"> | number
    maxCollaboratorsPerCanvas?: IntFilter<"Subscription"> | number
    canInviteToWorkspace?: BoolFilter<"Subscription"> | boolean
    canInviteToCanvas?: BoolFilter<"Subscription"> | boolean
    canCreatePublicLinks?: BoolFilter<"Subscription"> | boolean
    canUseAdvancedModels?: BoolFilter<"Subscription"> | boolean
    canAccessAnalytics?: BoolFilter<"Subscription"> | boolean
    canExportData?: BoolFilter<"Subscription"> | boolean
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    isByokMode?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    usageLogs?: PodUsageLogListRelationFilter
    creditPurchases?: CreditPurchaseListRelationFilter
    creditUsage?: CreditUsageLogListRelationFilter
    documentProcessingCost?: DocumentProcessingCostListRelationFilter
  }, "id" | "workspaceId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrderInput | SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    workspaceId?: StringWithAggregatesFilter<"Subscription"> | string
    tier?: EnumSubscriptionTierWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    credits?: IntWithAggregatesFilter<"Subscription"> | number
    monthlyCreditQuota?: IntWithAggregatesFilter<"Subscription"> | number
    creditResetDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    maxCanvases?: IntWithAggregatesFilter<"Subscription"> | number
    maxActionPodsPerCanvas?: IntWithAggregatesFilter<"Subscription"> | number
    maxDocumentSizeInMB?: IntWithAggregatesFilter<"Subscription"> | number
    maxCollaboratorsPerCanvas?: IntWithAggregatesFilter<"Subscription"> | number
    canInviteToWorkspace?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canInviteToCanvas?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canCreatePublicLinks?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canUseAdvancedModels?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canAccessAnalytics?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canExportData?: BoolWithAggregatesFilter<"Subscription"> | boolean
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    isByokMode?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type CreditPurchaseWhereInput = {
    AND?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    OR?: CreditPurchaseWhereInput[]
    NOT?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    id?: StringFilter<"CreditPurchase"> | string
    subscriptionId?: StringFilter<"CreditPurchase"> | string
    creditsPurchased?: IntFilter<"CreditPurchase"> | number
    amountPaid?: DecimalFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"CreditPurchase"> | string
    stripeChargeId?: StringFilter<"CreditPurchase"> | string
    status?: StringFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeFilter<"CreditPurchase"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type CreditPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: CreditPurchaseOrderByRelevanceInput
  }

  export type CreditPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeChargeId?: string
    AND?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    OR?: CreditPurchaseWhereInput[]
    NOT?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    subscriptionId?: StringFilter<"CreditPurchase"> | string
    creditsPurchased?: IntFilter<"CreditPurchase"> | number
    amountPaid?: DecimalFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"CreditPurchase"> | string
    status?: StringFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeFilter<"CreditPurchase"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id" | "stripeChargeId">

  export type CreditPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    _count?: CreditPurchaseCountOrderByAggregateInput
    _avg?: CreditPurchaseAvgOrderByAggregateInput
    _max?: CreditPurchaseMaxOrderByAggregateInput
    _min?: CreditPurchaseMinOrderByAggregateInput
    _sum?: CreditPurchaseSumOrderByAggregateInput
  }

  export type CreditPurchaseScalarWhereWithAggregatesInput = {
    AND?: CreditPurchaseScalarWhereWithAggregatesInput | CreditPurchaseScalarWhereWithAggregatesInput[]
    OR?: CreditPurchaseScalarWhereWithAggregatesInput[]
    NOT?: CreditPurchaseScalarWhereWithAggregatesInput | CreditPurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditPurchase"> | string
    subscriptionId?: StringWithAggregatesFilter<"CreditPurchase"> | string
    creditsPurchased?: IntWithAggregatesFilter<"CreditPurchase"> | number
    amountPaid?: DecimalWithAggregatesFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"CreditPurchase"> | string
    stripeChargeId?: StringWithAggregatesFilter<"CreditPurchase"> | string
    status?: StringWithAggregatesFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeWithAggregatesFilter<"CreditPurchase"> | Date | string
  }

  export type CreditUsageLogWhereInput = {
    AND?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    OR?: CreditUsageLogWhereInput[]
    NOT?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    id?: StringFilter<"CreditUsageLog"> | string
    subscriptionId?: StringFilter<"CreditUsageLog"> | string
    workspaceId?: StringFilter<"CreditUsageLog"> | string
    canvasId?: StringFilter<"CreditUsageLog"> | string
    podId?: StringFilter<"CreditUsageLog"> | string
    executionId?: StringFilter<"CreditUsageLog"> | string
    creditsUsed?: IntFilter<"CreditUsageLog"> | number
    balanceBefore?: IntFilter<"CreditUsageLog"> | number
    balanceAfter?: IntFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"CreditUsageLog"> | string
    modelName?: StringNullableFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeFilter<"CreditUsageLog"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type CreditUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: CreditUsageLogOrderByRelevanceInput
  }

  export type CreditUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    OR?: CreditUsageLogWhereInput[]
    NOT?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    subscriptionId?: StringFilter<"CreditUsageLog"> | string
    workspaceId?: StringFilter<"CreditUsageLog"> | string
    canvasId?: StringFilter<"CreditUsageLog"> | string
    podId?: StringFilter<"CreditUsageLog"> | string
    executionId?: StringFilter<"CreditUsageLog"> | string
    creditsUsed?: IntFilter<"CreditUsageLog"> | number
    balanceBefore?: IntFilter<"CreditUsageLog"> | number
    balanceAfter?: IntFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"CreditUsageLog"> | string
    modelName?: StringNullableFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeFilter<"CreditUsageLog"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type CreditUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CreditUsageLogCountOrderByAggregateInput
    _avg?: CreditUsageLogAvgOrderByAggregateInput
    _max?: CreditUsageLogMaxOrderByAggregateInput
    _min?: CreditUsageLogMinOrderByAggregateInput
    _sum?: CreditUsageLogSumOrderByAggregateInput
  }

  export type CreditUsageLogScalarWhereWithAggregatesInput = {
    AND?: CreditUsageLogScalarWhereWithAggregatesInput | CreditUsageLogScalarWhereWithAggregatesInput[]
    OR?: CreditUsageLogScalarWhereWithAggregatesInput[]
    NOT?: CreditUsageLogScalarWhereWithAggregatesInput | CreditUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    subscriptionId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    workspaceId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    canvasId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    podId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    executionId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    creditsUsed?: IntWithAggregatesFilter<"CreditUsageLog"> | number
    balanceBefore?: IntWithAggregatesFilter<"CreditUsageLog"> | number
    balanceAfter?: IntWithAggregatesFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderWithAggregatesFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    modelName?: StringNullableWithAggregatesFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CreditUsageLog"> | Date | string
  }

  export type ModelPricingTierWhereInput = {
    AND?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    OR?: ModelPricingTierWhereInput[]
    NOT?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    id?: StringFilter<"ModelPricingTier"> | string
    provider?: EnumLLMProviderFilter<"ModelPricingTier"> | $Enums.LLMProvider
    modelId?: StringFilter<"ModelPricingTier"> | string
    category?: EnumModelCategoryFilter<"ModelPricingTier"> | $Enums.ModelCategory
    displayName?: StringFilter<"ModelPricingTier"> | string
    description?: StringNullableFilter<"ModelPricingTier"> | string | null
    inputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionOutputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionReasoningTokens?: IntFilter<"ModelPricingTier"> | number
    maxTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    maxOutputTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    supportsStreaming?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVision?: BoolFilter<"ModelPricingTier"> | boolean
    supportsAudio?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVideo?: BoolFilter<"ModelPricingTier"> | boolean
    supportsFunctions?: BoolFilter<"ModelPricingTier"> | boolean
    supportsJsonMode?: BoolFilter<"ModelPricingTier"> | boolean
    supportsSystemPrompt?: BoolFilter<"ModelPricingTier"> | boolean
    providerConfig?: JsonNullableFilter<"ModelPricingTier">
    isActive?: BoolFilter<"ModelPricingTier"> | boolean
    effectiveFrom?: DateTimeFilter<"ModelPricingTier"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"ModelPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
    updatedAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
  }

  export type ModelPricingTierOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrderInput | SortOrder
    maxOutputTokens?: SortOrderInput | SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ModelPricingTierOrderByRelevanceInput
  }

  export type ModelPricingTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_modelId_effectiveFrom?: ModelPricingTierProviderModelIdEffectiveFromCompoundUniqueInput
    AND?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    OR?: ModelPricingTierWhereInput[]
    NOT?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    provider?: EnumLLMProviderFilter<"ModelPricingTier"> | $Enums.LLMProvider
    modelId?: StringFilter<"ModelPricingTier"> | string
    category?: EnumModelCategoryFilter<"ModelPricingTier"> | $Enums.ModelCategory
    displayName?: StringFilter<"ModelPricingTier"> | string
    description?: StringNullableFilter<"ModelPricingTier"> | string | null
    inputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionOutputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionReasoningTokens?: IntFilter<"ModelPricingTier"> | number
    maxTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    maxOutputTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    supportsStreaming?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVision?: BoolFilter<"ModelPricingTier"> | boolean
    supportsAudio?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVideo?: BoolFilter<"ModelPricingTier"> | boolean
    supportsFunctions?: BoolFilter<"ModelPricingTier"> | boolean
    supportsJsonMode?: BoolFilter<"ModelPricingTier"> | boolean
    supportsSystemPrompt?: BoolFilter<"ModelPricingTier"> | boolean
    providerConfig?: JsonNullableFilter<"ModelPricingTier">
    isActive?: BoolFilter<"ModelPricingTier"> | boolean
    effectiveFrom?: DateTimeFilter<"ModelPricingTier"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"ModelPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
    updatedAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
  }, "id" | "provider_modelId_effectiveFrom">

  export type ModelPricingTierOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrderInput | SortOrder
    maxOutputTokens?: SortOrderInput | SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelPricingTierCountOrderByAggregateInput
    _avg?: ModelPricingTierAvgOrderByAggregateInput
    _max?: ModelPricingTierMaxOrderByAggregateInput
    _min?: ModelPricingTierMinOrderByAggregateInput
    _sum?: ModelPricingTierSumOrderByAggregateInput
  }

  export type ModelPricingTierScalarWhereWithAggregatesInput = {
    AND?: ModelPricingTierScalarWhereWithAggregatesInput | ModelPricingTierScalarWhereWithAggregatesInput[]
    OR?: ModelPricingTierScalarWhereWithAggregatesInput[]
    NOT?: ModelPricingTierScalarWhereWithAggregatesInput | ModelPricingTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelPricingTier"> | string
    provider?: EnumLLMProviderWithAggregatesFilter<"ModelPricingTier"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"ModelPricingTier"> | string
    category?: EnumModelCategoryWithAggregatesFilter<"ModelPricingTier"> | $Enums.ModelCategory
    displayName?: StringWithAggregatesFilter<"ModelPricingTier"> | string
    description?: StringNullableWithAggregatesFilter<"ModelPricingTier"> | string | null
    inputTokenCost?: DecimalWithAggregatesFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalWithAggregatesFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalWithAggregatesFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntWithAggregatesFilter<"ModelPricingTier"> | number
    creditsPerMillionOutputTokens?: IntWithAggregatesFilter<"ModelPricingTier"> | number
    creditsPerMillionReasoningTokens?: IntWithAggregatesFilter<"ModelPricingTier"> | number
    maxTokens?: IntNullableWithAggregatesFilter<"ModelPricingTier"> | number | null
    maxOutputTokens?: IntNullableWithAggregatesFilter<"ModelPricingTier"> | number | null
    supportsStreaming?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsVision?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsAudio?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsVideo?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsFunctions?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsJsonMode?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsSystemPrompt?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    providerConfig?: JsonNullableWithAggregatesFilter<"ModelPricingTier">
    isActive?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    effectiveFrom?: DateTimeWithAggregatesFilter<"ModelPricingTier"> | Date | string
    effectiveUntil?: DateTimeNullableWithAggregatesFilter<"ModelPricingTier"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModelPricingTier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelPricingTier"> | Date | string
  }

  export type SpaceWhereInput = {
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    id?: StringFilter<"Space"> | string
    workspaceId?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    customInstructions?: StringNullableFilter<"Space"> | string | null
    icon?: StringNullableFilter<"Space"> | string | null
    color?: StringNullableFilter<"Space"> | string | null
    createdBy?: StringFilter<"Space"> | string
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    flows?: FlowListRelationFilter
  }

  export type SpaceOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    customInstructions?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    flows?: FlowOrderByRelationAggregateInput
    _relevance?: SpaceOrderByRelevanceInput
  }

  export type SpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_name?: SpaceWorkspaceIdNameCompoundUniqueInput
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    workspaceId?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    customInstructions?: StringNullableFilter<"Space"> | string | null
    icon?: StringNullableFilter<"Space"> | string | null
    color?: StringNullableFilter<"Space"> | string | null
    createdBy?: StringFilter<"Space"> | string
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    flows?: FlowListRelationFilter
  }, "id" | "workspaceId_name">

  export type SpaceOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    customInstructions?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpaceCountOrderByAggregateInput
    _max?: SpaceMaxOrderByAggregateInput
    _min?: SpaceMinOrderByAggregateInput
  }

  export type SpaceScalarWhereWithAggregatesInput = {
    AND?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    OR?: SpaceScalarWhereWithAggregatesInput[]
    NOT?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Space"> | string
    workspaceId?: StringWithAggregatesFilter<"Space"> | string
    name?: StringWithAggregatesFilter<"Space"> | string
    description?: StringNullableWithAggregatesFilter<"Space"> | string | null
    customInstructions?: StringNullableWithAggregatesFilter<"Space"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Space"> | string | null
    color?: StringNullableWithAggregatesFilter<"Space"> | string | null
    createdBy?: StringWithAggregatesFilter<"Space"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
  }

  export type FlowWhereInput = {
    AND?: FlowWhereInput | FlowWhereInput[]
    OR?: FlowWhereInput[]
    NOT?: FlowWhereInput | FlowWhereInput[]
    id?: StringFilter<"Flow"> | string
    workspaceId?: StringFilter<"Flow"> | string
    spaceId?: StringNullableFilter<"Flow"> | string | null
    name?: StringFilter<"Flow"> | string
    description?: StringNullableFilter<"Flow"> | string | null
    version?: IntFilter<"Flow"> | number
    visibility?: EnumFlowVisibilityFilter<"Flow"> | $Enums.FlowVisibility
    createdBy?: StringFilter<"Flow"> | string
    thumbnailS3Key?: StringNullableFilter<"Flow"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableFilter<"Flow"> | Date | string | null
    createdAt?: DateTimeFilter<"Flow"> | Date | string
    updatedAt?: DateTimeFilter<"Flow"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    space?: XOR<SpaceNullableScalarRelationFilter, SpaceWhereInput> | null
    pods?: PodListRelationFilter
    edges?: EdgeListRelationFilter
    contextualPods?: PodListRelationFilter
    contextModules?: ContextModuleListRelationFilter
    collaborators?: FlowCollaboratorListRelationFilter
    invitations?: FlowInvitationListRelationFilter
    sessions?: FlowSessionListRelationFilter
    activityLog?: FlowActivityLogListRelationFilter
    comments?: FlowCommentListRelationFilter
  }

  export type FlowOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    spaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrderInput | SortOrder
    thumbnailGeneratedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
    pods?: PodOrderByRelationAggregateInput
    edges?: EdgeOrderByRelationAggregateInput
    contextualPods?: PodOrderByRelationAggregateInput
    contextModules?: ContextModuleOrderByRelationAggregateInput
    collaborators?: FlowCollaboratorOrderByRelationAggregateInput
    invitations?: FlowInvitationOrderByRelationAggregateInput
    sessions?: FlowSessionOrderByRelationAggregateInput
    activityLog?: FlowActivityLogOrderByRelationAggregateInput
    comments?: FlowCommentOrderByRelationAggregateInput
    _relevance?: FlowOrderByRelevanceInput
  }

  export type FlowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlowWhereInput | FlowWhereInput[]
    OR?: FlowWhereInput[]
    NOT?: FlowWhereInput | FlowWhereInput[]
    workspaceId?: StringFilter<"Flow"> | string
    spaceId?: StringNullableFilter<"Flow"> | string | null
    name?: StringFilter<"Flow"> | string
    description?: StringNullableFilter<"Flow"> | string | null
    version?: IntFilter<"Flow"> | number
    visibility?: EnumFlowVisibilityFilter<"Flow"> | $Enums.FlowVisibility
    createdBy?: StringFilter<"Flow"> | string
    thumbnailS3Key?: StringNullableFilter<"Flow"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableFilter<"Flow"> | Date | string | null
    createdAt?: DateTimeFilter<"Flow"> | Date | string
    updatedAt?: DateTimeFilter<"Flow"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    space?: XOR<SpaceNullableScalarRelationFilter, SpaceWhereInput> | null
    pods?: PodListRelationFilter
    edges?: EdgeListRelationFilter
    contextualPods?: PodListRelationFilter
    contextModules?: ContextModuleListRelationFilter
    collaborators?: FlowCollaboratorListRelationFilter
    invitations?: FlowInvitationListRelationFilter
    sessions?: FlowSessionListRelationFilter
    activityLog?: FlowActivityLogListRelationFilter
    comments?: FlowCommentListRelationFilter
  }, "id">

  export type FlowOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    spaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrderInput | SortOrder
    thumbnailGeneratedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlowCountOrderByAggregateInput
    _avg?: FlowAvgOrderByAggregateInput
    _max?: FlowMaxOrderByAggregateInput
    _min?: FlowMinOrderByAggregateInput
    _sum?: FlowSumOrderByAggregateInput
  }

  export type FlowScalarWhereWithAggregatesInput = {
    AND?: FlowScalarWhereWithAggregatesInput | FlowScalarWhereWithAggregatesInput[]
    OR?: FlowScalarWhereWithAggregatesInput[]
    NOT?: FlowScalarWhereWithAggregatesInput | FlowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flow"> | string
    workspaceId?: StringWithAggregatesFilter<"Flow"> | string
    spaceId?: StringNullableWithAggregatesFilter<"Flow"> | string | null
    name?: StringWithAggregatesFilter<"Flow"> | string
    description?: StringNullableWithAggregatesFilter<"Flow"> | string | null
    version?: IntWithAggregatesFilter<"Flow"> | number
    visibility?: EnumFlowVisibilityWithAggregatesFilter<"Flow"> | $Enums.FlowVisibility
    createdBy?: StringWithAggregatesFilter<"Flow"> | string
    thumbnailS3Key?: StringNullableWithAggregatesFilter<"Flow"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableWithAggregatesFilter<"Flow"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Flow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flow"> | Date | string
  }

  export type FlowInvitationWhereInput = {
    AND?: FlowInvitationWhereInput | FlowInvitationWhereInput[]
    OR?: FlowInvitationWhereInput[]
    NOT?: FlowInvitationWhereInput | FlowInvitationWhereInput[]
    id?: StringFilter<"FlowInvitation"> | string
    flowId?: StringFilter<"FlowInvitation"> | string
    email?: StringFilter<"FlowInvitation"> | string
    accessLevel?: EnumFlowAccessLevelFilter<"FlowInvitation"> | $Enums.FlowAccessLevel
    permissions?: JsonNullableFilter<"FlowInvitation">
    invitedBy?: StringFilter<"FlowInvitation"> | string
    invitedUserId?: StringNullableFilter<"FlowInvitation"> | string | null
    token?: StringFilter<"FlowInvitation"> | string
    status?: EnumInvitationStatusFilter<"FlowInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"FlowInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"FlowInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"FlowInvitation"> | Date | string | null
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FlowInvitationOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    flow?: FlowOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
    _relevance?: FlowInvitationOrderByRelevanceInput
  }

  export type FlowInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: FlowInvitationWhereInput | FlowInvitationWhereInput[]
    OR?: FlowInvitationWhereInput[]
    NOT?: FlowInvitationWhereInput | FlowInvitationWhereInput[]
    flowId?: StringFilter<"FlowInvitation"> | string
    email?: StringFilter<"FlowInvitation"> | string
    accessLevel?: EnumFlowAccessLevelFilter<"FlowInvitation"> | $Enums.FlowAccessLevel
    permissions?: JsonNullableFilter<"FlowInvitation">
    invitedBy?: StringFilter<"FlowInvitation"> | string
    invitedUserId?: StringNullableFilter<"FlowInvitation"> | string | null
    status?: EnumInvitationStatusFilter<"FlowInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"FlowInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"FlowInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"FlowInvitation"> | Date | string | null
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "token">

  export type FlowInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: FlowInvitationCountOrderByAggregateInput
    _max?: FlowInvitationMaxOrderByAggregateInput
    _min?: FlowInvitationMinOrderByAggregateInput
  }

  export type FlowInvitationScalarWhereWithAggregatesInput = {
    AND?: FlowInvitationScalarWhereWithAggregatesInput | FlowInvitationScalarWhereWithAggregatesInput[]
    OR?: FlowInvitationScalarWhereWithAggregatesInput[]
    NOT?: FlowInvitationScalarWhereWithAggregatesInput | FlowInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlowInvitation"> | string
    flowId?: StringWithAggregatesFilter<"FlowInvitation"> | string
    email?: StringWithAggregatesFilter<"FlowInvitation"> | string
    accessLevel?: EnumFlowAccessLevelWithAggregatesFilter<"FlowInvitation"> | $Enums.FlowAccessLevel
    permissions?: JsonNullableWithAggregatesFilter<"FlowInvitation">
    invitedBy?: StringWithAggregatesFilter<"FlowInvitation"> | string
    invitedUserId?: StringNullableWithAggregatesFilter<"FlowInvitation"> | string | null
    token?: StringWithAggregatesFilter<"FlowInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"FlowInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeWithAggregatesFilter<"FlowInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"FlowInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"FlowInvitation"> | Date | string | null
  }

  export type FlowCollaboratorWhereInput = {
    AND?: FlowCollaboratorWhereInput | FlowCollaboratorWhereInput[]
    OR?: FlowCollaboratorWhereInput[]
    NOT?: FlowCollaboratorWhereInput | FlowCollaboratorWhereInput[]
    id?: StringFilter<"FlowCollaborator"> | string
    flowId?: StringFilter<"FlowCollaborator"> | string
    userId?: StringFilter<"FlowCollaborator"> | string
    accessLevel?: EnumFlowAccessLevelFilter<"FlowCollaborator"> | $Enums.FlowAccessLevel
    canEdit?: BoolFilter<"FlowCollaborator"> | boolean
    canExecute?: BoolFilter<"FlowCollaborator"> | boolean
    canDelete?: BoolFilter<"FlowCollaborator"> | boolean
    canShare?: BoolFilter<"FlowCollaborator"> | boolean
    canInvite?: BoolFilter<"FlowCollaborator"> | boolean
    invitedBy?: StringNullableFilter<"FlowCollaborator"> | string | null
    invitedAt?: DateTimeFilter<"FlowCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"FlowCollaborator"> | Date | string | null
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FlowCollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    flow?: FlowOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: FlowCollaboratorOrderByRelevanceInput
  }

  export type FlowCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flowId_userId?: FlowCollaboratorFlowIdUserIdCompoundUniqueInput
    AND?: FlowCollaboratorWhereInput | FlowCollaboratorWhereInput[]
    OR?: FlowCollaboratorWhereInput[]
    NOT?: FlowCollaboratorWhereInput | FlowCollaboratorWhereInput[]
    flowId?: StringFilter<"FlowCollaborator"> | string
    userId?: StringFilter<"FlowCollaborator"> | string
    accessLevel?: EnumFlowAccessLevelFilter<"FlowCollaborator"> | $Enums.FlowAccessLevel
    canEdit?: BoolFilter<"FlowCollaborator"> | boolean
    canExecute?: BoolFilter<"FlowCollaborator"> | boolean
    canDelete?: BoolFilter<"FlowCollaborator"> | boolean
    canShare?: BoolFilter<"FlowCollaborator"> | boolean
    canInvite?: BoolFilter<"FlowCollaborator"> | boolean
    invitedBy?: StringNullableFilter<"FlowCollaborator"> | string | null
    invitedAt?: DateTimeFilter<"FlowCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"FlowCollaborator"> | Date | string | null
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "flowId_userId">

  export type FlowCollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    _count?: FlowCollaboratorCountOrderByAggregateInput
    _max?: FlowCollaboratorMaxOrderByAggregateInput
    _min?: FlowCollaboratorMinOrderByAggregateInput
  }

  export type FlowCollaboratorScalarWhereWithAggregatesInput = {
    AND?: FlowCollaboratorScalarWhereWithAggregatesInput | FlowCollaboratorScalarWhereWithAggregatesInput[]
    OR?: FlowCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: FlowCollaboratorScalarWhereWithAggregatesInput | FlowCollaboratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlowCollaborator"> | string
    flowId?: StringWithAggregatesFilter<"FlowCollaborator"> | string
    userId?: StringWithAggregatesFilter<"FlowCollaborator"> | string
    accessLevel?: EnumFlowAccessLevelWithAggregatesFilter<"FlowCollaborator"> | $Enums.FlowAccessLevel
    canEdit?: BoolWithAggregatesFilter<"FlowCollaborator"> | boolean
    canExecute?: BoolWithAggregatesFilter<"FlowCollaborator"> | boolean
    canDelete?: BoolWithAggregatesFilter<"FlowCollaborator"> | boolean
    canShare?: BoolWithAggregatesFilter<"FlowCollaborator"> | boolean
    canInvite?: BoolWithAggregatesFilter<"FlowCollaborator"> | boolean
    invitedBy?: StringNullableWithAggregatesFilter<"FlowCollaborator"> | string | null
    invitedAt?: DateTimeWithAggregatesFilter<"FlowCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"FlowCollaborator"> | Date | string | null
  }

  export type FlowSessionWhereInput = {
    AND?: FlowSessionWhereInput | FlowSessionWhereInput[]
    OR?: FlowSessionWhereInput[]
    NOT?: FlowSessionWhereInput | FlowSessionWhereInput[]
    id?: StringFilter<"FlowSession"> | string
    flowId?: StringFilter<"FlowSession"> | string
    userId?: StringNullableFilter<"FlowSession"> | string | null
    anonymousName?: StringNullableFilter<"FlowSession"> | string | null
    sessionToken?: StringNullableFilter<"FlowSession"> | string | null
    socketId?: StringNullableFilter<"FlowSession"> | string | null
    cursorPosition?: JsonNullableFilter<"FlowSession">
    selectedPodIds?: JsonNullableFilter<"FlowSession">
    viewportState?: JsonNullableFilter<"FlowSession">
    userColor?: StringNullableFilter<"FlowSession"> | string | null
    userAgent?: StringNullableFilter<"FlowSession"> | string | null
    ipAddress?: StringNullableFilter<"FlowSession"> | string | null
    connectedAt?: DateTimeFilter<"FlowSession"> | Date | string
    lastHeartbeatAt?: DateTimeFilter<"FlowSession"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"FlowSession"> | Date | string | null
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
  }

  export type FlowSessionOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousName?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    socketId?: SortOrderInput | SortOrder
    cursorPosition?: SortOrderInput | SortOrder
    selectedPodIds?: SortOrderInput | SortOrder
    viewportState?: SortOrderInput | SortOrder
    userColor?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    flow?: FlowOrderByWithRelationInput
    _relevance?: FlowSessionOrderByRelevanceInput
  }

  export type FlowSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: FlowSessionWhereInput | FlowSessionWhereInput[]
    OR?: FlowSessionWhereInput[]
    NOT?: FlowSessionWhereInput | FlowSessionWhereInput[]
    flowId?: StringFilter<"FlowSession"> | string
    userId?: StringNullableFilter<"FlowSession"> | string | null
    anonymousName?: StringNullableFilter<"FlowSession"> | string | null
    socketId?: StringNullableFilter<"FlowSession"> | string | null
    cursorPosition?: JsonNullableFilter<"FlowSession">
    selectedPodIds?: JsonNullableFilter<"FlowSession">
    viewportState?: JsonNullableFilter<"FlowSession">
    userColor?: StringNullableFilter<"FlowSession"> | string | null
    userAgent?: StringNullableFilter<"FlowSession"> | string | null
    ipAddress?: StringNullableFilter<"FlowSession"> | string | null
    connectedAt?: DateTimeFilter<"FlowSession"> | Date | string
    lastHeartbeatAt?: DateTimeFilter<"FlowSession"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"FlowSession"> | Date | string | null
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
  }, "id" | "sessionToken">

  export type FlowSessionOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousName?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    socketId?: SortOrderInput | SortOrder
    cursorPosition?: SortOrderInput | SortOrder
    selectedPodIds?: SortOrderInput | SortOrder
    viewportState?: SortOrderInput | SortOrder
    userColor?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    _count?: FlowSessionCountOrderByAggregateInput
    _max?: FlowSessionMaxOrderByAggregateInput
    _min?: FlowSessionMinOrderByAggregateInput
  }

  export type FlowSessionScalarWhereWithAggregatesInput = {
    AND?: FlowSessionScalarWhereWithAggregatesInput | FlowSessionScalarWhereWithAggregatesInput[]
    OR?: FlowSessionScalarWhereWithAggregatesInput[]
    NOT?: FlowSessionScalarWhereWithAggregatesInput | FlowSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlowSession"> | string
    flowId?: StringWithAggregatesFilter<"FlowSession"> | string
    userId?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    anonymousName?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    sessionToken?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    socketId?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    cursorPosition?: JsonNullableWithAggregatesFilter<"FlowSession">
    selectedPodIds?: JsonNullableWithAggregatesFilter<"FlowSession">
    viewportState?: JsonNullableWithAggregatesFilter<"FlowSession">
    userColor?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"FlowSession"> | string | null
    connectedAt?: DateTimeWithAggregatesFilter<"FlowSession"> | Date | string
    lastHeartbeatAt?: DateTimeWithAggregatesFilter<"FlowSession"> | Date | string
    disconnectedAt?: DateTimeNullableWithAggregatesFilter<"FlowSession"> | Date | string | null
  }

  export type FlowActivityLogWhereInput = {
    AND?: FlowActivityLogWhereInput | FlowActivityLogWhereInput[]
    OR?: FlowActivityLogWhereInput[]
    NOT?: FlowActivityLogWhereInput | FlowActivityLogWhereInput[]
    id?: StringFilter<"FlowActivityLog"> | string
    flowId?: StringFilter<"FlowActivityLog"> | string
    userId?: StringNullableFilter<"FlowActivityLog"> | string | null
    action?: EnumFlowActivityActionFilter<"FlowActivityLog"> | $Enums.FlowActivityAction
    entityType?: StringNullableFilter<"FlowActivityLog"> | string | null
    entityId?: StringNullableFilter<"FlowActivityLog"> | string | null
    changeData?: JsonNullableFilter<"FlowActivityLog">
    createdAt?: DateTimeFilter<"FlowActivityLog"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
  }

  export type FlowActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    changeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    flow?: FlowOrderByWithRelationInput
    _relevance?: FlowActivityLogOrderByRelevanceInput
  }

  export type FlowActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlowActivityLogWhereInput | FlowActivityLogWhereInput[]
    OR?: FlowActivityLogWhereInput[]
    NOT?: FlowActivityLogWhereInput | FlowActivityLogWhereInput[]
    flowId?: StringFilter<"FlowActivityLog"> | string
    userId?: StringNullableFilter<"FlowActivityLog"> | string | null
    action?: EnumFlowActivityActionFilter<"FlowActivityLog"> | $Enums.FlowActivityAction
    entityType?: StringNullableFilter<"FlowActivityLog"> | string | null
    entityId?: StringNullableFilter<"FlowActivityLog"> | string | null
    changeData?: JsonNullableFilter<"FlowActivityLog">
    createdAt?: DateTimeFilter<"FlowActivityLog"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
  }, "id">

  export type FlowActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    changeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FlowActivityLogCountOrderByAggregateInput
    _max?: FlowActivityLogMaxOrderByAggregateInput
    _min?: FlowActivityLogMinOrderByAggregateInput
  }

  export type FlowActivityLogScalarWhereWithAggregatesInput = {
    AND?: FlowActivityLogScalarWhereWithAggregatesInput | FlowActivityLogScalarWhereWithAggregatesInput[]
    OR?: FlowActivityLogScalarWhereWithAggregatesInput[]
    NOT?: FlowActivityLogScalarWhereWithAggregatesInput | FlowActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlowActivityLog"> | string
    flowId?: StringWithAggregatesFilter<"FlowActivityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"FlowActivityLog"> | string | null
    action?: EnumFlowActivityActionWithAggregatesFilter<"FlowActivityLog"> | $Enums.FlowActivityAction
    entityType?: StringNullableWithAggregatesFilter<"FlowActivityLog"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"FlowActivityLog"> | string | null
    changeData?: JsonNullableWithAggregatesFilter<"FlowActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"FlowActivityLog"> | Date | string
  }

  export type FlowCommentWhereInput = {
    AND?: FlowCommentWhereInput | FlowCommentWhereInput[]
    OR?: FlowCommentWhereInput[]
    NOT?: FlowCommentWhereInput | FlowCommentWhereInput[]
    id?: StringFilter<"FlowComment"> | string
    flowId?: StringFilter<"FlowComment"> | string
    userId?: StringNullableFilter<"FlowComment"> | string | null
    content?: StringFilter<"FlowComment"> | string
    position?: JsonNullableFilter<"FlowComment">
    podId?: StringNullableFilter<"FlowComment"> | string | null
    parentId?: StringNullableFilter<"FlowComment"> | string | null
    isResolved?: BoolFilter<"FlowComment"> | boolean
    resolvedBy?: StringNullableFilter<"FlowComment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FlowComment"> | Date | string | null
    createdAt?: DateTimeFilter<"FlowComment"> | Date | string
    updatedAt?: DateTimeFilter<"FlowComment"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
  }

  export type FlowCommentOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    position?: SortOrderInput | SortOrder
    podId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flow?: FlowOrderByWithRelationInput
    _relevance?: FlowCommentOrderByRelevanceInput
  }

  export type FlowCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlowCommentWhereInput | FlowCommentWhereInput[]
    OR?: FlowCommentWhereInput[]
    NOT?: FlowCommentWhereInput | FlowCommentWhereInput[]
    flowId?: StringFilter<"FlowComment"> | string
    userId?: StringNullableFilter<"FlowComment"> | string | null
    content?: StringFilter<"FlowComment"> | string
    position?: JsonNullableFilter<"FlowComment">
    podId?: StringNullableFilter<"FlowComment"> | string | null
    parentId?: StringNullableFilter<"FlowComment"> | string | null
    isResolved?: BoolFilter<"FlowComment"> | boolean
    resolvedBy?: StringNullableFilter<"FlowComment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FlowComment"> | Date | string | null
    createdAt?: DateTimeFilter<"FlowComment"> | Date | string
    updatedAt?: DateTimeFilter<"FlowComment"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
  }, "id">

  export type FlowCommentOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    position?: SortOrderInput | SortOrder
    podId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlowCommentCountOrderByAggregateInput
    _max?: FlowCommentMaxOrderByAggregateInput
    _min?: FlowCommentMinOrderByAggregateInput
  }

  export type FlowCommentScalarWhereWithAggregatesInput = {
    AND?: FlowCommentScalarWhereWithAggregatesInput | FlowCommentScalarWhereWithAggregatesInput[]
    OR?: FlowCommentScalarWhereWithAggregatesInput[]
    NOT?: FlowCommentScalarWhereWithAggregatesInput | FlowCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlowComment"> | string
    flowId?: StringWithAggregatesFilter<"FlowComment"> | string
    userId?: StringNullableWithAggregatesFilter<"FlowComment"> | string | null
    content?: StringWithAggregatesFilter<"FlowComment"> | string
    position?: JsonNullableWithAggregatesFilter<"FlowComment">
    podId?: StringNullableWithAggregatesFilter<"FlowComment"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"FlowComment"> | string | null
    isResolved?: BoolWithAggregatesFilter<"FlowComment"> | boolean
    resolvedBy?: StringNullableWithAggregatesFilter<"FlowComment"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"FlowComment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FlowComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FlowComment"> | Date | string
  }

  export type PodWhereInput = {
    AND?: PodWhereInput | PodWhereInput[]
    OR?: PodWhereInput[]
    NOT?: PodWhereInput | PodWhereInput[]
    id?: StringFilter<"Pod"> | string
    flowId?: StringFilter<"Pod"> | string
    type?: EnumPodTypeFilter<"Pod"> | $Enums.PodType
    position?: JsonFilter<"Pod">
    executionStatus?: EnumPodExecutionStatusFilter<"Pod"> | $Enums.PodExecutionStatus
    lastExecutionId?: StringNullableFilter<"Pod"> | string | null
    contextFlowId?: StringNullableFilter<"Pod"> | string | null
    documentId?: StringNullableFilter<"Pod"> | string | null
    lockedBy?: StringNullableFilter<"Pod"> | string | null
    lockedAt?: DateTimeNullableFilter<"Pod"> | Date | string | null
    dynamoPartitionKey?: StringFilter<"Pod"> | string
    dynamoSortKey?: StringFilter<"Pod"> | string
    s3VectorBucket?: StringNullableFilter<"Pod"> | string | null
    s3VectorKey?: StringNullableFilter<"Pod"> | string | null
    createdAt?: DateTimeFilter<"Pod"> | Date | string
    updatedAt?: DateTimeFilter<"Pod"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    contextFlow?: XOR<FlowNullableScalarRelationFilter, FlowWhereInput> | null
    document?: XOR<DocumentNullableScalarRelationFilter, DocumentWhereInput> | null
    sourceEdges?: EdgeListRelationFilter
    targetEdges?: EdgeListRelationFilter
    executions?: PodExecutionListRelationFilter
    usageLogs?: PodUsageLogListRelationFilter
  }

  export type PodOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    type?: SortOrder
    position?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrderInput | SortOrder
    contextFlowId?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrderInput | SortOrder
    s3VectorKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flow?: FlowOrderByWithRelationInput
    contextFlow?: FlowOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
    sourceEdges?: EdgeOrderByRelationAggregateInput
    targetEdges?: EdgeOrderByRelationAggregateInput
    executions?: PodExecutionOrderByRelationAggregateInput
    usageLogs?: PodUsageLogOrderByRelationAggregateInput
    _relevance?: PodOrderByRelevanceInput
  }

  export type PodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dynamoPartitionKey_dynamoSortKey?: PodDynamoPartitionKeyDynamoSortKeyCompoundUniqueInput
    AND?: PodWhereInput | PodWhereInput[]
    OR?: PodWhereInput[]
    NOT?: PodWhereInput | PodWhereInput[]
    flowId?: StringFilter<"Pod"> | string
    type?: EnumPodTypeFilter<"Pod"> | $Enums.PodType
    position?: JsonFilter<"Pod">
    executionStatus?: EnumPodExecutionStatusFilter<"Pod"> | $Enums.PodExecutionStatus
    lastExecutionId?: StringNullableFilter<"Pod"> | string | null
    contextFlowId?: StringNullableFilter<"Pod"> | string | null
    documentId?: StringNullableFilter<"Pod"> | string | null
    lockedBy?: StringNullableFilter<"Pod"> | string | null
    lockedAt?: DateTimeNullableFilter<"Pod"> | Date | string | null
    dynamoPartitionKey?: StringFilter<"Pod"> | string
    dynamoSortKey?: StringFilter<"Pod"> | string
    s3VectorBucket?: StringNullableFilter<"Pod"> | string | null
    s3VectorKey?: StringNullableFilter<"Pod"> | string | null
    createdAt?: DateTimeFilter<"Pod"> | Date | string
    updatedAt?: DateTimeFilter<"Pod"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    contextFlow?: XOR<FlowNullableScalarRelationFilter, FlowWhereInput> | null
    document?: XOR<DocumentNullableScalarRelationFilter, DocumentWhereInput> | null
    sourceEdges?: EdgeListRelationFilter
    targetEdges?: EdgeListRelationFilter
    executions?: PodExecutionListRelationFilter
    usageLogs?: PodUsageLogListRelationFilter
  }, "id" | "dynamoPartitionKey_dynamoSortKey">

  export type PodOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    type?: SortOrder
    position?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrderInput | SortOrder
    contextFlowId?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrderInput | SortOrder
    s3VectorKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PodCountOrderByAggregateInput
    _max?: PodMaxOrderByAggregateInput
    _min?: PodMinOrderByAggregateInput
  }

  export type PodScalarWhereWithAggregatesInput = {
    AND?: PodScalarWhereWithAggregatesInput | PodScalarWhereWithAggregatesInput[]
    OR?: PodScalarWhereWithAggregatesInput[]
    NOT?: PodScalarWhereWithAggregatesInput | PodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pod"> | string
    flowId?: StringWithAggregatesFilter<"Pod"> | string
    type?: EnumPodTypeWithAggregatesFilter<"Pod"> | $Enums.PodType
    position?: JsonWithAggregatesFilter<"Pod">
    executionStatus?: EnumPodExecutionStatusWithAggregatesFilter<"Pod"> | $Enums.PodExecutionStatus
    lastExecutionId?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    contextFlowId?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    lockedBy?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"Pod"> | Date | string | null
    dynamoPartitionKey?: StringWithAggregatesFilter<"Pod"> | string
    dynamoSortKey?: StringWithAggregatesFilter<"Pod"> | string
    s3VectorBucket?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    s3VectorKey?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Pod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pod"> | Date | string
  }

  export type EdgeWhereInput = {
    AND?: EdgeWhereInput | EdgeWhereInput[]
    OR?: EdgeWhereInput[]
    NOT?: EdgeWhereInput | EdgeWhereInput[]
    id?: StringFilter<"Edge"> | string
    flowId?: StringFilter<"Edge"> | string
    sourcePodId?: StringFilter<"Edge"> | string
    targetPodId?: StringFilter<"Edge"> | string
    sourceHandle?: StringNullableFilter<"Edge"> | string | null
    targetHandle?: StringNullableFilter<"Edge"> | string | null
    animated?: BoolFilter<"Edge"> | boolean
    createdAt?: DateTimeFilter<"Edge"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    sourcePod?: XOR<PodScalarRelationFilter, PodWhereInput>
    targetPod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }

  export type EdgeOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrderInput | SortOrder
    targetHandle?: SortOrderInput | SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
    flow?: FlowOrderByWithRelationInput
    sourcePod?: PodOrderByWithRelationInput
    targetPod?: PodOrderByWithRelationInput
    _relevance?: EdgeOrderByRelevanceInput
  }

  export type EdgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flowId_sourcePodId_sourceHandle_targetPodId_targetHandle?: EdgeFlowIdSourcePodIdSourceHandleTargetPodIdTargetHandleCompoundUniqueInput
    AND?: EdgeWhereInput | EdgeWhereInput[]
    OR?: EdgeWhereInput[]
    NOT?: EdgeWhereInput | EdgeWhereInput[]
    flowId?: StringFilter<"Edge"> | string
    sourcePodId?: StringFilter<"Edge"> | string
    targetPodId?: StringFilter<"Edge"> | string
    sourceHandle?: StringNullableFilter<"Edge"> | string | null
    targetHandle?: StringNullableFilter<"Edge"> | string | null
    animated?: BoolFilter<"Edge"> | boolean
    createdAt?: DateTimeFilter<"Edge"> | Date | string
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    sourcePod?: XOR<PodScalarRelationFilter, PodWhereInput>
    targetPod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }, "id" | "flowId_sourcePodId_sourceHandle_targetPodId_targetHandle">

  export type EdgeOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrderInput | SortOrder
    targetHandle?: SortOrderInput | SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
    _count?: EdgeCountOrderByAggregateInput
    _max?: EdgeMaxOrderByAggregateInput
    _min?: EdgeMinOrderByAggregateInput
  }

  export type EdgeScalarWhereWithAggregatesInput = {
    AND?: EdgeScalarWhereWithAggregatesInput | EdgeScalarWhereWithAggregatesInput[]
    OR?: EdgeScalarWhereWithAggregatesInput[]
    NOT?: EdgeScalarWhereWithAggregatesInput | EdgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Edge"> | string
    flowId?: StringWithAggregatesFilter<"Edge"> | string
    sourcePodId?: StringWithAggregatesFilter<"Edge"> | string
    targetPodId?: StringWithAggregatesFilter<"Edge"> | string
    sourceHandle?: StringNullableWithAggregatesFilter<"Edge"> | string | null
    targetHandle?: StringNullableWithAggregatesFilter<"Edge"> | string | null
    animated?: BoolWithAggregatesFilter<"Edge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Edge"> | Date | string
  }

  export type PodExecutionWhereInput = {
    AND?: PodExecutionWhereInput | PodExecutionWhereInput[]
    OR?: PodExecutionWhereInput[]
    NOT?: PodExecutionWhereInput | PodExecutionWhereInput[]
    id?: StringFilter<"PodExecution"> | string
    podId?: StringFilter<"PodExecution"> | string
    flowId?: StringFilter<"PodExecution"> | string
    workspaceId?: StringFilter<"PodExecution"> | string
    status?: EnumPodExecutionStatusFilter<"PodExecution"> | $Enums.PodExecutionStatus
    startedAt?: DateTimeFilter<"PodExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"PodExecution"> | Date | string | null
    runtimeInMs?: IntNullableFilter<"PodExecution"> | number | null
    provider?: EnumLLMProviderFilter<"PodExecution"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodExecution"> | string
    modelName?: StringNullableFilter<"PodExecution"> | string | null
    providerMetadata?: JsonNullableFilter<"PodExecution">
    requestMetadata?: JsonNullableFilter<"PodExecution">
    responseMetadata?: JsonNullableFilter<"PodExecution">
    errorMessage?: StringNullableFilter<"PodExecution"> | string | null
    errorCode?: StringNullableFilter<"PodExecution"> | string | null
    inputTokens?: IntFilter<"PodExecution"> | number
    outputTokens?: IntFilter<"PodExecution"> | number
    reasoningTokens?: IntFilter<"PodExecution"> | number
    creditsConsumed?: IntFilter<"PodExecution"> | number
    costInUsd?: DecimalNullableFilter<"PodExecution"> | Decimal | DecimalJsLike | number | string | null
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }

  export type PodExecutionOrderByWithRelationInput = {
    id?: SortOrder
    podId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    requestMetadata?: SortOrderInput | SortOrder
    responseMetadata?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrderInput | SortOrder
    pod?: PodOrderByWithRelationInput
    _relevance?: PodExecutionOrderByRelevanceInput
  }

  export type PodExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PodExecutionWhereInput | PodExecutionWhereInput[]
    OR?: PodExecutionWhereInput[]
    NOT?: PodExecutionWhereInput | PodExecutionWhereInput[]
    podId?: StringFilter<"PodExecution"> | string
    flowId?: StringFilter<"PodExecution"> | string
    workspaceId?: StringFilter<"PodExecution"> | string
    status?: EnumPodExecutionStatusFilter<"PodExecution"> | $Enums.PodExecutionStatus
    startedAt?: DateTimeFilter<"PodExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"PodExecution"> | Date | string | null
    runtimeInMs?: IntNullableFilter<"PodExecution"> | number | null
    provider?: EnumLLMProviderFilter<"PodExecution"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodExecution"> | string
    modelName?: StringNullableFilter<"PodExecution"> | string | null
    providerMetadata?: JsonNullableFilter<"PodExecution">
    requestMetadata?: JsonNullableFilter<"PodExecution">
    responseMetadata?: JsonNullableFilter<"PodExecution">
    errorMessage?: StringNullableFilter<"PodExecution"> | string | null
    errorCode?: StringNullableFilter<"PodExecution"> | string | null
    inputTokens?: IntFilter<"PodExecution"> | number
    outputTokens?: IntFilter<"PodExecution"> | number
    reasoningTokens?: IntFilter<"PodExecution"> | number
    creditsConsumed?: IntFilter<"PodExecution"> | number
    costInUsd?: DecimalNullableFilter<"PodExecution"> | Decimal | DecimalJsLike | number | string | null
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }, "id">

  export type PodExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    podId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    requestMetadata?: SortOrderInput | SortOrder
    responseMetadata?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrderInput | SortOrder
    _count?: PodExecutionCountOrderByAggregateInput
    _avg?: PodExecutionAvgOrderByAggregateInput
    _max?: PodExecutionMaxOrderByAggregateInput
    _min?: PodExecutionMinOrderByAggregateInput
    _sum?: PodExecutionSumOrderByAggregateInput
  }

  export type PodExecutionScalarWhereWithAggregatesInput = {
    AND?: PodExecutionScalarWhereWithAggregatesInput | PodExecutionScalarWhereWithAggregatesInput[]
    OR?: PodExecutionScalarWhereWithAggregatesInput[]
    NOT?: PodExecutionScalarWhereWithAggregatesInput | PodExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PodExecution"> | string
    podId?: StringWithAggregatesFilter<"PodExecution"> | string
    flowId?: StringWithAggregatesFilter<"PodExecution"> | string
    workspaceId?: StringWithAggregatesFilter<"PodExecution"> | string
    status?: EnumPodExecutionStatusWithAggregatesFilter<"PodExecution"> | $Enums.PodExecutionStatus
    startedAt?: DateTimeWithAggregatesFilter<"PodExecution"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"PodExecution"> | Date | string | null
    runtimeInMs?: IntNullableWithAggregatesFilter<"PodExecution"> | number | null
    provider?: EnumLLMProviderWithAggregatesFilter<"PodExecution"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"PodExecution"> | string
    modelName?: StringNullableWithAggregatesFilter<"PodExecution"> | string | null
    providerMetadata?: JsonNullableWithAggregatesFilter<"PodExecution">
    requestMetadata?: JsonNullableWithAggregatesFilter<"PodExecution">
    responseMetadata?: JsonNullableWithAggregatesFilter<"PodExecution">
    errorMessage?: StringNullableWithAggregatesFilter<"PodExecution"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"PodExecution"> | string | null
    inputTokens?: IntWithAggregatesFilter<"PodExecution"> | number
    outputTokens?: IntWithAggregatesFilter<"PodExecution"> | number
    reasoningTokens?: IntWithAggregatesFilter<"PodExecution"> | number
    creditsConsumed?: IntWithAggregatesFilter<"PodExecution"> | number
    costInUsd?: DecimalNullableWithAggregatesFilter<"PodExecution"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogWhereInput = {
    AND?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    OR?: PodUsageLogWhereInput[]
    NOT?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    id?: StringFilter<"PodUsageLog"> | string
    podId?: StringFilter<"PodUsageLog"> | string
    executionId?: StringFilter<"PodUsageLog"> | string
    flowId?: StringFilter<"PodUsageLog"> | string
    workspaceId?: StringFilter<"PodUsageLog"> | string
    subscriptionId?: StringFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodUsageLog"> | string
    modelName?: StringNullableFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableFilter<"PodUsageLog">
    inputTokens?: IntFilter<"PodUsageLog"> | number
    outputTokens?: IntFilter<"PodUsageLog"> | number
    reasoningTokens?: IntFilter<"PodUsageLog"> | number
    creditsConsumed?: IntFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFilter<"PodUsageLog"> | Date | string
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type PodUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
    pod?: PodOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: PodUsageLogOrderByRelevanceInput
  }

  export type PodUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    OR?: PodUsageLogWhereInput[]
    NOT?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    podId?: StringFilter<"PodUsageLog"> | string
    executionId?: StringFilter<"PodUsageLog"> | string
    flowId?: StringFilter<"PodUsageLog"> | string
    workspaceId?: StringFilter<"PodUsageLog"> | string
    subscriptionId?: StringFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodUsageLog"> | string
    modelName?: StringNullableFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableFilter<"PodUsageLog">
    inputTokens?: IntFilter<"PodUsageLog"> | number
    outputTokens?: IntFilter<"PodUsageLog"> | number
    reasoningTokens?: IntFilter<"PodUsageLog"> | number
    creditsConsumed?: IntFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFilter<"PodUsageLog"> | Date | string
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type PodUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
    _count?: PodUsageLogCountOrderByAggregateInput
    _avg?: PodUsageLogAvgOrderByAggregateInput
    _max?: PodUsageLogMaxOrderByAggregateInput
    _min?: PodUsageLogMinOrderByAggregateInput
    _sum?: PodUsageLogSumOrderByAggregateInput
  }

  export type PodUsageLogScalarWhereWithAggregatesInput = {
    AND?: PodUsageLogScalarWhereWithAggregatesInput | PodUsageLogScalarWhereWithAggregatesInput[]
    OR?: PodUsageLogScalarWhereWithAggregatesInput[]
    NOT?: PodUsageLogScalarWhereWithAggregatesInput | PodUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PodUsageLog"> | string
    podId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    executionId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    flowId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    workspaceId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    subscriptionId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderWithAggregatesFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    modelName?: StringNullableWithAggregatesFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableWithAggregatesFilter<"PodUsageLog">
    inputTokens?: IntWithAggregatesFilter<"PodUsageLog"> | number
    outputTokens?: IntWithAggregatesFilter<"PodUsageLog"> | number
    reasoningTokens?: IntWithAggregatesFilter<"PodUsageLog"> | number
    creditsConsumed?: IntWithAggregatesFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableWithAggregatesFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeWithAggregatesFilter<"PodUsageLog"> | Date | string
  }

  export type ContextModuleWhereInput = {
    AND?: ContextModuleWhereInput | ContextModuleWhereInput[]
    OR?: ContextModuleWhereInput[]
    NOT?: ContextModuleWhereInput | ContextModuleWhereInput[]
    id?: StringFilter<"ContextModule"> | string
    workspaceId?: StringFilter<"ContextModule"> | string
    name?: StringFilter<"ContextModule"> | string
    description?: StringNullableFilter<"ContextModule"> | string | null
    definitionJson?: JsonFilter<"ContextModule">
    originalFlowId?: StringNullableFilter<"ContextModule"> | string | null
    version?: IntFilter<"ContextModule"> | number
    createdAt?: DateTimeFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeFilter<"ContextModule"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    originalFlow?: XOR<FlowNullableScalarRelationFilter, FlowWhereInput> | null
  }

  export type ContextModuleOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    definitionJson?: SortOrder
    originalFlowId?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    originalFlow?: FlowOrderByWithRelationInput
    _relevance?: ContextModuleOrderByRelevanceInput
  }

  export type ContextModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextModuleWhereInput | ContextModuleWhereInput[]
    OR?: ContextModuleWhereInput[]
    NOT?: ContextModuleWhereInput | ContextModuleWhereInput[]
    workspaceId?: StringFilter<"ContextModule"> | string
    name?: StringFilter<"ContextModule"> | string
    description?: StringNullableFilter<"ContextModule"> | string | null
    definitionJson?: JsonFilter<"ContextModule">
    originalFlowId?: StringNullableFilter<"ContextModule"> | string | null
    version?: IntFilter<"ContextModule"> | number
    createdAt?: DateTimeFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeFilter<"ContextModule"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    originalFlow?: XOR<FlowNullableScalarRelationFilter, FlowWhereInput> | null
  }, "id">

  export type ContextModuleOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    definitionJson?: SortOrder
    originalFlowId?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContextModuleCountOrderByAggregateInput
    _avg?: ContextModuleAvgOrderByAggregateInput
    _max?: ContextModuleMaxOrderByAggregateInput
    _min?: ContextModuleMinOrderByAggregateInput
    _sum?: ContextModuleSumOrderByAggregateInput
  }

  export type ContextModuleScalarWhereWithAggregatesInput = {
    AND?: ContextModuleScalarWhereWithAggregatesInput | ContextModuleScalarWhereWithAggregatesInput[]
    OR?: ContextModuleScalarWhereWithAggregatesInput[]
    NOT?: ContextModuleScalarWhereWithAggregatesInput | ContextModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextModule"> | string
    workspaceId?: StringWithAggregatesFilter<"ContextModule"> | string
    name?: StringWithAggregatesFilter<"ContextModule"> | string
    description?: StringNullableWithAggregatesFilter<"ContextModule"> | string | null
    definitionJson?: JsonWithAggregatesFilter<"ContextModule">
    originalFlowId?: StringNullableWithAggregatesFilter<"ContextModule"> | string | null
    version?: IntWithAggregatesFilter<"ContextModule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContextModule"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    workspaces?: WorkspaceUserListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    flowCollaborations?: FlowCollaboratorListRelationFilter
    sentWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    receivedWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    sentFlowInvites?: FlowInvitationListRelationFilter
    receivedFlowInvites?: FlowInvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    workspaces?: WorkspaceUserOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    flowCollaborations?: FlowCollaboratorOrderByRelationAggregateInput
    sentWorkspaceInvites?: WorkspaceInvitationOrderByRelationAggregateInput
    receivedWorkspaceInvites?: WorkspaceInvitationOrderByRelationAggregateInput
    sentFlowInvites?: FlowInvitationOrderByRelationAggregateInput
    receivedFlowInvites?: FlowInvitationOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    workspaces?: WorkspaceUserListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    flowCollaborations?: FlowCollaboratorListRelationFilter
    sentWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    receivedWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    sentFlowInvites?: FlowInvitationListRelationFilter
    receivedFlowInvites?: FlowInvitationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    hash?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    deviceName?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: RefreshTokenOrderByRelevanceInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    userId_deviceName?: RefreshTokenUserIdDeviceNameCompoundUniqueInput
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    deviceName?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "userId_deviceName">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    deviceName?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    provider?: EnumAuthProviderFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    provider?: EnumAuthProviderFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    provider?: EnumAuthProviderWithAggregatesFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    type?: EnumWorkspaceTypeFilter<"Workspace"> | $Enums.WorkspaceType
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceUserListRelationFilter
    spaces?: SpaceListRelationFilter
    flows?: FlowListRelationFilter
    documents?: DocumentListRelationFilter
    documentFolders?: DocumentFolderListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    contextModules?: ContextModuleListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
    apiKeys?: ProviderAPIKeyListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: WorkspaceUserOrderByRelationAggregateInput
    spaces?: SpaceOrderByRelationAggregateInput
    flows?: FlowOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    documentFolders?: DocumentFolderOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    contextModules?: ContextModuleOrderByRelationAggregateInput
    shareLinks?: ShareLinkOrderByRelationAggregateInput
    apiKeys?: ProviderAPIKeyOrderByRelationAggregateInput
    invitations?: WorkspaceInvitationOrderByRelationAggregateInput
    _relevance?: WorkspaceOrderByRelevanceInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    type?: EnumWorkspaceTypeFilter<"Workspace"> | $Enums.WorkspaceType
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceUserListRelationFilter
    spaces?: SpaceListRelationFilter
    flows?: FlowListRelationFilter
    documents?: DocumentListRelationFilter
    documentFolders?: DocumentFolderListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    contextModules?: ContextModuleListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
    apiKeys?: ProviderAPIKeyListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
  }, "id">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    type?: EnumWorkspaceTypeWithAggregatesFilter<"Workspace"> | $Enums.WorkspaceType
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceUserWhereInput = {
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceUser"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    _relevance?: WorkspaceUserOrderByRelevanceInput
  }

  export type WorkspaceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_workspaceId?: WorkspaceUserUserIdWorkspaceIdCompoundUniqueInput
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    userId?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceUser"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "userId_workspaceId">

  export type WorkspaceUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    _count?: WorkspaceUserCountOrderByAggregateInput
    _max?: WorkspaceUserMaxOrderByAggregateInput
    _min?: WorkspaceUserMinOrderByAggregateInput
  }

  export type WorkspaceUserScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    OR?: WorkspaceUserScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleWithAggregatesFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableWithAggregatesFilter<"WorkspaceUser"> | string | null
  }

  export type WorkspaceInvitationWhereInput = {
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableFilter<"WorkspaceInvitation">
    invitedBy?: StringFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    token?: StringFilter<"WorkspaceInvitation"> | string
    status?: EnumInvitationStatusFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WorkspaceInvitationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
    _relevance?: WorkspaceInvitationOrderByRelevanceInput
  }

  export type WorkspaceInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableFilter<"WorkspaceInvitation">
    invitedBy?: StringFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    status?: EnumInvitationStatusFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "token">

  export type WorkspaceInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: WorkspaceInvitationCountOrderByAggregateInput
    _max?: WorkspaceInvitationMaxOrderByAggregateInput
    _min?: WorkspaceInvitationMinOrderByAggregateInput
  }

  export type WorkspaceInvitationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    OR?: WorkspaceInvitationScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    email?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleWithAggregatesFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableWithAggregatesFilter<"WorkspaceInvitation">
    invitedBy?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableWithAggregatesFilter<"WorkspaceInvitation"> | string | null
    token?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceInvitation"> | Date | string | null
  }

  export type ProviderAPIKeyWhereInput = {
    AND?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    OR?: ProviderAPIKeyWhereInput[]
    NOT?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    id?: StringFilter<"ProviderAPIKey"> | string
    workspaceId?: StringFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringFilter<"ProviderAPIKey"> | string
    keyHash?: StringFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableFilter<"ProviderAPIKey">
    endpoint?: StringNullableFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type ProviderAPIKeyOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    _relevance?: ProviderAPIKeyOrderByRelevanceInput
  }

  export type ProviderAPIKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_provider_displayName?: ProviderAPIKeyWorkspaceIdProviderDisplayNameCompoundUniqueInput
    AND?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    OR?: ProviderAPIKeyWhereInput[]
    NOT?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    workspaceId?: StringFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringFilter<"ProviderAPIKey"> | string
    keyHash?: StringFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableFilter<"ProviderAPIKey">
    endpoint?: StringNullableFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_provider_displayName">

  export type ProviderAPIKeyOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ProviderAPIKeyCountOrderByAggregateInput
    _max?: ProviderAPIKeyMaxOrderByAggregateInput
    _min?: ProviderAPIKeyMinOrderByAggregateInput
  }

  export type ProviderAPIKeyScalarWhereWithAggregatesInput = {
    AND?: ProviderAPIKeyScalarWhereWithAggregatesInput | ProviderAPIKeyScalarWhereWithAggregatesInput[]
    OR?: ProviderAPIKeyScalarWhereWithAggregatesInput[]
    NOT?: ProviderAPIKeyScalarWhereWithAggregatesInput | ProviderAPIKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    workspaceId?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderWithAggregatesFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    keyHash?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableWithAggregatesFilter<"ProviderAPIKey">
    endpoint?: StringNullableWithAggregatesFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeWithAggregatesFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolWithAggregatesFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProviderAPIKey"> | Date | string | null
  }

  export type ShareLinkWhereInput = {
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[]
    OR?: ShareLinkWhereInput[]
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[]
    id?: StringFilter<"ShareLink"> | string
    publicToken?: StringFilter<"ShareLink"> | string
    assetType?: EnumShareableAssetTypeFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringFilter<"ShareLink"> | string
    workspaceId?: StringFilter<"ShareLink"> | string
    createdBy?: StringFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableFilter<"ShareLink"> | string | null
    viewCount?: IntFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type ShareLinkOrderByWithRelationInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    _relevance?: ShareLinkOrderByRelevanceInput
  }

  export type ShareLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicToken?: string
    assetType_assetId?: ShareLinkAssetTypeAssetIdCompoundUniqueInput
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[]
    OR?: ShareLinkWhereInput[]
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[]
    assetType?: EnumShareableAssetTypeFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringFilter<"ShareLink"> | string
    workspaceId?: StringFilter<"ShareLink"> | string
    createdBy?: StringFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableFilter<"ShareLink"> | string | null
    viewCount?: IntFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "publicToken" | "assetType_assetId">

  export type ShareLinkOrderByWithAggregationInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ShareLinkCountOrderByAggregateInput
    _avg?: ShareLinkAvgOrderByAggregateInput
    _max?: ShareLinkMaxOrderByAggregateInput
    _min?: ShareLinkMinOrderByAggregateInput
    _sum?: ShareLinkSumOrderByAggregateInput
  }

  export type ShareLinkScalarWhereWithAggregatesInput = {
    AND?: ShareLinkScalarWhereWithAggregatesInput | ShareLinkScalarWhereWithAggregatesInput[]
    OR?: ShareLinkScalarWhereWithAggregatesInput[]
    NOT?: ShareLinkScalarWhereWithAggregatesInput | ShareLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShareLink"> | string
    publicToken?: StringWithAggregatesFilter<"ShareLink"> | string
    assetType?: EnumShareableAssetTypeWithAggregatesFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringWithAggregatesFilter<"ShareLink"> | string
    workspaceId?: StringWithAggregatesFilter<"ShareLink"> | string
    createdBy?: StringWithAggregatesFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelWithAggregatesFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableWithAggregatesFilter<"ShareLink"> | string | null
    viewCount?: IntWithAggregatesFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ShareLink"> | Date | string | null
  }

  export type DocumentFolderWhereInput = {
    AND?: DocumentFolderWhereInput | DocumentFolderWhereInput[]
    OR?: DocumentFolderWhereInput[]
    NOT?: DocumentFolderWhereInput | DocumentFolderWhereInput[]
    id?: StringFilter<"DocumentFolder"> | string
    workspaceId?: StringFilter<"DocumentFolder"> | string
    name?: StringFilter<"DocumentFolder"> | string
    parentId?: StringNullableFilter<"DocumentFolder"> | string | null
    icon?: StringNullableFilter<"DocumentFolder"> | string | null
    color?: StringNullableFilter<"DocumentFolder"> | string | null
    sortOrder?: IntFilter<"DocumentFolder"> | number
    createdBy?: StringFilter<"DocumentFolder"> | string
    createdAt?: DateTimeFilter<"DocumentFolder"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentFolder"> | Date | string
    parent?: XOR<DocumentFolderNullableScalarRelationFilter, DocumentFolderWhereInput> | null
    children?: DocumentFolderListRelationFilter
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    documents?: DocumentListRelationFilter
  }

  export type DocumentFolderOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: DocumentFolderOrderByWithRelationInput
    children?: DocumentFolderOrderByRelationAggregateInput
    workspace?: WorkspaceOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    _relevance?: DocumentFolderOrderByRelevanceInput
  }

  export type DocumentFolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_parentId_name?: DocumentFolderWorkspaceIdParentIdNameCompoundUniqueInput
    AND?: DocumentFolderWhereInput | DocumentFolderWhereInput[]
    OR?: DocumentFolderWhereInput[]
    NOT?: DocumentFolderWhereInput | DocumentFolderWhereInput[]
    workspaceId?: StringFilter<"DocumentFolder"> | string
    name?: StringFilter<"DocumentFolder"> | string
    parentId?: StringNullableFilter<"DocumentFolder"> | string | null
    icon?: StringNullableFilter<"DocumentFolder"> | string | null
    color?: StringNullableFilter<"DocumentFolder"> | string | null
    sortOrder?: IntFilter<"DocumentFolder"> | number
    createdBy?: StringFilter<"DocumentFolder"> | string
    createdAt?: DateTimeFilter<"DocumentFolder"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentFolder"> | Date | string
    parent?: XOR<DocumentFolderNullableScalarRelationFilter, DocumentFolderWhereInput> | null
    children?: DocumentFolderListRelationFilter
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    documents?: DocumentListRelationFilter
  }, "id" | "workspaceId_parentId_name">

  export type DocumentFolderOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentFolderCountOrderByAggregateInput
    _avg?: DocumentFolderAvgOrderByAggregateInput
    _max?: DocumentFolderMaxOrderByAggregateInput
    _min?: DocumentFolderMinOrderByAggregateInput
    _sum?: DocumentFolderSumOrderByAggregateInput
  }

  export type DocumentFolderScalarWhereWithAggregatesInput = {
    AND?: DocumentFolderScalarWhereWithAggregatesInput | DocumentFolderScalarWhereWithAggregatesInput[]
    OR?: DocumentFolderScalarWhereWithAggregatesInput[]
    NOT?: DocumentFolderScalarWhereWithAggregatesInput | DocumentFolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentFolder"> | string
    workspaceId?: StringWithAggregatesFilter<"DocumentFolder"> | string
    name?: StringWithAggregatesFilter<"DocumentFolder"> | string
    parentId?: StringNullableWithAggregatesFilter<"DocumentFolder"> | string | null
    icon?: StringNullableWithAggregatesFilter<"DocumentFolder"> | string | null
    color?: StringNullableWithAggregatesFilter<"DocumentFolder"> | string | null
    sortOrder?: IntWithAggregatesFilter<"DocumentFolder"> | number
    createdBy?: StringWithAggregatesFilter<"DocumentFolder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentFolder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentFolder"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    workspaceId?: StringFilter<"Document"> | string
    folderId?: StringNullableFilter<"Document"> | string | null
    name?: StringFilter<"Document"> | string
    sourceType?: EnumDocumentSourceTypeFilter<"Document"> | $Enums.DocumentSourceType
    storageKey?: StringNullableFilter<"Document"> | string | null
    s3Bucket?: StringNullableFilter<"Document"> | string | null
    externalUrl?: StringNullableFilter<"Document"> | string | null
    externalProvider?: StringNullableFilter<"Document"> | string | null
    externalFileId?: StringNullableFilter<"Document"> | string | null
    fileType?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    sizeInBytes?: BigIntNullableFilter<"Document"> | bigint | number | null
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    folder?: XOR<DocumentFolderNullableScalarRelationFilter, DocumentFolderWhereInput> | null
    embeddings?: EmbeddingListRelationFilter
    pods?: PodListRelationFilter
    processingCostRecords?: DocumentProcessingCostListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    name?: SortOrder
    sourceType?: SortOrder
    storageKey?: SortOrderInput | SortOrder
    s3Bucket?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    externalProvider?: SortOrderInput | SortOrder
    externalFileId?: SortOrderInput | SortOrder
    fileType?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeInBytes?: SortOrderInput | SortOrder
    status?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    folder?: DocumentFolderOrderByWithRelationInput
    embeddings?: EmbeddingOrderByRelationAggregateInput
    pods?: PodOrderByRelationAggregateInput
    processingCostRecords?: DocumentProcessingCostOrderByRelationAggregateInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storageKey?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    workspaceId?: StringFilter<"Document"> | string
    folderId?: StringNullableFilter<"Document"> | string | null
    name?: StringFilter<"Document"> | string
    sourceType?: EnumDocumentSourceTypeFilter<"Document"> | $Enums.DocumentSourceType
    s3Bucket?: StringNullableFilter<"Document"> | string | null
    externalUrl?: StringNullableFilter<"Document"> | string | null
    externalProvider?: StringNullableFilter<"Document"> | string | null
    externalFileId?: StringNullableFilter<"Document"> | string | null
    fileType?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    sizeInBytes?: BigIntNullableFilter<"Document"> | bigint | number | null
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    folder?: XOR<DocumentFolderNullableScalarRelationFilter, DocumentFolderWhereInput> | null
    embeddings?: EmbeddingListRelationFilter
    pods?: PodListRelationFilter
    processingCostRecords?: DocumentProcessingCostListRelationFilter
  }, "id" | "storageKey">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    name?: SortOrder
    sourceType?: SortOrder
    storageKey?: SortOrderInput | SortOrder
    s3Bucket?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    externalProvider?: SortOrderInput | SortOrder
    externalFileId?: SortOrderInput | SortOrder
    fileType?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeInBytes?: SortOrderInput | SortOrder
    status?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    workspaceId?: StringWithAggregatesFilter<"Document"> | string
    folderId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    name?: StringWithAggregatesFilter<"Document"> | string
    sourceType?: EnumDocumentSourceTypeWithAggregatesFilter<"Document"> | $Enums.DocumentSourceType
    storageKey?: StringNullableWithAggregatesFilter<"Document"> | string | null
    s3Bucket?: StringNullableWithAggregatesFilter<"Document"> | string | null
    externalUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    externalProvider?: StringNullableWithAggregatesFilter<"Document"> | string | null
    externalFileId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileType?: StringWithAggregatesFilter<"Document"> | string
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    sizeInBytes?: BigIntNullableWithAggregatesFilter<"Document"> | bigint | number | null
    status?: EnumDocumentStatusWithAggregatesFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Document">
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type EmbeddingWhereInput = {
    AND?: EmbeddingWhereInput | EmbeddingWhereInput[]
    OR?: EmbeddingWhereInput[]
    NOT?: EmbeddingWhereInput | EmbeddingWhereInput[]
    id?: StringFilter<"Embedding"> | string
    documentId?: StringFilter<"Embedding"> | string
    model?: StringFilter<"Embedding"> | string
    chunkIndex?: IntFilter<"Embedding"> | number
    chunkText?: StringFilter<"Embedding"> | string
    s3VectorBucket?: StringFilter<"Embedding"> | string
    s3VectorKey?: StringFilter<"Embedding"> | string
    vectorDimension?: IntFilter<"Embedding"> | number
    metadata?: JsonNullableFilter<"Embedding">
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type EmbeddingOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    _relevance?: EmbeddingOrderByRelevanceInput
  }

  export type EmbeddingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId_chunkIndex?: EmbeddingDocumentIdChunkIndexCompoundUniqueInput
    s3VectorBucket_s3VectorKey?: EmbeddingS3VectorBucketS3VectorKeyCompoundUniqueInput
    AND?: EmbeddingWhereInput | EmbeddingWhereInput[]
    OR?: EmbeddingWhereInput[]
    NOT?: EmbeddingWhereInput | EmbeddingWhereInput[]
    documentId?: StringFilter<"Embedding"> | string
    model?: StringFilter<"Embedding"> | string
    chunkIndex?: IntFilter<"Embedding"> | number
    chunkText?: StringFilter<"Embedding"> | string
    s3VectorBucket?: StringFilter<"Embedding"> | string
    s3VectorKey?: StringFilter<"Embedding"> | string
    vectorDimension?: IntFilter<"Embedding"> | number
    metadata?: JsonNullableFilter<"Embedding">
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id" | "documentId_chunkIndex" | "s3VectorBucket_s3VectorKey">

  export type EmbeddingOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmbeddingCountOrderByAggregateInput
    _avg?: EmbeddingAvgOrderByAggregateInput
    _max?: EmbeddingMaxOrderByAggregateInput
    _min?: EmbeddingMinOrderByAggregateInput
    _sum?: EmbeddingSumOrderByAggregateInput
  }

  export type EmbeddingScalarWhereWithAggregatesInput = {
    AND?: EmbeddingScalarWhereWithAggregatesInput | EmbeddingScalarWhereWithAggregatesInput[]
    OR?: EmbeddingScalarWhereWithAggregatesInput[]
    NOT?: EmbeddingScalarWhereWithAggregatesInput | EmbeddingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Embedding"> | string
    documentId?: StringWithAggregatesFilter<"Embedding"> | string
    model?: StringWithAggregatesFilter<"Embedding"> | string
    chunkIndex?: IntWithAggregatesFilter<"Embedding"> | number
    chunkText?: StringWithAggregatesFilter<"Embedding"> | string
    s3VectorBucket?: StringWithAggregatesFilter<"Embedding"> | string
    s3VectorKey?: StringWithAggregatesFilter<"Embedding"> | string
    vectorDimension?: IntWithAggregatesFilter<"Embedding"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Embedding">
    createdAt?: DateTimeWithAggregatesFilter<"Embedding"> | Date | string
  }

  export type DocumentProcessingCostWhereInput = {
    AND?: DocumentProcessingCostWhereInput | DocumentProcessingCostWhereInput[]
    OR?: DocumentProcessingCostWhereInput[]
    NOT?: DocumentProcessingCostWhereInput | DocumentProcessingCostWhereInput[]
    id?: StringFilter<"DocumentProcessingCost"> | string
    documentId?: StringFilter<"DocumentProcessingCost"> | string
    workspaceId?: StringFilter<"DocumentProcessingCost"> | string
    subscriptionId?: StringFilter<"DocumentProcessingCost"> | string
    processingType?: EnumDocumentProcessingTypeFilter<"DocumentProcessingCost"> | $Enums.DocumentProcessingType
    creditsConsumed?: IntFilter<"DocumentProcessingCost"> | number
    extractionCost?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    chunkCount?: IntNullableFilter<"DocumentProcessingCost"> | number | null
    embeddingModel?: StringNullableFilter<"DocumentProcessingCost"> | string | null
    processingTimeMs?: IntNullableFilter<"DocumentProcessingCost"> | number | null
    tokensProcessed?: IntFilter<"DocumentProcessingCost"> | number
    processedAt?: DateTimeFilter<"DocumentProcessingCost"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type DocumentProcessingCostOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    processingType?: SortOrder
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrderInput | SortOrder
    embeddingModel?: SortOrderInput | SortOrder
    processingTimeMs?: SortOrderInput | SortOrder
    tokensProcessed?: SortOrder
    processedAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: DocumentProcessingCostOrderByRelevanceInput
  }

  export type DocumentProcessingCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentProcessingCostWhereInput | DocumentProcessingCostWhereInput[]
    OR?: DocumentProcessingCostWhereInput[]
    NOT?: DocumentProcessingCostWhereInput | DocumentProcessingCostWhereInput[]
    documentId?: StringFilter<"DocumentProcessingCost"> | string
    workspaceId?: StringFilter<"DocumentProcessingCost"> | string
    subscriptionId?: StringFilter<"DocumentProcessingCost"> | string
    processingType?: EnumDocumentProcessingTypeFilter<"DocumentProcessingCost"> | $Enums.DocumentProcessingType
    creditsConsumed?: IntFilter<"DocumentProcessingCost"> | number
    extractionCost?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    chunkCount?: IntNullableFilter<"DocumentProcessingCost"> | number | null
    embeddingModel?: StringNullableFilter<"DocumentProcessingCost"> | string | null
    processingTimeMs?: IntNullableFilter<"DocumentProcessingCost"> | number | null
    tokensProcessed?: IntFilter<"DocumentProcessingCost"> | number
    processedAt?: DateTimeFilter<"DocumentProcessingCost"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type DocumentProcessingCostOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    processingType?: SortOrder
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrderInput | SortOrder
    embeddingModel?: SortOrderInput | SortOrder
    processingTimeMs?: SortOrderInput | SortOrder
    tokensProcessed?: SortOrder
    processedAt?: SortOrder
    _count?: DocumentProcessingCostCountOrderByAggregateInput
    _avg?: DocumentProcessingCostAvgOrderByAggregateInput
    _max?: DocumentProcessingCostMaxOrderByAggregateInput
    _min?: DocumentProcessingCostMinOrderByAggregateInput
    _sum?: DocumentProcessingCostSumOrderByAggregateInput
  }

  export type DocumentProcessingCostScalarWhereWithAggregatesInput = {
    AND?: DocumentProcessingCostScalarWhereWithAggregatesInput | DocumentProcessingCostScalarWhereWithAggregatesInput[]
    OR?: DocumentProcessingCostScalarWhereWithAggregatesInput[]
    NOT?: DocumentProcessingCostScalarWhereWithAggregatesInput | DocumentProcessingCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentProcessingCost"> | string
    documentId?: StringWithAggregatesFilter<"DocumentProcessingCost"> | string
    workspaceId?: StringWithAggregatesFilter<"DocumentProcessingCost"> | string
    subscriptionId?: StringWithAggregatesFilter<"DocumentProcessingCost"> | string
    processingType?: EnumDocumentProcessingTypeWithAggregatesFilter<"DocumentProcessingCost"> | $Enums.DocumentProcessingType
    creditsConsumed?: IntWithAggregatesFilter<"DocumentProcessingCost"> | number
    extractionCost?: DecimalWithAggregatesFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalWithAggregatesFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalWithAggregatesFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    chunkCount?: IntNullableWithAggregatesFilter<"DocumentProcessingCost"> | number | null
    embeddingModel?: StringNullableWithAggregatesFilter<"DocumentProcessingCost"> | string | null
    processingTimeMs?: IntNullableWithAggregatesFilter<"DocumentProcessingCost"> | number | null
    tokensProcessed?: IntWithAggregatesFilter<"DocumentProcessingCost"> | number
    processedAt?: DateTimeWithAggregatesFilter<"DocumentProcessingCost"> | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionCreateInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
    admin: AdminCreateNestedOneWithoutSessionsInput
  }

  export type AdminSessionUncheckedCreateInput = {
    id?: string
    adminId: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type AdminSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionCreateManyInput = {
    id?: string
    adminId: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
    admin?: AdminCreateNestedOneWithoutAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    adminId?: string | null
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    adminId?: string | null
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionCreateInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutPermissionsInput
  }

  export type AdminPermissionUncheckedCreateInput = {
    id?: string
    adminId: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type AdminPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionCreateManyInput = {
    id?: string
    adminId: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyCreateInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutApiKeysInput
  }

  export type AdminAPIKeyUncheckedCreateInput = {
    id?: string
    adminId: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type AdminAPIKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyCreateManyInput = {
    id?: string
    adminId: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationCreateInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    inviter: AdminCreateNestedOneWithoutInvitationsInput
  }

  export type AdminInvitationUncheckedCreateInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    invitedBy: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviter?: AdminUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type AdminInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationCreateManyInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    invitedBy: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminSecurityEventCreateInput = {
    id?: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId?: string | null
    ipAddress: string
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type AdminSecurityEventUncheckedCreateInput = {
    id?: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId?: string | null
    ipAddress: string
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type AdminSecurityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSecurityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSecurityEventCreateManyInput = {
    id?: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId?: string | null
    ipAddress: string
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type AdminSecurityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSecurityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseCreateInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutCreditPurchasesInput
  }

  export type CreditPurchaseUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutCreditPurchasesNestedInput
  }

  export type CreditPurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseCreateManyInput = {
    id?: string
    subscriptionId: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogCreateInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutCreditUsageInput
  }

  export type CreditUsageLogUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutCreditUsageNestedInput
  }

  export type CreditUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogCreateManyInput = {
    id?: string
    subscriptionId: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierCreateInput = {
    id?: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description?: string | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens?: number
    maxTokens?: number | null
    maxOutputTokens?: number | null
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelPricingTierUncheckedCreateInput = {
    id?: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description?: string | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens?: number
    maxTokens?: number | null
    maxOutputTokens?: number | null
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelPricingTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierCreateManyInput = {
    id?: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description?: string | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens?: number
    maxTokens?: number | null
    maxOutputTokens?: number | null
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelPricingTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaceCreateInput = {
    id?: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSpacesInput
    flows?: FlowCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    flows?: FlowUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSpacesNestedInput
    flows?: FlowUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flows?: FlowUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowCreateManyInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowInvitationCreateInput = {
    id?: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    flow: FlowCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentFlowInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedFlowInvitesInput
  }

  export type FlowInvitationUncheckedCreateInput = {
    id?: string
    flowId: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow?: FlowUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentFlowInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedFlowInvitesNestedInput
  }

  export type FlowInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationCreateManyInput = {
    id?: string
    flowId: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowCollaboratorCreateInput = {
    id?: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
    flow: FlowCreateNestedOneWithoutCollaboratorsInput
    user: UserCreateNestedOneWithoutFlowCollaborationsInput
  }

  export type FlowCollaboratorUncheckedCreateInput = {
    id?: string
    flowId: string
    userId: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type FlowCollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow?: FlowUpdateOneRequiredWithoutCollaboratorsNestedInput
    user?: UserUpdateOneRequiredWithoutFlowCollaborationsNestedInput
  }

  export type FlowCollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowCollaboratorCreateManyInput = {
    id?: string
    flowId: string
    userId: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type FlowCollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowCollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowSessionCreateInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
    flow: FlowCreateNestedOneWithoutSessionsInput
  }

  export type FlowSessionUncheckedCreateInput = {
    id?: string
    flowId: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type FlowSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow?: FlowUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type FlowSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowSessionCreateManyInput = {
    id?: string
    flowId: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type FlowSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowActivityLogCreateInput = {
    id?: string
    userId?: string | null
    action: $Enums.FlowActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    flow: FlowCreateNestedOneWithoutActivityLogInput
  }

  export type FlowActivityLogUncheckedCreateInput = {
    id?: string
    flowId: string
    userId?: string | null
    action: $Enums.FlowActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlowActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type FlowActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowActivityLogCreateManyInput = {
    id?: string
    flowId: string
    userId?: string | null
    action: $Enums.FlowActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlowActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCommentCreateInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutCommentsInput
  }

  export type FlowCommentUncheckedCreateInput = {
    id?: string
    flowId: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type FlowCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCommentCreateManyInput = {
    id?: string
    flowId: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodCreateInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodCreateManyInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeCreateInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    flow: FlowCreateNestedOneWithoutEdgesInput
    sourcePod: PodCreateNestedOneWithoutSourceEdgesInput
    targetPod: PodCreateNestedOneWithoutTargetEdgesInput
  }

  export type EdgeUncheckedCreateInput = {
    id?: string
    flowId: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutEdgesNestedInput
    sourcePod?: PodUpdateOneRequiredWithoutSourceEdgesNestedInput
    targetPod?: PodUpdateOneRequiredWithoutTargetEdgesNestedInput
  }

  export type EdgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeCreateManyInput = {
    id?: string
    flowId: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodExecutionCreateInput = {
    id?: string
    flowId: string
    workspaceId: string
    status?: $Enums.PodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
    pod: PodCreateNestedOneWithoutExecutionsInput
  }

  export type PodExecutionUncheckedCreateInput = {
    id?: string
    podId: string
    flowId: string
    workspaceId: string
    status?: $Enums.PodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pod?: PodUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type PodExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionCreateManyInput = {
    id?: string
    podId: string
    flowId: string
    workspaceId: string
    status?: $Enums.PodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogCreateInput = {
    id?: string
    executionId: string
    flowId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
    pod: PodCreateNestedOneWithoutUsageLogsInput
    subscription: SubscriptionCreateNestedOneWithoutUsageLogsInput
  }

  export type PodUsageLogUncheckedCreateInput = {
    id?: string
    podId: string
    executionId: string
    flowId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: PodUpdateOneRequiredWithoutUsageLogsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type PodUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogCreateManyInput = {
    id?: string
    podId: string
    executionId: string
    flowId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutContextModulesInput
    originalFlow?: FlowCreateNestedOneWithoutContextModulesInput
  }

  export type ContextModuleUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalFlowId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutContextModulesNestedInput
    originalFlow?: FlowUpdateOneWithoutContextModulesNestedInput
  }

  export type ContextModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalFlowId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    deviceName: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    deviceName: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserCreateInput = {
    id?: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceUserUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInvitationCreateInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentWorkspaceInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationCreateManyInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyCreateInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutApiKeysInput
  }

  export type ProviderAPIKeyUncheckedCreateInput = {
    id?: string
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ProviderAPIKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyCreateManyInput = {
    id?: string
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkCreateInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutShareLinksInput
  }

  export type ShareLinkUncheckedCreateInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    workspaceId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutShareLinksNestedInput
  }

  export type ShareLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkCreateManyInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    workspaceId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentFolderCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DocumentFolderCreateNestedOneWithoutChildrenInput
    children?: DocumentFolderCreateNestedManyWithoutParentInput
    workspace: WorkspaceCreateNestedOneWithoutDocumentFoldersInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    parentId?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: DocumentFolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DocumentFolderUpdateOneWithoutChildrenNestedInput
    children?: DocumentFolderUpdateManyWithoutParentNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentFoldersNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: DocumentFolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    parentId?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentFolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    folder?: DocumentFolderCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    pods?: PodCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    workspaceId: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    pods?: PodUncheckedCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: DocumentFolderUpdateOneWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    pods?: PodUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    pods?: PodUncheckedUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    workspaceId: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutEmbeddingsInput
  }

  export type EmbeddingUncheckedCreateInput = {
    id?: string
    documentId: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutEmbeddingsNestedInput
  }

  export type EmbeddingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateManyInput = {
    id?: string
    documentId: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostCreateInput = {
    id?: string
    workspaceId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
    document: DocumentCreateNestedOneWithoutProcessingCostRecordsInput
    subscription: SubscriptionCreateNestedOneWithoutDocumentProcessingCostInput
  }

  export type DocumentProcessingCostUncheckedCreateInput = {
    id?: string
    documentId: string
    workspaceId: string
    subscriptionId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
  }

  export type DocumentProcessingCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutProcessingCostRecordsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutDocumentProcessingCostNestedInput
  }

  export type DocumentProcessingCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostCreateManyInput = {
    id?: string
    documentId: string
    workspaceId: string
    subscriptionId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
  }

  export type DocumentProcessingCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type EnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminSessionListRelationFilter = {
    every?: AdminSessionWhereInput
    some?: AdminSessionWhereInput
    none?: AdminSessionWhereInput
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type AdminPermissionListRelationFilter = {
    every?: AdminPermissionWhereInput
    some?: AdminPermissionWhereInput
    none?: AdminPermissionWhereInput
  }

  export type AdminAPIKeyListRelationFilter = {
    every?: AdminAPIKeyWhereInput
    some?: AdminAPIKeyWhereInput
    none?: AdminAPIKeyWhereInput
  }

  export type AdminInvitationListRelationFilter = {
    every?: AdminInvitationWhereInput
    some?: AdminInvitationWhereInput
    none?: AdminInvitationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAPIKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrder
    mfaBackupCodes?: SortOrder
    mfaVerifiedAt?: SortOrder
    allowedIpAddresses?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrder
    mfaVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrder
    mfaVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type EnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AdminSessionOrderByRelevanceInput = {
    fields: AdminSessionOrderByRelevanceFieldEnum | AdminSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminSessionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
  }

  export type AdminSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
  }

  export type AdminSessionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
  }

  export type EnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type EnumAdminResourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceFilter<$PrismaModel> | $Enums.AdminResource
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AdminAuditLogOrderByRelevanceInput = {
    fields: AdminAuditLogOrderByRelevanceFieldEnum | AdminAuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    changesBefore?: SortOrder
    changesAfter?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogAvgOrderByAggregateInput = {
    status?: SortOrder
    executionTimeMs?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogSumOrderByAggregateInput = {
    status?: SortOrder
    executionTimeMs?: SortOrder
  }

  export type EnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type EnumAdminResourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSpecificPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionFilter<$PrismaModel> | $Enums.SpecificPermission
  }

  export type EnumAdminResourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableFilter<$PrismaModel> | $Enums.AdminResource | null
  }

  export type AdminPermissionOrderByRelevanceInput = {
    fields: AdminPermissionOrderByRelevanceFieldEnum | AdminPermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminPermissionAdminIdPermissionResourceCompoundUniqueInput = {
    adminId: string
    permission: $Enums.SpecificPermission
    resource: $Enums.AdminResource
  }

  export type AdminPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
  }

  export type AdminPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
  }

  export type AdminPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumSpecificPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionWithAggregatesFilter<$PrismaModel> | $Enums.SpecificPermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecificPermissionFilter<$PrismaModel>
    _max?: NestedEnumSpecificPermissionFilter<$PrismaModel>
  }

  export type EnumAdminResourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminAPIKeyOrderByRelevanceInput = {
    fields: AdminAPIKeyOrderByRelevanceFieldEnum | AdminAPIKeyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminAPIKeyCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    allowedIps?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type AdminAPIKeyAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type AdminAPIKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type AdminAPIKeyMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type AdminAPIKeySumOrderByAggregateInput = {
    rateLimit?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AdminInvitationOrderByRelevanceInput = {
    fields: AdminInvitationOrderByRelevanceFieldEnum | AdminInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type AdminInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type AdminInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type AdminSecurityEventOrderByRelevanceInput = {
    fields: AdminSecurityEventOrderByRelevanceFieldEnum | AdminSecurityEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminSecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type EnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type PodUsageLogListRelationFilter = {
    every?: PodUsageLogWhereInput
    some?: PodUsageLogWhereInput
    none?: PodUsageLogWhereInput
  }

  export type CreditPurchaseListRelationFilter = {
    every?: CreditPurchaseWhereInput
    some?: CreditPurchaseWhereInput
    none?: CreditPurchaseWhereInput
  }

  export type CreditUsageLogListRelationFilter = {
    every?: CreditUsageLogWhereInput
    some?: CreditUsageLogWhereInput
    none?: CreditUsageLogWhereInput
  }

  export type DocumentProcessingCostListRelationFilter = {
    every?: DocumentProcessingCostWhereInput
    some?: DocumentProcessingCostWhereInput
    none?: DocumentProcessingCostWhereInput
  }

  export type PodUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentProcessingCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type CreditPurchaseOrderByRelevanceInput = {
    fields: CreditPurchaseOrderByRelevanceFieldEnum | CreditPurchaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CreditPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
  }

  export type CreditPurchaseAvgOrderByAggregateInput = {
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
  }

  export type CreditPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
  }

  export type CreditPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
  }

  export type CreditPurchaseSumOrderByAggregateInput = {
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumLLMProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderFilter<$PrismaModel> | $Enums.LLMProvider
  }

  export type CreditUsageLogOrderByRelevanceInput = {
    fields: CreditUsageLogOrderByRelevanceFieldEnum | CreditUsageLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CreditUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditUsageLogAvgOrderByAggregateInput = {
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type CreditUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditUsageLogSumOrderByAggregateInput = {
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type EnumLLMProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderWithAggregatesFilter<$PrismaModel> | $Enums.LLMProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLLMProviderFilter<$PrismaModel>
    _max?: NestedEnumLLMProviderFilter<$PrismaModel>
  }

  export type EnumModelCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryFilter<$PrismaModel> | $Enums.ModelCategory
  }

  export type ModelPricingTierOrderByRelevanceInput = {
    fields: ModelPricingTierOrderByRelevanceFieldEnum | ModelPricingTierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ModelPricingTierProviderModelIdEffectiveFromCompoundUniqueInput = {
    provider: $Enums.LLMProvider
    modelId: string
    effectiveFrom: Date | string
  }

  export type ModelPricingTierCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    providerConfig?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelPricingTierAvgOrderByAggregateInput = {
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
  }

  export type ModelPricingTierMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelPricingTierMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelPricingTierSumOrderByAggregateInput = {
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
  }

  export type EnumModelCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ModelCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelCategoryFilter<$PrismaModel>
    _max?: NestedEnumModelCategoryFilter<$PrismaModel>
  }

  export type FlowListRelationFilter = {
    every?: FlowWhereInput
    some?: FlowWhereInput
    none?: FlowWhereInput
  }

  export type FlowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceOrderByRelevanceInput = {
    fields: SpaceOrderByRelevanceFieldEnum | SpaceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SpaceWorkspaceIdNameCompoundUniqueInput = {
    workspaceId: string
    name: string
  }

  export type SpaceCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    customInstructions?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    customInstructions?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaceMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    customInstructions?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFlowVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowVisibility | EnumFlowVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowVisibilityFilter<$PrismaModel> | $Enums.FlowVisibility
  }

  export type SpaceNullableScalarRelationFilter = {
    is?: SpaceWhereInput | null
    isNot?: SpaceWhereInput | null
  }

  export type PodListRelationFilter = {
    every?: PodWhereInput
    some?: PodWhereInput
    none?: PodWhereInput
  }

  export type EdgeListRelationFilter = {
    every?: EdgeWhereInput
    some?: EdgeWhereInput
    none?: EdgeWhereInput
  }

  export type ContextModuleListRelationFilter = {
    every?: ContextModuleWhereInput
    some?: ContextModuleWhereInput
    none?: ContextModuleWhereInput
  }

  export type FlowCollaboratorListRelationFilter = {
    every?: FlowCollaboratorWhereInput
    some?: FlowCollaboratorWhereInput
    none?: FlowCollaboratorWhereInput
  }

  export type FlowInvitationListRelationFilter = {
    every?: FlowInvitationWhereInput
    some?: FlowInvitationWhereInput
    none?: FlowInvitationWhereInput
  }

  export type FlowSessionListRelationFilter = {
    every?: FlowSessionWhereInput
    some?: FlowSessionWhereInput
    none?: FlowSessionWhereInput
  }

  export type FlowActivityLogListRelationFilter = {
    every?: FlowActivityLogWhereInput
    some?: FlowActivityLogWhereInput
    none?: FlowActivityLogWhereInput
  }

  export type FlowCommentListRelationFilter = {
    every?: FlowCommentWhereInput
    some?: FlowCommentWhereInput
    none?: FlowCommentWhereInput
  }

  export type PodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EdgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContextModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowOrderByRelevanceInput = {
    fields: FlowOrderByRelevanceFieldEnum | FlowOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    spaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrder
    thumbnailGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlowAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type FlowMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    spaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrder
    thumbnailGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlowMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    spaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrder
    thumbnailGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlowSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumFlowVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowVisibility | EnumFlowVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.FlowVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlowVisibilityFilter<$PrismaModel>
    _max?: NestedEnumFlowVisibilityFilter<$PrismaModel>
  }

  export type EnumFlowAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowAccessLevel | EnumFlowAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowAccessLevelFilter<$PrismaModel> | $Enums.FlowAccessLevel
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type FlowScalarRelationFilter = {
    is?: FlowWhereInput
    isNot?: FlowWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type FlowInvitationOrderByRelevanceInput = {
    fields: FlowInvitationOrderByRelevanceFieldEnum | FlowInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type FlowInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type FlowInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumFlowAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowAccessLevel | EnumFlowAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.FlowAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlowAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumFlowAccessLevelFilter<$PrismaModel>
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type FlowCollaboratorOrderByRelevanceInput = {
    fields: FlowCollaboratorOrderByRelevanceFieldEnum | FlowCollaboratorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowCollaboratorFlowIdUserIdCompoundUniqueInput = {
    flowId: string
    userId: string
  }

  export type FlowCollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type FlowCollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type FlowCollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type FlowSessionOrderByRelevanceInput = {
    fields: FlowSessionOrderByRelevanceFieldEnum | FlowSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowSessionCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    anonymousName?: SortOrder
    sessionToken?: SortOrder
    socketId?: SortOrder
    cursorPosition?: SortOrder
    selectedPodIds?: SortOrder
    viewportState?: SortOrder
    userColor?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrder
  }

  export type FlowSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    anonymousName?: SortOrder
    sessionToken?: SortOrder
    socketId?: SortOrder
    userColor?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrder
  }

  export type FlowSessionMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    anonymousName?: SortOrder
    sessionToken?: SortOrder
    socketId?: SortOrder
    userColor?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrder
  }

  export type EnumFlowActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowActivityAction | EnumFlowActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowActivityActionFilter<$PrismaModel> | $Enums.FlowActivityAction
  }

  export type FlowActivityLogOrderByRelevanceInput = {
    fields: FlowActivityLogOrderByRelevanceFieldEnum | FlowActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changeData?: SortOrder
    createdAt?: SortOrder
  }

  export type FlowActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type FlowActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFlowActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowActivityAction | EnumFlowActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.FlowActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlowActivityActionFilter<$PrismaModel>
    _max?: NestedEnumFlowActivityActionFilter<$PrismaModel>
  }

  export type FlowCommentOrderByRelevanceInput = {
    fields: FlowCommentOrderByRelevanceFieldEnum | FlowCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowCommentCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    position?: SortOrder
    podId?: SortOrder
    parentId?: SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlowCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    podId?: SortOrder
    parentId?: SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlowCommentMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    podId?: SortOrder
    parentId?: SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PodType | EnumPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPodTypeFilter<$PrismaModel> | $Enums.PodType
  }

  export type EnumPodExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PodExecutionStatus | EnumPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPodExecutionStatusFilter<$PrismaModel> | $Enums.PodExecutionStatus
  }

  export type FlowNullableScalarRelationFilter = {
    is?: FlowWhereInput | null
    isNot?: FlowWhereInput | null
  }

  export type DocumentNullableScalarRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type PodExecutionListRelationFilter = {
    every?: PodExecutionWhereInput
    some?: PodExecutionWhereInput
    none?: PodExecutionWhereInput
  }

  export type PodExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PodOrderByRelevanceInput = {
    fields: PodOrderByRelevanceFieldEnum | PodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PodDynamoPartitionKeyDynamoSortKeyCompoundUniqueInput = {
    dynamoPartitionKey: string
    dynamoSortKey: string
  }

  export type PodCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    type?: SortOrder
    position?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrder
    contextFlowId?: SortOrder
    documentId?: SortOrder
    lockedBy?: SortOrder
    lockedAt?: SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PodMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    type?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrder
    contextFlowId?: SortOrder
    documentId?: SortOrder
    lockedBy?: SortOrder
    lockedAt?: SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PodMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    type?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrder
    contextFlowId?: SortOrder
    documentId?: SortOrder
    lockedBy?: SortOrder
    lockedAt?: SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PodType | EnumPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPodTypeFilter<$PrismaModel>
    _max?: NestedEnumPodTypeFilter<$PrismaModel>
  }

  export type EnumPodExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PodExecutionStatus | EnumPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPodExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PodExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPodExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumPodExecutionStatusFilter<$PrismaModel>
  }

  export type PodScalarRelationFilter = {
    is?: PodWhereInput
    isNot?: PodWhereInput
  }

  export type EdgeOrderByRelevanceInput = {
    fields: EdgeOrderByRelevanceFieldEnum | EdgeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EdgeFlowIdSourcePodIdSourceHandleTargetPodIdTargetHandleCompoundUniqueInput = {
    flowId: string
    sourcePodId: string
    sourceHandle: string
    targetPodId: string
    targetHandle: string
  }

  export type EdgeCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
  }

  export type EdgeMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
  }

  export type EdgeMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionOrderByRelevanceInput = {
    fields: PodExecutionOrderByRelevanceFieldEnum | PodExecutionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PodExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    runtimeInMs?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    providerMetadata?: SortOrder
    requestMetadata?: SortOrder
    responseMetadata?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type PodExecutionAvgOrderByAggregateInput = {
    runtimeInMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type PodExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    runtimeInMs?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type PodExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    runtimeInMs?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type PodExecutionSumOrderByAggregateInput = {
    runtimeInMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type PodUsageLogOrderByRelevanceInput = {
    fields: PodUsageLogOrderByRelevanceFieldEnum | PodUsageLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PodUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    providerMetadata?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
  }

  export type PodUsageLogAvgOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
  }

  export type PodUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
  }

  export type PodUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    flowId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
  }

  export type PodUsageLogSumOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
  }

  export type ContextModuleOrderByRelevanceInput = {
    fields: ContextModuleOrderByRelevanceFieldEnum | ContextModuleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContextModuleCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    definitionJson?: SortOrder
    originalFlowId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextModuleAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ContextModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    originalFlowId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextModuleMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    originalFlowId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextModuleSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type WorkspaceUserListRelationFilter = {
    every?: WorkspaceUserWhereInput
    some?: WorkspaceUserWhereInput
    none?: WorkspaceUserWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type WorkspaceInvitationListRelationFilter = {
    every?: WorkspaceInvitationWhereInput
    some?: WorkspaceInvitationWhereInput
    none?: WorkspaceInvitationWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenOrderByRelevanceInput = {
    fields: RefreshTokenOrderByRelevanceFieldEnum | RefreshTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefreshTokenUserIdDeviceNameCompoundUniqueInput = {
    userId: string
    deviceName: string
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: $Enums.AuthProvider
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type EnumWorkspaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeFilter<$PrismaModel> | $Enums.WorkspaceType
  }

  export type SpaceListRelationFilter = {
    every?: SpaceWhereInput
    some?: SpaceWhereInput
    none?: SpaceWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentFolderListRelationFilter = {
    every?: DocumentFolderWhereInput
    some?: DocumentFolderWhereInput
    none?: DocumentFolderWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type ShareLinkListRelationFilter = {
    every?: ShareLinkWhereInput
    some?: ShareLinkWhereInput
    none?: ShareLinkWhereInput
  }

  export type ProviderAPIKeyListRelationFilter = {
    every?: ProviderAPIKeyWhereInput
    some?: ProviderAPIKeyWhereInput
    none?: ProviderAPIKeyWhereInput
  }

  export type SpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentFolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderAPIKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceOrderByRelevanceInput = {
    fields: WorkspaceOrderByRelevanceFieldEnum | WorkspaceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkspaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
  }

  export type EnumWorkspaceRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleFilter<$PrismaModel> | $Enums.WorkspaceRole
  }

  export type WorkspaceUserOrderByRelevanceInput = {
    fields: WorkspaceUserOrderByRelevanceFieldEnum | WorkspaceUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WorkspaceUserUserIdWorkspaceIdCompoundUniqueInput = {
    userId: string
    workspaceId: string
  }

  export type WorkspaceUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type WorkspaceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type WorkspaceUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type EnumWorkspaceRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
  }

  export type WorkspaceInvitationOrderByRelevanceInput = {
    fields: WorkspaceInvitationOrderByRelevanceFieldEnum | WorkspaceInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WorkspaceInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type WorkspaceInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type WorkspaceInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeFilter<$PrismaModel> | $Enums.AuthType
  }

  export type ProviderAPIKeyOrderByRelevanceInput = {
    fields: ProviderAPIKeyOrderByRelevanceFieldEnum | ProviderAPIKeyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProviderAPIKeyWorkspaceIdProviderDisplayNameCompoundUniqueInput = {
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
  }

  export type ProviderAPIKeyCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    providerConfig?: SortOrder
    endpoint?: SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ProviderAPIKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    endpoint?: SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ProviderAPIKeyMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    endpoint?: SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTypeFilter<$PrismaModel>
  }

  export type EnumShareableAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeFilter<$PrismaModel> | $Enums.ShareableAssetType
  }

  export type EnumShareAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelFilter<$PrismaModel> | $Enums.ShareAccessLevel
  }

  export type ShareLinkOrderByRelevanceInput = {
    fields: ShareLinkOrderByRelevanceFieldEnum | ShareLinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShareLinkAssetTypeAssetIdCompoundUniqueInput = {
    assetType: $Enums.ShareableAssetType
    assetId: string
  }

  export type ShareLinkCountOrderByAggregateInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShareLinkAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type ShareLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShareLinkMinOrderByAggregateInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShareLinkSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumShareableAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShareableAssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
  }

  export type EnumShareAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.ShareAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumShareAccessLevelFilter<$PrismaModel>
  }

  export type DocumentFolderNullableScalarRelationFilter = {
    is?: DocumentFolderWhereInput | null
    isNot?: DocumentFolderWhereInput | null
  }

  export type DocumentFolderOrderByRelevanceInput = {
    fields: DocumentFolderOrderByRelevanceFieldEnum | DocumentFolderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentFolderWorkspaceIdParentIdNameCompoundUniqueInput = {
    workspaceId: string
    parentId: string
    name: string
  }

  export type DocumentFolderCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentFolderAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type DocumentFolderMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentFolderMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentFolderSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumDocumentSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSourceType | EnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceTypeFilter<$PrismaModel> | $Enums.DocumentSourceType
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type EmbeddingListRelationFilter = {
    every?: EmbeddingWhereInput
    some?: EmbeddingWhereInput
    none?: EmbeddingWhereInput
  }

  export type EmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    folderId?: SortOrder
    name?: SortOrder
    sourceType?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    externalUrl?: SortOrder
    externalProvider?: SortOrder
    externalFileId?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    sizeInBytes?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    folderId?: SortOrder
    name?: SortOrder
    sourceType?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    externalUrl?: SortOrder
    externalProvider?: SortOrder
    externalFileId?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    folderId?: SortOrder
    name?: SortOrder
    sourceType?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    externalUrl?: SortOrder
    externalProvider?: SortOrder
    externalFileId?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    sizeInBytes?: SortOrder
  }

  export type EnumDocumentSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSourceType | EnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentSourceTypeFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type EmbeddingOrderByRelevanceInput = {
    fields: EmbeddingOrderByRelevanceFieldEnum | EmbeddingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmbeddingDocumentIdChunkIndexCompoundUniqueInput = {
    documentId: string
    chunkIndex: number
  }

  export type EmbeddingS3VectorBucketS3VectorKeyCompoundUniqueInput = {
    s3VectorBucket: string
    s3VectorKey: string
  }

  export type EmbeddingCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    vectorDimension?: SortOrder
  }

  export type EmbeddingMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    vectorDimension?: SortOrder
  }

  export type EnumDocumentProcessingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentProcessingType | EnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentProcessingTypeFilter<$PrismaModel> | $Enums.DocumentProcessingType
  }

  export type DocumentProcessingCostOrderByRelevanceInput = {
    fields: DocumentProcessingCostOrderByRelevanceFieldEnum | DocumentProcessingCostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentProcessingCostCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    processingType?: SortOrder
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrder
    embeddingModel?: SortOrder
    processingTimeMs?: SortOrder
    tokensProcessed?: SortOrder
    processedAt?: SortOrder
  }

  export type DocumentProcessingCostAvgOrderByAggregateInput = {
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrder
    processingTimeMs?: SortOrder
    tokensProcessed?: SortOrder
  }

  export type DocumentProcessingCostMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    processingType?: SortOrder
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrder
    embeddingModel?: SortOrder
    processingTimeMs?: SortOrder
    tokensProcessed?: SortOrder
    processedAt?: SortOrder
  }

  export type DocumentProcessingCostMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    processingType?: SortOrder
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrder
    embeddingModel?: SortOrder
    processingTimeMs?: SortOrder
    tokensProcessed?: SortOrder
    processedAt?: SortOrder
  }

  export type DocumentProcessingCostSumOrderByAggregateInput = {
    creditsConsumed?: SortOrder
    extractionCost?: SortOrder
    embeddingCost?: SortOrder
    totalCostInUsd?: SortOrder
    chunkCount?: SortOrder
    processingTimeMs?: SortOrder
    tokensProcessed?: SortOrder
  }

  export type EnumDocumentProcessingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentProcessingType | EnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentProcessingTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentProcessingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentProcessingTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentProcessingTypeFilter<$PrismaModel>
  }

  export type AdminSessionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminPermissionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
  }

  export type AdminAPIKeyCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
  }

  export type AdminInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
  }

  export type AdminSessionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminPermissionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
  }

  export type AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
  }

  export type AdminInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type EnumAdminStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdminStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminSessionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminPermissionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminPermissionUpsertWithWhereUniqueWithoutAdminInput | AdminPermissionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    set?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    disconnect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    delete?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    update?: AdminPermissionUpdateWithWhereUniqueWithoutAdminInput | AdminPermissionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminPermissionUpdateManyWithWhereWithoutAdminInput | AdminPermissionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
  }

  export type AdminAPIKeyUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    set?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    disconnect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    delete?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    update?: AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAPIKeyUpdateManyWithWhereWithoutAdminInput | AdminAPIKeyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
  }

  export type AdminInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: AdminInvitationUpsertWithWhereUniqueWithoutInviterInput | AdminInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    set?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    disconnect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    delete?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    update?: AdminInvitationUpdateWithWhereUniqueWithoutInviterInput | AdminInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: AdminInvitationUpdateManyWithWhereWithoutInviterInput | AdminInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminPermissionUpsertWithWhereUniqueWithoutAdminInput | AdminPermissionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    set?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    disconnect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    delete?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    update?: AdminPermissionUpdateWithWhereUniqueWithoutAdminInput | AdminPermissionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminPermissionUpdateManyWithWhereWithoutAdminInput | AdminPermissionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
  }

  export type AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    set?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    disconnect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    delete?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    update?: AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAPIKeyUpdateManyWithWhereWithoutAdminInput | AdminAPIKeyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
  }

  export type AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: AdminInvitationUpsertWithWhereUniqueWithoutInviterInput | AdminInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    set?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    disconnect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    delete?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    update?: AdminInvitationUpdateWithWhereUniqueWithoutInviterInput | AdminInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: AdminInvitationUpdateManyWithWhereWithoutInviterInput | AdminInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSessionsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSessionsInput
    upsert?: AdminUpsertWithoutSessionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSessionsInput, AdminUpdateWithoutSessionsInput>, AdminUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuditLogsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumAdminActionFieldUpdateOperationsInput = {
    set?: $Enums.AdminAction
  }

  export type EnumAdminResourceFieldUpdateOperationsInput = {
    set?: $Enums.AdminResource
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuditLogsInput
    upsert?: AdminUpsertWithoutAuditLogsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuditLogsInput, AdminUpdateWithoutAuditLogsInput>, AdminUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPermissionsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumSpecificPermissionFieldUpdateOperationsInput = {
    set?: $Enums.SpecificPermission
  }

  export type NullableEnumAdminResourceFieldUpdateOperationsInput = {
    set?: $Enums.AdminResource | null
  }

  export type AdminUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPermissionsInput
    upsert?: AdminUpsertWithoutPermissionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutPermissionsInput, AdminUpdateWithoutPermissionsInput>, AdminUncheckedUpdateWithoutPermissionsInput>
  }

  export type AdminCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: AdminCreateOrConnectWithoutApiKeysInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: AdminCreateOrConnectWithoutApiKeysInput
    upsert?: AdminUpsertWithoutApiKeysInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutApiKeysInput, AdminUpdateWithoutApiKeysInput>, AdminUncheckedUpdateWithoutApiKeysInput>
  }

  export type AdminCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutInvitationsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutInvitationsInput
    upsert?: AdminUpsertWithoutInvitationsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutInvitationsInput, AdminUpdateWithoutInvitationsInput>, AdminUncheckedUpdateWithoutInvitationsInput>
  }

  export type EnumSecurityEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFieldUpdateOperationsInput = {
    set?: $Enums.SecuritySeverity
  }

  export type WorkspaceCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type PodUsageLogCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type CreditPurchaseCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
  }

  export type CreditUsageLogCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
  }

  export type DocumentProcessingCostCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutSubscriptionInput, DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput> | DocumentProcessingCostCreateWithoutSubscriptionInput[] | DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput | DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput[]
    createMany?: DocumentProcessingCostCreateManySubscriptionInputEnvelope
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
  }

  export type PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
  }

  export type CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
  }

  export type DocumentProcessingCostUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutSubscriptionInput, DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput> | DocumentProcessingCostCreateWithoutSubscriptionInput[] | DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput | DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput[]
    createMany?: DocumentProcessingCostCreateManySubscriptionInputEnvelope
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionInput
    upsert?: WorkspaceUpsertWithoutSubscriptionInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSubscriptionInput, WorkspaceUpdateWithoutSubscriptionInput>, WorkspaceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PodUsageLogUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput | PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type CreditPurchaseUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    set?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    disconnect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    delete?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    update?: CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput | CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
  }

  export type CreditUsageLogUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    set?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    disconnect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    delete?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    update?: CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput | CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
  }

  export type DocumentProcessingCostUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutSubscriptionInput, DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput> | DocumentProcessingCostCreateWithoutSubscriptionInput[] | DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput | DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput[]
    upsert?: DocumentProcessingCostUpsertWithWhereUniqueWithoutSubscriptionInput | DocumentProcessingCostUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: DocumentProcessingCostCreateManySubscriptionInputEnvelope
    set?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    disconnect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    delete?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    update?: DocumentProcessingCostUpdateWithWhereUniqueWithoutSubscriptionInput | DocumentProcessingCostUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: DocumentProcessingCostUpdateManyWithWhereWithoutSubscriptionInput | DocumentProcessingCostUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: DocumentProcessingCostScalarWhereInput | DocumentProcessingCostScalarWhereInput[]
  }

  export type PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput | PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    set?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    disconnect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    delete?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    update?: CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput | CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
  }

  export type CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    set?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    disconnect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    delete?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    update?: CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput | CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
  }

  export type DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutSubscriptionInput, DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput> | DocumentProcessingCostCreateWithoutSubscriptionInput[] | DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput | DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput[]
    upsert?: DocumentProcessingCostUpsertWithWhereUniqueWithoutSubscriptionInput | DocumentProcessingCostUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: DocumentProcessingCostCreateManySubscriptionInputEnvelope
    set?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    disconnect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    delete?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    update?: DocumentProcessingCostUpdateWithWhereUniqueWithoutSubscriptionInput | DocumentProcessingCostUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: DocumentProcessingCostUpdateManyWithWhereWithoutSubscriptionInput | DocumentProcessingCostUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: DocumentProcessingCostScalarWhereInput | DocumentProcessingCostScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutCreditPurchasesInput = {
    create?: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditPurchasesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionUpdateOneRequiredWithoutCreditPurchasesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditPurchasesInput
    upsert?: SubscriptionUpsertWithoutCreditPurchasesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCreditPurchasesInput, SubscriptionUpdateWithoutCreditPurchasesInput>, SubscriptionUncheckedUpdateWithoutCreditPurchasesInput>
  }

  export type SubscriptionCreateNestedOneWithoutCreditUsageInput = {
    create?: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditUsageInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumLLMProviderFieldUpdateOperationsInput = {
    set?: $Enums.LLMProvider
  }

  export type SubscriptionUpdateOneRequiredWithoutCreditUsageNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditUsageInput
    upsert?: SubscriptionUpsertWithoutCreditUsageInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCreditUsageInput, SubscriptionUpdateWithoutCreditUsageInput>, SubscriptionUncheckedUpdateWithoutCreditUsageInput>
  }

  export type EnumModelCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ModelCategory
  }

  export type WorkspaceCreateNestedOneWithoutSpacesInput = {
    create?: XOR<WorkspaceCreateWithoutSpacesInput, WorkspaceUncheckedCreateWithoutSpacesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSpacesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type FlowCreateNestedManyWithoutSpaceInput = {
    create?: XOR<FlowCreateWithoutSpaceInput, FlowUncheckedCreateWithoutSpaceInput> | FlowCreateWithoutSpaceInput[] | FlowUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutSpaceInput | FlowCreateOrConnectWithoutSpaceInput[]
    createMany?: FlowCreateManySpaceInputEnvelope
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
  }

  export type FlowUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<FlowCreateWithoutSpaceInput, FlowUncheckedCreateWithoutSpaceInput> | FlowCreateWithoutSpaceInput[] | FlowUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutSpaceInput | FlowCreateOrConnectWithoutSpaceInput[]
    createMany?: FlowCreateManySpaceInputEnvelope
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutSpacesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSpacesInput, WorkspaceUncheckedCreateWithoutSpacesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSpacesInput
    upsert?: WorkspaceUpsertWithoutSpacesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSpacesInput, WorkspaceUpdateWithoutSpacesInput>, WorkspaceUncheckedUpdateWithoutSpacesInput>
  }

  export type FlowUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<FlowCreateWithoutSpaceInput, FlowUncheckedCreateWithoutSpaceInput> | FlowCreateWithoutSpaceInput[] | FlowUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutSpaceInput | FlowCreateOrConnectWithoutSpaceInput[]
    upsert?: FlowUpsertWithWhereUniqueWithoutSpaceInput | FlowUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: FlowCreateManySpaceInputEnvelope
    set?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    disconnect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    delete?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    update?: FlowUpdateWithWhereUniqueWithoutSpaceInput | FlowUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: FlowUpdateManyWithWhereWithoutSpaceInput | FlowUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: FlowScalarWhereInput | FlowScalarWhereInput[]
  }

  export type FlowUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<FlowCreateWithoutSpaceInput, FlowUncheckedCreateWithoutSpaceInput> | FlowCreateWithoutSpaceInput[] | FlowUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutSpaceInput | FlowCreateOrConnectWithoutSpaceInput[]
    upsert?: FlowUpsertWithWhereUniqueWithoutSpaceInput | FlowUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: FlowCreateManySpaceInputEnvelope
    set?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    disconnect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    delete?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    update?: FlowUpdateWithWhereUniqueWithoutSpaceInput | FlowUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: FlowUpdateManyWithWhereWithoutSpaceInput | FlowUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: FlowScalarWhereInput | FlowScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutFlowsInput = {
    create?: XOR<WorkspaceCreateWithoutFlowsInput, WorkspaceUncheckedCreateWithoutFlowsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFlowsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutFlowsInput = {
    create?: XOR<SpaceCreateWithoutFlowsInput, SpaceUncheckedCreateWithoutFlowsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutFlowsInput
    connect?: SpaceWhereUniqueInput
  }

  export type PodCreateNestedManyWithoutFlowInput = {
    create?: XOR<PodCreateWithoutFlowInput, PodUncheckedCreateWithoutFlowInput> | PodCreateWithoutFlowInput[] | PodUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutFlowInput | PodCreateOrConnectWithoutFlowInput[]
    createMany?: PodCreateManyFlowInputEnvelope
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
  }

  export type EdgeCreateNestedManyWithoutFlowInput = {
    create?: XOR<EdgeCreateWithoutFlowInput, EdgeUncheckedCreateWithoutFlowInput> | EdgeCreateWithoutFlowInput[] | EdgeUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutFlowInput | EdgeCreateOrConnectWithoutFlowInput[]
    createMany?: EdgeCreateManyFlowInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type PodCreateNestedManyWithoutContextFlowInput = {
    create?: XOR<PodCreateWithoutContextFlowInput, PodUncheckedCreateWithoutContextFlowInput> | PodCreateWithoutContextFlowInput[] | PodUncheckedCreateWithoutContextFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutContextFlowInput | PodCreateOrConnectWithoutContextFlowInput[]
    createMany?: PodCreateManyContextFlowInputEnvelope
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
  }

  export type ContextModuleCreateNestedManyWithoutOriginalFlowInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalFlowInput, ContextModuleUncheckedCreateWithoutOriginalFlowInput> | ContextModuleCreateWithoutOriginalFlowInput[] | ContextModuleUncheckedCreateWithoutOriginalFlowInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalFlowInput | ContextModuleCreateOrConnectWithoutOriginalFlowInput[]
    createMany?: ContextModuleCreateManyOriginalFlowInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type FlowCollaboratorCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowCollaboratorCreateWithoutFlowInput, FlowCollaboratorUncheckedCreateWithoutFlowInput> | FlowCollaboratorCreateWithoutFlowInput[] | FlowCollaboratorUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutFlowInput | FlowCollaboratorCreateOrConnectWithoutFlowInput[]
    createMany?: FlowCollaboratorCreateManyFlowInputEnvelope
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
  }

  export type FlowInvitationCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowInvitationCreateWithoutFlowInput, FlowInvitationUncheckedCreateWithoutFlowInput> | FlowInvitationCreateWithoutFlowInput[] | FlowInvitationUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutFlowInput | FlowInvitationCreateOrConnectWithoutFlowInput[]
    createMany?: FlowInvitationCreateManyFlowInputEnvelope
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
  }

  export type FlowSessionCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowSessionCreateWithoutFlowInput, FlowSessionUncheckedCreateWithoutFlowInput> | FlowSessionCreateWithoutFlowInput[] | FlowSessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowSessionCreateOrConnectWithoutFlowInput | FlowSessionCreateOrConnectWithoutFlowInput[]
    createMany?: FlowSessionCreateManyFlowInputEnvelope
    connect?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
  }

  export type FlowActivityLogCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowActivityLogCreateWithoutFlowInput, FlowActivityLogUncheckedCreateWithoutFlowInput> | FlowActivityLogCreateWithoutFlowInput[] | FlowActivityLogUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowActivityLogCreateOrConnectWithoutFlowInput | FlowActivityLogCreateOrConnectWithoutFlowInput[]
    createMany?: FlowActivityLogCreateManyFlowInputEnvelope
    connect?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
  }

  export type FlowCommentCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowCommentCreateWithoutFlowInput, FlowCommentUncheckedCreateWithoutFlowInput> | FlowCommentCreateWithoutFlowInput[] | FlowCommentUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCommentCreateOrConnectWithoutFlowInput | FlowCommentCreateOrConnectWithoutFlowInput[]
    createMany?: FlowCommentCreateManyFlowInputEnvelope
    connect?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
  }

  export type PodUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<PodCreateWithoutFlowInput, PodUncheckedCreateWithoutFlowInput> | PodCreateWithoutFlowInput[] | PodUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutFlowInput | PodCreateOrConnectWithoutFlowInput[]
    createMany?: PodCreateManyFlowInputEnvelope
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
  }

  export type EdgeUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<EdgeCreateWithoutFlowInput, EdgeUncheckedCreateWithoutFlowInput> | EdgeCreateWithoutFlowInput[] | EdgeUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutFlowInput | EdgeCreateOrConnectWithoutFlowInput[]
    createMany?: EdgeCreateManyFlowInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type PodUncheckedCreateNestedManyWithoutContextFlowInput = {
    create?: XOR<PodCreateWithoutContextFlowInput, PodUncheckedCreateWithoutContextFlowInput> | PodCreateWithoutContextFlowInput[] | PodUncheckedCreateWithoutContextFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutContextFlowInput | PodCreateOrConnectWithoutContextFlowInput[]
    createMany?: PodCreateManyContextFlowInputEnvelope
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
  }

  export type ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalFlowInput, ContextModuleUncheckedCreateWithoutOriginalFlowInput> | ContextModuleCreateWithoutOriginalFlowInput[] | ContextModuleUncheckedCreateWithoutOriginalFlowInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalFlowInput | ContextModuleCreateOrConnectWithoutOriginalFlowInput[]
    createMany?: ContextModuleCreateManyOriginalFlowInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowCollaboratorCreateWithoutFlowInput, FlowCollaboratorUncheckedCreateWithoutFlowInput> | FlowCollaboratorCreateWithoutFlowInput[] | FlowCollaboratorUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutFlowInput | FlowCollaboratorCreateOrConnectWithoutFlowInput[]
    createMany?: FlowCollaboratorCreateManyFlowInputEnvelope
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
  }

  export type FlowInvitationUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowInvitationCreateWithoutFlowInput, FlowInvitationUncheckedCreateWithoutFlowInput> | FlowInvitationCreateWithoutFlowInput[] | FlowInvitationUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutFlowInput | FlowInvitationCreateOrConnectWithoutFlowInput[]
    createMany?: FlowInvitationCreateManyFlowInputEnvelope
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
  }

  export type FlowSessionUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowSessionCreateWithoutFlowInput, FlowSessionUncheckedCreateWithoutFlowInput> | FlowSessionCreateWithoutFlowInput[] | FlowSessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowSessionCreateOrConnectWithoutFlowInput | FlowSessionCreateOrConnectWithoutFlowInput[]
    createMany?: FlowSessionCreateManyFlowInputEnvelope
    connect?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
  }

  export type FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowActivityLogCreateWithoutFlowInput, FlowActivityLogUncheckedCreateWithoutFlowInput> | FlowActivityLogCreateWithoutFlowInput[] | FlowActivityLogUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowActivityLogCreateOrConnectWithoutFlowInput | FlowActivityLogCreateOrConnectWithoutFlowInput[]
    createMany?: FlowActivityLogCreateManyFlowInputEnvelope
    connect?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
  }

  export type FlowCommentUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<FlowCommentCreateWithoutFlowInput, FlowCommentUncheckedCreateWithoutFlowInput> | FlowCommentCreateWithoutFlowInput[] | FlowCommentUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCommentCreateOrConnectWithoutFlowInput | FlowCommentCreateOrConnectWithoutFlowInput[]
    createMany?: FlowCommentCreateManyFlowInputEnvelope
    connect?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
  }

  export type EnumFlowVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.FlowVisibility
  }

  export type WorkspaceUpdateOneRequiredWithoutFlowsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFlowsInput, WorkspaceUncheckedCreateWithoutFlowsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFlowsInput
    upsert?: WorkspaceUpsertWithoutFlowsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutFlowsInput, WorkspaceUpdateWithoutFlowsInput>, WorkspaceUncheckedUpdateWithoutFlowsInput>
  }

  export type SpaceUpdateOneWithoutFlowsNestedInput = {
    create?: XOR<SpaceCreateWithoutFlowsInput, SpaceUncheckedCreateWithoutFlowsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutFlowsInput
    upsert?: SpaceUpsertWithoutFlowsInput
    disconnect?: SpaceWhereInput | boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutFlowsInput, SpaceUpdateWithoutFlowsInput>, SpaceUncheckedUpdateWithoutFlowsInput>
  }

  export type PodUpdateManyWithoutFlowNestedInput = {
    create?: XOR<PodCreateWithoutFlowInput, PodUncheckedCreateWithoutFlowInput> | PodCreateWithoutFlowInput[] | PodUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutFlowInput | PodCreateOrConnectWithoutFlowInput[]
    upsert?: PodUpsertWithWhereUniqueWithoutFlowInput | PodUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: PodCreateManyFlowInputEnvelope
    set?: PodWhereUniqueInput | PodWhereUniqueInput[]
    disconnect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    delete?: PodWhereUniqueInput | PodWhereUniqueInput[]
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    update?: PodUpdateWithWhereUniqueWithoutFlowInput | PodUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: PodUpdateManyWithWhereWithoutFlowInput | PodUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: PodScalarWhereInput | PodScalarWhereInput[]
  }

  export type EdgeUpdateManyWithoutFlowNestedInput = {
    create?: XOR<EdgeCreateWithoutFlowInput, EdgeUncheckedCreateWithoutFlowInput> | EdgeCreateWithoutFlowInput[] | EdgeUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutFlowInput | EdgeCreateOrConnectWithoutFlowInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutFlowInput | EdgeUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: EdgeCreateManyFlowInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutFlowInput | EdgeUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutFlowInput | EdgeUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type PodUpdateManyWithoutContextFlowNestedInput = {
    create?: XOR<PodCreateWithoutContextFlowInput, PodUncheckedCreateWithoutContextFlowInput> | PodCreateWithoutContextFlowInput[] | PodUncheckedCreateWithoutContextFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutContextFlowInput | PodCreateOrConnectWithoutContextFlowInput[]
    upsert?: PodUpsertWithWhereUniqueWithoutContextFlowInput | PodUpsertWithWhereUniqueWithoutContextFlowInput[]
    createMany?: PodCreateManyContextFlowInputEnvelope
    set?: PodWhereUniqueInput | PodWhereUniqueInput[]
    disconnect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    delete?: PodWhereUniqueInput | PodWhereUniqueInput[]
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    update?: PodUpdateWithWhereUniqueWithoutContextFlowInput | PodUpdateWithWhereUniqueWithoutContextFlowInput[]
    updateMany?: PodUpdateManyWithWhereWithoutContextFlowInput | PodUpdateManyWithWhereWithoutContextFlowInput[]
    deleteMany?: PodScalarWhereInput | PodScalarWhereInput[]
  }

  export type ContextModuleUpdateManyWithoutOriginalFlowNestedInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalFlowInput, ContextModuleUncheckedCreateWithoutOriginalFlowInput> | ContextModuleCreateWithoutOriginalFlowInput[] | ContextModuleUncheckedCreateWithoutOriginalFlowInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalFlowInput | ContextModuleCreateOrConnectWithoutOriginalFlowInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutOriginalFlowInput | ContextModuleUpsertWithWhereUniqueWithoutOriginalFlowInput[]
    createMany?: ContextModuleCreateManyOriginalFlowInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutOriginalFlowInput | ContextModuleUpdateWithWhereUniqueWithoutOriginalFlowInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutOriginalFlowInput | ContextModuleUpdateManyWithWhereWithoutOriginalFlowInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type FlowCollaboratorUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowCollaboratorCreateWithoutFlowInput, FlowCollaboratorUncheckedCreateWithoutFlowInput> | FlowCollaboratorCreateWithoutFlowInput[] | FlowCollaboratorUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutFlowInput | FlowCollaboratorCreateOrConnectWithoutFlowInput[]
    upsert?: FlowCollaboratorUpsertWithWhereUniqueWithoutFlowInput | FlowCollaboratorUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowCollaboratorCreateManyFlowInputEnvelope
    set?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    disconnect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    delete?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    update?: FlowCollaboratorUpdateWithWhereUniqueWithoutFlowInput | FlowCollaboratorUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowCollaboratorUpdateManyWithWhereWithoutFlowInput | FlowCollaboratorUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowCollaboratorScalarWhereInput | FlowCollaboratorScalarWhereInput[]
  }

  export type FlowInvitationUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowInvitationCreateWithoutFlowInput, FlowInvitationUncheckedCreateWithoutFlowInput> | FlowInvitationCreateWithoutFlowInput[] | FlowInvitationUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutFlowInput | FlowInvitationCreateOrConnectWithoutFlowInput[]
    upsert?: FlowInvitationUpsertWithWhereUniqueWithoutFlowInput | FlowInvitationUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowInvitationCreateManyFlowInputEnvelope
    set?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    disconnect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    delete?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    update?: FlowInvitationUpdateWithWhereUniqueWithoutFlowInput | FlowInvitationUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowInvitationUpdateManyWithWhereWithoutFlowInput | FlowInvitationUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
  }

  export type FlowSessionUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowSessionCreateWithoutFlowInput, FlowSessionUncheckedCreateWithoutFlowInput> | FlowSessionCreateWithoutFlowInput[] | FlowSessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowSessionCreateOrConnectWithoutFlowInput | FlowSessionCreateOrConnectWithoutFlowInput[]
    upsert?: FlowSessionUpsertWithWhereUniqueWithoutFlowInput | FlowSessionUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowSessionCreateManyFlowInputEnvelope
    set?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    disconnect?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    delete?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    connect?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    update?: FlowSessionUpdateWithWhereUniqueWithoutFlowInput | FlowSessionUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowSessionUpdateManyWithWhereWithoutFlowInput | FlowSessionUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowSessionScalarWhereInput | FlowSessionScalarWhereInput[]
  }

  export type FlowActivityLogUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowActivityLogCreateWithoutFlowInput, FlowActivityLogUncheckedCreateWithoutFlowInput> | FlowActivityLogCreateWithoutFlowInput[] | FlowActivityLogUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowActivityLogCreateOrConnectWithoutFlowInput | FlowActivityLogCreateOrConnectWithoutFlowInput[]
    upsert?: FlowActivityLogUpsertWithWhereUniqueWithoutFlowInput | FlowActivityLogUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowActivityLogCreateManyFlowInputEnvelope
    set?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    disconnect?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    delete?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    connect?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    update?: FlowActivityLogUpdateWithWhereUniqueWithoutFlowInput | FlowActivityLogUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowActivityLogUpdateManyWithWhereWithoutFlowInput | FlowActivityLogUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowActivityLogScalarWhereInput | FlowActivityLogScalarWhereInput[]
  }

  export type FlowCommentUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowCommentCreateWithoutFlowInput, FlowCommentUncheckedCreateWithoutFlowInput> | FlowCommentCreateWithoutFlowInput[] | FlowCommentUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCommentCreateOrConnectWithoutFlowInput | FlowCommentCreateOrConnectWithoutFlowInput[]
    upsert?: FlowCommentUpsertWithWhereUniqueWithoutFlowInput | FlowCommentUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowCommentCreateManyFlowInputEnvelope
    set?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    disconnect?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    delete?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    connect?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    update?: FlowCommentUpdateWithWhereUniqueWithoutFlowInput | FlowCommentUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowCommentUpdateManyWithWhereWithoutFlowInput | FlowCommentUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowCommentScalarWhereInput | FlowCommentScalarWhereInput[]
  }

  export type PodUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<PodCreateWithoutFlowInput, PodUncheckedCreateWithoutFlowInput> | PodCreateWithoutFlowInput[] | PodUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutFlowInput | PodCreateOrConnectWithoutFlowInput[]
    upsert?: PodUpsertWithWhereUniqueWithoutFlowInput | PodUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: PodCreateManyFlowInputEnvelope
    set?: PodWhereUniqueInput | PodWhereUniqueInput[]
    disconnect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    delete?: PodWhereUniqueInput | PodWhereUniqueInput[]
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    update?: PodUpdateWithWhereUniqueWithoutFlowInput | PodUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: PodUpdateManyWithWhereWithoutFlowInput | PodUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: PodScalarWhereInput | PodScalarWhereInput[]
  }

  export type EdgeUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<EdgeCreateWithoutFlowInput, EdgeUncheckedCreateWithoutFlowInput> | EdgeCreateWithoutFlowInput[] | EdgeUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutFlowInput | EdgeCreateOrConnectWithoutFlowInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutFlowInput | EdgeUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: EdgeCreateManyFlowInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutFlowInput | EdgeUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutFlowInput | EdgeUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type PodUncheckedUpdateManyWithoutContextFlowNestedInput = {
    create?: XOR<PodCreateWithoutContextFlowInput, PodUncheckedCreateWithoutContextFlowInput> | PodCreateWithoutContextFlowInput[] | PodUncheckedCreateWithoutContextFlowInput[]
    connectOrCreate?: PodCreateOrConnectWithoutContextFlowInput | PodCreateOrConnectWithoutContextFlowInput[]
    upsert?: PodUpsertWithWhereUniqueWithoutContextFlowInput | PodUpsertWithWhereUniqueWithoutContextFlowInput[]
    createMany?: PodCreateManyContextFlowInputEnvelope
    set?: PodWhereUniqueInput | PodWhereUniqueInput[]
    disconnect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    delete?: PodWhereUniqueInput | PodWhereUniqueInput[]
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    update?: PodUpdateWithWhereUniqueWithoutContextFlowInput | PodUpdateWithWhereUniqueWithoutContextFlowInput[]
    updateMany?: PodUpdateManyWithWhereWithoutContextFlowInput | PodUpdateManyWithWhereWithoutContextFlowInput[]
    deleteMany?: PodScalarWhereInput | PodScalarWhereInput[]
  }

  export type ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalFlowInput, ContextModuleUncheckedCreateWithoutOriginalFlowInput> | ContextModuleCreateWithoutOriginalFlowInput[] | ContextModuleUncheckedCreateWithoutOriginalFlowInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalFlowInput | ContextModuleCreateOrConnectWithoutOriginalFlowInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutOriginalFlowInput | ContextModuleUpsertWithWhereUniqueWithoutOriginalFlowInput[]
    createMany?: ContextModuleCreateManyOriginalFlowInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutOriginalFlowInput | ContextModuleUpdateWithWhereUniqueWithoutOriginalFlowInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutOriginalFlowInput | ContextModuleUpdateManyWithWhereWithoutOriginalFlowInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowCollaboratorCreateWithoutFlowInput, FlowCollaboratorUncheckedCreateWithoutFlowInput> | FlowCollaboratorCreateWithoutFlowInput[] | FlowCollaboratorUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutFlowInput | FlowCollaboratorCreateOrConnectWithoutFlowInput[]
    upsert?: FlowCollaboratorUpsertWithWhereUniqueWithoutFlowInput | FlowCollaboratorUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowCollaboratorCreateManyFlowInputEnvelope
    set?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    disconnect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    delete?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    update?: FlowCollaboratorUpdateWithWhereUniqueWithoutFlowInput | FlowCollaboratorUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowCollaboratorUpdateManyWithWhereWithoutFlowInput | FlowCollaboratorUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowCollaboratorScalarWhereInput | FlowCollaboratorScalarWhereInput[]
  }

  export type FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowInvitationCreateWithoutFlowInput, FlowInvitationUncheckedCreateWithoutFlowInput> | FlowInvitationCreateWithoutFlowInput[] | FlowInvitationUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutFlowInput | FlowInvitationCreateOrConnectWithoutFlowInput[]
    upsert?: FlowInvitationUpsertWithWhereUniqueWithoutFlowInput | FlowInvitationUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowInvitationCreateManyFlowInputEnvelope
    set?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    disconnect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    delete?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    update?: FlowInvitationUpdateWithWhereUniqueWithoutFlowInput | FlowInvitationUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowInvitationUpdateManyWithWhereWithoutFlowInput | FlowInvitationUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
  }

  export type FlowSessionUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowSessionCreateWithoutFlowInput, FlowSessionUncheckedCreateWithoutFlowInput> | FlowSessionCreateWithoutFlowInput[] | FlowSessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowSessionCreateOrConnectWithoutFlowInput | FlowSessionCreateOrConnectWithoutFlowInput[]
    upsert?: FlowSessionUpsertWithWhereUniqueWithoutFlowInput | FlowSessionUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowSessionCreateManyFlowInputEnvelope
    set?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    disconnect?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    delete?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    connect?: FlowSessionWhereUniqueInput | FlowSessionWhereUniqueInput[]
    update?: FlowSessionUpdateWithWhereUniqueWithoutFlowInput | FlowSessionUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowSessionUpdateManyWithWhereWithoutFlowInput | FlowSessionUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowSessionScalarWhereInput | FlowSessionScalarWhereInput[]
  }

  export type FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowActivityLogCreateWithoutFlowInput, FlowActivityLogUncheckedCreateWithoutFlowInput> | FlowActivityLogCreateWithoutFlowInput[] | FlowActivityLogUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowActivityLogCreateOrConnectWithoutFlowInput | FlowActivityLogCreateOrConnectWithoutFlowInput[]
    upsert?: FlowActivityLogUpsertWithWhereUniqueWithoutFlowInput | FlowActivityLogUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowActivityLogCreateManyFlowInputEnvelope
    set?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    disconnect?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    delete?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    connect?: FlowActivityLogWhereUniqueInput | FlowActivityLogWhereUniqueInput[]
    update?: FlowActivityLogUpdateWithWhereUniqueWithoutFlowInput | FlowActivityLogUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowActivityLogUpdateManyWithWhereWithoutFlowInput | FlowActivityLogUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowActivityLogScalarWhereInput | FlowActivityLogScalarWhereInput[]
  }

  export type FlowCommentUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<FlowCommentCreateWithoutFlowInput, FlowCommentUncheckedCreateWithoutFlowInput> | FlowCommentCreateWithoutFlowInput[] | FlowCommentUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: FlowCommentCreateOrConnectWithoutFlowInput | FlowCommentCreateOrConnectWithoutFlowInput[]
    upsert?: FlowCommentUpsertWithWhereUniqueWithoutFlowInput | FlowCommentUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: FlowCommentCreateManyFlowInputEnvelope
    set?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    disconnect?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    delete?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    connect?: FlowCommentWhereUniqueInput | FlowCommentWhereUniqueInput[]
    update?: FlowCommentUpdateWithWhereUniqueWithoutFlowInput | FlowCommentUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: FlowCommentUpdateManyWithWhereWithoutFlowInput | FlowCommentUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: FlowCommentScalarWhereInput | FlowCommentScalarWhereInput[]
  }

  export type FlowCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<FlowCreateWithoutInvitationsInput, FlowUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutInvitationsInput
    connect?: FlowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentFlowInvitesInput = {
    create?: XOR<UserCreateWithoutSentFlowInvitesInput, UserUncheckedCreateWithoutSentFlowInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentFlowInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedFlowInvitesInput = {
    create?: XOR<UserCreateWithoutReceivedFlowInvitesInput, UserUncheckedCreateWithoutReceivedFlowInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedFlowInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFlowAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.FlowAccessLevel
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type FlowUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<FlowCreateWithoutInvitationsInput, FlowUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutInvitationsInput
    upsert?: FlowUpsertWithoutInvitationsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutInvitationsInput, FlowUpdateWithoutInvitationsInput>, FlowUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentFlowInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentFlowInvitesInput, UserUncheckedCreateWithoutSentFlowInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentFlowInvitesInput
    upsert?: UserUpsertWithoutSentFlowInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentFlowInvitesInput, UserUpdateWithoutSentFlowInvitesInput>, UserUncheckedUpdateWithoutSentFlowInvitesInput>
  }

  export type UserUpdateOneWithoutReceivedFlowInvitesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedFlowInvitesInput, UserUncheckedCreateWithoutReceivedFlowInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedFlowInvitesInput
    upsert?: UserUpsertWithoutReceivedFlowInvitesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedFlowInvitesInput, UserUpdateWithoutReceivedFlowInvitesInput>, UserUncheckedUpdateWithoutReceivedFlowInvitesInput>
  }

  export type FlowCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<FlowCreateWithoutCollaboratorsInput, FlowUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutCollaboratorsInput
    connect?: FlowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFlowCollaborationsInput = {
    create?: XOR<UserCreateWithoutFlowCollaborationsInput, UserUncheckedCreateWithoutFlowCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlowCollaborationsInput
    connect?: UserWhereUniqueInput
  }

  export type FlowUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<FlowCreateWithoutCollaboratorsInput, FlowUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutCollaboratorsInput
    upsert?: FlowUpsertWithoutCollaboratorsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutCollaboratorsInput, FlowUpdateWithoutCollaboratorsInput>, FlowUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type UserUpdateOneRequiredWithoutFlowCollaborationsNestedInput = {
    create?: XOR<UserCreateWithoutFlowCollaborationsInput, UserUncheckedCreateWithoutFlowCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlowCollaborationsInput
    upsert?: UserUpsertWithoutFlowCollaborationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlowCollaborationsInput, UserUpdateWithoutFlowCollaborationsInput>, UserUncheckedUpdateWithoutFlowCollaborationsInput>
  }

  export type FlowCreateNestedOneWithoutSessionsInput = {
    create?: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutSessionsInput
    connect?: FlowWhereUniqueInput
  }

  export type FlowUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutSessionsInput
    upsert?: FlowUpsertWithoutSessionsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutSessionsInput, FlowUpdateWithoutSessionsInput>, FlowUncheckedUpdateWithoutSessionsInput>
  }

  export type FlowCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<FlowCreateWithoutActivityLogInput, FlowUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: FlowCreateOrConnectWithoutActivityLogInput
    connect?: FlowWhereUniqueInput
  }

  export type EnumFlowActivityActionFieldUpdateOperationsInput = {
    set?: $Enums.FlowActivityAction
  }

  export type FlowUpdateOneRequiredWithoutActivityLogNestedInput = {
    create?: XOR<FlowCreateWithoutActivityLogInput, FlowUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: FlowCreateOrConnectWithoutActivityLogInput
    upsert?: FlowUpsertWithoutActivityLogInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutActivityLogInput, FlowUpdateWithoutActivityLogInput>, FlowUncheckedUpdateWithoutActivityLogInput>
  }

  export type FlowCreateNestedOneWithoutCommentsInput = {
    create?: XOR<FlowCreateWithoutCommentsInput, FlowUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutCommentsInput
    connect?: FlowWhereUniqueInput
  }

  export type FlowUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<FlowCreateWithoutCommentsInput, FlowUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutCommentsInput
    upsert?: FlowUpsertWithoutCommentsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutCommentsInput, FlowUpdateWithoutCommentsInput>, FlowUncheckedUpdateWithoutCommentsInput>
  }

  export type FlowCreateNestedOneWithoutPodsInput = {
    create?: XOR<FlowCreateWithoutPodsInput, FlowUncheckedCreateWithoutPodsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutPodsInput
    connect?: FlowWhereUniqueInput
  }

  export type FlowCreateNestedOneWithoutContextualPodsInput = {
    create?: XOR<FlowCreateWithoutContextualPodsInput, FlowUncheckedCreateWithoutContextualPodsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutContextualPodsInput
    connect?: FlowWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutPodsInput = {
    create?: XOR<DocumentCreateWithoutPodsInput, DocumentUncheckedCreateWithoutPodsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPodsInput
    connect?: DocumentWhereUniqueInput
  }

  export type EdgeCreateNestedManyWithoutSourcePodInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type EdgeCreateNestedManyWithoutTargetPodInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type PodExecutionCreateNestedManyWithoutPodInput = {
    create?: XOR<PodExecutionCreateWithoutPodInput, PodExecutionUncheckedCreateWithoutPodInput> | PodExecutionCreateWithoutPodInput[] | PodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodExecutionCreateOrConnectWithoutPodInput | PodExecutionCreateOrConnectWithoutPodInput[]
    createMany?: PodExecutionCreateManyPodInputEnvelope
    connect?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
  }

  export type PodUsageLogCreateNestedManyWithoutPodInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type EdgeUncheckedCreateNestedManyWithoutSourcePodInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type EdgeUncheckedCreateNestedManyWithoutTargetPodInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type PodExecutionUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<PodExecutionCreateWithoutPodInput, PodExecutionUncheckedCreateWithoutPodInput> | PodExecutionCreateWithoutPodInput[] | PodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodExecutionCreateOrConnectWithoutPodInput | PodExecutionCreateOrConnectWithoutPodInput[]
    createMany?: PodExecutionCreateManyPodInputEnvelope
    connect?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
  }

  export type PodUsageLogUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type EnumPodTypeFieldUpdateOperationsInput = {
    set?: $Enums.PodType
  }

  export type EnumPodExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PodExecutionStatus
  }

  export type FlowUpdateOneRequiredWithoutPodsNestedInput = {
    create?: XOR<FlowCreateWithoutPodsInput, FlowUncheckedCreateWithoutPodsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutPodsInput
    upsert?: FlowUpsertWithoutPodsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutPodsInput, FlowUpdateWithoutPodsInput>, FlowUncheckedUpdateWithoutPodsInput>
  }

  export type FlowUpdateOneWithoutContextualPodsNestedInput = {
    create?: XOR<FlowCreateWithoutContextualPodsInput, FlowUncheckedCreateWithoutContextualPodsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutContextualPodsInput
    upsert?: FlowUpsertWithoutContextualPodsInput
    disconnect?: FlowWhereInput | boolean
    delete?: FlowWhereInput | boolean
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutContextualPodsInput, FlowUpdateWithoutContextualPodsInput>, FlowUncheckedUpdateWithoutContextualPodsInput>
  }

  export type DocumentUpdateOneWithoutPodsNestedInput = {
    create?: XOR<DocumentCreateWithoutPodsInput, DocumentUncheckedCreateWithoutPodsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPodsInput
    upsert?: DocumentUpsertWithoutPodsInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutPodsInput, DocumentUpdateWithoutPodsInput>, DocumentUncheckedUpdateWithoutPodsInput>
  }

  export type EdgeUpdateManyWithoutSourcePodNestedInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutSourcePodInput | EdgeUpsertWithWhereUniqueWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutSourcePodInput | EdgeUpdateWithWhereUniqueWithoutSourcePodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutSourcePodInput | EdgeUpdateManyWithWhereWithoutSourcePodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type EdgeUpdateManyWithoutTargetPodNestedInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutTargetPodInput | EdgeUpsertWithWhereUniqueWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutTargetPodInput | EdgeUpdateWithWhereUniqueWithoutTargetPodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutTargetPodInput | EdgeUpdateManyWithWhereWithoutTargetPodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type PodExecutionUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodExecutionCreateWithoutPodInput, PodExecutionUncheckedCreateWithoutPodInput> | PodExecutionCreateWithoutPodInput[] | PodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodExecutionCreateOrConnectWithoutPodInput | PodExecutionCreateOrConnectWithoutPodInput[]
    upsert?: PodExecutionUpsertWithWhereUniqueWithoutPodInput | PodExecutionUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodExecutionCreateManyPodInputEnvelope
    set?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    disconnect?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    delete?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    connect?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    update?: PodExecutionUpdateWithWhereUniqueWithoutPodInput | PodExecutionUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodExecutionUpdateManyWithWhereWithoutPodInput | PodExecutionUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodExecutionScalarWhereInput | PodExecutionScalarWhereInput[]
  }

  export type PodUsageLogUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutPodInput | PodUsageLogUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutPodInput | PodUsageLogUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutPodInput | PodUsageLogUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type EdgeUncheckedUpdateManyWithoutSourcePodNestedInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutSourcePodInput | EdgeUpsertWithWhereUniqueWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutSourcePodInput | EdgeUpdateWithWhereUniqueWithoutSourcePodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutSourcePodInput | EdgeUpdateManyWithWhereWithoutSourcePodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type EdgeUncheckedUpdateManyWithoutTargetPodNestedInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutTargetPodInput | EdgeUpsertWithWhereUniqueWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutTargetPodInput | EdgeUpdateWithWhereUniqueWithoutTargetPodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutTargetPodInput | EdgeUpdateManyWithWhereWithoutTargetPodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type PodExecutionUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodExecutionCreateWithoutPodInput, PodExecutionUncheckedCreateWithoutPodInput> | PodExecutionCreateWithoutPodInput[] | PodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodExecutionCreateOrConnectWithoutPodInput | PodExecutionCreateOrConnectWithoutPodInput[]
    upsert?: PodExecutionUpsertWithWhereUniqueWithoutPodInput | PodExecutionUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodExecutionCreateManyPodInputEnvelope
    set?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    disconnect?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    delete?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    connect?: PodExecutionWhereUniqueInput | PodExecutionWhereUniqueInput[]
    update?: PodExecutionUpdateWithWhereUniqueWithoutPodInput | PodExecutionUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodExecutionUpdateManyWithWhereWithoutPodInput | PodExecutionUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodExecutionScalarWhereInput | PodExecutionScalarWhereInput[]
  }

  export type PodUsageLogUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutPodInput | PodUsageLogUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutPodInput | PodUsageLogUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutPodInput | PodUsageLogUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type FlowCreateNestedOneWithoutEdgesInput = {
    create?: XOR<FlowCreateWithoutEdgesInput, FlowUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: FlowCreateOrConnectWithoutEdgesInput
    connect?: FlowWhereUniqueInput
  }

  export type PodCreateNestedOneWithoutSourceEdgesInput = {
    create?: XOR<PodCreateWithoutSourceEdgesInput, PodUncheckedCreateWithoutSourceEdgesInput>
    connectOrCreate?: PodCreateOrConnectWithoutSourceEdgesInput
    connect?: PodWhereUniqueInput
  }

  export type PodCreateNestedOneWithoutTargetEdgesInput = {
    create?: XOR<PodCreateWithoutTargetEdgesInput, PodUncheckedCreateWithoutTargetEdgesInput>
    connectOrCreate?: PodCreateOrConnectWithoutTargetEdgesInput
    connect?: PodWhereUniqueInput
  }

  export type FlowUpdateOneRequiredWithoutEdgesNestedInput = {
    create?: XOR<FlowCreateWithoutEdgesInput, FlowUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: FlowCreateOrConnectWithoutEdgesInput
    upsert?: FlowUpsertWithoutEdgesInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutEdgesInput, FlowUpdateWithoutEdgesInput>, FlowUncheckedUpdateWithoutEdgesInput>
  }

  export type PodUpdateOneRequiredWithoutSourceEdgesNestedInput = {
    create?: XOR<PodCreateWithoutSourceEdgesInput, PodUncheckedCreateWithoutSourceEdgesInput>
    connectOrCreate?: PodCreateOrConnectWithoutSourceEdgesInput
    upsert?: PodUpsertWithoutSourceEdgesInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutSourceEdgesInput, PodUpdateWithoutSourceEdgesInput>, PodUncheckedUpdateWithoutSourceEdgesInput>
  }

  export type PodUpdateOneRequiredWithoutTargetEdgesNestedInput = {
    create?: XOR<PodCreateWithoutTargetEdgesInput, PodUncheckedCreateWithoutTargetEdgesInput>
    connectOrCreate?: PodCreateOrConnectWithoutTargetEdgesInput
    upsert?: PodUpsertWithoutTargetEdgesInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutTargetEdgesInput, PodUpdateWithoutTargetEdgesInput>, PodUncheckedUpdateWithoutTargetEdgesInput>
  }

  export type PodCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<PodCreateWithoutExecutionsInput, PodUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: PodCreateOrConnectWithoutExecutionsInput
    connect?: PodWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PodUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<PodCreateWithoutExecutionsInput, PodUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: PodCreateOrConnectWithoutExecutionsInput
    upsert?: PodUpsertWithoutExecutionsInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutExecutionsInput, PodUpdateWithoutExecutionsInput>, PodUncheckedUpdateWithoutExecutionsInput>
  }

  export type PodCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<PodCreateWithoutUsageLogsInput, PodUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: PodCreateOrConnectWithoutUsageLogsInput
    connect?: PodWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageLogsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type PodUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<PodCreateWithoutUsageLogsInput, PodUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: PodCreateOrConnectWithoutUsageLogsInput
    upsert?: PodUpsertWithoutUsageLogsInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutUsageLogsInput, PodUpdateWithoutUsageLogsInput>, PodUncheckedUpdateWithoutUsageLogsInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageLogsInput
    upsert?: SubscriptionUpsertWithoutUsageLogsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUsageLogsInput, SubscriptionUpdateWithoutUsageLogsInput>, SubscriptionUncheckedUpdateWithoutUsageLogsInput>
  }

  export type WorkspaceCreateNestedOneWithoutContextModulesInput = {
    create?: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutContextModulesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type FlowCreateNestedOneWithoutContextModulesInput = {
    create?: XOR<FlowCreateWithoutContextModulesInput, FlowUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: FlowCreateOrConnectWithoutContextModulesInput
    connect?: FlowWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutContextModulesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutContextModulesInput
    upsert?: WorkspaceUpsertWithoutContextModulesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutContextModulesInput, WorkspaceUpdateWithoutContextModulesInput>, WorkspaceUncheckedUpdateWithoutContextModulesInput>
  }

  export type FlowUpdateOneWithoutContextModulesNestedInput = {
    create?: XOR<FlowCreateWithoutContextModulesInput, FlowUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: FlowCreateOrConnectWithoutContextModulesInput
    upsert?: FlowUpsertWithoutContextModulesInput
    disconnect?: FlowWhereInput | boolean
    delete?: FlowWhereInput | boolean
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutContextModulesInput, FlowUpdateWithoutContextModulesInput>, FlowUncheckedUpdateWithoutContextModulesInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type WorkspaceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type FlowCollaboratorCreateNestedManyWithoutUserInput = {
    create?: XOR<FlowCollaboratorCreateWithoutUserInput, FlowCollaboratorUncheckedCreateWithoutUserInput> | FlowCollaboratorCreateWithoutUserInput[] | FlowCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutUserInput | FlowCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: FlowCollaboratorCreateManyUserInputEnvelope
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type FlowInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<FlowInvitationCreateWithoutInviterInput, FlowInvitationUncheckedCreateWithoutInviterInput> | FlowInvitationCreateWithoutInviterInput[] | FlowInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInviterInput | FlowInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: FlowInvitationCreateManyInviterInputEnvelope
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
  }

  export type FlowInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<FlowInvitationCreateWithoutInvitedUserInput, FlowInvitationUncheckedCreateWithoutInvitedUserInput> | FlowInvitationCreateWithoutInvitedUserInput[] | FlowInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInvitedUserInput | FlowInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: FlowInvitationCreateManyInvitedUserInputEnvelope
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlowCollaboratorCreateWithoutUserInput, FlowCollaboratorUncheckedCreateWithoutUserInput> | FlowCollaboratorCreateWithoutUserInput[] | FlowCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutUserInput | FlowCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: FlowCollaboratorCreateManyUserInputEnvelope
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type FlowInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<FlowInvitationCreateWithoutInviterInput, FlowInvitationUncheckedCreateWithoutInviterInput> | FlowInvitationCreateWithoutInviterInput[] | FlowInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInviterInput | FlowInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: FlowInvitationCreateManyInviterInputEnvelope
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
  }

  export type FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<FlowInvitationCreateWithoutInvitedUserInput, FlowInvitationUncheckedCreateWithoutInvitedUserInput> | FlowInvitationCreateWithoutInvitedUserInput[] | FlowInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInvitedUserInput | FlowInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: FlowInvitationCreateManyInvitedUserInputEnvelope
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type WorkspaceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type FlowCollaboratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlowCollaboratorCreateWithoutUserInput, FlowCollaboratorUncheckedCreateWithoutUserInput> | FlowCollaboratorCreateWithoutUserInput[] | FlowCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutUserInput | FlowCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: FlowCollaboratorUpsertWithWhereUniqueWithoutUserInput | FlowCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlowCollaboratorCreateManyUserInputEnvelope
    set?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    disconnect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    delete?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    update?: FlowCollaboratorUpdateWithWhereUniqueWithoutUserInput | FlowCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlowCollaboratorUpdateManyWithWhereWithoutUserInput | FlowCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlowCollaboratorScalarWhereInput | FlowCollaboratorScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput | WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput | WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type FlowInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<FlowInvitationCreateWithoutInviterInput, FlowInvitationUncheckedCreateWithoutInviterInput> | FlowInvitationCreateWithoutInviterInput[] | FlowInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInviterInput | FlowInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: FlowInvitationUpsertWithWhereUniqueWithoutInviterInput | FlowInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: FlowInvitationCreateManyInviterInputEnvelope
    set?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    disconnect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    delete?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    update?: FlowInvitationUpdateWithWhereUniqueWithoutInviterInput | FlowInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: FlowInvitationUpdateManyWithWhereWithoutInviterInput | FlowInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
  }

  export type FlowInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<FlowInvitationCreateWithoutInvitedUserInput, FlowInvitationUncheckedCreateWithoutInvitedUserInput> | FlowInvitationCreateWithoutInvitedUserInput[] | FlowInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInvitedUserInput | FlowInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: FlowInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | FlowInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: FlowInvitationCreateManyInvitedUserInputEnvelope
    set?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    disconnect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    delete?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    update?: FlowInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | FlowInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: FlowInvitationUpdateManyWithWhereWithoutInvitedUserInput | FlowInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlowCollaboratorCreateWithoutUserInput, FlowCollaboratorUncheckedCreateWithoutUserInput> | FlowCollaboratorCreateWithoutUserInput[] | FlowCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlowCollaboratorCreateOrConnectWithoutUserInput | FlowCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: FlowCollaboratorUpsertWithWhereUniqueWithoutUserInput | FlowCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlowCollaboratorCreateManyUserInputEnvelope
    set?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    disconnect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    delete?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    connect?: FlowCollaboratorWhereUniqueInput | FlowCollaboratorWhereUniqueInput[]
    update?: FlowCollaboratorUpdateWithWhereUniqueWithoutUserInput | FlowCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlowCollaboratorUpdateManyWithWhereWithoutUserInput | FlowCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlowCollaboratorScalarWhereInput | FlowCollaboratorScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput | WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput | WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<FlowInvitationCreateWithoutInviterInput, FlowInvitationUncheckedCreateWithoutInviterInput> | FlowInvitationCreateWithoutInviterInput[] | FlowInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInviterInput | FlowInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: FlowInvitationUpsertWithWhereUniqueWithoutInviterInput | FlowInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: FlowInvitationCreateManyInviterInputEnvelope
    set?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    disconnect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    delete?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    update?: FlowInvitationUpdateWithWhereUniqueWithoutInviterInput | FlowInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: FlowInvitationUpdateManyWithWhereWithoutInviterInput | FlowInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
  }

  export type FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<FlowInvitationCreateWithoutInvitedUserInput, FlowInvitationUncheckedCreateWithoutInvitedUserInput> | FlowInvitationCreateWithoutInvitedUserInput[] | FlowInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: FlowInvitationCreateOrConnectWithoutInvitedUserInput | FlowInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: FlowInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | FlowInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: FlowInvitationCreateManyInvitedUserInputEnvelope
    set?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    disconnect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    delete?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    connect?: FlowInvitationWhereUniqueInput | FlowInvitationWhereUniqueInput[]
    update?: FlowInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | FlowInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: FlowInvitationUpdateManyWithWhereWithoutInvitedUserInput | FlowInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type WorkspaceUserCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type SpaceCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<SpaceCreateWithoutWorkspaceInput, SpaceUncheckedCreateWithoutWorkspaceInput> | SpaceCreateWithoutWorkspaceInput[] | SpaceUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutWorkspaceInput | SpaceCreateOrConnectWithoutWorkspaceInput[]
    createMany?: SpaceCreateManyWorkspaceInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type FlowCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FlowCreateWithoutWorkspaceInput, FlowUncheckedCreateWithoutWorkspaceInput> | FlowCreateWithoutWorkspaceInput[] | FlowUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutWorkspaceInput | FlowCreateOrConnectWithoutWorkspaceInput[]
    createMany?: FlowCreateManyWorkspaceInputEnvelope
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentFolderCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DocumentFolderCreateWithoutWorkspaceInput, DocumentFolderUncheckedCreateWithoutWorkspaceInput> | DocumentFolderCreateWithoutWorkspaceInput[] | DocumentFolderUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutWorkspaceInput | DocumentFolderCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DocumentFolderCreateManyWorkspaceInputEnvelope
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContextModuleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type ShareLinkCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type SpaceUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<SpaceCreateWithoutWorkspaceInput, SpaceUncheckedCreateWithoutWorkspaceInput> | SpaceCreateWithoutWorkspaceInput[] | SpaceUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutWorkspaceInput | SpaceCreateOrConnectWithoutWorkspaceInput[]
    createMany?: SpaceCreateManyWorkspaceInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type FlowUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FlowCreateWithoutWorkspaceInput, FlowUncheckedCreateWithoutWorkspaceInput> | FlowCreateWithoutWorkspaceInput[] | FlowUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutWorkspaceInput | FlowCreateOrConnectWithoutWorkspaceInput[]
    createMany?: FlowCreateManyWorkspaceInputEnvelope
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DocumentFolderCreateWithoutWorkspaceInput, DocumentFolderUncheckedCreateWithoutWorkspaceInput> | DocumentFolderCreateWithoutWorkspaceInput[] | DocumentFolderUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutWorkspaceInput | DocumentFolderCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DocumentFolderCreateManyWorkspaceInputEnvelope
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type EnumWorkspaceTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceType
  }

  export type WorkspaceUserUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type SpaceUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<SpaceCreateWithoutWorkspaceInput, SpaceUncheckedCreateWithoutWorkspaceInput> | SpaceCreateWithoutWorkspaceInput[] | SpaceUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutWorkspaceInput | SpaceCreateOrConnectWithoutWorkspaceInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutWorkspaceInput | SpaceUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: SpaceCreateManyWorkspaceInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutWorkspaceInput | SpaceUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutWorkspaceInput | SpaceUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type FlowUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FlowCreateWithoutWorkspaceInput, FlowUncheckedCreateWithoutWorkspaceInput> | FlowCreateWithoutWorkspaceInput[] | FlowUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutWorkspaceInput | FlowCreateOrConnectWithoutWorkspaceInput[]
    upsert?: FlowUpsertWithWhereUniqueWithoutWorkspaceInput | FlowUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: FlowCreateManyWorkspaceInputEnvelope
    set?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    disconnect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    delete?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    update?: FlowUpdateWithWhereUniqueWithoutWorkspaceInput | FlowUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: FlowUpdateManyWithWhereWithoutWorkspaceInput | FlowUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: FlowScalarWhereInput | FlowScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutWorkspaceInput | DocumentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutWorkspaceInput | DocumentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutWorkspaceInput | DocumentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentFolderUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DocumentFolderCreateWithoutWorkspaceInput, DocumentFolderUncheckedCreateWithoutWorkspaceInput> | DocumentFolderCreateWithoutWorkspaceInput[] | DocumentFolderUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutWorkspaceInput | DocumentFolderCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DocumentFolderUpsertWithWhereUniqueWithoutWorkspaceInput | DocumentFolderUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DocumentFolderCreateManyWorkspaceInputEnvelope
    set?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    disconnect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    delete?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    update?: DocumentFolderUpdateWithWhereUniqueWithoutWorkspaceInput | DocumentFolderUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DocumentFolderUpdateManyWithWhereWithoutWorkspaceInput | DocumentFolderUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DocumentFolderScalarWhereInput | DocumentFolderScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    upsert?: SubscriptionUpsertWithoutWorkspaceInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutWorkspaceInput, SubscriptionUpdateWithoutWorkspaceInput>, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ContextModuleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutWorkspaceInput | ContextModuleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type ShareLinkUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutWorkspaceInput | ShareLinkUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    set?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    disconnect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    delete?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    update?: ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput | ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<SpaceCreateWithoutWorkspaceInput, SpaceUncheckedCreateWithoutWorkspaceInput> | SpaceCreateWithoutWorkspaceInput[] | SpaceUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutWorkspaceInput | SpaceCreateOrConnectWithoutWorkspaceInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutWorkspaceInput | SpaceUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: SpaceCreateManyWorkspaceInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutWorkspaceInput | SpaceUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutWorkspaceInput | SpaceUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type FlowUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FlowCreateWithoutWorkspaceInput, FlowUncheckedCreateWithoutWorkspaceInput> | FlowCreateWithoutWorkspaceInput[] | FlowUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutWorkspaceInput | FlowCreateOrConnectWithoutWorkspaceInput[]
    upsert?: FlowUpsertWithWhereUniqueWithoutWorkspaceInput | FlowUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: FlowCreateManyWorkspaceInputEnvelope
    set?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    disconnect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    delete?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    update?: FlowUpdateWithWhereUniqueWithoutWorkspaceInput | FlowUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: FlowUpdateManyWithWhereWithoutWorkspaceInput | FlowUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: FlowScalarWhereInput | FlowScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutWorkspaceInput | DocumentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutWorkspaceInput | DocumentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutWorkspaceInput | DocumentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DocumentFolderCreateWithoutWorkspaceInput, DocumentFolderUncheckedCreateWithoutWorkspaceInput> | DocumentFolderCreateWithoutWorkspaceInput[] | DocumentFolderUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutWorkspaceInput | DocumentFolderCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DocumentFolderUpsertWithWhereUniqueWithoutWorkspaceInput | DocumentFolderUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DocumentFolderCreateManyWorkspaceInputEnvelope
    set?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    disconnect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    delete?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    update?: DocumentFolderUpdateWithWhereUniqueWithoutWorkspaceInput | DocumentFolderUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DocumentFolderUpdateManyWithWhereWithoutWorkspaceInput | DocumentFolderUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DocumentFolderScalarWhereInput | DocumentFolderScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    upsert?: SubscriptionUpsertWithoutWorkspaceInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutWorkspaceInput, SubscriptionUpdateWithoutWorkspaceInput>, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutWorkspaceInput | ContextModuleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutWorkspaceInput | ShareLinkUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    set?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    disconnect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    delete?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    update?: ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput | ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumWorkspaceRoleFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceRole
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    upsert?: WorkspaceUpsertWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutMembersInput, WorkspaceUpdateWithoutMembersInput>, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentWorkspaceInvitesInput = {
    create?: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentWorkspaceInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput = {
    create?: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedWorkspaceInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    upsert?: WorkspaceUpsertWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitationsInput, WorkspaceUpdateWithoutInvitationsInput>, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentWorkspaceInvitesInput
    upsert?: UserUpsertWithoutSentWorkspaceInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentWorkspaceInvitesInput, UserUpdateWithoutSentWorkspaceInvitesInput>, UserUncheckedUpdateWithoutSentWorkspaceInvitesInput>
  }

  export type UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedWorkspaceInvitesInput
    upsert?: UserUpsertWithoutReceivedWorkspaceInvitesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedWorkspaceInvitesInput, UserUpdateWithoutReceivedWorkspaceInvitesInput>, UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput>
  }

  export type WorkspaceCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApiKeysInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumAuthTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuthType
  }

  export type WorkspaceUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApiKeysInput
    upsert?: WorkspaceUpsertWithoutApiKeysInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutApiKeysInput, WorkspaceUpdateWithoutApiKeysInput>, WorkspaceUncheckedUpdateWithoutApiKeysInput>
  }

  export type WorkspaceCreateNestedOneWithoutShareLinksInput = {
    create?: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutShareLinksInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumShareableAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShareableAssetType
  }

  export type EnumShareAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.ShareAccessLevel
  }

  export type WorkspaceUpdateOneRequiredWithoutShareLinksNestedInput = {
    create?: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutShareLinksInput
    upsert?: WorkspaceUpsertWithoutShareLinksInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutShareLinksInput, WorkspaceUpdateWithoutShareLinksInput>, WorkspaceUncheckedUpdateWithoutShareLinksInput>
  }

  export type DocumentFolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<DocumentFolderCreateWithoutChildrenInput, DocumentFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutChildrenInput
    connect?: DocumentFolderWhereUniqueInput
  }

  export type DocumentFolderCreateNestedManyWithoutParentInput = {
    create?: XOR<DocumentFolderCreateWithoutParentInput, DocumentFolderUncheckedCreateWithoutParentInput> | DocumentFolderCreateWithoutParentInput[] | DocumentFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutParentInput | DocumentFolderCreateOrConnectWithoutParentInput[]
    createMany?: DocumentFolderCreateManyParentInputEnvelope
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedOneWithoutDocumentFoldersInput = {
    create?: XOR<WorkspaceCreateWithoutDocumentFoldersInput, WorkspaceUncheckedCreateWithoutDocumentFoldersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocumentFoldersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutFolderInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentFolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DocumentFolderCreateWithoutParentInput, DocumentFolderUncheckedCreateWithoutParentInput> | DocumentFolderCreateWithoutParentInput[] | DocumentFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutParentInput | DocumentFolderCreateOrConnectWithoutParentInput[]
    createMany?: DocumentFolderCreateManyParentInputEnvelope
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentFolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<DocumentFolderCreateWithoutChildrenInput, DocumentFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutChildrenInput
    upsert?: DocumentFolderUpsertWithoutChildrenInput
    disconnect?: DocumentFolderWhereInput | boolean
    delete?: DocumentFolderWhereInput | boolean
    connect?: DocumentFolderWhereUniqueInput
    update?: XOR<XOR<DocumentFolderUpdateToOneWithWhereWithoutChildrenInput, DocumentFolderUpdateWithoutChildrenInput>, DocumentFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type DocumentFolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<DocumentFolderCreateWithoutParentInput, DocumentFolderUncheckedCreateWithoutParentInput> | DocumentFolderCreateWithoutParentInput[] | DocumentFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutParentInput | DocumentFolderCreateOrConnectWithoutParentInput[]
    upsert?: DocumentFolderUpsertWithWhereUniqueWithoutParentInput | DocumentFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DocumentFolderCreateManyParentInputEnvelope
    set?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    disconnect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    delete?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    update?: DocumentFolderUpdateWithWhereUniqueWithoutParentInput | DocumentFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DocumentFolderUpdateManyWithWhereWithoutParentInput | DocumentFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DocumentFolderScalarWhereInput | DocumentFolderScalarWhereInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutDocumentFoldersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDocumentFoldersInput, WorkspaceUncheckedCreateWithoutDocumentFoldersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocumentFoldersInput
    upsert?: WorkspaceUpsertWithoutDocumentFoldersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDocumentFoldersInput, WorkspaceUpdateWithoutDocumentFoldersInput>, WorkspaceUncheckedUpdateWithoutDocumentFoldersInput>
  }

  export type DocumentUpdateManyWithoutFolderNestedInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutFolderInput | DocumentUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutFolderInput | DocumentUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutFolderInput | DocumentUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentFolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DocumentFolderCreateWithoutParentInput, DocumentFolderUncheckedCreateWithoutParentInput> | DocumentFolderCreateWithoutParentInput[] | DocumentFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutParentInput | DocumentFolderCreateOrConnectWithoutParentInput[]
    upsert?: DocumentFolderUpsertWithWhereUniqueWithoutParentInput | DocumentFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DocumentFolderCreateManyParentInputEnvelope
    set?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    disconnect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    delete?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    connect?: DocumentFolderWhereUniqueInput | DocumentFolderWhereUniqueInput[]
    update?: DocumentFolderUpdateWithWhereUniqueWithoutParentInput | DocumentFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DocumentFolderUpdateManyWithWhereWithoutParentInput | DocumentFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DocumentFolderScalarWhereInput | DocumentFolderScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutFolderInput | DocumentUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutFolderInput | DocumentUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutFolderInput | DocumentUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocumentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DocumentFolderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DocumentFolderCreateWithoutDocumentsInput, DocumentFolderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutDocumentsInput
    connect?: DocumentFolderWhereUniqueInput
  }

  export type EmbeddingCreateNestedManyWithoutDocumentInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
  }

  export type PodCreateNestedManyWithoutDocumentInput = {
    create?: XOR<PodCreateWithoutDocumentInput, PodUncheckedCreateWithoutDocumentInput> | PodCreateWithoutDocumentInput[] | PodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PodCreateOrConnectWithoutDocumentInput | PodCreateOrConnectWithoutDocumentInput[]
    createMany?: PodCreateManyDocumentInputEnvelope
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
  }

  export type DocumentProcessingCostCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutDocumentInput, DocumentProcessingCostUncheckedCreateWithoutDocumentInput> | DocumentProcessingCostCreateWithoutDocumentInput[] | DocumentProcessingCostUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutDocumentInput | DocumentProcessingCostCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentProcessingCostCreateManyDocumentInputEnvelope
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
  }

  export type EmbeddingUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
  }

  export type PodUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<PodCreateWithoutDocumentInput, PodUncheckedCreateWithoutDocumentInput> | PodCreateWithoutDocumentInput[] | PodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PodCreateOrConnectWithoutDocumentInput | PodCreateOrConnectWithoutDocumentInput[]
    createMany?: PodCreateManyDocumentInputEnvelope
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
  }

  export type DocumentProcessingCostUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutDocumentInput, DocumentProcessingCostUncheckedCreateWithoutDocumentInput> | DocumentProcessingCostCreateWithoutDocumentInput[] | DocumentProcessingCostUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutDocumentInput | DocumentProcessingCostCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentProcessingCostCreateManyDocumentInputEnvelope
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
  }

  export type EnumDocumentSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentSourceType
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocumentsInput
    upsert?: WorkspaceUpsertWithoutDocumentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDocumentsInput, WorkspaceUpdateWithoutDocumentsInput>, WorkspaceUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentFolderUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DocumentFolderCreateWithoutDocumentsInput, DocumentFolderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentFolderCreateOrConnectWithoutDocumentsInput
    upsert?: DocumentFolderUpsertWithoutDocumentsInput
    disconnect?: DocumentFolderWhereInput | boolean
    delete?: DocumentFolderWhereInput | boolean
    connect?: DocumentFolderWhereUniqueInput
    update?: XOR<XOR<DocumentFolderUpdateToOneWithWhereWithoutDocumentsInput, DocumentFolderUpdateWithoutDocumentsInput>, DocumentFolderUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmbeddingUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    upsert?: EmbeddingUpsertWithWhereUniqueWithoutDocumentInput | EmbeddingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    set?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    disconnect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    delete?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    update?: EmbeddingUpdateWithWhereUniqueWithoutDocumentInput | EmbeddingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: EmbeddingUpdateManyWithWhereWithoutDocumentInput | EmbeddingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
  }

  export type PodUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<PodCreateWithoutDocumentInput, PodUncheckedCreateWithoutDocumentInput> | PodCreateWithoutDocumentInput[] | PodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PodCreateOrConnectWithoutDocumentInput | PodCreateOrConnectWithoutDocumentInput[]
    upsert?: PodUpsertWithWhereUniqueWithoutDocumentInput | PodUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: PodCreateManyDocumentInputEnvelope
    set?: PodWhereUniqueInput | PodWhereUniqueInput[]
    disconnect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    delete?: PodWhereUniqueInput | PodWhereUniqueInput[]
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    update?: PodUpdateWithWhereUniqueWithoutDocumentInput | PodUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: PodUpdateManyWithWhereWithoutDocumentInput | PodUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: PodScalarWhereInput | PodScalarWhereInput[]
  }

  export type DocumentProcessingCostUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutDocumentInput, DocumentProcessingCostUncheckedCreateWithoutDocumentInput> | DocumentProcessingCostCreateWithoutDocumentInput[] | DocumentProcessingCostUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutDocumentInput | DocumentProcessingCostCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentProcessingCostUpsertWithWhereUniqueWithoutDocumentInput | DocumentProcessingCostUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentProcessingCostCreateManyDocumentInputEnvelope
    set?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    disconnect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    delete?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    update?: DocumentProcessingCostUpdateWithWhereUniqueWithoutDocumentInput | DocumentProcessingCostUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentProcessingCostUpdateManyWithWhereWithoutDocumentInput | DocumentProcessingCostUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentProcessingCostScalarWhereInput | DocumentProcessingCostScalarWhereInput[]
  }

  export type EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    upsert?: EmbeddingUpsertWithWhereUniqueWithoutDocumentInput | EmbeddingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    set?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    disconnect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    delete?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    update?: EmbeddingUpdateWithWhereUniqueWithoutDocumentInput | EmbeddingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: EmbeddingUpdateManyWithWhereWithoutDocumentInput | EmbeddingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
  }

  export type PodUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<PodCreateWithoutDocumentInput, PodUncheckedCreateWithoutDocumentInput> | PodCreateWithoutDocumentInput[] | PodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PodCreateOrConnectWithoutDocumentInput | PodCreateOrConnectWithoutDocumentInput[]
    upsert?: PodUpsertWithWhereUniqueWithoutDocumentInput | PodUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: PodCreateManyDocumentInputEnvelope
    set?: PodWhereUniqueInput | PodWhereUniqueInput[]
    disconnect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    delete?: PodWhereUniqueInput | PodWhereUniqueInput[]
    connect?: PodWhereUniqueInput | PodWhereUniqueInput[]
    update?: PodUpdateWithWhereUniqueWithoutDocumentInput | PodUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: PodUpdateManyWithWhereWithoutDocumentInput | PodUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: PodScalarWhereInput | PodScalarWhereInput[]
  }

  export type DocumentProcessingCostUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentProcessingCostCreateWithoutDocumentInput, DocumentProcessingCostUncheckedCreateWithoutDocumentInput> | DocumentProcessingCostCreateWithoutDocumentInput[] | DocumentProcessingCostUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentProcessingCostCreateOrConnectWithoutDocumentInput | DocumentProcessingCostCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentProcessingCostUpsertWithWhereUniqueWithoutDocumentInput | DocumentProcessingCostUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentProcessingCostCreateManyDocumentInputEnvelope
    set?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    disconnect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    delete?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    connect?: DocumentProcessingCostWhereUniqueInput | DocumentProcessingCostWhereUniqueInput[]
    update?: DocumentProcessingCostUpdateWithWhereUniqueWithoutDocumentInput | DocumentProcessingCostUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentProcessingCostUpdateManyWithWhereWithoutDocumentInput | DocumentProcessingCostUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentProcessingCostScalarWhereInput | DocumentProcessingCostScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutEmbeddingsInput = {
    create?: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutEmbeddingsInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutEmbeddingsNestedInput = {
    create?: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutEmbeddingsInput
    upsert?: DocumentUpsertWithoutEmbeddingsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutEmbeddingsInput, DocumentUpdateWithoutEmbeddingsInput>, DocumentUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type DocumentCreateNestedOneWithoutProcessingCostRecordsInput = {
    create?: XOR<DocumentCreateWithoutProcessingCostRecordsInput, DocumentUncheckedCreateWithoutProcessingCostRecordsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutProcessingCostRecordsInput
    connect?: DocumentWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutDocumentProcessingCostInput = {
    create?: XOR<SubscriptionCreateWithoutDocumentProcessingCostInput, SubscriptionUncheckedCreateWithoutDocumentProcessingCostInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutDocumentProcessingCostInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumDocumentProcessingTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentProcessingType
  }

  export type DocumentUpdateOneRequiredWithoutProcessingCostRecordsNestedInput = {
    create?: XOR<DocumentCreateWithoutProcessingCostRecordsInput, DocumentUncheckedCreateWithoutProcessingCostRecordsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutProcessingCostRecordsInput
    upsert?: DocumentUpsertWithoutProcessingCostRecordsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutProcessingCostRecordsInput, DocumentUpdateWithoutProcessingCostRecordsInput>, DocumentUncheckedUpdateWithoutProcessingCostRecordsInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutDocumentProcessingCostNestedInput = {
    create?: XOR<SubscriptionCreateWithoutDocumentProcessingCostInput, SubscriptionUncheckedCreateWithoutDocumentProcessingCostInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutDocumentProcessingCostInput
    upsert?: SubscriptionUpsertWithoutDocumentProcessingCostInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutDocumentProcessingCostInput, SubscriptionUpdateWithoutDocumentProcessingCostInput>, SubscriptionUncheckedUpdateWithoutDocumentProcessingCostInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type NestedEnumAdminResourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceFilter<$PrismaModel> | $Enums.AdminResource
  }

  export type NestedEnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type NestedEnumAdminResourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSpecificPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionFilter<$PrismaModel> | $Enums.SpecificPermission
  }

  export type NestedEnumAdminResourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableFilter<$PrismaModel> | $Enums.AdminResource | null
  }

  export type NestedEnumSpecificPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionWithAggregatesFilter<$PrismaModel> | $Enums.SpecificPermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecificPermissionFilter<$PrismaModel>
    _max?: NestedEnumSpecificPermissionFilter<$PrismaModel>
  }

  export type NestedEnumAdminResourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type NestedEnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumLLMProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderFilter<$PrismaModel> | $Enums.LLMProvider
  }

  export type NestedEnumLLMProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderWithAggregatesFilter<$PrismaModel> | $Enums.LLMProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLLMProviderFilter<$PrismaModel>
    _max?: NestedEnumLLMProviderFilter<$PrismaModel>
  }

  export type NestedEnumModelCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryFilter<$PrismaModel> | $Enums.ModelCategory
  }

  export type NestedEnumModelCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ModelCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelCategoryFilter<$PrismaModel>
    _max?: NestedEnumModelCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFlowVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowVisibility | EnumFlowVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowVisibilityFilter<$PrismaModel> | $Enums.FlowVisibility
  }

  export type NestedEnumFlowVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowVisibility | EnumFlowVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowVisibility[] | ListEnumFlowVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.FlowVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlowVisibilityFilter<$PrismaModel>
    _max?: NestedEnumFlowVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumFlowAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowAccessLevel | EnumFlowAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowAccessLevelFilter<$PrismaModel> | $Enums.FlowAccessLevel
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumFlowAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowAccessLevel | EnumFlowAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowAccessLevel[] | ListEnumFlowAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.FlowAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlowAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumFlowAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumFlowActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowActivityAction | EnumFlowActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowActivityActionFilter<$PrismaModel> | $Enums.FlowActivityAction
  }

  export type NestedEnumFlowActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowActivityAction | EnumFlowActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlowActivityAction[] | ListEnumFlowActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFlowActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.FlowActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlowActivityActionFilter<$PrismaModel>
    _max?: NestedEnumFlowActivityActionFilter<$PrismaModel>
  }

  export type NestedEnumPodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PodType | EnumPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPodTypeFilter<$PrismaModel> | $Enums.PodType
  }

  export type NestedEnumPodExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PodExecutionStatus | EnumPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPodExecutionStatusFilter<$PrismaModel> | $Enums.PodExecutionStatus
  }

  export type NestedEnumPodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PodType | EnumPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodType[] | ListEnumPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPodTypeFilter<$PrismaModel>
    _max?: NestedEnumPodTypeFilter<$PrismaModel>
  }

  export type NestedEnumPodExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PodExecutionStatus | EnumPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PodExecutionStatus[] | ListEnumPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPodExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PodExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPodExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumPodExecutionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeFilter<$PrismaModel> | $Enums.WorkspaceType
  }

  export type NestedEnumWorkspaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleFilter<$PrismaModel> | $Enums.WorkspaceRole
  }

  export type NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeFilter<$PrismaModel> | $Enums.AuthType
  }

  export type NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTypeFilter<$PrismaModel>
  }

  export type NestedEnumShareableAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeFilter<$PrismaModel> | $Enums.ShareableAssetType
  }

  export type NestedEnumShareAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelFilter<$PrismaModel> | $Enums.ShareAccessLevel
  }

  export type NestedEnumShareableAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShareableAssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
  }

  export type NestedEnumShareAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.ShareAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumShareAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumDocumentSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSourceType | EnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceTypeFilter<$PrismaModel> | $Enums.DocumentSourceType
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSourceType | EnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSourceType[] | ListEnumDocumentSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentSourceTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentProcessingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentProcessingType | EnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentProcessingTypeFilter<$PrismaModel> | $Enums.DocumentProcessingType
  }

  export type NestedEnumDocumentProcessingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentProcessingType | EnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentProcessingType[] | ListEnumDocumentProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentProcessingTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentProcessingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentProcessingTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentProcessingTypeFilter<$PrismaModel>
  }

  export type AdminSessionCreateWithoutAdminInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionUncheckedCreateWithoutAdminInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionCreateOrConnectWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionCreateManyAdminInputEnvelope = {
    data: AdminSessionCreateManyAdminInput | AdminSessionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogCreateManyAdminInputEnvelope = {
    data: AdminAuditLogCreateManyAdminInput | AdminAuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminPermissionCreateWithoutAdminInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionUncheckedCreateWithoutAdminInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionCreateOrConnectWithoutAdminInput = {
    where: AdminPermissionWhereUniqueInput
    create: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput>
  }

  export type AdminPermissionCreateManyAdminInputEnvelope = {
    data: AdminPermissionCreateManyAdminInput | AdminPermissionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAPIKeyCreateWithoutAdminInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyCreateOrConnectWithoutAdminInput = {
    where: AdminAPIKeyWhereUniqueInput
    create: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput>
  }

  export type AdminAPIKeyCreateManyAdminInputEnvelope = {
    data: AdminAPIKeyCreateManyAdminInput | AdminAPIKeyCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationCreateOrConnectWithoutInviterInput = {
    where: AdminInvitationWhereUniqueInput
    create: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput>
  }

  export type AdminInvitationCreateManyInviterInputEnvelope = {
    data: AdminInvitationCreateManyInviterInput | AdminInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type AdminSessionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    update: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    data: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminSessionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminSessionScalarWhereInput
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminSessionScalarWhereInput = {
    AND?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    OR?: AdminSessionScalarWhereInput[]
    NOT?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    token?: StringFilter<"AdminSession"> | string
    refreshToken?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableFilter<"AdminSession"> | string | null
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableFilter<"AdminSession"> | string | null
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringNullableFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    method?: StringFilter<"AdminAuditLog"> | string
    endpoint?: StringFilter<"AdminAuditLog"> | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableFilter<"AdminAuditLog">
    changesAfter?: JsonNullableFilter<"AdminAuditLog">
    status?: IntFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminPermissionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminPermissionWhereUniqueInput
    update: XOR<AdminPermissionUpdateWithoutAdminInput, AdminPermissionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput>
  }

  export type AdminPermissionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminPermissionWhereUniqueInput
    data: XOR<AdminPermissionUpdateWithoutAdminInput, AdminPermissionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminPermissionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminPermissionScalarWhereInput
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminPermissionScalarWhereInput = {
    AND?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
    OR?: AdminPermissionScalarWhereInput[]
    NOT?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
    id?: StringFilter<"AdminPermission"> | string
    adminId?: StringFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableFilter<"AdminPermission"> | Date | string | null
  }

  export type AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAPIKeyWhereUniqueInput
    update: XOR<AdminAPIKeyUpdateWithoutAdminInput, AdminAPIKeyUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput>
  }

  export type AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAPIKeyWhereUniqueInput
    data: XOR<AdminAPIKeyUpdateWithoutAdminInput, AdminAPIKeyUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAPIKeyUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAPIKeyScalarWhereInput
    data: XOR<AdminAPIKeyUpdateManyMutationInput, AdminAPIKeyUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAPIKeyScalarWhereInput = {
    AND?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
    OR?: AdminAPIKeyScalarWhereInput[]
    NOT?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
    id?: StringFilter<"AdminAPIKey"> | string
    adminId?: StringFilter<"AdminAPIKey"> | string
    name?: StringFilter<"AdminAPIKey"> | string
    keyHash?: StringFilter<"AdminAPIKey"> | string
    keyPrefix?: StringFilter<"AdminAPIKey"> | string
    scopes?: JsonFilter<"AdminAPIKey">
    rateLimit?: IntNullableFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableFilter<"AdminAPIKey">
    createdAt?: DateTimeFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
  }

  export type AdminInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: AdminInvitationWhereUniqueInput
    update: XOR<AdminInvitationUpdateWithoutInviterInput, AdminInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput>
  }

  export type AdminInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: AdminInvitationWhereUniqueInput
    data: XOR<AdminInvitationUpdateWithoutInviterInput, AdminInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type AdminInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: AdminInvitationScalarWhereInput
    data: XOR<AdminInvitationUpdateManyMutationInput, AdminInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type AdminInvitationScalarWhereInput = {
    AND?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
    OR?: AdminInvitationScalarWhereInput[]
    NOT?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
    id?: StringFilter<"AdminInvitation"> | string
    email?: StringFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleFilter<"AdminInvitation"> | $Enums.AdminRole
    token?: StringFilter<"AdminInvitation"> | string
    invitedBy?: StringFilter<"AdminInvitation"> | string
    createdAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"AdminInvitation"> | Date | string | null
  }

  export type AdminCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutSessionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
  }

  export type AdminUpsertWithoutSessionsInput = {
    update: XOR<AdminUpdateWithoutSessionsInput, AdminUncheckedUpdateWithoutSessionsInput>
    create: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSessionsInput, AdminUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutAuditLogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
  }

  export type AdminUpsertWithoutAuditLogsInput = {
    update: XOR<AdminUpdateWithoutAuditLogsInput, AdminUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuditLogsInput, AdminUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutPermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutPermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutPermissionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
  }

  export type AdminUpsertWithoutPermissionsInput = {
    update: XOR<AdminUpdateWithoutPermissionsInput, AdminUncheckedUpdateWithoutPermissionsInput>
    create: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutPermissionsInput, AdminUncheckedUpdateWithoutPermissionsInput>
  }

  export type AdminUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutApiKeysInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
  }

  export type AdminUpsertWithoutApiKeysInput = {
    update: XOR<AdminUpdateWithoutApiKeysInput, AdminUncheckedUpdateWithoutApiKeysInput>
    create: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutApiKeysInput, AdminUncheckedUpdateWithoutApiKeysInput>
  }

  export type AdminUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutInvitationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutInvitationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutInvitationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
  }

  export type AdminUpsertWithoutInvitationsInput = {
    update: XOR<AdminUpdateWithoutInvitationsInput, AdminUncheckedUpdateWithoutInvitationsInput>
    create: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutInvitationsInput, AdminUncheckedUpdateWithoutInvitationsInput>
  }

  export type AdminUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type WorkspaceCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSubscriptionInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
  }

  export type PodUsageLogCreateWithoutSubscriptionInput = {
    id?: string
    executionId: string
    flowId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
    pod: PodCreateNestedOneWithoutUsageLogsInput
  }

  export type PodUsageLogUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    podId: string
    executionId: string
    flowId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogCreateOrConnectWithoutSubscriptionInput = {
    where: PodUsageLogWhereUniqueInput
    create: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type PodUsageLogCreateManySubscriptionInputEnvelope = {
    data: PodUsageLogCreateManySubscriptionInput | PodUsageLogCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CreditPurchaseCreateWithoutSubscriptionInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseCreateOrConnectWithoutSubscriptionInput = {
    where: CreditPurchaseWhereUniqueInput
    create: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditPurchaseCreateManySubscriptionInputEnvelope = {
    data: CreditPurchaseCreateManySubscriptionInput | CreditPurchaseCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CreditUsageLogCreateWithoutSubscriptionInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogCreateOrConnectWithoutSubscriptionInput = {
    where: CreditUsageLogWhereUniqueInput
    create: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditUsageLogCreateManySubscriptionInputEnvelope = {
    data: CreditUsageLogCreateManySubscriptionInput | CreditUsageLogCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type DocumentProcessingCostCreateWithoutSubscriptionInput = {
    id?: string
    workspaceId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
    document: DocumentCreateNestedOneWithoutProcessingCostRecordsInput
  }

  export type DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    documentId: string
    workspaceId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
  }

  export type DocumentProcessingCostCreateOrConnectWithoutSubscriptionInput = {
    where: DocumentProcessingCostWhereUniqueInput
    create: XOR<DocumentProcessingCostCreateWithoutSubscriptionInput, DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput>
  }

  export type DocumentProcessingCostCreateManySubscriptionInputEnvelope = {
    data: DocumentProcessingCostCreateManySubscriptionInput | DocumentProcessingCostCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutSubscriptionInput = {
    update: XOR<WorkspaceUpdateWithoutSubscriptionInput, WorkspaceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSubscriptionInput, WorkspaceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type WorkspaceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PodUsageLogWhereUniqueInput
    update: XOR<PodUsageLogUpdateWithoutSubscriptionInput, PodUsageLogUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PodUsageLogWhereUniqueInput
    data: XOR<PodUsageLogUpdateWithoutSubscriptionInput, PodUsageLogUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PodUsageLogScalarWhereInput
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PodUsageLogScalarWhereInput = {
    AND?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
    OR?: PodUsageLogScalarWhereInput[]
    NOT?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
    id?: StringFilter<"PodUsageLog"> | string
    podId?: StringFilter<"PodUsageLog"> | string
    executionId?: StringFilter<"PodUsageLog"> | string
    flowId?: StringFilter<"PodUsageLog"> | string
    workspaceId?: StringFilter<"PodUsageLog"> | string
    subscriptionId?: StringFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodUsageLog"> | string
    modelName?: StringNullableFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableFilter<"PodUsageLog">
    inputTokens?: IntFilter<"PodUsageLog"> | number
    outputTokens?: IntFilter<"PodUsageLog"> | number
    reasoningTokens?: IntFilter<"PodUsageLog"> | number
    creditsConsumed?: IntFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFilter<"PodUsageLog"> | Date | string
  }

  export type CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditPurchaseWhereUniqueInput
    update: XOR<CreditPurchaseUpdateWithoutSubscriptionInput, CreditPurchaseUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditPurchaseWhereUniqueInput
    data: XOR<CreditPurchaseUpdateWithoutSubscriptionInput, CreditPurchaseUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput = {
    where: CreditPurchaseScalarWhereInput
    data: XOR<CreditPurchaseUpdateManyMutationInput, CreditPurchaseUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type CreditPurchaseScalarWhereInput = {
    AND?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
    OR?: CreditPurchaseScalarWhereInput[]
    NOT?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
    id?: StringFilter<"CreditPurchase"> | string
    subscriptionId?: StringFilter<"CreditPurchase"> | string
    creditsPurchased?: IntFilter<"CreditPurchase"> | number
    amountPaid?: DecimalFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"CreditPurchase"> | string
    stripeChargeId?: StringFilter<"CreditPurchase"> | string
    status?: StringFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeFilter<"CreditPurchase"> | Date | string
  }

  export type CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditUsageLogWhereUniqueInput
    update: XOR<CreditUsageLogUpdateWithoutSubscriptionInput, CreditUsageLogUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditUsageLogWhereUniqueInput
    data: XOR<CreditUsageLogUpdateWithoutSubscriptionInput, CreditUsageLogUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput = {
    where: CreditUsageLogScalarWhereInput
    data: XOR<CreditUsageLogUpdateManyMutationInput, CreditUsageLogUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type CreditUsageLogScalarWhereInput = {
    AND?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
    OR?: CreditUsageLogScalarWhereInput[]
    NOT?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
    id?: StringFilter<"CreditUsageLog"> | string
    subscriptionId?: StringFilter<"CreditUsageLog"> | string
    workspaceId?: StringFilter<"CreditUsageLog"> | string
    canvasId?: StringFilter<"CreditUsageLog"> | string
    podId?: StringFilter<"CreditUsageLog"> | string
    executionId?: StringFilter<"CreditUsageLog"> | string
    creditsUsed?: IntFilter<"CreditUsageLog"> | number
    balanceBefore?: IntFilter<"CreditUsageLog"> | number
    balanceAfter?: IntFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"CreditUsageLog"> | string
    modelName?: StringNullableFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeFilter<"CreditUsageLog"> | Date | string
  }

  export type DocumentProcessingCostUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: DocumentProcessingCostWhereUniqueInput
    update: XOR<DocumentProcessingCostUpdateWithoutSubscriptionInput, DocumentProcessingCostUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<DocumentProcessingCostCreateWithoutSubscriptionInput, DocumentProcessingCostUncheckedCreateWithoutSubscriptionInput>
  }

  export type DocumentProcessingCostUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: DocumentProcessingCostWhereUniqueInput
    data: XOR<DocumentProcessingCostUpdateWithoutSubscriptionInput, DocumentProcessingCostUncheckedUpdateWithoutSubscriptionInput>
  }

  export type DocumentProcessingCostUpdateManyWithWhereWithoutSubscriptionInput = {
    where: DocumentProcessingCostScalarWhereInput
    data: XOR<DocumentProcessingCostUpdateManyMutationInput, DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type DocumentProcessingCostScalarWhereInput = {
    AND?: DocumentProcessingCostScalarWhereInput | DocumentProcessingCostScalarWhereInput[]
    OR?: DocumentProcessingCostScalarWhereInput[]
    NOT?: DocumentProcessingCostScalarWhereInput | DocumentProcessingCostScalarWhereInput[]
    id?: StringFilter<"DocumentProcessingCost"> | string
    documentId?: StringFilter<"DocumentProcessingCost"> | string
    workspaceId?: StringFilter<"DocumentProcessingCost"> | string
    subscriptionId?: StringFilter<"DocumentProcessingCost"> | string
    processingType?: EnumDocumentProcessingTypeFilter<"DocumentProcessingCost"> | $Enums.DocumentProcessingType
    creditsConsumed?: IntFilter<"DocumentProcessingCost"> | number
    extractionCost?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"DocumentProcessingCost"> | Decimal | DecimalJsLike | number | string
    chunkCount?: IntNullableFilter<"DocumentProcessingCost"> | number | null
    embeddingModel?: StringNullableFilter<"DocumentProcessingCost"> | string | null
    processingTimeMs?: IntNullableFilter<"DocumentProcessingCost"> | number | null
    tokensProcessed?: IntFilter<"DocumentProcessingCost"> | number
    processedAt?: DateTimeFilter<"DocumentProcessingCost"> | Date | string
  }

  export type SubscriptionCreateWithoutCreditPurchasesInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCreditPurchasesInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCreditPurchasesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
  }

  export type SubscriptionUpsertWithoutCreditPurchasesInput = {
    update: XOR<SubscriptionUpdateWithoutCreditPurchasesInput, SubscriptionUncheckedUpdateWithoutCreditPurchasesInput>
    create: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutCreditPurchasesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutCreditPurchasesInput, SubscriptionUncheckedUpdateWithoutCreditPurchasesInput>
  }

  export type SubscriptionUpdateWithoutCreditPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCreditPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateWithoutCreditUsageInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCreditUsageInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCreditUsageInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
  }

  export type SubscriptionUpsertWithoutCreditUsageInput = {
    update: XOR<SubscriptionUpdateWithoutCreditUsageInput, SubscriptionUncheckedUpdateWithoutCreditUsageInput>
    create: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutCreditUsageInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutCreditUsageInput, SubscriptionUncheckedUpdateWithoutCreditUsageInput>
  }

  export type SubscriptionUpdateWithoutCreditUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCreditUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceCreateWithoutSpacesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSpacesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSpacesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSpacesInput, WorkspaceUncheckedCreateWithoutSpacesInput>
  }

  export type FlowCreateWithoutSpaceInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutSpaceInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutSpaceInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutSpaceInput, FlowUncheckedCreateWithoutSpaceInput>
  }

  export type FlowCreateManySpaceInputEnvelope = {
    data: FlowCreateManySpaceInput | FlowCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutSpacesInput = {
    update: XOR<WorkspaceUpdateWithoutSpacesInput, WorkspaceUncheckedUpdateWithoutSpacesInput>
    create: XOR<WorkspaceCreateWithoutSpacesInput, WorkspaceUncheckedCreateWithoutSpacesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSpacesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSpacesInput, WorkspaceUncheckedUpdateWithoutSpacesInput>
  }

  export type WorkspaceUpdateWithoutSpacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSpacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type FlowUpsertWithWhereUniqueWithoutSpaceInput = {
    where: FlowWhereUniqueInput
    update: XOR<FlowUpdateWithoutSpaceInput, FlowUncheckedUpdateWithoutSpaceInput>
    create: XOR<FlowCreateWithoutSpaceInput, FlowUncheckedCreateWithoutSpaceInput>
  }

  export type FlowUpdateWithWhereUniqueWithoutSpaceInput = {
    where: FlowWhereUniqueInput
    data: XOR<FlowUpdateWithoutSpaceInput, FlowUncheckedUpdateWithoutSpaceInput>
  }

  export type FlowUpdateManyWithWhereWithoutSpaceInput = {
    where: FlowScalarWhereInput
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyWithoutSpaceInput>
  }

  export type FlowScalarWhereInput = {
    AND?: FlowScalarWhereInput | FlowScalarWhereInput[]
    OR?: FlowScalarWhereInput[]
    NOT?: FlowScalarWhereInput | FlowScalarWhereInput[]
    id?: StringFilter<"Flow"> | string
    workspaceId?: StringFilter<"Flow"> | string
    spaceId?: StringNullableFilter<"Flow"> | string | null
    name?: StringFilter<"Flow"> | string
    description?: StringNullableFilter<"Flow"> | string | null
    version?: IntFilter<"Flow"> | number
    visibility?: EnumFlowVisibilityFilter<"Flow"> | $Enums.FlowVisibility
    createdBy?: StringFilter<"Flow"> | string
    thumbnailS3Key?: StringNullableFilter<"Flow"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableFilter<"Flow"> | Date | string | null
    createdAt?: DateTimeFilter<"Flow"> | Date | string
    updatedAt?: DateTimeFilter<"Flow"> | Date | string
  }

  export type WorkspaceCreateWithoutFlowsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutFlowsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutFlowsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFlowsInput, WorkspaceUncheckedCreateWithoutFlowsInput>
  }

  export type SpaceCreateWithoutFlowsInput = {
    id?: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSpacesInput
  }

  export type SpaceUncheckedCreateWithoutFlowsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaceCreateOrConnectWithoutFlowsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutFlowsInput, SpaceUncheckedCreateWithoutFlowsInput>
  }

  export type PodCreateWithoutFlowInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutFlowInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutFlowInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutFlowInput, PodUncheckedCreateWithoutFlowInput>
  }

  export type PodCreateManyFlowInputEnvelope = {
    data: PodCreateManyFlowInput | PodCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type EdgeCreateWithoutFlowInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    sourcePod: PodCreateNestedOneWithoutSourceEdgesInput
    targetPod: PodCreateNestedOneWithoutTargetEdgesInput
  }

  export type EdgeUncheckedCreateWithoutFlowInput = {
    id?: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateOrConnectWithoutFlowInput = {
    where: EdgeWhereUniqueInput
    create: XOR<EdgeCreateWithoutFlowInput, EdgeUncheckedCreateWithoutFlowInput>
  }

  export type EdgeCreateManyFlowInputEnvelope = {
    data: EdgeCreateManyFlowInput | EdgeCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type PodCreateWithoutContextFlowInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutContextFlowInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutContextFlowInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutContextFlowInput, PodUncheckedCreateWithoutContextFlowInput>
  }

  export type PodCreateManyContextFlowInputEnvelope = {
    data: PodCreateManyContextFlowInput | PodCreateManyContextFlowInput[]
    skipDuplicates?: boolean
  }

  export type ContextModuleCreateWithoutOriginalFlowInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutContextModulesInput
  }

  export type ContextModuleUncheckedCreateWithoutOriginalFlowInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateOrConnectWithoutOriginalFlowInput = {
    where: ContextModuleWhereUniqueInput
    create: XOR<ContextModuleCreateWithoutOriginalFlowInput, ContextModuleUncheckedCreateWithoutOriginalFlowInput>
  }

  export type ContextModuleCreateManyOriginalFlowInputEnvelope = {
    data: ContextModuleCreateManyOriginalFlowInput | ContextModuleCreateManyOriginalFlowInput[]
    skipDuplicates?: boolean
  }

  export type FlowCollaboratorCreateWithoutFlowInput = {
    id?: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFlowCollaborationsInput
  }

  export type FlowCollaboratorUncheckedCreateWithoutFlowInput = {
    id?: string
    userId: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type FlowCollaboratorCreateOrConnectWithoutFlowInput = {
    where: FlowCollaboratorWhereUniqueInput
    create: XOR<FlowCollaboratorCreateWithoutFlowInput, FlowCollaboratorUncheckedCreateWithoutFlowInput>
  }

  export type FlowCollaboratorCreateManyFlowInputEnvelope = {
    data: FlowCollaboratorCreateManyFlowInput | FlowCollaboratorCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type FlowInvitationCreateWithoutFlowInput = {
    id?: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    inviter: UserCreateNestedOneWithoutSentFlowInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedFlowInvitesInput
  }

  export type FlowInvitationUncheckedCreateWithoutFlowInput = {
    id?: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationCreateOrConnectWithoutFlowInput = {
    where: FlowInvitationWhereUniqueInput
    create: XOR<FlowInvitationCreateWithoutFlowInput, FlowInvitationUncheckedCreateWithoutFlowInput>
  }

  export type FlowInvitationCreateManyFlowInputEnvelope = {
    data: FlowInvitationCreateManyFlowInput | FlowInvitationCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type FlowSessionCreateWithoutFlowInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type FlowSessionUncheckedCreateWithoutFlowInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type FlowSessionCreateOrConnectWithoutFlowInput = {
    where: FlowSessionWhereUniqueInput
    create: XOR<FlowSessionCreateWithoutFlowInput, FlowSessionUncheckedCreateWithoutFlowInput>
  }

  export type FlowSessionCreateManyFlowInputEnvelope = {
    data: FlowSessionCreateManyFlowInput | FlowSessionCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type FlowActivityLogCreateWithoutFlowInput = {
    id?: string
    userId?: string | null
    action: $Enums.FlowActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlowActivityLogUncheckedCreateWithoutFlowInput = {
    id?: string
    userId?: string | null
    action: $Enums.FlowActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlowActivityLogCreateOrConnectWithoutFlowInput = {
    where: FlowActivityLogWhereUniqueInput
    create: XOR<FlowActivityLogCreateWithoutFlowInput, FlowActivityLogUncheckedCreateWithoutFlowInput>
  }

  export type FlowActivityLogCreateManyFlowInputEnvelope = {
    data: FlowActivityLogCreateManyFlowInput | FlowActivityLogCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type FlowCommentCreateWithoutFlowInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCommentUncheckedCreateWithoutFlowInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCommentCreateOrConnectWithoutFlowInput = {
    where: FlowCommentWhereUniqueInput
    create: XOR<FlowCommentCreateWithoutFlowInput, FlowCommentUncheckedCreateWithoutFlowInput>
  }

  export type FlowCommentCreateManyFlowInputEnvelope = {
    data: FlowCommentCreateManyFlowInput | FlowCommentCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutFlowsInput = {
    update: XOR<WorkspaceUpdateWithoutFlowsInput, WorkspaceUncheckedUpdateWithoutFlowsInput>
    create: XOR<WorkspaceCreateWithoutFlowsInput, WorkspaceUncheckedCreateWithoutFlowsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutFlowsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutFlowsInput, WorkspaceUncheckedUpdateWithoutFlowsInput>
  }

  export type WorkspaceUpdateWithoutFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type SpaceUpsertWithoutFlowsInput = {
    update: XOR<SpaceUpdateWithoutFlowsInput, SpaceUncheckedUpdateWithoutFlowsInput>
    create: XOR<SpaceCreateWithoutFlowsInput, SpaceUncheckedCreateWithoutFlowsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutFlowsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutFlowsInput, SpaceUncheckedUpdateWithoutFlowsInput>
  }

  export type SpaceUpdateWithoutFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSpacesNestedInput
  }

  export type SpaceUncheckedUpdateWithoutFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUpsertWithWhereUniqueWithoutFlowInput = {
    where: PodWhereUniqueInput
    update: XOR<PodUpdateWithoutFlowInput, PodUncheckedUpdateWithoutFlowInput>
    create: XOR<PodCreateWithoutFlowInput, PodUncheckedCreateWithoutFlowInput>
  }

  export type PodUpdateWithWhereUniqueWithoutFlowInput = {
    where: PodWhereUniqueInput
    data: XOR<PodUpdateWithoutFlowInput, PodUncheckedUpdateWithoutFlowInput>
  }

  export type PodUpdateManyWithWhereWithoutFlowInput = {
    where: PodScalarWhereInput
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyWithoutFlowInput>
  }

  export type PodScalarWhereInput = {
    AND?: PodScalarWhereInput | PodScalarWhereInput[]
    OR?: PodScalarWhereInput[]
    NOT?: PodScalarWhereInput | PodScalarWhereInput[]
    id?: StringFilter<"Pod"> | string
    flowId?: StringFilter<"Pod"> | string
    type?: EnumPodTypeFilter<"Pod"> | $Enums.PodType
    position?: JsonFilter<"Pod">
    executionStatus?: EnumPodExecutionStatusFilter<"Pod"> | $Enums.PodExecutionStatus
    lastExecutionId?: StringNullableFilter<"Pod"> | string | null
    contextFlowId?: StringNullableFilter<"Pod"> | string | null
    documentId?: StringNullableFilter<"Pod"> | string | null
    lockedBy?: StringNullableFilter<"Pod"> | string | null
    lockedAt?: DateTimeNullableFilter<"Pod"> | Date | string | null
    dynamoPartitionKey?: StringFilter<"Pod"> | string
    dynamoSortKey?: StringFilter<"Pod"> | string
    s3VectorBucket?: StringNullableFilter<"Pod"> | string | null
    s3VectorKey?: StringNullableFilter<"Pod"> | string | null
    createdAt?: DateTimeFilter<"Pod"> | Date | string
    updatedAt?: DateTimeFilter<"Pod"> | Date | string
  }

  export type EdgeUpsertWithWhereUniqueWithoutFlowInput = {
    where: EdgeWhereUniqueInput
    update: XOR<EdgeUpdateWithoutFlowInput, EdgeUncheckedUpdateWithoutFlowInput>
    create: XOR<EdgeCreateWithoutFlowInput, EdgeUncheckedCreateWithoutFlowInput>
  }

  export type EdgeUpdateWithWhereUniqueWithoutFlowInput = {
    where: EdgeWhereUniqueInput
    data: XOR<EdgeUpdateWithoutFlowInput, EdgeUncheckedUpdateWithoutFlowInput>
  }

  export type EdgeUpdateManyWithWhereWithoutFlowInput = {
    where: EdgeScalarWhereInput
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutFlowInput>
  }

  export type EdgeScalarWhereInput = {
    AND?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
    OR?: EdgeScalarWhereInput[]
    NOT?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
    id?: StringFilter<"Edge"> | string
    flowId?: StringFilter<"Edge"> | string
    sourcePodId?: StringFilter<"Edge"> | string
    targetPodId?: StringFilter<"Edge"> | string
    sourceHandle?: StringNullableFilter<"Edge"> | string | null
    targetHandle?: StringNullableFilter<"Edge"> | string | null
    animated?: BoolFilter<"Edge"> | boolean
    createdAt?: DateTimeFilter<"Edge"> | Date | string
  }

  export type PodUpsertWithWhereUniqueWithoutContextFlowInput = {
    where: PodWhereUniqueInput
    update: XOR<PodUpdateWithoutContextFlowInput, PodUncheckedUpdateWithoutContextFlowInput>
    create: XOR<PodCreateWithoutContextFlowInput, PodUncheckedCreateWithoutContextFlowInput>
  }

  export type PodUpdateWithWhereUniqueWithoutContextFlowInput = {
    where: PodWhereUniqueInput
    data: XOR<PodUpdateWithoutContextFlowInput, PodUncheckedUpdateWithoutContextFlowInput>
  }

  export type PodUpdateManyWithWhereWithoutContextFlowInput = {
    where: PodScalarWhereInput
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyWithoutContextFlowInput>
  }

  export type ContextModuleUpsertWithWhereUniqueWithoutOriginalFlowInput = {
    where: ContextModuleWhereUniqueInput
    update: XOR<ContextModuleUpdateWithoutOriginalFlowInput, ContextModuleUncheckedUpdateWithoutOriginalFlowInput>
    create: XOR<ContextModuleCreateWithoutOriginalFlowInput, ContextModuleUncheckedCreateWithoutOriginalFlowInput>
  }

  export type ContextModuleUpdateWithWhereUniqueWithoutOriginalFlowInput = {
    where: ContextModuleWhereUniqueInput
    data: XOR<ContextModuleUpdateWithoutOriginalFlowInput, ContextModuleUncheckedUpdateWithoutOriginalFlowInput>
  }

  export type ContextModuleUpdateManyWithWhereWithoutOriginalFlowInput = {
    where: ContextModuleScalarWhereInput
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyWithoutOriginalFlowInput>
  }

  export type ContextModuleScalarWhereInput = {
    AND?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
    OR?: ContextModuleScalarWhereInput[]
    NOT?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
    id?: StringFilter<"ContextModule"> | string
    workspaceId?: StringFilter<"ContextModule"> | string
    name?: StringFilter<"ContextModule"> | string
    description?: StringNullableFilter<"ContextModule"> | string | null
    definitionJson?: JsonFilter<"ContextModule">
    originalFlowId?: StringNullableFilter<"ContextModule"> | string | null
    version?: IntFilter<"ContextModule"> | number
    createdAt?: DateTimeFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeFilter<"ContextModule"> | Date | string
  }

  export type FlowCollaboratorUpsertWithWhereUniqueWithoutFlowInput = {
    where: FlowCollaboratorWhereUniqueInput
    update: XOR<FlowCollaboratorUpdateWithoutFlowInput, FlowCollaboratorUncheckedUpdateWithoutFlowInput>
    create: XOR<FlowCollaboratorCreateWithoutFlowInput, FlowCollaboratorUncheckedCreateWithoutFlowInput>
  }

  export type FlowCollaboratorUpdateWithWhereUniqueWithoutFlowInput = {
    where: FlowCollaboratorWhereUniqueInput
    data: XOR<FlowCollaboratorUpdateWithoutFlowInput, FlowCollaboratorUncheckedUpdateWithoutFlowInput>
  }

  export type FlowCollaboratorUpdateManyWithWhereWithoutFlowInput = {
    where: FlowCollaboratorScalarWhereInput
    data: XOR<FlowCollaboratorUpdateManyMutationInput, FlowCollaboratorUncheckedUpdateManyWithoutFlowInput>
  }

  export type FlowCollaboratorScalarWhereInput = {
    AND?: FlowCollaboratorScalarWhereInput | FlowCollaboratorScalarWhereInput[]
    OR?: FlowCollaboratorScalarWhereInput[]
    NOT?: FlowCollaboratorScalarWhereInput | FlowCollaboratorScalarWhereInput[]
    id?: StringFilter<"FlowCollaborator"> | string
    flowId?: StringFilter<"FlowCollaborator"> | string
    userId?: StringFilter<"FlowCollaborator"> | string
    accessLevel?: EnumFlowAccessLevelFilter<"FlowCollaborator"> | $Enums.FlowAccessLevel
    canEdit?: BoolFilter<"FlowCollaborator"> | boolean
    canExecute?: BoolFilter<"FlowCollaborator"> | boolean
    canDelete?: BoolFilter<"FlowCollaborator"> | boolean
    canShare?: BoolFilter<"FlowCollaborator"> | boolean
    canInvite?: BoolFilter<"FlowCollaborator"> | boolean
    invitedBy?: StringNullableFilter<"FlowCollaborator"> | string | null
    invitedAt?: DateTimeFilter<"FlowCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"FlowCollaborator"> | Date | string | null
  }

  export type FlowInvitationUpsertWithWhereUniqueWithoutFlowInput = {
    where: FlowInvitationWhereUniqueInput
    update: XOR<FlowInvitationUpdateWithoutFlowInput, FlowInvitationUncheckedUpdateWithoutFlowInput>
    create: XOR<FlowInvitationCreateWithoutFlowInput, FlowInvitationUncheckedCreateWithoutFlowInput>
  }

  export type FlowInvitationUpdateWithWhereUniqueWithoutFlowInput = {
    where: FlowInvitationWhereUniqueInput
    data: XOR<FlowInvitationUpdateWithoutFlowInput, FlowInvitationUncheckedUpdateWithoutFlowInput>
  }

  export type FlowInvitationUpdateManyWithWhereWithoutFlowInput = {
    where: FlowInvitationScalarWhereInput
    data: XOR<FlowInvitationUpdateManyMutationInput, FlowInvitationUncheckedUpdateManyWithoutFlowInput>
  }

  export type FlowInvitationScalarWhereInput = {
    AND?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
    OR?: FlowInvitationScalarWhereInput[]
    NOT?: FlowInvitationScalarWhereInput | FlowInvitationScalarWhereInput[]
    id?: StringFilter<"FlowInvitation"> | string
    flowId?: StringFilter<"FlowInvitation"> | string
    email?: StringFilter<"FlowInvitation"> | string
    accessLevel?: EnumFlowAccessLevelFilter<"FlowInvitation"> | $Enums.FlowAccessLevel
    permissions?: JsonNullableFilter<"FlowInvitation">
    invitedBy?: StringFilter<"FlowInvitation"> | string
    invitedUserId?: StringNullableFilter<"FlowInvitation"> | string | null
    token?: StringFilter<"FlowInvitation"> | string
    status?: EnumInvitationStatusFilter<"FlowInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"FlowInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"FlowInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"FlowInvitation"> | Date | string | null
  }

  export type FlowSessionUpsertWithWhereUniqueWithoutFlowInput = {
    where: FlowSessionWhereUniqueInput
    update: XOR<FlowSessionUpdateWithoutFlowInput, FlowSessionUncheckedUpdateWithoutFlowInput>
    create: XOR<FlowSessionCreateWithoutFlowInput, FlowSessionUncheckedCreateWithoutFlowInput>
  }

  export type FlowSessionUpdateWithWhereUniqueWithoutFlowInput = {
    where: FlowSessionWhereUniqueInput
    data: XOR<FlowSessionUpdateWithoutFlowInput, FlowSessionUncheckedUpdateWithoutFlowInput>
  }

  export type FlowSessionUpdateManyWithWhereWithoutFlowInput = {
    where: FlowSessionScalarWhereInput
    data: XOR<FlowSessionUpdateManyMutationInput, FlowSessionUncheckedUpdateManyWithoutFlowInput>
  }

  export type FlowSessionScalarWhereInput = {
    AND?: FlowSessionScalarWhereInput | FlowSessionScalarWhereInput[]
    OR?: FlowSessionScalarWhereInput[]
    NOT?: FlowSessionScalarWhereInput | FlowSessionScalarWhereInput[]
    id?: StringFilter<"FlowSession"> | string
    flowId?: StringFilter<"FlowSession"> | string
    userId?: StringNullableFilter<"FlowSession"> | string | null
    anonymousName?: StringNullableFilter<"FlowSession"> | string | null
    sessionToken?: StringNullableFilter<"FlowSession"> | string | null
    socketId?: StringNullableFilter<"FlowSession"> | string | null
    cursorPosition?: JsonNullableFilter<"FlowSession">
    selectedPodIds?: JsonNullableFilter<"FlowSession">
    viewportState?: JsonNullableFilter<"FlowSession">
    userColor?: StringNullableFilter<"FlowSession"> | string | null
    userAgent?: StringNullableFilter<"FlowSession"> | string | null
    ipAddress?: StringNullableFilter<"FlowSession"> | string | null
    connectedAt?: DateTimeFilter<"FlowSession"> | Date | string
    lastHeartbeatAt?: DateTimeFilter<"FlowSession"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"FlowSession"> | Date | string | null
  }

  export type FlowActivityLogUpsertWithWhereUniqueWithoutFlowInput = {
    where: FlowActivityLogWhereUniqueInput
    update: XOR<FlowActivityLogUpdateWithoutFlowInput, FlowActivityLogUncheckedUpdateWithoutFlowInput>
    create: XOR<FlowActivityLogCreateWithoutFlowInput, FlowActivityLogUncheckedCreateWithoutFlowInput>
  }

  export type FlowActivityLogUpdateWithWhereUniqueWithoutFlowInput = {
    where: FlowActivityLogWhereUniqueInput
    data: XOR<FlowActivityLogUpdateWithoutFlowInput, FlowActivityLogUncheckedUpdateWithoutFlowInput>
  }

  export type FlowActivityLogUpdateManyWithWhereWithoutFlowInput = {
    where: FlowActivityLogScalarWhereInput
    data: XOR<FlowActivityLogUpdateManyMutationInput, FlowActivityLogUncheckedUpdateManyWithoutFlowInput>
  }

  export type FlowActivityLogScalarWhereInput = {
    AND?: FlowActivityLogScalarWhereInput | FlowActivityLogScalarWhereInput[]
    OR?: FlowActivityLogScalarWhereInput[]
    NOT?: FlowActivityLogScalarWhereInput | FlowActivityLogScalarWhereInput[]
    id?: StringFilter<"FlowActivityLog"> | string
    flowId?: StringFilter<"FlowActivityLog"> | string
    userId?: StringNullableFilter<"FlowActivityLog"> | string | null
    action?: EnumFlowActivityActionFilter<"FlowActivityLog"> | $Enums.FlowActivityAction
    entityType?: StringNullableFilter<"FlowActivityLog"> | string | null
    entityId?: StringNullableFilter<"FlowActivityLog"> | string | null
    changeData?: JsonNullableFilter<"FlowActivityLog">
    createdAt?: DateTimeFilter<"FlowActivityLog"> | Date | string
  }

  export type FlowCommentUpsertWithWhereUniqueWithoutFlowInput = {
    where: FlowCommentWhereUniqueInput
    update: XOR<FlowCommentUpdateWithoutFlowInput, FlowCommentUncheckedUpdateWithoutFlowInput>
    create: XOR<FlowCommentCreateWithoutFlowInput, FlowCommentUncheckedCreateWithoutFlowInput>
  }

  export type FlowCommentUpdateWithWhereUniqueWithoutFlowInput = {
    where: FlowCommentWhereUniqueInput
    data: XOR<FlowCommentUpdateWithoutFlowInput, FlowCommentUncheckedUpdateWithoutFlowInput>
  }

  export type FlowCommentUpdateManyWithWhereWithoutFlowInput = {
    where: FlowCommentScalarWhereInput
    data: XOR<FlowCommentUpdateManyMutationInput, FlowCommentUncheckedUpdateManyWithoutFlowInput>
  }

  export type FlowCommentScalarWhereInput = {
    AND?: FlowCommentScalarWhereInput | FlowCommentScalarWhereInput[]
    OR?: FlowCommentScalarWhereInput[]
    NOT?: FlowCommentScalarWhereInput | FlowCommentScalarWhereInput[]
    id?: StringFilter<"FlowComment"> | string
    flowId?: StringFilter<"FlowComment"> | string
    userId?: StringNullableFilter<"FlowComment"> | string | null
    content?: StringFilter<"FlowComment"> | string
    position?: JsonNullableFilter<"FlowComment">
    podId?: StringNullableFilter<"FlowComment"> | string | null
    parentId?: StringNullableFilter<"FlowComment"> | string | null
    isResolved?: BoolFilter<"FlowComment"> | boolean
    resolvedBy?: StringNullableFilter<"FlowComment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FlowComment"> | Date | string | null
    createdAt?: DateTimeFilter<"FlowComment"> | Date | string
    updatedAt?: DateTimeFilter<"FlowComment"> | Date | string
  }

  export type FlowCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutInvitationsInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutInvitationsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutInvitationsInput, FlowUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentFlowInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutSentFlowInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutSentFlowInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentFlowInvitesInput, UserUncheckedCreateWithoutSentFlowInvitesInput>
  }

  export type UserCreateWithoutReceivedFlowInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateWithoutReceivedFlowInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserCreateOrConnectWithoutReceivedFlowInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedFlowInvitesInput, UserUncheckedCreateWithoutReceivedFlowInvitesInput>
  }

  export type FlowUpsertWithoutInvitationsInput = {
    update: XOR<FlowUpdateWithoutInvitationsInput, FlowUncheckedUpdateWithoutInvitationsInput>
    create: XOR<FlowCreateWithoutInvitationsInput, FlowUncheckedCreateWithoutInvitationsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutInvitationsInput, FlowUncheckedUpdateWithoutInvitationsInput>
  }

  export type FlowUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type UserUpsertWithoutSentFlowInvitesInput = {
    update: XOR<UserUpdateWithoutSentFlowInvitesInput, UserUncheckedUpdateWithoutSentFlowInvitesInput>
    create: XOR<UserCreateWithoutSentFlowInvitesInput, UserUncheckedCreateWithoutSentFlowInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentFlowInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentFlowInvitesInput, UserUncheckedUpdateWithoutSentFlowInvitesInput>
  }

  export type UserUpdateWithoutSentFlowInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentFlowInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUpsertWithoutReceivedFlowInvitesInput = {
    update: XOR<UserUpdateWithoutReceivedFlowInvitesInput, UserUncheckedUpdateWithoutReceivedFlowInvitesInput>
    create: XOR<UserCreateWithoutReceivedFlowInvitesInput, UserUncheckedCreateWithoutReceivedFlowInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedFlowInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedFlowInvitesInput, UserUncheckedUpdateWithoutReceivedFlowInvitesInput>
  }

  export type UserUpdateWithoutReceivedFlowInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedFlowInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type FlowCreateWithoutCollaboratorsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutCollaboratorsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutCollaboratorsInput, FlowUncheckedCreateWithoutCollaboratorsInput>
  }

  export type UserCreateWithoutFlowCollaborationsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutFlowCollaborationsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutFlowCollaborationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlowCollaborationsInput, UserUncheckedCreateWithoutFlowCollaborationsInput>
  }

  export type FlowUpsertWithoutCollaboratorsInput = {
    update: XOR<FlowUpdateWithoutCollaboratorsInput, FlowUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<FlowCreateWithoutCollaboratorsInput, FlowUncheckedCreateWithoutCollaboratorsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutCollaboratorsInput, FlowUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type FlowUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type UserUpsertWithoutFlowCollaborationsInput = {
    update: XOR<UserUpdateWithoutFlowCollaborationsInput, UserUncheckedUpdateWithoutFlowCollaborationsInput>
    create: XOR<UserCreateWithoutFlowCollaborationsInput, UserUncheckedCreateWithoutFlowCollaborationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlowCollaborationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlowCollaborationsInput, UserUncheckedUpdateWithoutFlowCollaborationsInput>
  }

  export type UserUpdateWithoutFlowCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlowCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type FlowCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutSessionsInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutSessionsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
  }

  export type FlowUpsertWithoutSessionsInput = {
    update: XOR<FlowUpdateWithoutSessionsInput, FlowUncheckedUpdateWithoutSessionsInput>
    create: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutSessionsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutSessionsInput, FlowUncheckedUpdateWithoutSessionsInput>
  }

  export type FlowUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowCreateWithoutActivityLogInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutActivityLogInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutActivityLogInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutActivityLogInput, FlowUncheckedCreateWithoutActivityLogInput>
  }

  export type FlowUpsertWithoutActivityLogInput = {
    update: XOR<FlowUpdateWithoutActivityLogInput, FlowUncheckedUpdateWithoutActivityLogInput>
    create: XOR<FlowCreateWithoutActivityLogInput, FlowUncheckedCreateWithoutActivityLogInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutActivityLogInput, FlowUncheckedUpdateWithoutActivityLogInput>
  }

  export type FlowUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutCommentsInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutCommentsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutCommentsInput, FlowUncheckedCreateWithoutCommentsInput>
  }

  export type FlowUpsertWithoutCommentsInput = {
    update: XOR<FlowUpdateWithoutCommentsInput, FlowUncheckedUpdateWithoutCommentsInput>
    create: XOR<FlowCreateWithoutCommentsInput, FlowUncheckedCreateWithoutCommentsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutCommentsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutCommentsInput, FlowUncheckedUpdateWithoutCommentsInput>
  }

  export type FlowUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowCreateWithoutPodsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutPodsInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutPodsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutPodsInput, FlowUncheckedCreateWithoutPodsInput>
  }

  export type FlowCreateWithoutContextualPodsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutContextualPodsInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutContextualPodsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutContextualPodsInput, FlowUncheckedCreateWithoutContextualPodsInput>
  }

  export type DocumentCreateWithoutPodsInput = {
    id?: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    folder?: DocumentFolderCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutPodsInput = {
    id?: string
    workspaceId: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutPodsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPodsInput, DocumentUncheckedCreateWithoutPodsInput>
  }

  export type EdgeCreateWithoutSourcePodInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    flow: FlowCreateNestedOneWithoutEdgesInput
    targetPod: PodCreateNestedOneWithoutTargetEdgesInput
  }

  export type EdgeUncheckedCreateWithoutSourcePodInput = {
    id?: string
    flowId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateOrConnectWithoutSourcePodInput = {
    where: EdgeWhereUniqueInput
    create: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput>
  }

  export type EdgeCreateManySourcePodInputEnvelope = {
    data: EdgeCreateManySourcePodInput | EdgeCreateManySourcePodInput[]
    skipDuplicates?: boolean
  }

  export type EdgeCreateWithoutTargetPodInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    flow: FlowCreateNestedOneWithoutEdgesInput
    sourcePod: PodCreateNestedOneWithoutSourceEdgesInput
  }

  export type EdgeUncheckedCreateWithoutTargetPodInput = {
    id?: string
    flowId: string
    sourcePodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateOrConnectWithoutTargetPodInput = {
    where: EdgeWhereUniqueInput
    create: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput>
  }

  export type EdgeCreateManyTargetPodInputEnvelope = {
    data: EdgeCreateManyTargetPodInput | EdgeCreateManyTargetPodInput[]
    skipDuplicates?: boolean
  }

  export type PodExecutionCreateWithoutPodInput = {
    id?: string
    flowId: string
    workspaceId: string
    status?: $Enums.PodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionUncheckedCreateWithoutPodInput = {
    id?: string
    flowId: string
    workspaceId: string
    status?: $Enums.PodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionCreateOrConnectWithoutPodInput = {
    where: PodExecutionWhereUniqueInput
    create: XOR<PodExecutionCreateWithoutPodInput, PodExecutionUncheckedCreateWithoutPodInput>
  }

  export type PodExecutionCreateManyPodInputEnvelope = {
    data: PodExecutionCreateManyPodInput | PodExecutionCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type PodUsageLogCreateWithoutPodInput = {
    id?: string
    executionId: string
    flowId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutUsageLogsInput
  }

  export type PodUsageLogUncheckedCreateWithoutPodInput = {
    id?: string
    executionId: string
    flowId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogCreateOrConnectWithoutPodInput = {
    where: PodUsageLogWhereUniqueInput
    create: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput>
  }

  export type PodUsageLogCreateManyPodInputEnvelope = {
    data: PodUsageLogCreateManyPodInput | PodUsageLogCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type FlowUpsertWithoutPodsInput = {
    update: XOR<FlowUpdateWithoutPodsInput, FlowUncheckedUpdateWithoutPodsInput>
    create: XOR<FlowCreateWithoutPodsInput, FlowUncheckedCreateWithoutPodsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutPodsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutPodsInput, FlowUncheckedUpdateWithoutPodsInput>
  }

  export type FlowUpdateWithoutPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowUpsertWithoutContextualPodsInput = {
    update: XOR<FlowUpdateWithoutContextualPodsInput, FlowUncheckedUpdateWithoutContextualPodsInput>
    create: XOR<FlowCreateWithoutContextualPodsInput, FlowUncheckedCreateWithoutContextualPodsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutContextualPodsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutContextualPodsInput, FlowUncheckedUpdateWithoutContextualPodsInput>
  }

  export type FlowUpdateWithoutContextualPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutContextualPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type DocumentUpsertWithoutPodsInput = {
    update: XOR<DocumentUpdateWithoutPodsInput, DocumentUncheckedUpdateWithoutPodsInput>
    create: XOR<DocumentCreateWithoutPodsInput, DocumentUncheckedCreateWithoutPodsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutPodsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutPodsInput, DocumentUncheckedUpdateWithoutPodsInput>
  }

  export type DocumentUpdateWithoutPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: DocumentFolderUpdateOneWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EdgeUpsertWithWhereUniqueWithoutSourcePodInput = {
    where: EdgeWhereUniqueInput
    update: XOR<EdgeUpdateWithoutSourcePodInput, EdgeUncheckedUpdateWithoutSourcePodInput>
    create: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput>
  }

  export type EdgeUpdateWithWhereUniqueWithoutSourcePodInput = {
    where: EdgeWhereUniqueInput
    data: XOR<EdgeUpdateWithoutSourcePodInput, EdgeUncheckedUpdateWithoutSourcePodInput>
  }

  export type EdgeUpdateManyWithWhereWithoutSourcePodInput = {
    where: EdgeScalarWhereInput
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutSourcePodInput>
  }

  export type EdgeUpsertWithWhereUniqueWithoutTargetPodInput = {
    where: EdgeWhereUniqueInput
    update: XOR<EdgeUpdateWithoutTargetPodInput, EdgeUncheckedUpdateWithoutTargetPodInput>
    create: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput>
  }

  export type EdgeUpdateWithWhereUniqueWithoutTargetPodInput = {
    where: EdgeWhereUniqueInput
    data: XOR<EdgeUpdateWithoutTargetPodInput, EdgeUncheckedUpdateWithoutTargetPodInput>
  }

  export type EdgeUpdateManyWithWhereWithoutTargetPodInput = {
    where: EdgeScalarWhereInput
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutTargetPodInput>
  }

  export type PodExecutionUpsertWithWhereUniqueWithoutPodInput = {
    where: PodExecutionWhereUniqueInput
    update: XOR<PodExecutionUpdateWithoutPodInput, PodExecutionUncheckedUpdateWithoutPodInput>
    create: XOR<PodExecutionCreateWithoutPodInput, PodExecutionUncheckedCreateWithoutPodInput>
  }

  export type PodExecutionUpdateWithWhereUniqueWithoutPodInput = {
    where: PodExecutionWhereUniqueInput
    data: XOR<PodExecutionUpdateWithoutPodInput, PodExecutionUncheckedUpdateWithoutPodInput>
  }

  export type PodExecutionUpdateManyWithWhereWithoutPodInput = {
    where: PodExecutionScalarWhereInput
    data: XOR<PodExecutionUpdateManyMutationInput, PodExecutionUncheckedUpdateManyWithoutPodInput>
  }

  export type PodExecutionScalarWhereInput = {
    AND?: PodExecutionScalarWhereInput | PodExecutionScalarWhereInput[]
    OR?: PodExecutionScalarWhereInput[]
    NOT?: PodExecutionScalarWhereInput | PodExecutionScalarWhereInput[]
    id?: StringFilter<"PodExecution"> | string
    podId?: StringFilter<"PodExecution"> | string
    flowId?: StringFilter<"PodExecution"> | string
    workspaceId?: StringFilter<"PodExecution"> | string
    status?: EnumPodExecutionStatusFilter<"PodExecution"> | $Enums.PodExecutionStatus
    startedAt?: DateTimeFilter<"PodExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"PodExecution"> | Date | string | null
    runtimeInMs?: IntNullableFilter<"PodExecution"> | number | null
    provider?: EnumLLMProviderFilter<"PodExecution"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodExecution"> | string
    modelName?: StringNullableFilter<"PodExecution"> | string | null
    providerMetadata?: JsonNullableFilter<"PodExecution">
    requestMetadata?: JsonNullableFilter<"PodExecution">
    responseMetadata?: JsonNullableFilter<"PodExecution">
    errorMessage?: StringNullableFilter<"PodExecution"> | string | null
    errorCode?: StringNullableFilter<"PodExecution"> | string | null
    inputTokens?: IntFilter<"PodExecution"> | number
    outputTokens?: IntFilter<"PodExecution"> | number
    reasoningTokens?: IntFilter<"PodExecution"> | number
    creditsConsumed?: IntFilter<"PodExecution"> | number
    costInUsd?: DecimalNullableFilter<"PodExecution"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogUpsertWithWhereUniqueWithoutPodInput = {
    where: PodUsageLogWhereUniqueInput
    update: XOR<PodUsageLogUpdateWithoutPodInput, PodUsageLogUncheckedUpdateWithoutPodInput>
    create: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput>
  }

  export type PodUsageLogUpdateWithWhereUniqueWithoutPodInput = {
    where: PodUsageLogWhereUniqueInput
    data: XOR<PodUsageLogUpdateWithoutPodInput, PodUsageLogUncheckedUpdateWithoutPodInput>
  }

  export type PodUsageLogUpdateManyWithWhereWithoutPodInput = {
    where: PodUsageLogScalarWhereInput
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyWithoutPodInput>
  }

  export type FlowCreateWithoutEdgesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutEdgesInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutEdgesInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutEdgesInput, FlowUncheckedCreateWithoutEdgesInput>
  }

  export type PodCreateWithoutSourceEdgesInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutSourceEdgesInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutSourceEdgesInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutSourceEdgesInput, PodUncheckedCreateWithoutSourceEdgesInput>
  }

  export type PodCreateWithoutTargetEdgesInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutTargetEdgesInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutTargetEdgesInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutTargetEdgesInput, PodUncheckedCreateWithoutTargetEdgesInput>
  }

  export type FlowUpsertWithoutEdgesInput = {
    update: XOR<FlowUpdateWithoutEdgesInput, FlowUncheckedUpdateWithoutEdgesInput>
    create: XOR<FlowCreateWithoutEdgesInput, FlowUncheckedCreateWithoutEdgesInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutEdgesInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutEdgesInput, FlowUncheckedUpdateWithoutEdgesInput>
  }

  export type FlowUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type PodUpsertWithoutSourceEdgesInput = {
    update: XOR<PodUpdateWithoutSourceEdgesInput, PodUncheckedUpdateWithoutSourceEdgesInput>
    create: XOR<PodCreateWithoutSourceEdgesInput, PodUncheckedCreateWithoutSourceEdgesInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutSourceEdgesInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutSourceEdgesInput, PodUncheckedUpdateWithoutSourceEdgesInput>
  }

  export type PodUpdateWithoutSourceEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutSourceEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodUpsertWithoutTargetEdgesInput = {
    update: XOR<PodUpdateWithoutTargetEdgesInput, PodUncheckedUpdateWithoutTargetEdgesInput>
    create: XOR<PodCreateWithoutTargetEdgesInput, PodUncheckedCreateWithoutTargetEdgesInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutTargetEdgesInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutTargetEdgesInput, PodUncheckedUpdateWithoutTargetEdgesInput>
  }

  export type PodUpdateWithoutTargetEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutTargetEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodCreateWithoutExecutionsInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutExecutionsInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutExecutionsInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutExecutionsInput, PodUncheckedCreateWithoutExecutionsInput>
  }

  export type PodUpsertWithoutExecutionsInput = {
    update: XOR<PodUpdateWithoutExecutionsInput, PodUncheckedUpdateWithoutExecutionsInput>
    create: XOR<PodCreateWithoutExecutionsInput, PodUncheckedCreateWithoutExecutionsInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutExecutionsInput, PodUncheckedUpdateWithoutExecutionsInput>
  }

  export type PodUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodCreateWithoutUsageLogsInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutUsageLogsInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutUsageLogsInput, PodUncheckedCreateWithoutUsageLogsInput>
  }

  export type SubscriptionCreateWithoutUsageLogsInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUsageLogsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
  }

  export type PodUpsertWithoutUsageLogsInput = {
    update: XOR<PodUpdateWithoutUsageLogsInput, PodUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<PodCreateWithoutUsageLogsInput, PodUncheckedCreateWithoutUsageLogsInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutUsageLogsInput, PodUncheckedUpdateWithoutUsageLogsInput>
  }

  export type PodUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
  }

  export type SubscriptionUpsertWithoutUsageLogsInput = {
    update: XOR<SubscriptionUpdateWithoutUsageLogsInput, SubscriptionUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUsageLogsInput, SubscriptionUncheckedUpdateWithoutUsageLogsInput>
  }

  export type SubscriptionUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceCreateWithoutContextModulesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutContextModulesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutContextModulesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
  }

  export type FlowCreateWithoutContextModulesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFlowsInput
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutContextModulesInput = {
    id?: string
    workspaceId: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutContextModulesInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutContextModulesInput, FlowUncheckedCreateWithoutContextModulesInput>
  }

  export type WorkspaceUpsertWithoutContextModulesInput = {
    update: XOR<WorkspaceUpdateWithoutContextModulesInput, WorkspaceUncheckedUpdateWithoutContextModulesInput>
    create: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutContextModulesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutContextModulesInput, WorkspaceUncheckedUpdateWithoutContextModulesInput>
  }

  export type WorkspaceUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type FlowUpsertWithoutContextModulesInput = {
    update: XOR<FlowUpdateWithoutContextModulesInput, FlowUncheckedUpdateWithoutContextModulesInput>
    create: XOR<FlowCreateWithoutContextModulesInput, FlowUncheckedCreateWithoutContextModulesInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutContextModulesInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutContextModulesInput, FlowUncheckedUpdateWithoutContextModulesInput>
  }

  export type FlowUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserCreateWithoutUserInput = {
    id?: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceUserUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserCreateManyUserInputEnvelope = {
    data: WorkspaceUserCreateManyUserInput | WorkspaceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FlowCollaboratorCreateWithoutUserInput = {
    id?: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
    flow: FlowCreateNestedOneWithoutCollaboratorsInput
  }

  export type FlowCollaboratorUncheckedCreateWithoutUserInput = {
    id?: string
    flowId: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type FlowCollaboratorCreateOrConnectWithoutUserInput = {
    where: FlowCollaboratorWhereUniqueInput
    create: XOR<FlowCollaboratorCreateWithoutUserInput, FlowCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type FlowCollaboratorCreateManyUserInputEnvelope = {
    data: FlowCollaboratorCreateManyUserInput | FlowCollaboratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    invitedUser?: UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutInviterInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput>
  }

  export type WorkspaceInvitationCreateManyInviterInputEnvelope = {
    data: WorkspaceInvitationCreateManyInviterInput | WorkspaceInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutInvitedUserInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type WorkspaceInvitationCreateManyInvitedUserInputEnvelope = {
    data: WorkspaceInvitationCreateManyInvitedUserInput | WorkspaceInvitationCreateManyInvitedUserInput[]
    skipDuplicates?: boolean
  }

  export type FlowInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    flow: FlowCreateNestedOneWithoutInvitationsInput
    invitedUser?: UserCreateNestedOneWithoutReceivedFlowInvitesInput
  }

  export type FlowInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    flowId: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationCreateOrConnectWithoutInviterInput = {
    where: FlowInvitationWhereUniqueInput
    create: XOR<FlowInvitationCreateWithoutInviterInput, FlowInvitationUncheckedCreateWithoutInviterInput>
  }

  export type FlowInvitationCreateManyInviterInputEnvelope = {
    data: FlowInvitationCreateManyInviterInput | FlowInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type FlowInvitationCreateWithoutInvitedUserInput = {
    id?: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    flow: FlowCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentFlowInvitesInput
  }

  export type FlowInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    flowId: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: FlowInvitationWhereUniqueInput
    create: XOR<FlowInvitationCreateWithoutInvitedUserInput, FlowInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type FlowInvitationCreateManyInvitedUserInputEnvelope = {
    data: FlowInvitationCreateManyInvitedUserInput | FlowInvitationCreateManyInvitedUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    provider?: EnumAuthProviderFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUserScalarWhereInput = {
    AND?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    OR?: WorkspaceUserScalarWhereInput[]
    NOT?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceUser"> | string | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    deviceName?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type FlowCollaboratorUpsertWithWhereUniqueWithoutUserInput = {
    where: FlowCollaboratorWhereUniqueInput
    update: XOR<FlowCollaboratorUpdateWithoutUserInput, FlowCollaboratorUncheckedUpdateWithoutUserInput>
    create: XOR<FlowCollaboratorCreateWithoutUserInput, FlowCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type FlowCollaboratorUpdateWithWhereUniqueWithoutUserInput = {
    where: FlowCollaboratorWhereUniqueInput
    data: XOR<FlowCollaboratorUpdateWithoutUserInput, FlowCollaboratorUncheckedUpdateWithoutUserInput>
  }

  export type FlowCollaboratorUpdateManyWithWhereWithoutUserInput = {
    where: FlowCollaboratorScalarWhereInput
    data: XOR<FlowCollaboratorUpdateManyMutationInput, FlowCollaboratorUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutInviterInput, WorkspaceInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutInviterInput, WorkspaceInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type WorkspaceInvitationScalarWhereInput = {
    AND?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    OR?: WorkspaceInvitationScalarWhereInput[]
    NOT?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableFilter<"WorkspaceInvitation">
    invitedBy?: StringFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    token?: StringFilter<"WorkspaceInvitation"> | string
    status?: EnumInvitationStatusFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutInvitedUserInput, WorkspaceInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutInvitedUserInput, WorkspaceInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserInput>
  }

  export type FlowInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: FlowInvitationWhereUniqueInput
    update: XOR<FlowInvitationUpdateWithoutInviterInput, FlowInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<FlowInvitationCreateWithoutInviterInput, FlowInvitationUncheckedCreateWithoutInviterInput>
  }

  export type FlowInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: FlowInvitationWhereUniqueInput
    data: XOR<FlowInvitationUpdateWithoutInviterInput, FlowInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type FlowInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: FlowInvitationScalarWhereInput
    data: XOR<FlowInvitationUpdateManyMutationInput, FlowInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type FlowInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: FlowInvitationWhereUniqueInput
    update: XOR<FlowInvitationUpdateWithoutInvitedUserInput, FlowInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<FlowInvitationCreateWithoutInvitedUserInput, FlowInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type FlowInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: FlowInvitationWhereUniqueInput
    data: XOR<FlowInvitationUpdateWithoutInvitedUserInput, FlowInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type FlowInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: FlowInvitationScalarWhereInput
    data: XOR<FlowInvitationUpdateManyMutationInput, FlowInvitationUncheckedUpdateManyWithoutInvitedUserInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type WorkspaceUserCreateWithoutWorkspaceInput = {
    id?: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserCreateManyWorkspaceInput | WorkspaceUserCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type SpaceCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    flows?: FlowCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    flows?: FlowUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutWorkspaceInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutWorkspaceInput, SpaceUncheckedCreateWithoutWorkspaceInput>
  }

  export type SpaceCreateManyWorkspaceInputEnvelope = {
    data: SpaceCreateManyWorkspaceInput | SpaceCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type FlowCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    space?: SpaceCreateNestedOneWithoutFlowsInput
    pods?: PodCreateNestedManyWithoutFlowInput
    edges?: EdgeCreateNestedManyWithoutFlowInput
    contextualPods?: PodCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogCreateNestedManyWithoutFlowInput
    comments?: FlowCommentCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutFlowInput
    edges?: EdgeUncheckedCreateNestedManyWithoutFlowInput
    contextualPods?: PodUncheckedCreateNestedManyWithoutContextFlowInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalFlowInput
    collaborators?: FlowCollaboratorUncheckedCreateNestedManyWithoutFlowInput
    invitations?: FlowInvitationUncheckedCreateNestedManyWithoutFlowInput
    sessions?: FlowSessionUncheckedCreateNestedManyWithoutFlowInput
    activityLog?: FlowActivityLogUncheckedCreateNestedManyWithoutFlowInput
    comments?: FlowCommentUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutWorkspaceInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutWorkspaceInput, FlowUncheckedCreateWithoutWorkspaceInput>
  }

  export type FlowCreateManyWorkspaceInputEnvelope = {
    data: FlowCreateManyWorkspaceInput | FlowCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: DocumentFolderCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    pods?: PodCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    pods?: PodUncheckedCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutWorkspaceInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput>
  }

  export type DocumentCreateManyWorkspaceInputEnvelope = {
    data: DocumentCreateManyWorkspaceInput | DocumentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type DocumentFolderCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DocumentFolderCreateNestedOneWithoutChildrenInput
    children?: DocumentFolderCreateNestedManyWithoutParentInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    parentId?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: DocumentFolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderCreateOrConnectWithoutWorkspaceInput = {
    where: DocumentFolderWhereUniqueInput
    create: XOR<DocumentFolderCreateWithoutWorkspaceInput, DocumentFolderUncheckedCreateWithoutWorkspaceInput>
  }

  export type DocumentFolderCreateManyWorkspaceInputEnvelope = {
    data: DocumentFolderCreateManyWorkspaceInput | DocumentFolderCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutWorkspaceInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    documentProcessingCost?: DocumentProcessingCostUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutWorkspaceInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
  }

  export type ContextModuleCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    originalFlow?: FlowCreateNestedOneWithoutContextModulesInput
  }

  export type ContextModuleUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalFlowId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateOrConnectWithoutWorkspaceInput = {
    where: ContextModuleWhereUniqueInput
    create: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput>
  }

  export type ContextModuleCreateManyWorkspaceInputEnvelope = {
    data: ContextModuleCreateManyWorkspaceInput | ContextModuleCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ShareLinkCreateWithoutWorkspaceInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkCreateOrConnectWithoutWorkspaceInput = {
    where: ShareLinkWhereUniqueInput
    create: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput>
  }

  export type ShareLinkCreateManyWorkspaceInputEnvelope = {
    data: ShareLinkCreateManyWorkspaceInput | ShareLinkCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ProviderAPIKeyCreateWithoutWorkspaceInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput = {
    where: ProviderAPIKeyWhereUniqueInput
    create: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyCreateManyWorkspaceInputEnvelope = {
    data: ProviderAPIKeyCreateManyWorkspaceInput | ProviderAPIKeyCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    inviter: UserCreateNestedOneWithoutSentWorkspaceInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceInvitationCreateManyWorkspaceInput | WorkspaceInvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type SpaceUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: SpaceWhereUniqueInput
    update: XOR<SpaceUpdateWithoutWorkspaceInput, SpaceUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<SpaceCreateWithoutWorkspaceInput, SpaceUncheckedCreateWithoutWorkspaceInput>
  }

  export type SpaceUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: SpaceWhereUniqueInput
    data: XOR<SpaceUpdateWithoutWorkspaceInput, SpaceUncheckedUpdateWithoutWorkspaceInput>
  }

  export type SpaceUpdateManyWithWhereWithoutWorkspaceInput = {
    where: SpaceScalarWhereInput
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type SpaceScalarWhereInput = {
    AND?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    OR?: SpaceScalarWhereInput[]
    NOT?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    id?: StringFilter<"Space"> | string
    workspaceId?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    customInstructions?: StringNullableFilter<"Space"> | string | null
    icon?: StringNullableFilter<"Space"> | string | null
    color?: StringNullableFilter<"Space"> | string | null
    createdBy?: StringFilter<"Space"> | string
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
  }

  export type FlowUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: FlowWhereUniqueInput
    update: XOR<FlowUpdateWithoutWorkspaceInput, FlowUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<FlowCreateWithoutWorkspaceInput, FlowUncheckedCreateWithoutWorkspaceInput>
  }

  export type FlowUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: FlowWhereUniqueInput
    data: XOR<FlowUpdateWithoutWorkspaceInput, FlowUncheckedUpdateWithoutWorkspaceInput>
  }

  export type FlowUpdateManyWithWhereWithoutWorkspaceInput = {
    where: FlowScalarWhereInput
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutWorkspaceInput, DocumentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutWorkspaceInput, DocumentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type DocumentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    workspaceId?: StringFilter<"Document"> | string
    folderId?: StringNullableFilter<"Document"> | string | null
    name?: StringFilter<"Document"> | string
    sourceType?: EnumDocumentSourceTypeFilter<"Document"> | $Enums.DocumentSourceType
    storageKey?: StringNullableFilter<"Document"> | string | null
    s3Bucket?: StringNullableFilter<"Document"> | string | null
    externalUrl?: StringNullableFilter<"Document"> | string | null
    externalProvider?: StringNullableFilter<"Document"> | string | null
    externalFileId?: StringNullableFilter<"Document"> | string | null
    fileType?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    sizeInBytes?: BigIntNullableFilter<"Document"> | bigint | number | null
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DocumentFolderUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: DocumentFolderWhereUniqueInput
    update: XOR<DocumentFolderUpdateWithoutWorkspaceInput, DocumentFolderUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<DocumentFolderCreateWithoutWorkspaceInput, DocumentFolderUncheckedCreateWithoutWorkspaceInput>
  }

  export type DocumentFolderUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: DocumentFolderWhereUniqueInput
    data: XOR<DocumentFolderUpdateWithoutWorkspaceInput, DocumentFolderUncheckedUpdateWithoutWorkspaceInput>
  }

  export type DocumentFolderUpdateManyWithWhereWithoutWorkspaceInput = {
    where: DocumentFolderScalarWhereInput
    data: XOR<DocumentFolderUpdateManyMutationInput, DocumentFolderUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DocumentFolderScalarWhereInput = {
    AND?: DocumentFolderScalarWhereInput | DocumentFolderScalarWhereInput[]
    OR?: DocumentFolderScalarWhereInput[]
    NOT?: DocumentFolderScalarWhereInput | DocumentFolderScalarWhereInput[]
    id?: StringFilter<"DocumentFolder"> | string
    workspaceId?: StringFilter<"DocumentFolder"> | string
    name?: StringFilter<"DocumentFolder"> | string
    parentId?: StringNullableFilter<"DocumentFolder"> | string | null
    icon?: StringNullableFilter<"DocumentFolder"> | string | null
    color?: StringNullableFilter<"DocumentFolder"> | string | null
    sortOrder?: IntFilter<"DocumentFolder"> | number
    createdBy?: StringFilter<"DocumentFolder"> | string
    createdAt?: DateTimeFilter<"DocumentFolder"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentFolder"> | Date | string
  }

  export type SubscriptionUpsertWithoutWorkspaceInput = {
    update: XOR<SubscriptionUpdateWithoutWorkspaceInput, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutWorkspaceInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutWorkspaceInput, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type SubscriptionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    documentProcessingCost?: DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ContextModuleWhereUniqueInput
    update: XOR<ContextModuleUpdateWithoutWorkspaceInput, ContextModuleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput>
  }

  export type ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ContextModuleWhereUniqueInput
    data: XOR<ContextModuleUpdateWithoutWorkspaceInput, ContextModuleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ContextModuleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ContextModuleScalarWhereInput
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ShareLinkWhereUniqueInput
    update: XOR<ShareLinkUpdateWithoutWorkspaceInput, ShareLinkUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput>
  }

  export type ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ShareLinkWhereUniqueInput
    data: XOR<ShareLinkUpdateWithoutWorkspaceInput, ShareLinkUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ShareLinkUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ShareLinkScalarWhereInput
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ShareLinkScalarWhereInput = {
    AND?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
    OR?: ShareLinkScalarWhereInput[]
    NOT?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
    id?: StringFilter<"ShareLink"> | string
    publicToken?: StringFilter<"ShareLink"> | string
    assetType?: EnumShareableAssetTypeFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringFilter<"ShareLink"> | string
    workspaceId?: StringFilter<"ShareLink"> | string
    createdBy?: StringFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableFilter<"ShareLink"> | string | null
    viewCount?: IntFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
  }

  export type ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProviderAPIKeyWhereUniqueInput
    update: XOR<ProviderAPIKeyUpdateWithoutWorkspaceInput, ProviderAPIKeyUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProviderAPIKeyWhereUniqueInput
    data: XOR<ProviderAPIKeyUpdateWithoutWorkspaceInput, ProviderAPIKeyUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProviderAPIKeyScalarWhereInput
    data: XOR<ProviderAPIKeyUpdateManyMutationInput, ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyScalarWhereInput = {
    AND?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
    OR?: ProviderAPIKeyScalarWhereInput[]
    NOT?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
    id?: StringFilter<"ProviderAPIKey"> | string
    workspaceId?: StringFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringFilter<"ProviderAPIKey"> | string
    keyHash?: StringFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableFilter<"ProviderAPIKey">
    endpoint?: StringNullableFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateWithoutMembersInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutMembersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type WorkspaceUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutInvitationsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutSentWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutSentWorkspaceInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
  }

  export type UserCreateWithoutReceivedWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    sentFlowInvites?: FlowInvitationCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    flowCollaborations?: FlowCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    sentFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedFlowInvites?: FlowInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutReceivedWorkspaceInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
  }

  export type WorkspaceUpsertWithoutInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type WorkspaceUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutSentWorkspaceInvitesInput = {
    update: XOR<UserUpdateWithoutSentWorkspaceInvitesInput, UserUncheckedUpdateWithoutSentWorkspaceInvitesInput>
    create: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentWorkspaceInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentWorkspaceInvitesInput, UserUncheckedUpdateWithoutSentWorkspaceInvitesInput>
  }

  export type UserUpdateWithoutSentWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUpsertWithoutReceivedWorkspaceInvitesInput = {
    update: XOR<UserUpdateWithoutReceivedWorkspaceInvitesInput, UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput>
    create: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedWorkspaceInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedWorkspaceInvitesInput, UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput>
  }

  export type UserUpdateWithoutReceivedWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    sentFlowInvites?: FlowInvitationUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    flowCollaborations?: FlowCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    sentFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedFlowInvites?: FlowInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type WorkspaceCreateWithoutApiKeysInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutApiKeysInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
  }

  export type WorkspaceUpsertWithoutApiKeysInput = {
    update: XOR<WorkspaceUpdateWithoutApiKeysInput, WorkspaceUncheckedUpdateWithoutApiKeysInput>
    create: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutApiKeysInput, WorkspaceUncheckedUpdateWithoutApiKeysInput>
  }

  export type WorkspaceUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutShareLinksInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutShareLinksInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutShareLinksInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
  }

  export type WorkspaceUpsertWithoutShareLinksInput = {
    update: XOR<WorkspaceUpdateWithoutShareLinksInput, WorkspaceUncheckedUpdateWithoutShareLinksInput>
    create: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutShareLinksInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutShareLinksInput, WorkspaceUncheckedUpdateWithoutShareLinksInput>
  }

  export type WorkspaceUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DocumentFolderCreateWithoutChildrenInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DocumentFolderCreateNestedOneWithoutChildrenInput
    workspace: WorkspaceCreateNestedOneWithoutDocumentFoldersInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderUncheckedCreateWithoutChildrenInput = {
    id?: string
    workspaceId: string
    name: string
    parentId?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderCreateOrConnectWithoutChildrenInput = {
    where: DocumentFolderWhereUniqueInput
    create: XOR<DocumentFolderCreateWithoutChildrenInput, DocumentFolderUncheckedCreateWithoutChildrenInput>
  }

  export type DocumentFolderCreateWithoutParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: DocumentFolderCreateNestedManyWithoutParentInput
    workspace: WorkspaceCreateNestedOneWithoutDocumentFoldersInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderUncheckedCreateWithoutParentInput = {
    id?: string
    workspaceId: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: DocumentFolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
  }

  export type DocumentFolderCreateOrConnectWithoutParentInput = {
    where: DocumentFolderWhereUniqueInput
    create: XOR<DocumentFolderCreateWithoutParentInput, DocumentFolderUncheckedCreateWithoutParentInput>
  }

  export type DocumentFolderCreateManyParentInputEnvelope = {
    data: DocumentFolderCreateManyParentInput | DocumentFolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutDocumentFoldersInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDocumentFoldersInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDocumentFoldersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDocumentFoldersInput, WorkspaceUncheckedCreateWithoutDocumentFoldersInput>
  }

  export type DocumentCreateWithoutFolderInput = {
    id?: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    pods?: PodCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutFolderInput = {
    id?: string
    workspaceId: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    pods?: PodUncheckedCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutFolderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput>
  }

  export type DocumentCreateManyFolderInputEnvelope = {
    data: DocumentCreateManyFolderInput | DocumentCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type DocumentFolderUpsertWithoutChildrenInput = {
    update: XOR<DocumentFolderUpdateWithoutChildrenInput, DocumentFolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<DocumentFolderCreateWithoutChildrenInput, DocumentFolderUncheckedCreateWithoutChildrenInput>
    where?: DocumentFolderWhereInput
  }

  export type DocumentFolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: DocumentFolderWhereInput
    data: XOR<DocumentFolderUpdateWithoutChildrenInput, DocumentFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type DocumentFolderUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DocumentFolderUpdateOneWithoutChildrenNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentFoldersNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUpsertWithWhereUniqueWithoutParentInput = {
    where: DocumentFolderWhereUniqueInput
    update: XOR<DocumentFolderUpdateWithoutParentInput, DocumentFolderUncheckedUpdateWithoutParentInput>
    create: XOR<DocumentFolderCreateWithoutParentInput, DocumentFolderUncheckedCreateWithoutParentInput>
  }

  export type DocumentFolderUpdateWithWhereUniqueWithoutParentInput = {
    where: DocumentFolderWhereUniqueInput
    data: XOR<DocumentFolderUpdateWithoutParentInput, DocumentFolderUncheckedUpdateWithoutParentInput>
  }

  export type DocumentFolderUpdateManyWithWhereWithoutParentInput = {
    where: DocumentFolderScalarWhereInput
    data: XOR<DocumentFolderUpdateManyMutationInput, DocumentFolderUncheckedUpdateManyWithoutParentInput>
  }

  export type WorkspaceUpsertWithoutDocumentFoldersInput = {
    update: XOR<WorkspaceUpdateWithoutDocumentFoldersInput, WorkspaceUncheckedUpdateWithoutDocumentFoldersInput>
    create: XOR<WorkspaceCreateWithoutDocumentFoldersInput, WorkspaceUncheckedCreateWithoutDocumentFoldersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDocumentFoldersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDocumentFoldersInput, WorkspaceUncheckedUpdateWithoutDocumentFoldersInput>
  }

  export type WorkspaceUpdateWithoutDocumentFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDocumentFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutFolderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutFolderInput, DocumentUncheckedUpdateWithoutFolderInput>
    create: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutFolderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutFolderInput, DocumentUncheckedUpdateWithoutFolderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutFolderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutFolderInput>
  }

  export type WorkspaceCreateWithoutDocumentsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceCreateNestedManyWithoutWorkspaceInput
    flows?: FlowCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutWorkspaceInput
    flows?: FlowUncheckedCreateNestedManyWithoutWorkspaceInput
    documentFolders?: DocumentFolderUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDocumentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentFolderCreateWithoutDocumentsInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DocumentFolderCreateNestedOneWithoutChildrenInput
    children?: DocumentFolderCreateNestedManyWithoutParentInput
    workspace: WorkspaceCreateNestedOneWithoutDocumentFoldersInput
  }

  export type DocumentFolderUncheckedCreateWithoutDocumentsInput = {
    id?: string
    workspaceId: string
    name: string
    parentId?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: DocumentFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type DocumentFolderCreateOrConnectWithoutDocumentsInput = {
    where: DocumentFolderWhereUniqueInput
    create: XOR<DocumentFolderCreateWithoutDocumentsInput, DocumentFolderUncheckedCreateWithoutDocumentsInput>
  }

  export type EmbeddingCreateWithoutDocumentInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingUncheckedCreateWithoutDocumentInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingCreateOrConnectWithoutDocumentInput = {
    where: EmbeddingWhereUniqueInput
    create: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput>
  }

  export type EmbeddingCreateManyDocumentInputEnvelope = {
    data: EmbeddingCreateManyDocumentInput | EmbeddingCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type PodCreateWithoutDocumentInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    flow: FlowCreateNestedOneWithoutPodsInput
    contextFlow?: FlowCreateNestedOneWithoutContextualPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutDocumentInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: PodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutDocumentInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutDocumentInput, PodUncheckedCreateWithoutDocumentInput>
  }

  export type PodCreateManyDocumentInputEnvelope = {
    data: PodCreateManyDocumentInput | PodCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentProcessingCostCreateWithoutDocumentInput = {
    id?: string
    workspaceId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutDocumentProcessingCostInput
  }

  export type DocumentProcessingCostUncheckedCreateWithoutDocumentInput = {
    id?: string
    workspaceId: string
    subscriptionId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
  }

  export type DocumentProcessingCostCreateOrConnectWithoutDocumentInput = {
    where: DocumentProcessingCostWhereUniqueInput
    create: XOR<DocumentProcessingCostCreateWithoutDocumentInput, DocumentProcessingCostUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentProcessingCostCreateManyDocumentInputEnvelope = {
    data: DocumentProcessingCostCreateManyDocumentInput | DocumentProcessingCostCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutDocumentsInput = {
    update: XOR<WorkspaceUpdateWithoutDocumentsInput, WorkspaceUncheckedUpdateWithoutDocumentsInput>
    create: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDocumentsInput, WorkspaceUncheckedUpdateWithoutDocumentsInput>
  }

  export type WorkspaceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutWorkspaceNestedInput
    flows?: FlowUncheckedUpdateManyWithoutWorkspaceNestedInput
    documentFolders?: DocumentFolderUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DocumentFolderUpsertWithoutDocumentsInput = {
    update: XOR<DocumentFolderUpdateWithoutDocumentsInput, DocumentFolderUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DocumentFolderCreateWithoutDocumentsInput, DocumentFolderUncheckedCreateWithoutDocumentsInput>
    where?: DocumentFolderWhereInput
  }

  export type DocumentFolderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DocumentFolderWhereInput
    data: XOR<DocumentFolderUpdateWithoutDocumentsInput, DocumentFolderUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentFolderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DocumentFolderUpdateOneWithoutChildrenNestedInput
    children?: DocumentFolderUpdateManyWithoutParentNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentFoldersNestedInput
  }

  export type DocumentFolderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: DocumentFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EmbeddingUpsertWithWhereUniqueWithoutDocumentInput = {
    where: EmbeddingWhereUniqueInput
    update: XOR<EmbeddingUpdateWithoutDocumentInput, EmbeddingUncheckedUpdateWithoutDocumentInput>
    create: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput>
  }

  export type EmbeddingUpdateWithWhereUniqueWithoutDocumentInput = {
    where: EmbeddingWhereUniqueInput
    data: XOR<EmbeddingUpdateWithoutDocumentInput, EmbeddingUncheckedUpdateWithoutDocumentInput>
  }

  export type EmbeddingUpdateManyWithWhereWithoutDocumentInput = {
    where: EmbeddingScalarWhereInput
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyWithoutDocumentInput>
  }

  export type EmbeddingScalarWhereInput = {
    AND?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
    OR?: EmbeddingScalarWhereInput[]
    NOT?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
    id?: StringFilter<"Embedding"> | string
    documentId?: StringFilter<"Embedding"> | string
    model?: StringFilter<"Embedding"> | string
    chunkIndex?: IntFilter<"Embedding"> | number
    chunkText?: StringFilter<"Embedding"> | string
    s3VectorBucket?: StringFilter<"Embedding"> | string
    s3VectorKey?: StringFilter<"Embedding"> | string
    vectorDimension?: IntFilter<"Embedding"> | number
    metadata?: JsonNullableFilter<"Embedding">
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
  }

  export type PodUpsertWithWhereUniqueWithoutDocumentInput = {
    where: PodWhereUniqueInput
    update: XOR<PodUpdateWithoutDocumentInput, PodUncheckedUpdateWithoutDocumentInput>
    create: XOR<PodCreateWithoutDocumentInput, PodUncheckedCreateWithoutDocumentInput>
  }

  export type PodUpdateWithWhereUniqueWithoutDocumentInput = {
    where: PodWhereUniqueInput
    data: XOR<PodUpdateWithoutDocumentInput, PodUncheckedUpdateWithoutDocumentInput>
  }

  export type PodUpdateManyWithWhereWithoutDocumentInput = {
    where: PodScalarWhereInput
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentProcessingCostUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentProcessingCostWhereUniqueInput
    update: XOR<DocumentProcessingCostUpdateWithoutDocumentInput, DocumentProcessingCostUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentProcessingCostCreateWithoutDocumentInput, DocumentProcessingCostUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentProcessingCostUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentProcessingCostWhereUniqueInput
    data: XOR<DocumentProcessingCostUpdateWithoutDocumentInput, DocumentProcessingCostUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentProcessingCostUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentProcessingCostScalarWhereInput
    data: XOR<DocumentProcessingCostUpdateManyMutationInput, DocumentProcessingCostUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutEmbeddingsInput = {
    id?: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    folder?: DocumentFolderCreateNestedOneWithoutDocumentsInput
    pods?: PodCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutEmbeddingsInput = {
    id?: string
    workspaceId: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    pods?: PodUncheckedCreateNestedManyWithoutDocumentInput
    processingCostRecords?: DocumentProcessingCostUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutEmbeddingsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
  }

  export type DocumentUpsertWithoutEmbeddingsInput = {
    update: XOR<DocumentUpdateWithoutEmbeddingsInput, DocumentUncheckedUpdateWithoutEmbeddingsInput>
    create: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutEmbeddingsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutEmbeddingsInput, DocumentUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type DocumentUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: DocumentFolderUpdateOneWithoutDocumentsNestedInput
    pods?: PodUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateWithoutProcessingCostRecordsInput = {
    id?: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    folder?: DocumentFolderCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    pods?: PodCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutProcessingCostRecordsInput = {
    id?: string
    workspaceId: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    pods?: PodUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutProcessingCostRecordsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProcessingCostRecordsInput, DocumentUncheckedCreateWithoutProcessingCostRecordsInput>
  }

  export type SubscriptionCreateWithoutDocumentProcessingCostInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutDocumentProcessingCostInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutDocumentProcessingCostInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutDocumentProcessingCostInput, SubscriptionUncheckedCreateWithoutDocumentProcessingCostInput>
  }

  export type DocumentUpsertWithoutProcessingCostRecordsInput = {
    update: XOR<DocumentUpdateWithoutProcessingCostRecordsInput, DocumentUncheckedUpdateWithoutProcessingCostRecordsInput>
    create: XOR<DocumentCreateWithoutProcessingCostRecordsInput, DocumentUncheckedCreateWithoutProcessingCostRecordsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutProcessingCostRecordsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutProcessingCostRecordsInput, DocumentUncheckedUpdateWithoutProcessingCostRecordsInput>
  }

  export type DocumentUpdateWithoutProcessingCostRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: DocumentFolderUpdateOneWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    pods?: PodUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProcessingCostRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    pods?: PodUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type SubscriptionUpsertWithoutDocumentProcessingCostInput = {
    update: XOR<SubscriptionUpdateWithoutDocumentProcessingCostInput, SubscriptionUncheckedUpdateWithoutDocumentProcessingCostInput>
    create: XOR<SubscriptionCreateWithoutDocumentProcessingCostInput, SubscriptionUncheckedCreateWithoutDocumentProcessingCostInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutDocumentProcessingCostInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutDocumentProcessingCostInput, SubscriptionUncheckedUpdateWithoutDocumentProcessingCostInput>
  }

  export type SubscriptionUpdateWithoutDocumentProcessingCostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutDocumentProcessingCostInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type AdminSessionCreateManyAdminInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminAuditLogCreateManyAdminInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminPermissionCreateManyAdminInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminAPIKeyCreateManyAdminInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminInvitationCreateManyInviterInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminSessionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PodUsageLogCreateManySubscriptionInput = {
    id?: string
    podId: string
    executionId: string
    flowId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type CreditPurchaseCreateManySubscriptionInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditUsageLogCreateManySubscriptionInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type DocumentProcessingCostCreateManySubscriptionInput = {
    id?: string
    documentId: string
    workspaceId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
  }

  export type PodUsageLogUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: PodUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type PodUsageLogUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutProcessingCostRecordsNestedInput
  }

  export type DocumentProcessingCostUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCreateManySpaceInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodCreateManyFlowInput = {
    id?: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EdgeCreateManyFlowInput = {
    id?: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type PodCreateManyContextFlowInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateManyOriginalFlowInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCollaboratorCreateManyFlowInput = {
    id?: string
    userId: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type FlowInvitationCreateManyFlowInput = {
    id?: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowSessionCreateManyFlowInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type FlowActivityLogCreateManyFlowInput = {
    id?: string
    userId?: string | null
    action: $Enums.FlowActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlowCommentCreateManyFlowInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PodUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourcePod?: PodUpdateOneRequiredWithoutSourceEdgesNestedInput
    targetPod?: PodUpdateOneRequiredWithoutTargetEdgesNestedInput
  }

  export type EdgeUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUpdateWithoutContextFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    document?: DocumentUpdateOneWithoutPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutContextFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateManyWithoutContextFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUpdateWithoutOriginalFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutContextModulesNestedInput
  }

  export type ContextModuleUncheckedUpdateWithoutOriginalFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUncheckedUpdateManyWithoutOriginalFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCollaboratorUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFlowCollaborationsNestedInput
  }

  export type FlowCollaboratorUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowCollaboratorUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviter?: UserUpdateOneRequiredWithoutSentFlowInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedFlowInvitesNestedInput
  }

  export type FlowInvitationUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowSessionUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowSessionUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowSessionUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowActivityLogUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowActivityLogUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowActivityLogUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumFlowActivityActionFieldUpdateOperationsInput | $Enums.FlowActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCommentUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCommentUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCommentUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeCreateManySourcePodInput = {
    id?: string
    flowId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateManyTargetPodInput = {
    id?: string
    flowId: string
    sourcePodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type PodExecutionCreateManyPodInput = {
    id?: string
    flowId: string
    workspaceId: string
    status?: $Enums.PodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogCreateManyPodInput = {
    id?: string
    executionId: string
    flowId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type EdgeUpdateWithoutSourcePodInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutEdgesNestedInput
    targetPod?: PodUpdateOneRequiredWithoutTargetEdgesNestedInput
  }

  export type EdgeUncheckedUpdateWithoutSourcePodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyWithoutSourcePodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUpdateWithoutTargetPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutEdgesNestedInput
    sourcePod?: PodUpdateOneRequiredWithoutSourceEdgesNestedInput
  }

  export type EdgeUncheckedUpdateWithoutTargetPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyWithoutTargetPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodExecutionUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionUncheckedUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodExecutionUncheckedUpdateManyWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type PodUsageLogUncheckedUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogUncheckedUpdateManyWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WorkspaceUserCreateManyUserInput = {
    id?: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCollaboratorCreateManyUserInput = {
    id?: string
    flowId: string
    accessLevel?: $Enums.FlowAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyInviterInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyInvitedUserInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationCreateManyInviterInput = {
    id?: string
    flowId: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type FlowInvitationCreateManyInvitedUserInput = {
    id?: string
    flowId: string
    email: string
    accessLevel?: $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowCollaboratorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow?: FlowUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type FlowCollaboratorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowCollaboratorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow?: FlowUpdateOneRequiredWithoutInvitationsNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedFlowInvitesNestedInput
  }

  export type FlowInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow?: FlowUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentFlowInvitesNestedInput
  }

  export type FlowInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlowInvitationUncheckedUpdateManyWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumFlowAccessLevelFieldUpdateOperationsInput | $Enums.FlowAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type SpaceCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    customInstructions?: string | null
    icon?: string | null
    color?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlowCreateManyWorkspaceInput = {
    id?: string
    spaceId?: string | null
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.FlowVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyWorkspaceInput = {
    id?: string
    folderId?: string | null
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentFolderCreateManyWorkspaceInput = {
    id?: string
    name: string
    parentId?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalFlowId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareLinkCreateManyWorkspaceInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyCreateManyWorkspaceInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyWorkspaceInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceUserUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpaceUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flows?: FlowUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flows?: FlowUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    space?: SpaceUpdateOneWithoutFlowsNestedInput
    pods?: PodUpdateManyWithoutFlowNestedInput
    edges?: EdgeUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pods?: PodUncheckedUpdateManyWithoutFlowNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutFlowNestedInput
    contextualPods?: PodUncheckedUpdateManyWithoutContextFlowNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalFlowNestedInput
    collaborators?: FlowCollaboratorUncheckedUpdateManyWithoutFlowNestedInput
    invitations?: FlowInvitationUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: FlowSessionUncheckedUpdateManyWithoutFlowNestedInput
    activityLog?: FlowActivityLogUncheckedUpdateManyWithoutFlowNestedInput
    comments?: FlowCommentUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumFlowVisibilityFieldUpdateOperationsInput | $Enums.FlowVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: DocumentFolderUpdateOneWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    pods?: PodUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    pods?: PodUncheckedUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFolderUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DocumentFolderUpdateOneWithoutChildrenNestedInput
    children?: DocumentFolderUpdateManyWithoutParentNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: DocumentFolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalFlow?: FlowUpdateOneWithoutContextModulesNestedInput
  }

  export type ContextModuleUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviter?: UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentFolderCreateManyParentInput = {
    id?: string
    workspaceId: string
    name: string
    icon?: string | null
    color?: string | null
    sortOrder?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyFolderInput = {
    id?: string
    workspaceId: string
    name: string
    sourceType?: $Enums.DocumentSourceType
    storageKey?: string | null
    s3Bucket?: string | null
    externalUrl?: string | null
    externalProvider?: string | null
    externalFileId?: string | null
    fileType: string
    mimeType?: string | null
    sizeInBytes?: bigint | number | null
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentFolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: DocumentFolderUpdateManyWithoutParentNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentFoldersNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: DocumentFolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type DocumentFolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    pods?: PodUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    pods?: PodUncheckedUpdateManyWithoutDocumentNestedInput
    processingCostRecords?: DocumentProcessingCostUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumDocumentSourceTypeFieldUpdateOperationsInput | $Enums.DocumentSourceType
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalFileId?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateManyDocumentInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PodCreateManyDocumentInput = {
    id?: string
    flowId: string
    type: $Enums.PodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.PodExecutionStatus
    lastExecutionId?: string | null
    contextFlowId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentProcessingCostCreateManyDocumentInput = {
    id?: string
    workspaceId: string
    subscriptionId: string
    processingType: $Enums.DocumentProcessingType
    creditsConsumed?: number
    extractionCost?: Decimal | DecimalJsLike | number | string
    embeddingCost?: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    chunkCount?: number | null
    embeddingModel?: string | null
    processingTimeMs?: number | null
    tokensProcessed?: number
    processedAt?: Date | string
  }

  export type EmbeddingUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flow?: FlowUpdateOneRequiredWithoutPodsNestedInput
    contextFlow?: FlowUpdateOneWithoutContextualPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: PodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    type?: EnumPodTypeFieldUpdateOperationsInput | $Enums.PodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumPodExecutionStatusFieldUpdateOperationsInput | $Enums.PodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutDocumentProcessingCostNestedInput
  }

  export type DocumentProcessingCostUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentProcessingCostUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    processingType?: EnumDocumentProcessingTypeFieldUpdateOperationsInput | $Enums.DocumentProcessingType
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    extractionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    embeddingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chunkCount?: NullableIntFieldUpdateOperationsInput | number | null
    embeddingModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    tokensProcessed?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}