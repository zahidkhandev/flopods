
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminSession
 * 
 */
export type AdminSession = $Result.DefaultSelection<Prisma.$AdminSessionPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model AdminPermission
 * 
 */
export type AdminPermission = $Result.DefaultSelection<Prisma.$AdminPermissionPayload>
/**
 * Model AdminAPIKey
 * 
 */
export type AdminAPIKey = $Result.DefaultSelection<Prisma.$AdminAPIKeyPayload>
/**
 * Model AdminInvitation
 * 
 */
export type AdminInvitation = $Result.DefaultSelection<Prisma.$AdminInvitationPayload>
/**
 * Model AdminSecurityEvent
 * 
 */
export type AdminSecurityEvent = $Result.DefaultSelection<Prisma.$AdminSecurityEventPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model CreditPurchase
 * 
 */
export type CreditPurchase = $Result.DefaultSelection<Prisma.$CreditPurchasePayload>
/**
 * Model CreditUsageLog
 * 
 */
export type CreditUsageLog = $Result.DefaultSelection<Prisma.$CreditUsageLogPayload>
/**
 * Model ModelPricingTier
 * 
 */
export type ModelPricingTier = $Result.DefaultSelection<Prisma.$ModelPricingTierPayload>
/**
 * Model Canvas
 * 
 */
export type Canvas = $Result.DefaultSelection<Prisma.$CanvasPayload>
/**
 * Model CanvasInvitation
 * 
 */
export type CanvasInvitation = $Result.DefaultSelection<Prisma.$CanvasInvitationPayload>
/**
 * Model CanvasCollaborator
 * 
 */
export type CanvasCollaborator = $Result.DefaultSelection<Prisma.$CanvasCollaboratorPayload>
/**
 * Model CanvasSession
 * 
 */
export type CanvasSession = $Result.DefaultSelection<Prisma.$CanvasSessionPayload>
/**
 * Model CanvasActivityLog
 * 
 */
export type CanvasActivityLog = $Result.DefaultSelection<Prisma.$CanvasActivityLogPayload>
/**
 * Model CanvasComment
 * 
 */
export type CanvasComment = $Result.DefaultSelection<Prisma.$CanvasCommentPayload>
/**
 * Model ActionPod
 * 
 */
export type ActionPod = $Result.DefaultSelection<Prisma.$ActionPodPayload>
/**
 * Model Edge
 * 
 */
export type Edge = $Result.DefaultSelection<Prisma.$EdgePayload>
/**
 * Model ActionPodExecution
 * 
 */
export type ActionPodExecution = $Result.DefaultSelection<Prisma.$ActionPodExecutionPayload>
/**
 * Model PodUsageLog
 * 
 */
export type PodUsageLog = $Result.DefaultSelection<Prisma.$PodUsageLogPayload>
/**
 * Model ContextModule
 * 
 */
export type ContextModule = $Result.DefaultSelection<Prisma.$ContextModulePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceUser
 * 
 */
export type WorkspaceUser = $Result.DefaultSelection<Prisma.$WorkspaceUserPayload>
/**
 * Model WorkspaceInvitation
 * 
 */
export type WorkspaceInvitation = $Result.DefaultSelection<Prisma.$WorkspaceInvitationPayload>
/**
 * Model ProviderAPIKey
 * 
 */
export type ProviderAPIKey = $Result.DefaultSelection<Prisma.$ProviderAPIKeyPayload>
/**
 * Model ShareLink
 * 
 */
export type ShareLink = $Result.DefaultSelection<Prisma.$ShareLinkPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Embedding
 * 
 */
export type Embedding = $Result.DefaultSelection<Prisma.$EmbeddingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AdminRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  FINANCE: 'FINANCE',
  SUPPORT: 'SUPPORT',
  DEVELOPER: 'DEVELOPER',
  ANALYST: 'ANALYST'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]


export const AdminStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DEACTIVATED: 'DEACTIVATED',
  LOCKED: 'LOCKED'
};

export type AdminStatus = (typeof AdminStatus)[keyof typeof AdminStatus]


export const AdminAction: {
  USER_CREATED: 'USER_CREATED',
  USER_UPDATED: 'USER_UPDATED',
  USER_DELETED: 'USER_DELETED',
  USER_SUSPENDED: 'USER_SUSPENDED',
  WORKSPACE_DELETED: 'WORKSPACE_DELETED',
  SUBSCRIPTION_UPDATED: 'SUBSCRIPTION_UPDATED',
  SUBSCRIPTION_CANCELLED: 'SUBSCRIPTION_CANCELLED',
  CREDITS_ADDED: 'CREDITS_ADDED',
  CREDITS_REMOVED: 'CREDITS_REMOVED',
  REFUND_ISSUED: 'REFUND_ISSUED',
  MODEL_ADDED: 'MODEL_ADDED',
  MODEL_UPDATED: 'MODEL_UPDATED',
  PRICING_CHANGED: 'PRICING_CHANGED',
  ADMIN_INVITED: 'ADMIN_INVITED',
  ADMIN_CREATED: 'ADMIN_CREATED',
  ADMIN_ROLE_CHANGED: 'ADMIN_ROLE_CHANGED',
  PERMISSION_GRANTED: 'PERMISSION_GRANTED',
  SESSION_REVOKED: 'SESSION_REVOKED',
  CONFIG_CHANGED: 'CONFIG_CHANGED',
  DATA_EXPORTED: 'DATA_EXPORTED'
};

export type AdminAction = (typeof AdminAction)[keyof typeof AdminAction]


export const AdminResource: {
  USER: 'USER',
  WORKSPACE: 'WORKSPACE',
  SUBSCRIPTION: 'SUBSCRIPTION',
  CREDIT: 'CREDIT',
  MODEL: 'MODEL',
  ADMIN: 'ADMIN',
  PERMISSION: 'PERMISSION',
  SESSION: 'SESSION',
  API_KEY: 'API_KEY',
  CANVAS: 'CANVAS',
  ACTION_POD: 'ACTION_POD',
  DOCUMENT: 'DOCUMENT',
  AUDIT_LOG: 'AUDIT_LOG',
  SYSTEM_CONFIG: 'SYSTEM_CONFIG'
};

export type AdminResource = (typeof AdminResource)[keyof typeof AdminResource]


export const SpecificPermission: {
  USER_VIEW: 'USER_VIEW',
  USER_UPDATE: 'USER_UPDATE',
  USER_DELETE: 'USER_DELETE',
  USER_SUSPEND: 'USER_SUSPEND',
  WORKSPACE_VIEW: 'WORKSPACE_VIEW',
  WORKSPACE_DELETE: 'WORKSPACE_DELETE',
  BILLING_VIEW: 'BILLING_VIEW',
  BILLING_MANAGE: 'BILLING_MANAGE',
  CREDITS_MANAGE: 'CREDITS_MANAGE',
  REFUND_ISSUE: 'REFUND_ISSUE',
  MODEL_VIEW: 'MODEL_VIEW',
  MODEL_MANAGE: 'MODEL_MANAGE',
  PRICING_MANAGE: 'PRICING_MANAGE',
  ADMIN_VIEW: 'ADMIN_VIEW',
  ADMIN_INVITE: 'ADMIN_INVITE',
  ADMIN_MANAGE: 'ADMIN_MANAGE',
  SYSTEM_CONFIG_VIEW: 'SYSTEM_CONFIG_VIEW',
  SYSTEM_CONFIG_MANAGE: 'SYSTEM_CONFIG_MANAGE',
  AUDIT_LOG_VIEW: 'AUDIT_LOG_VIEW',
  AUDIT_LOG_EXPORT: 'AUDIT_LOG_EXPORT',
  DATA_EXPORT: 'DATA_EXPORT',
  DATA_DELETE: 'DATA_DELETE'
};

export type SpecificPermission = (typeof SpecificPermission)[keyof typeof SpecificPermission]


export const SecurityEventType: {
  FAILED_LOGIN: 'FAILED_LOGIN',
  MULTIPLE_FAILED_LOGINS: 'MULTIPLE_FAILED_LOGINS',
  SUSPICIOUS_IP: 'SUSPICIOUS_IP',
  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
  MFA_FAILED: 'MFA_FAILED',
  UNAUTHORIZED_ACCESS_ATTEMPT: 'UNAUTHORIZED_ACCESS_ATTEMPT'
};

export type SecurityEventType = (typeof SecurityEventType)[keyof typeof SecurityEventType]


export const SecuritySeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type SecuritySeverity = (typeof SecuritySeverity)[keyof typeof SecuritySeverity]


export const SubscriptionTier: {
  HOBBYIST: 'HOBBYIST',
  PRO: 'PRO',
  TEAM: 'TEAM'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELED: 'CANCELED',
  PAST_DUE: 'PAST_DUE',
  TRIALING: 'TRIALING',
  INCOMPLETE: 'INCOMPLETE',
  PAUSED: 'PAUSED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const ModelCategory: {
  WORKHORSE: 'WORKHORSE',
  POWERHOUSE: 'POWERHOUSE',
  REASONING: 'REASONING',
  SPECIALIST: 'SPECIALIST',
  IMAGE_GEN: 'IMAGE_GEN',
  VIDEO_GEN: 'VIDEO_GEN',
  AUDIO_GEN: 'AUDIO_GEN',
  EMBEDDING: 'EMBEDDING',
  RERANKING: 'RERANKING',
  MODERATION: 'MODERATION',
  SEARCH: 'SEARCH',
  TRANSLATION: 'TRANSLATION'
};

export type ModelCategory = (typeof ModelCategory)[keyof typeof ModelCategory]


export const ActionPodType: {
  TEXT_INPUT: 'TEXT_INPUT',
  DOCUMENT_INPUT: 'DOCUMENT_INPUT',
  URL_INPUT: 'URL_INPUT',
  IMAGE_INPUT: 'IMAGE_INPUT',
  VIDEO_INPUT: 'VIDEO_INPUT',
  AUDIO_INPUT: 'AUDIO_INPUT',
  LLM_PROMPT: 'LLM_PROMPT',
  EMBEDDING_POD: 'EMBEDDING_POD',
  TOOL_POD: 'TOOL_POD',
  TEXT_OUTPUT: 'TEXT_OUTPUT',
  IMAGE_OUTPUT: 'IMAGE_OUTPUT',
  VIDEO_OUTPUT: 'VIDEO_OUTPUT',
  AUDIO_OUTPUT: 'AUDIO_OUTPUT',
  CONTEXT_MODULE: 'CONTEXT_MODULE',
  CANVAS_CONTEXT_INPUT: 'CANVAS_CONTEXT_INPUT',
  CODE_EXECUTION: 'CODE_EXECUTION'
};

export type ActionPodType = (typeof ActionPodType)[keyof typeof ActionPodType]


export const ActionPodExecutionStatus: {
  IDLE: 'IDLE',
  QUEUED: 'QUEUED',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  CANCELLED: 'CANCELLED'
};

export type ActionPodExecutionStatus = (typeof ActionPodExecutionStatus)[keyof typeof ActionPodExecutionStatus]


export const CanvasVisibility: {
  PRIVATE: 'PRIVATE',
  WORKSPACE: 'WORKSPACE',
  PUBLIC: 'PUBLIC'
};

export type CanvasVisibility = (typeof CanvasVisibility)[keyof typeof CanvasVisibility]


export const CanvasAccessLevel: {
  VIEWER: 'VIEWER',
  COMMENTER: 'COMMENTER',
  EDITOR: 'EDITOR',
  OWNER: 'OWNER'
};

export type CanvasAccessLevel = (typeof CanvasAccessLevel)[keyof typeof CanvasAccessLevel]


export const CanvasActivityAction: {
  CANVAS_CREATED: 'CANVAS_CREATED',
  CANVAS_UPDATED: 'CANVAS_UPDATED',
  CANVAS_DELETED: 'CANVAS_DELETED',
  CANVAS_SHARED: 'CANVAS_SHARED',
  CANVAS_VISIBILITY_CHANGED: 'CANVAS_VISIBILITY_CHANGED',
  POD_CREATED: 'POD_CREATED',
  POD_UPDATED: 'POD_UPDATED',
  POD_DELETED: 'POD_DELETED',
  POD_MOVED: 'POD_MOVED',
  POD_EXECUTED: 'POD_EXECUTED',
  POD_LOCKED: 'POD_LOCKED',
  POD_UNLOCKED: 'POD_UNLOCKED',
  EDGE_CREATED: 'EDGE_CREATED',
  EDGE_DELETED: 'EDGE_DELETED',
  COLLABORATOR_ADDED: 'COLLABORATOR_ADDED',
  COLLABORATOR_REMOVED: 'COLLABORATOR_REMOVED',
  COLLABORATOR_PERMISSIONS_CHANGED: 'COLLABORATOR_PERMISSIONS_CHANGED',
  COMMENT_ADDED: 'COMMENT_ADDED',
  COMMENT_RESOLVED: 'COMMENT_RESOLVED',
  USER_JOINED: 'USER_JOINED',
  USER_LEFT: 'USER_LEFT'
};

export type CanvasActivityAction = (typeof CanvasActivityAction)[keyof typeof CanvasActivityAction]


export const AuthProvider: {
  GOOGLE: 'GOOGLE',
  GITHUB: 'GITHUB',
  EMAIL: 'EMAIL'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const WorkspaceType: {
  PERSONAL: 'PERSONAL',
  TEAM: 'TEAM'
};

export type WorkspaceType = (typeof WorkspaceType)[keyof typeof WorkspaceType]


export const WorkspaceRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type WorkspaceRole = (typeof WorkspaceRole)[keyof typeof WorkspaceRole]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const ShareAccessLevel: {
  VIEW_ONLY: 'VIEW_ONLY',
  COMMENT: 'COMMENT',
  EDIT: 'EDIT'
};

export type ShareAccessLevel = (typeof ShareAccessLevel)[keyof typeof ShareAccessLevel]


export const LLMProvider: {
  OPENAI: 'OPENAI',
  ANTHROPIC: 'ANTHROPIC',
  GOOGLE_GEMINI: 'GOOGLE_GEMINI',
  PERPLEXITY: 'PERPLEXITY',
  MISTRAL: 'MISTRAL',
  META_AI: 'META_AI',
  XAI: 'XAI',
  DEEPSEEK: 'DEEPSEEK',
  COHERE: 'COHERE',
  GROQ: 'GROQ',
  TOGETHER: 'TOGETHER',
  REPLICATE: 'REPLICATE',
  HUGGINGFACE: 'HUGGINGFACE',
  OPENROUTER: 'OPENROUTER',
  BEDROCK: 'BEDROCK',
  OLLAMA: 'OLLAMA',
  VLLM: 'VLLM',
  LLAMACPP: 'LLAMACPP',
  TEXTGEN_WEBUI: 'TEXTGEN_WEBUI',
  CUSTOM: 'CUSTOM'
};

export type LLMProvider = (typeof LLMProvider)[keyof typeof LLMProvider]


export const AuthType: {
  BEARER_TOKEN: 'BEARER_TOKEN',
  API_KEY_HEADER: 'API_KEY_HEADER',
  BASIC_AUTH: 'BASIC_AUTH',
  OAUTH2: 'OAUTH2',
  AWS_SIGV4: 'AWS_SIGV4',
  CUSTOM_HEADER: 'CUSTOM_HEADER'
};

export type AuthType = (typeof AuthType)[keyof typeof AuthType]


export const ShareableAssetType: {
  CANVAS: 'CANVAS',
  CONTEXT_MODULE: 'CONTEXT_MODULE'
};

export type ShareableAssetType = (typeof ShareableAssetType)[keyof typeof ShareableAssetType]


export const DocumentStatus: {
  UPLOADING: 'UPLOADING',
  PROCESSING: 'PROCESSING',
  READY: 'READY',
  ERROR: 'ERROR',
  ARCHIVED: 'ARCHIVED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]

}

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

export type AdminStatus = $Enums.AdminStatus

export const AdminStatus: typeof $Enums.AdminStatus

export type AdminAction = $Enums.AdminAction

export const AdminAction: typeof $Enums.AdminAction

export type AdminResource = $Enums.AdminResource

export const AdminResource: typeof $Enums.AdminResource

export type SpecificPermission = $Enums.SpecificPermission

export const SpecificPermission: typeof $Enums.SpecificPermission

export type SecurityEventType = $Enums.SecurityEventType

export const SecurityEventType: typeof $Enums.SecurityEventType

export type SecuritySeverity = $Enums.SecuritySeverity

export const SecuritySeverity: typeof $Enums.SecuritySeverity

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type ModelCategory = $Enums.ModelCategory

export const ModelCategory: typeof $Enums.ModelCategory

export type ActionPodType = $Enums.ActionPodType

export const ActionPodType: typeof $Enums.ActionPodType

export type ActionPodExecutionStatus = $Enums.ActionPodExecutionStatus

export const ActionPodExecutionStatus: typeof $Enums.ActionPodExecutionStatus

export type CanvasVisibility = $Enums.CanvasVisibility

export const CanvasVisibility: typeof $Enums.CanvasVisibility

export type CanvasAccessLevel = $Enums.CanvasAccessLevel

export const CanvasAccessLevel: typeof $Enums.CanvasAccessLevel

export type CanvasActivityAction = $Enums.CanvasActivityAction

export const CanvasActivityAction: typeof $Enums.CanvasActivityAction

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type WorkspaceType = $Enums.WorkspaceType

export const WorkspaceType: typeof $Enums.WorkspaceType

export type WorkspaceRole = $Enums.WorkspaceRole

export const WorkspaceRole: typeof $Enums.WorkspaceRole

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type ShareAccessLevel = $Enums.ShareAccessLevel

export const ShareAccessLevel: typeof $Enums.ShareAccessLevel

export type LLMProvider = $Enums.LLMProvider

export const LLMProvider: typeof $Enums.LLMProvider

export type AuthType = $Enums.AuthType

export const AuthType: typeof $Enums.AuthType

export type ShareableAssetType = $Enums.ShareableAssetType

export const ShareableAssetType: typeof $Enums.ShareableAssetType

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSession`: Exposes CRUD operations for the **AdminSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSessions
    * const adminSessions = await prisma.adminSession.findMany()
    * ```
    */
  get adminSession(): Prisma.AdminSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminPermission`: Exposes CRUD operations for the **AdminPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminPermissions
    * const adminPermissions = await prisma.adminPermission.findMany()
    * ```
    */
  get adminPermission(): Prisma.AdminPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAPIKey`: Exposes CRUD operations for the **AdminAPIKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAPIKeys
    * const adminAPIKeys = await prisma.adminAPIKey.findMany()
    * ```
    */
  get adminAPIKey(): Prisma.AdminAPIKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminInvitation`: Exposes CRUD operations for the **AdminInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminInvitations
    * const adminInvitations = await prisma.adminInvitation.findMany()
    * ```
    */
  get adminInvitation(): Prisma.AdminInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSecurityEvent`: Exposes CRUD operations for the **AdminSecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSecurityEvents
    * const adminSecurityEvents = await prisma.adminSecurityEvent.findMany()
    * ```
    */
  get adminSecurityEvent(): Prisma.AdminSecurityEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditPurchase`: Exposes CRUD operations for the **CreditPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditPurchases
    * const creditPurchases = await prisma.creditPurchase.findMany()
    * ```
    */
  get creditPurchase(): Prisma.CreditPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditUsageLog`: Exposes CRUD operations for the **CreditUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditUsageLogs
    * const creditUsageLogs = await prisma.creditUsageLog.findMany()
    * ```
    */
  get creditUsageLog(): Prisma.CreditUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelPricingTier`: Exposes CRUD operations for the **ModelPricingTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelPricingTiers
    * const modelPricingTiers = await prisma.modelPricingTier.findMany()
    * ```
    */
  get modelPricingTier(): Prisma.ModelPricingTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvas`: Exposes CRUD operations for the **Canvas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Canvas
    * const canvas = await prisma.canvas.findMany()
    * ```
    */
  get canvas(): Prisma.CanvasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasInvitation`: Exposes CRUD operations for the **CanvasInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasInvitations
    * const canvasInvitations = await prisma.canvasInvitation.findMany()
    * ```
    */
  get canvasInvitation(): Prisma.CanvasInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasCollaborator`: Exposes CRUD operations for the **CanvasCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasCollaborators
    * const canvasCollaborators = await prisma.canvasCollaborator.findMany()
    * ```
    */
  get canvasCollaborator(): Prisma.CanvasCollaboratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasSession`: Exposes CRUD operations for the **CanvasSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasSessions
    * const canvasSessions = await prisma.canvasSession.findMany()
    * ```
    */
  get canvasSession(): Prisma.CanvasSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasActivityLog`: Exposes CRUD operations for the **CanvasActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasActivityLogs
    * const canvasActivityLogs = await prisma.canvasActivityLog.findMany()
    * ```
    */
  get canvasActivityLog(): Prisma.CanvasActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasComment`: Exposes CRUD operations for the **CanvasComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasComments
    * const canvasComments = await prisma.canvasComment.findMany()
    * ```
    */
  get canvasComment(): Prisma.CanvasCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actionPod`: Exposes CRUD operations for the **ActionPod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionPods
    * const actionPods = await prisma.actionPod.findMany()
    * ```
    */
  get actionPod(): Prisma.ActionPodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edge`: Exposes CRUD operations for the **Edge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Edges
    * const edges = await prisma.edge.findMany()
    * ```
    */
  get edge(): Prisma.EdgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actionPodExecution`: Exposes CRUD operations for the **ActionPodExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionPodExecutions
    * const actionPodExecutions = await prisma.actionPodExecution.findMany()
    * ```
    */
  get actionPodExecution(): Prisma.ActionPodExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podUsageLog`: Exposes CRUD operations for the **PodUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodUsageLogs
    * const podUsageLogs = await prisma.podUsageLog.findMany()
    * ```
    */
  get podUsageLog(): Prisma.PodUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contextModule`: Exposes CRUD operations for the **ContextModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextModules
    * const contextModules = await prisma.contextModule.findMany()
    * ```
    */
  get contextModule(): Prisma.ContextModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceUser`: Exposes CRUD operations for the **WorkspaceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUsers
    * const workspaceUsers = await prisma.workspaceUser.findMany()
    * ```
    */
  get workspaceUser(): Prisma.WorkspaceUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceInvitation`: Exposes CRUD operations for the **WorkspaceInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceInvitations
    * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
    * ```
    */
  get workspaceInvitation(): Prisma.WorkspaceInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerAPIKey`: Exposes CRUD operations for the **ProviderAPIKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderAPIKeys
    * const providerAPIKeys = await prisma.providerAPIKey.findMany()
    * ```
    */
  get providerAPIKey(): Prisma.ProviderAPIKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareLink`: Exposes CRUD operations for the **ShareLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareLinks
    * const shareLinks = await prisma.shareLink.findMany()
    * ```
    */
  get shareLink(): Prisma.ShareLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.embedding`: Exposes CRUD operations for the **Embedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Embeddings
    * const embeddings = await prisma.embedding.findMany()
    * ```
    */
  get embedding(): Prisma.EmbeddingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    AdminSession: 'AdminSession',
    AdminAuditLog: 'AdminAuditLog',
    AdminPermission: 'AdminPermission',
    AdminAPIKey: 'AdminAPIKey',
    AdminInvitation: 'AdminInvitation',
    AdminSecurityEvent: 'AdminSecurityEvent',
    Subscription: 'Subscription',
    CreditPurchase: 'CreditPurchase',
    CreditUsageLog: 'CreditUsageLog',
    ModelPricingTier: 'ModelPricingTier',
    Canvas: 'Canvas',
    CanvasInvitation: 'CanvasInvitation',
    CanvasCollaborator: 'CanvasCollaborator',
    CanvasSession: 'CanvasSession',
    CanvasActivityLog: 'CanvasActivityLog',
    CanvasComment: 'CanvasComment',
    ActionPod: 'ActionPod',
    Edge: 'Edge',
    ActionPodExecution: 'ActionPodExecution',
    PodUsageLog: 'PodUsageLog',
    ContextModule: 'ContextModule',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Account: 'Account',
    Workspace: 'Workspace',
    WorkspaceUser: 'WorkspaceUser',
    WorkspaceInvitation: 'WorkspaceInvitation',
    ProviderAPIKey: 'ProviderAPIKey',
    ShareLink: 'ShareLink',
    Document: 'Document',
    Embedding: 'Embedding'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "adminSession" | "adminAuditLog" | "adminPermission" | "adminAPIKey" | "adminInvitation" | "adminSecurityEvent" | "subscription" | "creditPurchase" | "creditUsageLog" | "modelPricingTier" | "canvas" | "canvasInvitation" | "canvasCollaborator" | "canvasSession" | "canvasActivityLog" | "canvasComment" | "actionPod" | "edge" | "actionPodExecution" | "podUsageLog" | "contextModule" | "user" | "refreshToken" | "account" | "workspace" | "workspaceUser" | "workspaceInvitation" | "providerAPIKey" | "shareLink" | "document" | "embedding"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminSession: {
        payload: Prisma.$AdminSessionPayload<ExtArgs>
        fields: Prisma.AdminSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findFirst: {
            args: Prisma.AdminSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findMany: {
            args: Prisma.AdminSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          create: {
            args: Prisma.AdminSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          createMany: {
            args: Prisma.AdminSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          delete: {
            args: Prisma.AdminSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          update: {
            args: Prisma.AdminSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          deleteMany: {
            args: Prisma.AdminSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          upsert: {
            args: Prisma.AdminSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          aggregate: {
            args: Prisma.AdminSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSession>
          }
          groupBy: {
            args: Prisma.AdminSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      AdminPermission: {
        payload: Prisma.$AdminPermissionPayload<ExtArgs>
        fields: Prisma.AdminPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          findFirst: {
            args: Prisma.AdminPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          findMany: {
            args: Prisma.AdminPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          create: {
            args: Prisma.AdminPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          createMany: {
            args: Prisma.AdminPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          delete: {
            args: Prisma.AdminPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          update: {
            args: Prisma.AdminPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          deleteMany: {
            args: Prisma.AdminPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          upsert: {
            args: Prisma.AdminPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          aggregate: {
            args: Prisma.AdminPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminPermission>
          }
          groupBy: {
            args: Prisma.AdminPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminPermissionCountAggregateOutputType> | number
          }
        }
      }
      AdminAPIKey: {
        payload: Prisma.$AdminAPIKeyPayload<ExtArgs>
        fields: Prisma.AdminAPIKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAPIKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAPIKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          findFirst: {
            args: Prisma.AdminAPIKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAPIKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          findMany: {
            args: Prisma.AdminAPIKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>[]
          }
          create: {
            args: Prisma.AdminAPIKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          createMany: {
            args: Prisma.AdminAPIKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAPIKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>[]
          }
          delete: {
            args: Prisma.AdminAPIKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          update: {
            args: Prisma.AdminAPIKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          deleteMany: {
            args: Prisma.AdminAPIKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAPIKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAPIKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>[]
          }
          upsert: {
            args: Prisma.AdminAPIKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAPIKeyPayload>
          }
          aggregate: {
            args: Prisma.AdminAPIKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAPIKey>
          }
          groupBy: {
            args: Prisma.AdminAPIKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAPIKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAPIKeyCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAPIKeyCountAggregateOutputType> | number
          }
        }
      }
      AdminInvitation: {
        payload: Prisma.$AdminInvitationPayload<ExtArgs>
        fields: Prisma.AdminInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          findFirst: {
            args: Prisma.AdminInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          findMany: {
            args: Prisma.AdminInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>[]
          }
          create: {
            args: Prisma.AdminInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          createMany: {
            args: Prisma.AdminInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>[]
          }
          delete: {
            args: Prisma.AdminInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          update: {
            args: Prisma.AdminInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          deleteMany: {
            args: Prisma.AdminInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>[]
          }
          upsert: {
            args: Prisma.AdminInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminInvitationPayload>
          }
          aggregate: {
            args: Prisma.AdminInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminInvitation>
          }
          groupBy: {
            args: Prisma.AdminInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<AdminInvitationCountAggregateOutputType> | number
          }
        }
      }
      AdminSecurityEvent: {
        payload: Prisma.$AdminSecurityEventPayload<ExtArgs>
        fields: Prisma.AdminSecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          findFirst: {
            args: Prisma.AdminSecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          findMany: {
            args: Prisma.AdminSecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>[]
          }
          create: {
            args: Prisma.AdminSecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          createMany: {
            args: Prisma.AdminSecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>[]
          }
          delete: {
            args: Prisma.AdminSecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          update: {
            args: Prisma.AdminSecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.AdminSecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminSecurityEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>[]
          }
          upsert: {
            args: Prisma.AdminSecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSecurityEventPayload>
          }
          aggregate: {
            args: Prisma.AdminSecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSecurityEvent>
          }
          groupBy: {
            args: Prisma.AdminSecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSecurityEventCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      CreditPurchase: {
        payload: Prisma.$CreditPurchasePayload<ExtArgs>
        fields: Prisma.CreditPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          findFirst: {
            args: Prisma.CreditPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          findMany: {
            args: Prisma.CreditPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>[]
          }
          create: {
            args: Prisma.CreditPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          createMany: {
            args: Prisma.CreditPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditPurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>[]
          }
          delete: {
            args: Prisma.CreditPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          update: {
            args: Prisma.CreditPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          deleteMany: {
            args: Prisma.CreditPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditPurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>[]
          }
          upsert: {
            args: Prisma.CreditPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPurchasePayload>
          }
          aggregate: {
            args: Prisma.CreditPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditPurchase>
          }
          groupBy: {
            args: Prisma.CreditPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<CreditPurchaseCountAggregateOutputType> | number
          }
        }
      }
      CreditUsageLog: {
        payload: Prisma.$CreditUsageLogPayload<ExtArgs>
        fields: Prisma.CreditUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          findFirst: {
            args: Prisma.CreditUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          findMany: {
            args: Prisma.CreditUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>[]
          }
          create: {
            args: Prisma.CreditUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          createMany: {
            args: Prisma.CreditUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>[]
          }
          delete: {
            args: Prisma.CreditUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          update: {
            args: Prisma.CreditUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.CreditUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.CreditUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditUsageLogPayload>
          }
          aggregate: {
            args: Prisma.CreditUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditUsageLog>
          }
          groupBy: {
            args: Prisma.CreditUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<CreditUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ModelPricingTier: {
        payload: Prisma.$ModelPricingTierPayload<ExtArgs>
        fields: Prisma.ModelPricingTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelPricingTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelPricingTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          findFirst: {
            args: Prisma.ModelPricingTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelPricingTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          findMany: {
            args: Prisma.ModelPricingTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>[]
          }
          create: {
            args: Prisma.ModelPricingTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          createMany: {
            args: Prisma.ModelPricingTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelPricingTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>[]
          }
          delete: {
            args: Prisma.ModelPricingTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          update: {
            args: Prisma.ModelPricingTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          deleteMany: {
            args: Prisma.ModelPricingTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelPricingTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelPricingTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>[]
          }
          upsert: {
            args: Prisma.ModelPricingTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingTierPayload>
          }
          aggregate: {
            args: Prisma.ModelPricingTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelPricingTier>
          }
          groupBy: {
            args: Prisma.ModelPricingTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelPricingTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelPricingTierCountArgs<ExtArgs>
            result: $Utils.Optional<ModelPricingTierCountAggregateOutputType> | number
          }
        }
      }
      Canvas: {
        payload: Prisma.$CanvasPayload<ExtArgs>
        fields: Prisma.CanvasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          findFirst: {
            args: Prisma.CanvasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          findMany: {
            args: Prisma.CanvasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>[]
          }
          create: {
            args: Prisma.CanvasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          createMany: {
            args: Prisma.CanvasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>[]
          }
          delete: {
            args: Prisma.CanvasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          update: {
            args: Prisma.CanvasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          deleteMany: {
            args: Prisma.CanvasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>[]
          }
          upsert: {
            args: Prisma.CanvasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          aggregate: {
            args: Prisma.CanvasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvas>
          }
          groupBy: {
            args: Prisma.CanvasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasCountAggregateOutputType> | number
          }
        }
      }
      CanvasInvitation: {
        payload: Prisma.$CanvasInvitationPayload<ExtArgs>
        fields: Prisma.CanvasInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>
          }
          findFirst: {
            args: Prisma.CanvasInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>
          }
          findMany: {
            args: Prisma.CanvasInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>[]
          }
          create: {
            args: Prisma.CanvasInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>
          }
          createMany: {
            args: Prisma.CanvasInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>[]
          }
          delete: {
            args: Prisma.CanvasInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>
          }
          update: {
            args: Prisma.CanvasInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>
          }
          deleteMany: {
            args: Prisma.CanvasInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>[]
          }
          upsert: {
            args: Prisma.CanvasInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasInvitationPayload>
          }
          aggregate: {
            args: Prisma.CanvasInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasInvitation>
          }
          groupBy: {
            args: Prisma.CanvasInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasInvitationCountAggregateOutputType> | number
          }
        }
      }
      CanvasCollaborator: {
        payload: Prisma.$CanvasCollaboratorPayload<ExtArgs>
        fields: Prisma.CanvasCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.CanvasCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>
          }
          findMany: {
            args: Prisma.CanvasCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>[]
          }
          create: {
            args: Prisma.CanvasCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>
          }
          createMany: {
            args: Prisma.CanvasCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.CanvasCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>
          }
          update: {
            args: Prisma.CanvasCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.CanvasCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasCollaboratorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>[]
          }
          upsert: {
            args: Prisma.CanvasCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.CanvasCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasCollaborator>
          }
          groupBy: {
            args: Prisma.CanvasCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasCollaboratorCountAggregateOutputType> | number
          }
        }
      }
      CanvasSession: {
        payload: Prisma.$CanvasSessionPayload<ExtArgs>
        fields: Prisma.CanvasSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>
          }
          findFirst: {
            args: Prisma.CanvasSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>
          }
          findMany: {
            args: Prisma.CanvasSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>[]
          }
          create: {
            args: Prisma.CanvasSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>
          }
          createMany: {
            args: Prisma.CanvasSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>[]
          }
          delete: {
            args: Prisma.CanvasSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>
          }
          update: {
            args: Prisma.CanvasSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>
          }
          deleteMany: {
            args: Prisma.CanvasSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>[]
          }
          upsert: {
            args: Prisma.CanvasSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasSessionPayload>
          }
          aggregate: {
            args: Prisma.CanvasSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasSession>
          }
          groupBy: {
            args: Prisma.CanvasSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasSessionCountAggregateOutputType> | number
          }
        }
      }
      CanvasActivityLog: {
        payload: Prisma.$CanvasActivityLogPayload<ExtArgs>
        fields: Prisma.CanvasActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>
          }
          findFirst: {
            args: Prisma.CanvasActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>
          }
          findMany: {
            args: Prisma.CanvasActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>[]
          }
          create: {
            args: Prisma.CanvasActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>
          }
          createMany: {
            args: Prisma.CanvasActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>[]
          }
          delete: {
            args: Prisma.CanvasActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>
          }
          update: {
            args: Prisma.CanvasActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.CanvasActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.CanvasActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasActivityLogPayload>
          }
          aggregate: {
            args: Prisma.CanvasActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasActivityLog>
          }
          groupBy: {
            args: Prisma.CanvasActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasActivityLogCountAggregateOutputType> | number
          }
        }
      }
      CanvasComment: {
        payload: Prisma.$CanvasCommentPayload<ExtArgs>
        fields: Prisma.CanvasCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>
          }
          findFirst: {
            args: Prisma.CanvasCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>
          }
          findMany: {
            args: Prisma.CanvasCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>[]
          }
          create: {
            args: Prisma.CanvasCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>
          }
          createMany: {
            args: Prisma.CanvasCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>[]
          }
          delete: {
            args: Prisma.CanvasCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>
          }
          update: {
            args: Prisma.CanvasCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>
          }
          deleteMany: {
            args: Prisma.CanvasCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>[]
          }
          upsert: {
            args: Prisma.CanvasCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasCommentPayload>
          }
          aggregate: {
            args: Prisma.CanvasCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasComment>
          }
          groupBy: {
            args: Prisma.CanvasCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasCommentCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasCommentCountAggregateOutputType> | number
          }
        }
      }
      ActionPod: {
        payload: Prisma.$ActionPodPayload<ExtArgs>
        fields: Prisma.ActionPodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionPodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionPodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>
          }
          findFirst: {
            args: Prisma.ActionPodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionPodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>
          }
          findMany: {
            args: Prisma.ActionPodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>[]
          }
          create: {
            args: Prisma.ActionPodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>
          }
          createMany: {
            args: Prisma.ActionPodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionPodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>[]
          }
          delete: {
            args: Prisma.ActionPodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>
          }
          update: {
            args: Prisma.ActionPodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>
          }
          deleteMany: {
            args: Prisma.ActionPodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionPodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionPodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>[]
          }
          upsert: {
            args: Prisma.ActionPodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodPayload>
          }
          aggregate: {
            args: Prisma.ActionPodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionPod>
          }
          groupBy: {
            args: Prisma.ActionPodGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionPodGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionPodCountArgs<ExtArgs>
            result: $Utils.Optional<ActionPodCountAggregateOutputType> | number
          }
        }
      }
      Edge: {
        payload: Prisma.$EdgePayload<ExtArgs>
        fields: Prisma.EdgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EdgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EdgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          findFirst: {
            args: Prisma.EdgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EdgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          findMany: {
            args: Prisma.EdgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]
          }
          create: {
            args: Prisma.EdgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          createMany: {
            args: Prisma.EdgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EdgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]
          }
          delete: {
            args: Prisma.EdgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          update: {
            args: Prisma.EdgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          deleteMany: {
            args: Prisma.EdgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EdgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EdgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]
          }
          upsert: {
            args: Prisma.EdgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgePayload>
          }
          aggregate: {
            args: Prisma.EdgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdge>
          }
          groupBy: {
            args: Prisma.EdgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EdgeCountArgs<ExtArgs>
            result: $Utils.Optional<EdgeCountAggregateOutputType> | number
          }
        }
      }
      ActionPodExecution: {
        payload: Prisma.$ActionPodExecutionPayload<ExtArgs>
        fields: Prisma.ActionPodExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionPodExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionPodExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>
          }
          findFirst: {
            args: Prisma.ActionPodExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionPodExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>
          }
          findMany: {
            args: Prisma.ActionPodExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>[]
          }
          create: {
            args: Prisma.ActionPodExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>
          }
          createMany: {
            args: Prisma.ActionPodExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionPodExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>[]
          }
          delete: {
            args: Prisma.ActionPodExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>
          }
          update: {
            args: Prisma.ActionPodExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>
          }
          deleteMany: {
            args: Prisma.ActionPodExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionPodExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionPodExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>[]
          }
          upsert: {
            args: Prisma.ActionPodExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPodExecutionPayload>
          }
          aggregate: {
            args: Prisma.ActionPodExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionPodExecution>
          }
          groupBy: {
            args: Prisma.ActionPodExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionPodExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionPodExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionPodExecutionCountAggregateOutputType> | number
          }
        }
      }
      PodUsageLog: {
        payload: Prisma.$PodUsageLogPayload<ExtArgs>
        fields: Prisma.PodUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          findFirst: {
            args: Prisma.PodUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          findMany: {
            args: Prisma.PodUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>[]
          }
          create: {
            args: Prisma.PodUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          createMany: {
            args: Prisma.PodUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>[]
          }
          delete: {
            args: Prisma.PodUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          update: {
            args: Prisma.PodUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.PodUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.PodUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodUsageLogPayload>
          }
          aggregate: {
            args: Prisma.PodUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodUsageLog>
          }
          groupBy: {
            args: Prisma.PodUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<PodUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ContextModule: {
        payload: Prisma.$ContextModulePayload<ExtArgs>
        fields: Prisma.ContextModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          findFirst: {
            args: Prisma.ContextModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          findMany: {
            args: Prisma.ContextModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>[]
          }
          create: {
            args: Prisma.ContextModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          createMany: {
            args: Prisma.ContextModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContextModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>[]
          }
          delete: {
            args: Prisma.ContextModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          update: {
            args: Prisma.ContextModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          deleteMany: {
            args: Prisma.ContextModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContextModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContextModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>[]
          }
          upsert: {
            args: Prisma.ContextModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextModulePayload>
          }
          aggregate: {
            args: Prisma.ContextModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContextModule>
          }
          groupBy: {
            args: Prisma.ContextModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContextModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ContextModuleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUser: {
        payload: Prisma.$WorkspaceUserPayload<ExtArgs>
        fields: Prisma.WorkspaceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          update: {
            args: Prisma.WorkspaceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUser>
          }
          groupBy: {
            args: Prisma.WorkspaceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceInvitation: {
        payload: Prisma.$WorkspaceInvitationPayload<ExtArgs>
        fields: Prisma.WorkspaceInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          update: {
            args: Prisma.WorkspaceInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceInvitation>
          }
          groupBy: {
            args: Prisma.WorkspaceInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationCountAggregateOutputType> | number
          }
        }
      }
      ProviderAPIKey: {
        payload: Prisma.$ProviderAPIKeyPayload<ExtArgs>
        fields: Prisma.ProviderAPIKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderAPIKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderAPIKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          findFirst: {
            args: Prisma.ProviderAPIKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderAPIKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          findMany: {
            args: Prisma.ProviderAPIKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>[]
          }
          create: {
            args: Prisma.ProviderAPIKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          createMany: {
            args: Prisma.ProviderAPIKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderAPIKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>[]
          }
          delete: {
            args: Prisma.ProviderAPIKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          update: {
            args: Prisma.ProviderAPIKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          deleteMany: {
            args: Prisma.ProviderAPIKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderAPIKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderAPIKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>[]
          }
          upsert: {
            args: Prisma.ProviderAPIKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderAPIKeyPayload>
          }
          aggregate: {
            args: Prisma.ProviderAPIKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderAPIKey>
          }
          groupBy: {
            args: Prisma.ProviderAPIKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderAPIKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderAPIKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderAPIKeyCountAggregateOutputType> | number
          }
        }
      }
      ShareLink: {
        payload: Prisma.$ShareLinkPayload<ExtArgs>
        fields: Prisma.ShareLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          findFirst: {
            args: Prisma.ShareLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          findMany: {
            args: Prisma.ShareLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          create: {
            args: Prisma.ShareLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          createMany: {
            args: Prisma.ShareLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          delete: {
            args: Prisma.ShareLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          update: {
            args: Prisma.ShareLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          deleteMany: {
            args: Prisma.ShareLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShareLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          upsert: {
            args: Prisma.ShareLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          aggregate: {
            args: Prisma.ShareLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareLink>
          }
          groupBy: {
            args: Prisma.ShareLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ShareLinkCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Embedding: {
        payload: Prisma.$EmbeddingPayload<ExtArgs>
        fields: Prisma.EmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          findFirst: {
            args: Prisma.EmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          findMany: {
            args: Prisma.EmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          create: {
            args: Prisma.EmbeddingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          createMany: {
            args: Prisma.EmbeddingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmbeddingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          delete: {
            args: Prisma.EmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          update: {
            args: Prisma.EmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.EmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          upsert: {
            args: Prisma.EmbeddingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          aggregate: {
            args: Prisma.EmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmbedding>
          }
          groupBy: {
            args: Prisma.EmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    adminSession?: AdminSessionOmit
    adminAuditLog?: AdminAuditLogOmit
    adminPermission?: AdminPermissionOmit
    adminAPIKey?: AdminAPIKeyOmit
    adminInvitation?: AdminInvitationOmit
    adminSecurityEvent?: AdminSecurityEventOmit
    subscription?: SubscriptionOmit
    creditPurchase?: CreditPurchaseOmit
    creditUsageLog?: CreditUsageLogOmit
    modelPricingTier?: ModelPricingTierOmit
    canvas?: CanvasOmit
    canvasInvitation?: CanvasInvitationOmit
    canvasCollaborator?: CanvasCollaboratorOmit
    canvasSession?: CanvasSessionOmit
    canvasActivityLog?: CanvasActivityLogOmit
    canvasComment?: CanvasCommentOmit
    actionPod?: ActionPodOmit
    edge?: EdgeOmit
    actionPodExecution?: ActionPodExecutionOmit
    podUsageLog?: PodUsageLogOmit
    contextModule?: ContextModuleOmit
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    account?: AccountOmit
    workspace?: WorkspaceOmit
    workspaceUser?: WorkspaceUserOmit
    workspaceInvitation?: WorkspaceInvitationOmit
    providerAPIKey?: ProviderAPIKeyOmit
    shareLink?: ShareLinkOmit
    document?: DocumentOmit
    embedding?: EmbeddingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    sessions: number
    auditLogs: number
    permissions: number
    apiKeys: number
    invitations: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AdminCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | AdminCountOutputTypeCountAuditLogsArgs
    permissions?: boolean | AdminCountOutputTypeCountPermissionsArgs
    apiKeys?: boolean | AdminCountOutputTypeCountApiKeysArgs
    invitations?: boolean | AdminCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPermissionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAPIKeyWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminInvitationWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    usageLogs: number
    creditPurchases: number
    creditUsage: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | SubscriptionCountOutputTypeCountUsageLogsArgs
    creditPurchases?: boolean | SubscriptionCountOutputTypeCountCreditPurchasesArgs
    creditUsage?: boolean | SubscriptionCountOutputTypeCountCreditUsageArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodUsageLogWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountCreditPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPurchaseWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountCreditUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditUsageLogWhereInput
  }


  /**
   * Count Type CanvasCountOutputType
   */

  export type CanvasCountOutputType = {
    actionPods: number
    edges: number
    contextualPods: number
    contextModules: number
    collaborators: number
    invitations: number
    sessions: number
    activityLog: number
    comments: number
  }

  export type CanvasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionPods?: boolean | CanvasCountOutputTypeCountActionPodsArgs
    edges?: boolean | CanvasCountOutputTypeCountEdgesArgs
    contextualPods?: boolean | CanvasCountOutputTypeCountContextualPodsArgs
    contextModules?: boolean | CanvasCountOutputTypeCountContextModulesArgs
    collaborators?: boolean | CanvasCountOutputTypeCountCollaboratorsArgs
    invitations?: boolean | CanvasCountOutputTypeCountInvitationsArgs
    sessions?: boolean | CanvasCountOutputTypeCountSessionsArgs
    activityLog?: boolean | CanvasCountOutputTypeCountActivityLogArgs
    comments?: boolean | CanvasCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCountOutputType
     */
    select?: CanvasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountActionPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPodWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountContextualPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPodWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountContextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextModuleWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasCollaboratorWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasInvitationWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasSessionWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasActivityLogWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasCommentWhereInput
  }


  /**
   * Count Type ActionPodCountOutputType
   */

  export type ActionPodCountOutputType = {
    sourceEdges: number
    targetEdges: number
    executions: number
    usageLogs: number
  }

  export type ActionPodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceEdges?: boolean | ActionPodCountOutputTypeCountSourceEdgesArgs
    targetEdges?: boolean | ActionPodCountOutputTypeCountTargetEdgesArgs
    executions?: boolean | ActionPodCountOutputTypeCountExecutionsArgs
    usageLogs?: boolean | ActionPodCountOutputTypeCountUsageLogsArgs
  }

  // Custom InputTypes
  /**
   * ActionPodCountOutputType without action
   */
  export type ActionPodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodCountOutputType
     */
    select?: ActionPodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionPodCountOutputType without action
   */
  export type ActionPodCountOutputTypeCountSourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
  }

  /**
   * ActionPodCountOutputType without action
   */
  export type ActionPodCountOutputTypeCountTargetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
  }

  /**
   * ActionPodCountOutputType without action
   */
  export type ActionPodCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPodExecutionWhereInput
  }

  /**
   * ActionPodCountOutputType without action
   */
  export type ActionPodCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodUsageLogWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    workspaces: number
    refreshTokens: number
    canvasCollaborations: number
    sentWorkspaceInvites: number
    receivedWorkspaceInvites: number
    sentCanvasInvites: number
    receivedCanvasInvites: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    canvasCollaborations?: boolean | UserCountOutputTypeCountCanvasCollaborationsArgs
    sentWorkspaceInvites?: boolean | UserCountOutputTypeCountSentWorkspaceInvitesArgs
    receivedWorkspaceInvites?: boolean | UserCountOutputTypeCountReceivedWorkspaceInvitesArgs
    sentCanvasInvites?: boolean | UserCountOutputTypeCountSentCanvasInvitesArgs
    receivedCanvasInvites?: boolean | UserCountOutputTypeCountReceivedCanvasInvitesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCanvasCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasCollaboratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentCanvasInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedCanvasInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasInvitationWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    members: number
    canvases: number
    documents: number
    contextModules: number
    shareLinks: number
    apiKeys: number
    invitations: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceCountOutputTypeCountMembersArgs
    canvases?: boolean | WorkspaceCountOutputTypeCountCanvasesArgs
    documents?: boolean | WorkspaceCountOutputTypeCountDocumentsArgs
    contextModules?: boolean | WorkspaceCountOutputTypeCountContextModulesArgs
    shareLinks?: boolean | WorkspaceCountOutputTypeCountShareLinksArgs
    apiKeys?: boolean | WorkspaceCountOutputTypeCountApiKeysArgs
    invitations?: boolean | WorkspaceCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountCanvasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountContextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextModuleWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountShareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderAPIKeyWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    embeddings: number
    actionPods: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | DocumentCountOutputTypeCountEmbeddingsArgs
    actionPods?: boolean | DocumentCountOutputTypeCountActionPodsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountEmbeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbeddingWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountActionPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPodWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type AdminSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.AdminRole | null
    status: $Enums.AdminStatus | null
    isSuperAdmin: boolean | null
    requiresMfa: boolean | null
    mfaSecret: string | null
    mfaVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    deactivatedAt: Date | null
    deactivatedBy: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.AdminRole | null
    status: $Enums.AdminStatus | null
    isSuperAdmin: boolean | null
    requiresMfa: boolean | null
    mfaSecret: string | null
    mfaVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    deactivatedAt: Date | null
    deactivatedBy: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    role: number
    status: number
    isSuperAdmin: number
    requiresMfa: number
    mfaSecret: number
    mfaBackupCodes: number
    mfaVerifiedAt: number
    allowedIpAddresses: number
    lastLoginAt: number
    lastLoginIp: number
    failedLoginAttempts: number
    lockedUntil: number
    passwordChangedAt: number
    passwordResetToken: number
    passwordResetExpiry: number
    createdAt: number
    updatedAt: number
    createdBy: number
    deactivatedAt: number
    deactivatedBy: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type AdminSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    status?: true
    isSuperAdmin?: true
    requiresMfa?: true
    mfaSecret?: true
    mfaVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    status?: true
    isSuperAdmin?: true
    requiresMfa?: true
    mfaSecret?: true
    mfaVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    status?: true
    isSuperAdmin?: true
    requiresMfa?: true
    mfaSecret?: true
    mfaBackupCodes?: true
    mfaVerifiedAt?: true
    allowedIpAddresses?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    role: $Enums.AdminRole
    status: $Enums.AdminStatus
    isSuperAdmin: boolean
    requiresMfa: boolean
    mfaSecret: string | null
    mfaBackupCodes: JsonValue | null
    mfaVerifiedAt: Date | null
    allowedIpAddresses: JsonValue | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginAttempts: number
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    deactivatedAt: Date | null
    deactivatedBy: string | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
    sessions?: boolean | Admin$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Admin$auditLogsArgs<ExtArgs>
    permissions?: boolean | Admin$permissionsArgs<ExtArgs>
    apiKeys?: boolean | Admin$apiKeysArgs<ExtArgs>
    invitations?: boolean | Admin$invitationsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    mfaVerifiedAt?: boolean
    allowedIpAddresses?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "passwordHash" | "role" | "status" | "isSuperAdmin" | "requiresMfa" | "mfaSecret" | "mfaBackupCodes" | "mfaVerifiedAt" | "allowedIpAddresses" | "lastLoginAt" | "lastLoginIp" | "failedLoginAttempts" | "lockedUntil" | "passwordChangedAt" | "passwordResetToken" | "passwordResetExpiry" | "createdAt" | "updatedAt" | "createdBy" | "deactivatedAt" | "deactivatedBy", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Admin$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Admin$auditLogsArgs<ExtArgs>
    permissions?: boolean | Admin$permissionsArgs<ExtArgs>
    apiKeys?: boolean | Admin$apiKeysArgs<ExtArgs>
    invitations?: boolean | Admin$invitationsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      sessions: Prisma.$AdminSessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
      permissions: Prisma.$AdminPermissionPayload<ExtArgs>[]
      apiKeys: Prisma.$AdminAPIKeyPayload<ExtArgs>[]
      invitations: Prisma.$AdminInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      role: $Enums.AdminRole
      status: $Enums.AdminStatus
      isSuperAdmin: boolean
      requiresMfa: boolean
      mfaSecret: string | null
      mfaBackupCodes: Prisma.JsonValue | null
      mfaVerifiedAt: Date | null
      allowedIpAddresses: Prisma.JsonValue | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedLoginAttempts: number
      lockedUntil: Date | null
      passwordChangedAt: Date | null
      passwordResetToken: string | null
      passwordResetExpiry: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      deactivatedAt: Date | null
      deactivatedBy: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Admin$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Admin$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Admin$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends Admin$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Admin$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Admin$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly passwordHash: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'AdminRole'>
    readonly status: FieldRef<"Admin", 'AdminStatus'>
    readonly isSuperAdmin: FieldRef<"Admin", 'Boolean'>
    readonly requiresMfa: FieldRef<"Admin", 'Boolean'>
    readonly mfaSecret: FieldRef<"Admin", 'String'>
    readonly mfaBackupCodes: FieldRef<"Admin", 'Json'>
    readonly mfaVerifiedAt: FieldRef<"Admin", 'DateTime'>
    readonly allowedIpAddresses: FieldRef<"Admin", 'Json'>
    readonly lastLoginAt: FieldRef<"Admin", 'DateTime'>
    readonly lastLoginIp: FieldRef<"Admin", 'String'>
    readonly failedLoginAttempts: FieldRef<"Admin", 'Int'>
    readonly lockedUntil: FieldRef<"Admin", 'DateTime'>
    readonly passwordChangedAt: FieldRef<"Admin", 'DateTime'>
    readonly passwordResetToken: FieldRef<"Admin", 'String'>
    readonly passwordResetExpiry: FieldRef<"Admin", 'DateTime'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly createdBy: FieldRef<"Admin", 'String'>
    readonly deactivatedAt: FieldRef<"Admin", 'DateTime'>
    readonly deactivatedBy: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.sessions
   */
  export type Admin$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    cursor?: AdminSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * Admin.auditLogs
   */
  export type Admin$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * Admin.permissions
   */
  export type Admin$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    where?: AdminPermissionWhereInput
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    cursor?: AdminPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * Admin.apiKeys
   */
  export type Admin$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    where?: AdminAPIKeyWhereInput
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    cursor?: AdminAPIKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * Admin.invitations
   */
  export type Admin$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    where?: AdminInvitationWhereInput
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    cursor?: AdminInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model AdminSession
   */

  export type AggregateAdminSession = {
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  export type AdminSessionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    createdAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    revokedAt: Date | null
    revokedReason: string | null
  }

  export type AdminSessionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    createdAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    revokedAt: Date | null
    revokedReason: string | null
  }

  export type AdminSessionCountAggregateOutputType = {
    id: number
    adminId: number
    token: number
    refreshToken: number
    ipAddress: number
    userAgent: number
    deviceFingerprint: number
    createdAt: number
    expiresAt: number
    lastActivityAt: number
    revokedAt: number
    revokedReason: number
    _all: number
  }


  export type AdminSessionMinAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    createdAt?: true
    expiresAt?: true
    lastActivityAt?: true
    revokedAt?: true
    revokedReason?: true
  }

  export type AdminSessionMaxAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    createdAt?: true
    expiresAt?: true
    lastActivityAt?: true
    revokedAt?: true
    revokedReason?: true
  }

  export type AdminSessionCountAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    createdAt?: true
    expiresAt?: true
    lastActivityAt?: true
    revokedAt?: true
    revokedReason?: true
    _all?: true
  }

  export type AdminSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSession to aggregate.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSessions
    **/
    _count?: true | AdminSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSessionMaxAggregateInputType
  }

  export type GetAdminSessionAggregateType<T extends AdminSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSession[P]>
      : GetScalarType<T[P], AggregateAdminSession[P]>
  }




  export type AdminSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithAggregationInput | AdminSessionOrderByWithAggregationInput[]
    by: AdminSessionScalarFieldEnum[] | AdminSessionScalarFieldEnum
    having?: AdminSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSessionCountAggregateInputType | true
    _min?: AdminSessionMinAggregateInputType
    _max?: AdminSessionMaxAggregateInputType
  }

  export type AdminSessionGroupByOutputType = {
    id: string
    adminId: string
    token: string
    refreshToken: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint: string | null
    createdAt: Date
    expiresAt: Date
    lastActivityAt: Date
    revokedAt: Date | null
    revokedReason: string | null
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  type GetAdminSessionGroupByPayload<T extends AdminSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
        }
      >
    >


  export type AdminSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectScalar = {
    id?: boolean
    adminId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
  }

  export type AdminSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "token" | "refreshToken" | "ipAddress" | "userAgent" | "deviceFingerprint" | "createdAt" | "expiresAt" | "lastActivityAt" | "revokedAt" | "revokedReason", ExtArgs["result"]["adminSession"]>
  export type AdminSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSession"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      token: string
      refreshToken: string | null
      ipAddress: string
      userAgent: string
      deviceFingerprint: string | null
      createdAt: Date
      expiresAt: Date
      lastActivityAt: Date
      revokedAt: Date | null
      revokedReason: string | null
    }, ExtArgs["result"]["adminSession"]>
    composites: {}
  }

  type AdminSessionGetPayload<S extends boolean | null | undefined | AdminSessionDefaultArgs> = $Result.GetResult<Prisma.$AdminSessionPayload, S>

  type AdminSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminSessionCountAggregateInputType | true
    }

  export interface AdminSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSession'], meta: { name: 'AdminSession' } }
    /**
     * Find zero or one AdminSession that matches the filter.
     * @param {AdminSessionFindUniqueArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSessionFindUniqueArgs>(args: SelectSubset<T, AdminSessionFindUniqueArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSessionFindUniqueOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSessionFindFirstArgs>(args?: SelectSubset<T, AdminSessionFindFirstArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSessions
     * const adminSessions = await prisma.adminSession.findMany()
     * 
     * // Get first 10 AdminSessions
     * const adminSessions = await prisma.adminSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSessionFindManyArgs>(args?: SelectSubset<T, AdminSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminSession.
     * @param {AdminSessionCreateArgs} args - Arguments to create a AdminSession.
     * @example
     * // Create one AdminSession
     * const AdminSession = await prisma.adminSession.create({
     *   data: {
     *     // ... data to create a AdminSession
     *   }
     * })
     * 
     */
    create<T extends AdminSessionCreateArgs>(args: SelectSubset<T, AdminSessionCreateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminSessions.
     * @param {AdminSessionCreateManyArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSessionCreateManyArgs>(args?: SelectSubset<T, AdminSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSessions and returns the data saved in the database.
     * @param {AdminSessionCreateManyAndReturnArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminSession.
     * @param {AdminSessionDeleteArgs} args - Arguments to delete one AdminSession.
     * @example
     * // Delete one AdminSession
     * const AdminSession = await prisma.adminSession.delete({
     *   where: {
     *     // ... filter to delete one AdminSession
     *   }
     * })
     * 
     */
    delete<T extends AdminSessionDeleteArgs>(args: SelectSubset<T, AdminSessionDeleteArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminSession.
     * @param {AdminSessionUpdateArgs} args - Arguments to update one AdminSession.
     * @example
     * // Update one AdminSession
     * const adminSession = await prisma.adminSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSessionUpdateArgs>(args: SelectSubset<T, AdminSessionUpdateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminSessions.
     * @param {AdminSessionDeleteManyArgs} args - Arguments to filter AdminSessions to delete.
     * @example
     * // Delete a few AdminSessions
     * const { count } = await prisma.adminSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSessionDeleteManyArgs>(args?: SelectSubset<T, AdminSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSessionUpdateManyArgs>(args: SelectSubset<T, AdminSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions and returns the data updated in the database.
     * @param {AdminSessionUpdateManyAndReturnArgs} args - Arguments to update many AdminSessions.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminSession.
     * @param {AdminSessionUpsertArgs} args - Arguments to update or create a AdminSession.
     * @example
     * // Update or create a AdminSession
     * const adminSession = await prisma.adminSession.upsert({
     *   create: {
     *     // ... data to create a AdminSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSession we want to update
     *   }
     * })
     */
    upsert<T extends AdminSessionUpsertArgs>(args: SelectSubset<T, AdminSessionUpsertArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionCountArgs} args - Arguments to filter AdminSessions to count.
     * @example
     * // Count the number of AdminSessions
     * const count = await prisma.adminSession.count({
     *   where: {
     *     // ... the filter for the AdminSessions we want to count
     *   }
     * })
    **/
    count<T extends AdminSessionCountArgs>(
      args?: Subset<T, AdminSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSessionAggregateArgs>(args: Subset<T, AdminSessionAggregateArgs>): Prisma.PrismaPromise<GetAdminSessionAggregateType<T>>

    /**
     * Group by AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSessionGroupByArgs['orderBy'] }
        : { orderBy?: AdminSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSession model
   */
  readonly fields: AdminSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSession model
   */
  interface AdminSessionFieldRefs {
    readonly id: FieldRef<"AdminSession", 'String'>
    readonly adminId: FieldRef<"AdminSession", 'String'>
    readonly token: FieldRef<"AdminSession", 'String'>
    readonly refreshToken: FieldRef<"AdminSession", 'String'>
    readonly ipAddress: FieldRef<"AdminSession", 'String'>
    readonly userAgent: FieldRef<"AdminSession", 'String'>
    readonly deviceFingerprint: FieldRef<"AdminSession", 'String'>
    readonly createdAt: FieldRef<"AdminSession", 'DateTime'>
    readonly expiresAt: FieldRef<"AdminSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"AdminSession", 'DateTime'>
    readonly revokedAt: FieldRef<"AdminSession", 'DateTime'>
    readonly revokedReason: FieldRef<"AdminSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminSession findUnique
   */
  export type AdminSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findUniqueOrThrow
   */
  export type AdminSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findFirst
   */
  export type AdminSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findFirstOrThrow
   */
  export type AdminSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findMany
   */
  export type AdminSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSessions to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession create
   */
  export type AdminSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminSession.
     */
    data: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
  }

  /**
   * AdminSession createMany
   */
  export type AdminSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSession createManyAndReturn
   */
  export type AdminSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession update
   */
  export type AdminSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminSession.
     */
    data: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
    /**
     * Choose, which AdminSession to update.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession updateMany
   */
  export type AdminSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to update.
     */
    limit?: number
  }

  /**
   * AdminSession updateManyAndReturn
   */
  export type AdminSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession upsert
   */
  export type AdminSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminSession to update in case it exists.
     */
    where: AdminSessionWhereUniqueInput
    /**
     * In case the AdminSession found by the `where` argument doesn't exist, create a new AdminSession with this data.
     */
    create: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
    /**
     * In case the AdminSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
  }

  /**
   * AdminSession delete
   */
  export type AdminSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter which AdminSession to delete.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession deleteMany
   */
  export type AdminSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSessions to delete
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to delete.
     */
    limit?: number
  }

  /**
   * AdminSession without action
   */
  export type AdminSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _avg: AdminAuditLogAvgAggregateOutputType | null
    _sum: AdminAuditLogSumAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogAvgAggregateOutputType = {
    status: number | null
    executionTimeMs: number | null
  }

  export type AdminAuditLogSumAggregateOutputType = {
    status: number | null
    executionTimeMs: number | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: $Enums.AdminAction | null
    resource: $Enums.AdminResource | null
    resourceId: string | null
    method: string | null
    endpoint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: number | null
    errorMessage: string | null
    executionTimeMs: number | null
    createdAt: Date | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: $Enums.AdminAction | null
    resource: $Enums.AdminResource | null
    resourceId: string | null
    method: string | null
    endpoint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: number | null
    errorMessage: string | null
    executionTimeMs: number | null
    createdAt: Date | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    resource: number
    resourceId: number
    method: number
    endpoint: number
    ipAddress: number
    userAgent: number
    changesBefore: number
    changesAfter: number
    status: number
    errorMessage: number
    metadata: number
    executionTimeMs: number
    createdAt: number
    _all: number
  }


  export type AdminAuditLogAvgAggregateInputType = {
    status?: true
    executionTimeMs?: true
  }

  export type AdminAuditLogSumAggregateInputType = {
    status?: true
    executionTimeMs?: true
  }

  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    method?: true
    endpoint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    method?: true
    endpoint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    method?: true
    endpoint?: true
    ipAddress?: true
    userAgent?: true
    changesBefore?: true
    changesAfter?: true
    status?: true
    errorMessage?: true
    metadata?: true
    executionTimeMs?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _avg?: AdminAuditLogAvgAggregateInputType
    _sum?: AdminAuditLogSumAggregateInputType
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    adminId: string | null
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent: string | null
    changesBefore: JsonValue | null
    changesAfter: JsonValue | null
    status: number
    errorMessage: string | null
    metadata: JsonValue | null
    executionTimeMs: number | null
    createdAt: Date
    _count: AdminAuditLogCountAggregateOutputType | null
    _avg: AdminAuditLogAvgAggregateOutputType | null
    _sum: AdminAuditLogSumAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    method?: boolean
    endpoint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changesBefore?: boolean
    changesAfter?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
  }

  export type AdminAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "resource" | "resourceId" | "method" | "endpoint" | "ipAddress" | "userAgent" | "changesBefore" | "changesAfter" | "status" | "errorMessage" | "metadata" | "executionTimeMs" | "createdAt", ExtArgs["result"]["adminAuditLog"]>
  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAuditLog$adminArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string | null
      action: $Enums.AdminAction
      resource: $Enums.AdminResource
      resourceId: string | null
      method: string
      endpoint: string
      ipAddress: string
      userAgent: string | null
      changesBefore: Prisma.JsonValue | null
      changesAfter: Prisma.JsonValue | null
      status: number
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      executionTimeMs: number | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs and returns the data updated in the database.
     * @param {AdminAuditLogUpdateManyAndReturnArgs} args - Arguments to update many AdminAuditLogs.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminAuditLog$adminArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuditLog$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly adminId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'AdminAction'>
    readonly resource: FieldRef<"AdminAuditLog", 'AdminResource'>
    readonly resourceId: FieldRef<"AdminAuditLog", 'String'>
    readonly method: FieldRef<"AdminAuditLog", 'String'>
    readonly endpoint: FieldRef<"AdminAuditLog", 'String'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
    readonly userAgent: FieldRef<"AdminAuditLog", 'String'>
    readonly changesBefore: FieldRef<"AdminAuditLog", 'Json'>
    readonly changesAfter: FieldRef<"AdminAuditLog", 'Json'>
    readonly status: FieldRef<"AdminAuditLog", 'Int'>
    readonly errorMessage: FieldRef<"AdminAuditLog", 'String'>
    readonly metadata: FieldRef<"AdminAuditLog", 'Json'>
    readonly executionTimeMs: FieldRef<"AdminAuditLog", 'Int'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
  }

  /**
   * AdminAuditLog updateManyAndReturn
   */
  export type AdminAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminAuditLog.admin
   */
  export type AdminAuditLog$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AdminPermission
   */

  export type AggregateAdminPermission = {
    _count: AdminPermissionCountAggregateOutputType | null
    _min: AdminPermissionMinAggregateOutputType | null
    _max: AdminPermissionMaxAggregateOutputType | null
  }

  export type AdminPermissionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    permission: $Enums.SpecificPermission | null
    resource: $Enums.AdminResource | null
    grantedAt: Date | null
    grantedBy: string | null
    expiresAt: Date | null
  }

  export type AdminPermissionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    permission: $Enums.SpecificPermission | null
    resource: $Enums.AdminResource | null
    grantedAt: Date | null
    grantedBy: string | null
    expiresAt: Date | null
  }

  export type AdminPermissionCountAggregateOutputType = {
    id: number
    adminId: number
    permission: number
    resource: number
    grantedAt: number
    grantedBy: number
    expiresAt: number
    _all: number
  }


  export type AdminPermissionMinAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    resource?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
  }

  export type AdminPermissionMaxAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    resource?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
  }

  export type AdminPermissionCountAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    resource?: true
    grantedAt?: true
    grantedBy?: true
    expiresAt?: true
    _all?: true
  }

  export type AdminPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPermission to aggregate.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminPermissions
    **/
    _count?: true | AdminPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminPermissionMaxAggregateInputType
  }

  export type GetAdminPermissionAggregateType<T extends AdminPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminPermission[P]>
      : GetScalarType<T[P], AggregateAdminPermission[P]>
  }




  export type AdminPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPermissionWhereInput
    orderBy?: AdminPermissionOrderByWithAggregationInput | AdminPermissionOrderByWithAggregationInput[]
    by: AdminPermissionScalarFieldEnum[] | AdminPermissionScalarFieldEnum
    having?: AdminPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminPermissionCountAggregateInputType | true
    _min?: AdminPermissionMinAggregateInputType
    _max?: AdminPermissionMaxAggregateInputType
  }

  export type AdminPermissionGroupByOutputType = {
    id: string
    adminId: string
    permission: $Enums.SpecificPermission
    resource: $Enums.AdminResource | null
    grantedAt: Date
    grantedBy: string | null
    expiresAt: Date | null
    _count: AdminPermissionCountAggregateOutputType | null
    _min: AdminPermissionMinAggregateOutputType | null
    _max: AdminPermissionMaxAggregateOutputType | null
  }

  type GetAdminPermissionGroupByPayload<T extends AdminPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminPermissionGroupByOutputType[P]>
        }
      >
    >


  export type AdminPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectScalar = {
    id?: boolean
    adminId?: boolean
    permission?: boolean
    resource?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    expiresAt?: boolean
  }

  export type AdminPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "permission" | "resource" | "grantedAt" | "grantedBy" | "expiresAt", ExtArgs["result"]["adminPermission"]>
  export type AdminPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminPermission"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      permission: $Enums.SpecificPermission
      resource: $Enums.AdminResource | null
      grantedAt: Date
      grantedBy: string | null
      expiresAt: Date | null
    }, ExtArgs["result"]["adminPermission"]>
    composites: {}
  }

  type AdminPermissionGetPayload<S extends boolean | null | undefined | AdminPermissionDefaultArgs> = $Result.GetResult<Prisma.$AdminPermissionPayload, S>

  type AdminPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminPermissionCountAggregateInputType | true
    }

  export interface AdminPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminPermission'], meta: { name: 'AdminPermission' } }
    /**
     * Find zero or one AdminPermission that matches the filter.
     * @param {AdminPermissionFindUniqueArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminPermissionFindUniqueArgs>(args: SelectSubset<T, AdminPermissionFindUniqueArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminPermissionFindUniqueOrThrowArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindFirstArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminPermissionFindFirstArgs>(args?: SelectSubset<T, AdminPermissionFindFirstArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindFirstOrThrowArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminPermissions
     * const adminPermissions = await prisma.adminPermission.findMany()
     * 
     * // Get first 10 AdminPermissions
     * const adminPermissions = await prisma.adminPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminPermissionFindManyArgs>(args?: SelectSubset<T, AdminPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminPermission.
     * @param {AdminPermissionCreateArgs} args - Arguments to create a AdminPermission.
     * @example
     * // Create one AdminPermission
     * const AdminPermission = await prisma.adminPermission.create({
     *   data: {
     *     // ... data to create a AdminPermission
     *   }
     * })
     * 
     */
    create<T extends AdminPermissionCreateArgs>(args: SelectSubset<T, AdminPermissionCreateArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminPermissions.
     * @param {AdminPermissionCreateManyArgs} args - Arguments to create many AdminPermissions.
     * @example
     * // Create many AdminPermissions
     * const adminPermission = await prisma.adminPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminPermissionCreateManyArgs>(args?: SelectSubset<T, AdminPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminPermissions and returns the data saved in the database.
     * @param {AdminPermissionCreateManyAndReturnArgs} args - Arguments to create many AdminPermissions.
     * @example
     * // Create many AdminPermissions
     * const adminPermission = await prisma.adminPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminPermissions and only return the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminPermission.
     * @param {AdminPermissionDeleteArgs} args - Arguments to delete one AdminPermission.
     * @example
     * // Delete one AdminPermission
     * const AdminPermission = await prisma.adminPermission.delete({
     *   where: {
     *     // ... filter to delete one AdminPermission
     *   }
     * })
     * 
     */
    delete<T extends AdminPermissionDeleteArgs>(args: SelectSubset<T, AdminPermissionDeleteArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminPermission.
     * @param {AdminPermissionUpdateArgs} args - Arguments to update one AdminPermission.
     * @example
     * // Update one AdminPermission
     * const adminPermission = await prisma.adminPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminPermissionUpdateArgs>(args: SelectSubset<T, AdminPermissionUpdateArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminPermissions.
     * @param {AdminPermissionDeleteManyArgs} args - Arguments to filter AdminPermissions to delete.
     * @example
     * // Delete a few AdminPermissions
     * const { count } = await prisma.adminPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminPermissionDeleteManyArgs>(args?: SelectSubset<T, AdminPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminPermissions
     * const adminPermission = await prisma.adminPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminPermissionUpdateManyArgs>(args: SelectSubset<T, AdminPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPermissions and returns the data updated in the database.
     * @param {AdminPermissionUpdateManyAndReturnArgs} args - Arguments to update many AdminPermissions.
     * @example
     * // Update many AdminPermissions
     * const adminPermission = await prisma.adminPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminPermissions and only return the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminPermission.
     * @param {AdminPermissionUpsertArgs} args - Arguments to update or create a AdminPermission.
     * @example
     * // Update or create a AdminPermission
     * const adminPermission = await prisma.adminPermission.upsert({
     *   create: {
     *     // ... data to create a AdminPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminPermission we want to update
     *   }
     * })
     */
    upsert<T extends AdminPermissionUpsertArgs>(args: SelectSubset<T, AdminPermissionUpsertArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionCountArgs} args - Arguments to filter AdminPermissions to count.
     * @example
     * // Count the number of AdminPermissions
     * const count = await prisma.adminPermission.count({
     *   where: {
     *     // ... the filter for the AdminPermissions we want to count
     *   }
     * })
    **/
    count<T extends AdminPermissionCountArgs>(
      args?: Subset<T, AdminPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminPermissionAggregateArgs>(args: Subset<T, AdminPermissionAggregateArgs>): Prisma.PrismaPromise<GetAdminPermissionAggregateType<T>>

    /**
     * Group by AdminPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminPermissionGroupByArgs['orderBy'] }
        : { orderBy?: AdminPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminPermission model
   */
  readonly fields: AdminPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminPermission model
   */
  interface AdminPermissionFieldRefs {
    readonly id: FieldRef<"AdminPermission", 'String'>
    readonly adminId: FieldRef<"AdminPermission", 'String'>
    readonly permission: FieldRef<"AdminPermission", 'SpecificPermission'>
    readonly resource: FieldRef<"AdminPermission", 'AdminResource'>
    readonly grantedAt: FieldRef<"AdminPermission", 'DateTime'>
    readonly grantedBy: FieldRef<"AdminPermission", 'String'>
    readonly expiresAt: FieldRef<"AdminPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminPermission findUnique
   */
  export type AdminPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission findUniqueOrThrow
   */
  export type AdminPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission findFirst
   */
  export type AdminPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPermissions.
     */
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission findFirstOrThrow
   */
  export type AdminPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPermissions.
     */
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission findMany
   */
  export type AdminPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermissions to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission create
   */
  export type AdminPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminPermission.
     */
    data: XOR<AdminPermissionCreateInput, AdminPermissionUncheckedCreateInput>
  }

  /**
   * AdminPermission createMany
   */
  export type AdminPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminPermissions.
     */
    data: AdminPermissionCreateManyInput | AdminPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPermission createManyAndReturn
   */
  export type AdminPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminPermissions.
     */
    data: AdminPermissionCreateManyInput | AdminPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminPermission update
   */
  export type AdminPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminPermission.
     */
    data: XOR<AdminPermissionUpdateInput, AdminPermissionUncheckedUpdateInput>
    /**
     * Choose, which AdminPermission to update.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission updateMany
   */
  export type AdminPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminPermissions.
     */
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPermissions to update
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to update.
     */
    limit?: number
  }

  /**
   * AdminPermission updateManyAndReturn
   */
  export type AdminPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * The data used to update AdminPermissions.
     */
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPermissions to update
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminPermission upsert
   */
  export type AdminPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminPermission to update in case it exists.
     */
    where: AdminPermissionWhereUniqueInput
    /**
     * In case the AdminPermission found by the `where` argument doesn't exist, create a new AdminPermission with this data.
     */
    create: XOR<AdminPermissionCreateInput, AdminPermissionUncheckedCreateInput>
    /**
     * In case the AdminPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminPermissionUpdateInput, AdminPermissionUncheckedUpdateInput>
  }

  /**
   * AdminPermission delete
   */
  export type AdminPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter which AdminPermission to delete.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission deleteMany
   */
  export type AdminPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPermissions to delete
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to delete.
     */
    limit?: number
  }

  /**
   * AdminPermission without action
   */
  export type AdminPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAPIKey
   */

  export type AggregateAdminAPIKey = {
    _count: AdminAPIKeyCountAggregateOutputType | null
    _avg: AdminAPIKeyAvgAggregateOutputType | null
    _sum: AdminAPIKeySumAggregateOutputType | null
    _min: AdminAPIKeyMinAggregateOutputType | null
    _max: AdminAPIKeyMaxAggregateOutputType | null
  }

  export type AdminAPIKeyAvgAggregateOutputType = {
    rateLimit: number | null
  }

  export type AdminAPIKeySumAggregateOutputType = {
    rateLimit: number | null
  }

  export type AdminAPIKeyMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    name: string | null
    keyHash: string | null
    keyPrefix: string | null
    rateLimit: number | null
    createdAt: Date | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
  }

  export type AdminAPIKeyMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    name: string | null
    keyHash: string | null
    keyPrefix: string | null
    rateLimit: number | null
    createdAt: Date | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
  }

  export type AdminAPIKeyCountAggregateOutputType = {
    id: number
    adminId: number
    name: number
    keyHash: number
    keyPrefix: number
    scopes: number
    rateLimit: number
    allowedIps: number
    createdAt: number
    lastUsedAt: number
    expiresAt: number
    revokedAt: number
    _all: number
  }


  export type AdminAPIKeyAvgAggregateInputType = {
    rateLimit?: true
  }

  export type AdminAPIKeySumAggregateInputType = {
    rateLimit?: true
  }

  export type AdminAPIKeyMinAggregateInputType = {
    id?: true
    adminId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    rateLimit?: true
    createdAt?: true
    lastUsedAt?: true
    expiresAt?: true
    revokedAt?: true
  }

  export type AdminAPIKeyMaxAggregateInputType = {
    id?: true
    adminId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    rateLimit?: true
    createdAt?: true
    lastUsedAt?: true
    expiresAt?: true
    revokedAt?: true
  }

  export type AdminAPIKeyCountAggregateInputType = {
    id?: true
    adminId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    scopes?: true
    rateLimit?: true
    allowedIps?: true
    createdAt?: true
    lastUsedAt?: true
    expiresAt?: true
    revokedAt?: true
    _all?: true
  }

  export type AdminAPIKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAPIKey to aggregate.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAPIKeys
    **/
    _count?: true | AdminAPIKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAPIKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAPIKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAPIKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAPIKeyMaxAggregateInputType
  }

  export type GetAdminAPIKeyAggregateType<T extends AdminAPIKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAPIKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAPIKey[P]>
      : GetScalarType<T[P], AggregateAdminAPIKey[P]>
  }




  export type AdminAPIKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAPIKeyWhereInput
    orderBy?: AdminAPIKeyOrderByWithAggregationInput | AdminAPIKeyOrderByWithAggregationInput[]
    by: AdminAPIKeyScalarFieldEnum[] | AdminAPIKeyScalarFieldEnum
    having?: AdminAPIKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAPIKeyCountAggregateInputType | true
    _avg?: AdminAPIKeyAvgAggregateInputType
    _sum?: AdminAPIKeySumAggregateInputType
    _min?: AdminAPIKeyMinAggregateInputType
    _max?: AdminAPIKeyMaxAggregateInputType
  }

  export type AdminAPIKeyGroupByOutputType = {
    id: string
    adminId: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonValue
    rateLimit: number | null
    allowedIps: JsonValue | null
    createdAt: Date
    lastUsedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
    _count: AdminAPIKeyCountAggregateOutputType | null
    _avg: AdminAPIKeyAvgAggregateOutputType | null
    _sum: AdminAPIKeySumAggregateOutputType | null
    _min: AdminAPIKeyMinAggregateOutputType | null
    _max: AdminAPIKeyMaxAggregateOutputType | null
  }

  type GetAdminAPIKeyGroupByPayload<T extends AdminAPIKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAPIKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAPIKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAPIKeyGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAPIKeyGroupByOutputType[P]>
        }
      >
    >


  export type AdminAPIKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAPIKey"]>

  export type AdminAPIKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAPIKey"]>

  export type AdminAPIKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAPIKey"]>

  export type AdminAPIKeySelectScalar = {
    id?: boolean
    adminId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    scopes?: boolean
    rateLimit?: boolean
    allowedIps?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
  }

  export type AdminAPIKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "name" | "keyHash" | "keyPrefix" | "scopes" | "rateLimit" | "allowedIps" | "createdAt" | "lastUsedAt" | "expiresAt" | "revokedAt", ExtArgs["result"]["adminAPIKey"]>
  export type AdminAPIKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminAPIKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminAPIKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminAPIKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAPIKey"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      name: string
      keyHash: string
      keyPrefix: string
      scopes: Prisma.JsonValue
      rateLimit: number | null
      allowedIps: Prisma.JsonValue | null
      createdAt: Date
      lastUsedAt: Date | null
      expiresAt: Date | null
      revokedAt: Date | null
    }, ExtArgs["result"]["adminAPIKey"]>
    composites: {}
  }

  type AdminAPIKeyGetPayload<S extends boolean | null | undefined | AdminAPIKeyDefaultArgs> = $Result.GetResult<Prisma.$AdminAPIKeyPayload, S>

  type AdminAPIKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAPIKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAPIKeyCountAggregateInputType | true
    }

  export interface AdminAPIKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAPIKey'], meta: { name: 'AdminAPIKey' } }
    /**
     * Find zero or one AdminAPIKey that matches the filter.
     * @param {AdminAPIKeyFindUniqueArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAPIKeyFindUniqueArgs>(args: SelectSubset<T, AdminAPIKeyFindUniqueArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAPIKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAPIKeyFindUniqueOrThrowArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAPIKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAPIKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAPIKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyFindFirstArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAPIKeyFindFirstArgs>(args?: SelectSubset<T, AdminAPIKeyFindFirstArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAPIKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyFindFirstOrThrowArgs} args - Arguments to find a AdminAPIKey
     * @example
     * // Get one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAPIKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAPIKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAPIKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAPIKeys
     * const adminAPIKeys = await prisma.adminAPIKey.findMany()
     * 
     * // Get first 10 AdminAPIKeys
     * const adminAPIKeys = await prisma.adminAPIKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAPIKeyWithIdOnly = await prisma.adminAPIKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAPIKeyFindManyArgs>(args?: SelectSubset<T, AdminAPIKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAPIKey.
     * @param {AdminAPIKeyCreateArgs} args - Arguments to create a AdminAPIKey.
     * @example
     * // Create one AdminAPIKey
     * const AdminAPIKey = await prisma.adminAPIKey.create({
     *   data: {
     *     // ... data to create a AdminAPIKey
     *   }
     * })
     * 
     */
    create<T extends AdminAPIKeyCreateArgs>(args: SelectSubset<T, AdminAPIKeyCreateArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAPIKeys.
     * @param {AdminAPIKeyCreateManyArgs} args - Arguments to create many AdminAPIKeys.
     * @example
     * // Create many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAPIKeyCreateManyArgs>(args?: SelectSubset<T, AdminAPIKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAPIKeys and returns the data saved in the database.
     * @param {AdminAPIKeyCreateManyAndReturnArgs} args - Arguments to create many AdminAPIKeys.
     * @example
     * // Create many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAPIKeys and only return the `id`
     * const adminAPIKeyWithIdOnly = await prisma.adminAPIKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAPIKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAPIKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAPIKey.
     * @param {AdminAPIKeyDeleteArgs} args - Arguments to delete one AdminAPIKey.
     * @example
     * // Delete one AdminAPIKey
     * const AdminAPIKey = await prisma.adminAPIKey.delete({
     *   where: {
     *     // ... filter to delete one AdminAPIKey
     *   }
     * })
     * 
     */
    delete<T extends AdminAPIKeyDeleteArgs>(args: SelectSubset<T, AdminAPIKeyDeleteArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAPIKey.
     * @param {AdminAPIKeyUpdateArgs} args - Arguments to update one AdminAPIKey.
     * @example
     * // Update one AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAPIKeyUpdateArgs>(args: SelectSubset<T, AdminAPIKeyUpdateArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAPIKeys.
     * @param {AdminAPIKeyDeleteManyArgs} args - Arguments to filter AdminAPIKeys to delete.
     * @example
     * // Delete a few AdminAPIKeys
     * const { count } = await prisma.adminAPIKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAPIKeyDeleteManyArgs>(args?: SelectSubset<T, AdminAPIKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAPIKeyUpdateManyArgs>(args: SelectSubset<T, AdminAPIKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAPIKeys and returns the data updated in the database.
     * @param {AdminAPIKeyUpdateManyAndReturnArgs} args - Arguments to update many AdminAPIKeys.
     * @example
     * // Update many AdminAPIKeys
     * const adminAPIKey = await prisma.adminAPIKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAPIKeys and only return the `id`
     * const adminAPIKeyWithIdOnly = await prisma.adminAPIKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAPIKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAPIKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAPIKey.
     * @param {AdminAPIKeyUpsertArgs} args - Arguments to update or create a AdminAPIKey.
     * @example
     * // Update or create a AdminAPIKey
     * const adminAPIKey = await prisma.adminAPIKey.upsert({
     *   create: {
     *     // ... data to create a AdminAPIKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAPIKey we want to update
     *   }
     * })
     */
    upsert<T extends AdminAPIKeyUpsertArgs>(args: SelectSubset<T, AdminAPIKeyUpsertArgs<ExtArgs>>): Prisma__AdminAPIKeyClient<$Result.GetResult<Prisma.$AdminAPIKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyCountArgs} args - Arguments to filter AdminAPIKeys to count.
     * @example
     * // Count the number of AdminAPIKeys
     * const count = await prisma.adminAPIKey.count({
     *   where: {
     *     // ... the filter for the AdminAPIKeys we want to count
     *   }
     * })
    **/
    count<T extends AdminAPIKeyCountArgs>(
      args?: Subset<T, AdminAPIKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAPIKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAPIKeyAggregateArgs>(args: Subset<T, AdminAPIKeyAggregateArgs>): Prisma.PrismaPromise<GetAdminAPIKeyAggregateType<T>>

    /**
     * Group by AdminAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAPIKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAPIKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAPIKeyGroupByArgs['orderBy'] }
        : { orderBy?: AdminAPIKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAPIKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAPIKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAPIKey model
   */
  readonly fields: AdminAPIKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAPIKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAPIKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAPIKey model
   */
  interface AdminAPIKeyFieldRefs {
    readonly id: FieldRef<"AdminAPIKey", 'String'>
    readonly adminId: FieldRef<"AdminAPIKey", 'String'>
    readonly name: FieldRef<"AdminAPIKey", 'String'>
    readonly keyHash: FieldRef<"AdminAPIKey", 'String'>
    readonly keyPrefix: FieldRef<"AdminAPIKey", 'String'>
    readonly scopes: FieldRef<"AdminAPIKey", 'Json'>
    readonly rateLimit: FieldRef<"AdminAPIKey", 'Int'>
    readonly allowedIps: FieldRef<"AdminAPIKey", 'Json'>
    readonly createdAt: FieldRef<"AdminAPIKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"AdminAPIKey", 'DateTime'>
    readonly expiresAt: FieldRef<"AdminAPIKey", 'DateTime'>
    readonly revokedAt: FieldRef<"AdminAPIKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAPIKey findUnique
   */
  export type AdminAPIKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey findUniqueOrThrow
   */
  export type AdminAPIKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey findFirst
   */
  export type AdminAPIKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAPIKeys.
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAPIKeys.
     */
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * AdminAPIKey findFirstOrThrow
   */
  export type AdminAPIKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKey to fetch.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAPIKeys.
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAPIKeys.
     */
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * AdminAPIKey findMany
   */
  export type AdminAPIKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which AdminAPIKeys to fetch.
     */
    where?: AdminAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAPIKeys to fetch.
     */
    orderBy?: AdminAPIKeyOrderByWithRelationInput | AdminAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAPIKeys.
     */
    cursor?: AdminAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAPIKeys.
     */
    skip?: number
    distinct?: AdminAPIKeyScalarFieldEnum | AdminAPIKeyScalarFieldEnum[]
  }

  /**
   * AdminAPIKey create
   */
  export type AdminAPIKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAPIKey.
     */
    data: XOR<AdminAPIKeyCreateInput, AdminAPIKeyUncheckedCreateInput>
  }

  /**
   * AdminAPIKey createMany
   */
  export type AdminAPIKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAPIKeys.
     */
    data: AdminAPIKeyCreateManyInput | AdminAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAPIKey createManyAndReturn
   */
  export type AdminAPIKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAPIKeys.
     */
    data: AdminAPIKeyCreateManyInput | AdminAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAPIKey update
   */
  export type AdminAPIKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAPIKey.
     */
    data: XOR<AdminAPIKeyUpdateInput, AdminAPIKeyUncheckedUpdateInput>
    /**
     * Choose, which AdminAPIKey to update.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey updateMany
   */
  export type AdminAPIKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAPIKeys.
     */
    data: XOR<AdminAPIKeyUpdateManyMutationInput, AdminAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which AdminAPIKeys to update
     */
    where?: AdminAPIKeyWhereInput
    /**
     * Limit how many AdminAPIKeys to update.
     */
    limit?: number
  }

  /**
   * AdminAPIKey updateManyAndReturn
   */
  export type AdminAPIKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to update AdminAPIKeys.
     */
    data: XOR<AdminAPIKeyUpdateManyMutationInput, AdminAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which AdminAPIKeys to update
     */
    where?: AdminAPIKeyWhereInput
    /**
     * Limit how many AdminAPIKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAPIKey upsert
   */
  export type AdminAPIKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAPIKey to update in case it exists.
     */
    where: AdminAPIKeyWhereUniqueInput
    /**
     * In case the AdminAPIKey found by the `where` argument doesn't exist, create a new AdminAPIKey with this data.
     */
    create: XOR<AdminAPIKeyCreateInput, AdminAPIKeyUncheckedCreateInput>
    /**
     * In case the AdminAPIKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAPIKeyUpdateInput, AdminAPIKeyUncheckedUpdateInput>
  }

  /**
   * AdminAPIKey delete
   */
  export type AdminAPIKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
    /**
     * Filter which AdminAPIKey to delete.
     */
    where: AdminAPIKeyWhereUniqueInput
  }

  /**
   * AdminAPIKey deleteMany
   */
  export type AdminAPIKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAPIKeys to delete
     */
    where?: AdminAPIKeyWhereInput
    /**
     * Limit how many AdminAPIKeys to delete.
     */
    limit?: number
  }

  /**
   * AdminAPIKey without action
   */
  export type AdminAPIKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAPIKey
     */
    select?: AdminAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAPIKey
     */
    omit?: AdminAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAPIKeyInclude<ExtArgs> | null
  }


  /**
   * Model AdminInvitation
   */

  export type AggregateAdminInvitation = {
    _count: AdminInvitationCountAggregateOutputType | null
    _min: AdminInvitationMinAggregateOutputType | null
    _max: AdminInvitationMaxAggregateOutputType | null
  }

  export type AdminInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.AdminRole | null
    token: string | null
    invitedBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type AdminInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.AdminRole | null
    token: string | null
    invitedBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type AdminInvitationCountAggregateOutputType = {
    id: number
    email: number
    role: number
    token: number
    invitedBy: number
    createdAt: number
    expiresAt: number
    acceptedAt: number
    _all: number
  }


  export type AdminInvitationMinAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    invitedBy?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type AdminInvitationMaxAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    invitedBy?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type AdminInvitationCountAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    invitedBy?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type AdminInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminInvitation to aggregate.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminInvitations
    **/
    _count?: true | AdminInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminInvitationMaxAggregateInputType
  }

  export type GetAdminInvitationAggregateType<T extends AdminInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminInvitation[P]>
      : GetScalarType<T[P], AggregateAdminInvitation[P]>
  }




  export type AdminInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminInvitationWhereInput
    orderBy?: AdminInvitationOrderByWithAggregationInput | AdminInvitationOrderByWithAggregationInput[]
    by: AdminInvitationScalarFieldEnum[] | AdminInvitationScalarFieldEnum
    having?: AdminInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminInvitationCountAggregateInputType | true
    _min?: AdminInvitationMinAggregateInputType
    _max?: AdminInvitationMaxAggregateInputType
  }

  export type AdminInvitationGroupByOutputType = {
    id: string
    email: string
    role: $Enums.AdminRole
    token: string
    invitedBy: string
    createdAt: Date
    expiresAt: Date
    acceptedAt: Date | null
    _count: AdminInvitationCountAggregateOutputType | null
    _min: AdminInvitationMinAggregateOutputType | null
    _max: AdminInvitationMaxAggregateOutputType | null
  }

  type GetAdminInvitationGroupByPayload<T extends AdminInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], AdminInvitationGroupByOutputType[P]>
        }
      >
    >


  export type AdminInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminInvitation"]>

  export type AdminInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminInvitation"]>

  export type AdminInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminInvitation"]>

  export type AdminInvitationSelectScalar = {
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
  }

  export type AdminInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "role" | "token" | "invitedBy" | "createdAt" | "expiresAt" | "acceptedAt", ExtArgs["result"]["adminInvitation"]>
  export type AdminInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminInvitation"
    objects: {
      inviter: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      role: $Enums.AdminRole
      token: string
      invitedBy: string
      createdAt: Date
      expiresAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["adminInvitation"]>
    composites: {}
  }

  type AdminInvitationGetPayload<S extends boolean | null | undefined | AdminInvitationDefaultArgs> = $Result.GetResult<Prisma.$AdminInvitationPayload, S>

  type AdminInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminInvitationCountAggregateInputType | true
    }

  export interface AdminInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminInvitation'], meta: { name: 'AdminInvitation' } }
    /**
     * Find zero or one AdminInvitation that matches the filter.
     * @param {AdminInvitationFindUniqueArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminInvitationFindUniqueArgs>(args: SelectSubset<T, AdminInvitationFindUniqueArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminInvitationFindUniqueOrThrowArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationFindFirstArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminInvitationFindFirstArgs>(args?: SelectSubset<T, AdminInvitationFindFirstArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationFindFirstOrThrowArgs} args - Arguments to find a AdminInvitation
     * @example
     * // Get one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminInvitations
     * const adminInvitations = await prisma.adminInvitation.findMany()
     * 
     * // Get first 10 AdminInvitations
     * const adminInvitations = await prisma.adminInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminInvitationWithIdOnly = await prisma.adminInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminInvitationFindManyArgs>(args?: SelectSubset<T, AdminInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminInvitation.
     * @param {AdminInvitationCreateArgs} args - Arguments to create a AdminInvitation.
     * @example
     * // Create one AdminInvitation
     * const AdminInvitation = await prisma.adminInvitation.create({
     *   data: {
     *     // ... data to create a AdminInvitation
     *   }
     * })
     * 
     */
    create<T extends AdminInvitationCreateArgs>(args: SelectSubset<T, AdminInvitationCreateArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminInvitations.
     * @param {AdminInvitationCreateManyArgs} args - Arguments to create many AdminInvitations.
     * @example
     * // Create many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminInvitationCreateManyArgs>(args?: SelectSubset<T, AdminInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminInvitations and returns the data saved in the database.
     * @param {AdminInvitationCreateManyAndReturnArgs} args - Arguments to create many AdminInvitations.
     * @example
     * // Create many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminInvitations and only return the `id`
     * const adminInvitationWithIdOnly = await prisma.adminInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminInvitation.
     * @param {AdminInvitationDeleteArgs} args - Arguments to delete one AdminInvitation.
     * @example
     * // Delete one AdminInvitation
     * const AdminInvitation = await prisma.adminInvitation.delete({
     *   where: {
     *     // ... filter to delete one AdminInvitation
     *   }
     * })
     * 
     */
    delete<T extends AdminInvitationDeleteArgs>(args: SelectSubset<T, AdminInvitationDeleteArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminInvitation.
     * @param {AdminInvitationUpdateArgs} args - Arguments to update one AdminInvitation.
     * @example
     * // Update one AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminInvitationUpdateArgs>(args: SelectSubset<T, AdminInvitationUpdateArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminInvitations.
     * @param {AdminInvitationDeleteManyArgs} args - Arguments to filter AdminInvitations to delete.
     * @example
     * // Delete a few AdminInvitations
     * const { count } = await prisma.adminInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminInvitationDeleteManyArgs>(args?: SelectSubset<T, AdminInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminInvitationUpdateManyArgs>(args: SelectSubset<T, AdminInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminInvitations and returns the data updated in the database.
     * @param {AdminInvitationUpdateManyAndReturnArgs} args - Arguments to update many AdminInvitations.
     * @example
     * // Update many AdminInvitations
     * const adminInvitation = await prisma.adminInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminInvitations and only return the `id`
     * const adminInvitationWithIdOnly = await prisma.adminInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminInvitation.
     * @param {AdminInvitationUpsertArgs} args - Arguments to update or create a AdminInvitation.
     * @example
     * // Update or create a AdminInvitation
     * const adminInvitation = await prisma.adminInvitation.upsert({
     *   create: {
     *     // ... data to create a AdminInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminInvitation we want to update
     *   }
     * })
     */
    upsert<T extends AdminInvitationUpsertArgs>(args: SelectSubset<T, AdminInvitationUpsertArgs<ExtArgs>>): Prisma__AdminInvitationClient<$Result.GetResult<Prisma.$AdminInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationCountArgs} args - Arguments to filter AdminInvitations to count.
     * @example
     * // Count the number of AdminInvitations
     * const count = await prisma.adminInvitation.count({
     *   where: {
     *     // ... the filter for the AdminInvitations we want to count
     *   }
     * })
    **/
    count<T extends AdminInvitationCountArgs>(
      args?: Subset<T, AdminInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminInvitationAggregateArgs>(args: Subset<T, AdminInvitationAggregateArgs>): Prisma.PrismaPromise<GetAdminInvitationAggregateType<T>>

    /**
     * Group by AdminInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminInvitationGroupByArgs['orderBy'] }
        : { orderBy?: AdminInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminInvitation model
   */
  readonly fields: AdminInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminInvitation model
   */
  interface AdminInvitationFieldRefs {
    readonly id: FieldRef<"AdminInvitation", 'String'>
    readonly email: FieldRef<"AdminInvitation", 'String'>
    readonly role: FieldRef<"AdminInvitation", 'AdminRole'>
    readonly token: FieldRef<"AdminInvitation", 'String'>
    readonly invitedBy: FieldRef<"AdminInvitation", 'String'>
    readonly createdAt: FieldRef<"AdminInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"AdminInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"AdminInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminInvitation findUnique
   */
  export type AdminInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation findUniqueOrThrow
   */
  export type AdminInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation findFirst
   */
  export type AdminInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminInvitations.
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminInvitations.
     */
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * AdminInvitation findFirstOrThrow
   */
  export type AdminInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitation to fetch.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminInvitations.
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminInvitations.
     */
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * AdminInvitation findMany
   */
  export type AdminInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AdminInvitations to fetch.
     */
    where?: AdminInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminInvitations to fetch.
     */
    orderBy?: AdminInvitationOrderByWithRelationInput | AdminInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminInvitations.
     */
    cursor?: AdminInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminInvitations.
     */
    skip?: number
    distinct?: AdminInvitationScalarFieldEnum | AdminInvitationScalarFieldEnum[]
  }

  /**
   * AdminInvitation create
   */
  export type AdminInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminInvitation.
     */
    data: XOR<AdminInvitationCreateInput, AdminInvitationUncheckedCreateInput>
  }

  /**
   * AdminInvitation createMany
   */
  export type AdminInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminInvitations.
     */
    data: AdminInvitationCreateManyInput | AdminInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminInvitation createManyAndReturn
   */
  export type AdminInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many AdminInvitations.
     */
    data: AdminInvitationCreateManyInput | AdminInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminInvitation update
   */
  export type AdminInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminInvitation.
     */
    data: XOR<AdminInvitationUpdateInput, AdminInvitationUncheckedUpdateInput>
    /**
     * Choose, which AdminInvitation to update.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation updateMany
   */
  export type AdminInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminInvitations.
     */
    data: XOR<AdminInvitationUpdateManyMutationInput, AdminInvitationUncheckedUpdateManyInput>
    /**
     * Filter which AdminInvitations to update
     */
    where?: AdminInvitationWhereInput
    /**
     * Limit how many AdminInvitations to update.
     */
    limit?: number
  }

  /**
   * AdminInvitation updateManyAndReturn
   */
  export type AdminInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * The data used to update AdminInvitations.
     */
    data: XOR<AdminInvitationUpdateManyMutationInput, AdminInvitationUncheckedUpdateManyInput>
    /**
     * Filter which AdminInvitations to update
     */
    where?: AdminInvitationWhereInput
    /**
     * Limit how many AdminInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminInvitation upsert
   */
  export type AdminInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminInvitation to update in case it exists.
     */
    where: AdminInvitationWhereUniqueInput
    /**
     * In case the AdminInvitation found by the `where` argument doesn't exist, create a new AdminInvitation with this data.
     */
    create: XOR<AdminInvitationCreateInput, AdminInvitationUncheckedCreateInput>
    /**
     * In case the AdminInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminInvitationUpdateInput, AdminInvitationUncheckedUpdateInput>
  }

  /**
   * AdminInvitation delete
   */
  export type AdminInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
    /**
     * Filter which AdminInvitation to delete.
     */
    where: AdminInvitationWhereUniqueInput
  }

  /**
   * AdminInvitation deleteMany
   */
  export type AdminInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminInvitations to delete
     */
    where?: AdminInvitationWhereInput
    /**
     * Limit how many AdminInvitations to delete.
     */
    limit?: number
  }

  /**
   * AdminInvitation without action
   */
  export type AdminInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminInvitation
     */
    select?: AdminInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminInvitation
     */
    omit?: AdminInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInvitationInclude<ExtArgs> | null
  }


  /**
   * Model AdminSecurityEvent
   */

  export type AggregateAdminSecurityEvent = {
    _count: AdminSecurityEventCountAggregateOutputType | null
    _min: AdminSecurityEventMinAggregateOutputType | null
    _max: AdminSecurityEventMaxAggregateOutputType | null
  }

  export type AdminSecurityEventMinAggregateOutputType = {
    id: string | null
    eventType: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    adminId: string | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type AdminSecurityEventMaxAggregateOutputType = {
    id: string | null
    eventType: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    adminId: string | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type AdminSecurityEventCountAggregateOutputType = {
    id: number
    eventType: number
    severity: number
    adminId: number
    ipAddress: number
    userAgent: number
    description: number
    metadata: number
    resolved: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    _all: number
  }


  export type AdminSecurityEventMinAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type AdminSecurityEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type AdminSecurityEventCountAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    metadata?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    _all?: true
  }

  export type AdminSecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSecurityEvent to aggregate.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSecurityEvents
    **/
    _count?: true | AdminSecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSecurityEventMaxAggregateInputType
  }

  export type GetAdminSecurityEventAggregateType<T extends AdminSecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSecurityEvent[P]>
      : GetScalarType<T[P], AggregateAdminSecurityEvent[P]>
  }




  export type AdminSecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSecurityEventWhereInput
    orderBy?: AdminSecurityEventOrderByWithAggregationInput | AdminSecurityEventOrderByWithAggregationInput[]
    by: AdminSecurityEventScalarFieldEnum[] | AdminSecurityEventScalarFieldEnum
    having?: AdminSecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSecurityEventCountAggregateInputType | true
    _min?: AdminSecurityEventMinAggregateInputType
    _max?: AdminSecurityEventMaxAggregateInputType
  }

  export type AdminSecurityEventGroupByOutputType = {
    id: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId: string | null
    ipAddress: string
    userAgent: string | null
    description: string
    metadata: JsonValue | null
    resolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    _count: AdminSecurityEventCountAggregateOutputType | null
    _min: AdminSecurityEventMinAggregateOutputType | null
    _max: AdminSecurityEventMaxAggregateOutputType | null
  }

  type GetAdminSecurityEventGroupByPayload<T extends AdminSecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type AdminSecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminSecurityEvent"]>

  export type AdminSecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminSecurityEvent"]>

  export type AdminSecurityEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminSecurityEvent"]>

  export type AdminSecurityEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    severity?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }

  export type AdminSecurityEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "severity" | "adminId" | "ipAddress" | "userAgent" | "description" | "metadata" | "resolved" | "resolvedAt" | "resolvedBy" | "createdAt", ExtArgs["result"]["adminSecurityEvent"]>

  export type $AdminSecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSecurityEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: $Enums.SecurityEventType
      severity: $Enums.SecuritySeverity
      adminId: string | null
      ipAddress: string
      userAgent: string | null
      description: string
      metadata: Prisma.JsonValue | null
      resolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminSecurityEvent"]>
    composites: {}
  }

  type AdminSecurityEventGetPayload<S extends boolean | null | undefined | AdminSecurityEventDefaultArgs> = $Result.GetResult<Prisma.$AdminSecurityEventPayload, S>

  type AdminSecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminSecurityEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminSecurityEventCountAggregateInputType | true
    }

  export interface AdminSecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSecurityEvent'], meta: { name: 'AdminSecurityEvent' } }
    /**
     * Find zero or one AdminSecurityEvent that matches the filter.
     * @param {AdminSecurityEventFindUniqueArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSecurityEventFindUniqueArgs>(args: SelectSubset<T, AdminSecurityEventFindUniqueArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminSecurityEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSecurityEventFindUniqueOrThrowArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventFindFirstArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSecurityEventFindFirstArgs>(args?: SelectSubset<T, AdminSecurityEventFindFirstArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventFindFirstOrThrowArgs} args - Arguments to find a AdminSecurityEvent
     * @example
     * // Get one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminSecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSecurityEvents
     * const adminSecurityEvents = await prisma.adminSecurityEvent.findMany()
     * 
     * // Get first 10 AdminSecurityEvents
     * const adminSecurityEvents = await prisma.adminSecurityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSecurityEventWithIdOnly = await prisma.adminSecurityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSecurityEventFindManyArgs>(args?: SelectSubset<T, AdminSecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminSecurityEvent.
     * @param {AdminSecurityEventCreateArgs} args - Arguments to create a AdminSecurityEvent.
     * @example
     * // Create one AdminSecurityEvent
     * const AdminSecurityEvent = await prisma.adminSecurityEvent.create({
     *   data: {
     *     // ... data to create a AdminSecurityEvent
     *   }
     * })
     * 
     */
    create<T extends AdminSecurityEventCreateArgs>(args: SelectSubset<T, AdminSecurityEventCreateArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminSecurityEvents.
     * @param {AdminSecurityEventCreateManyArgs} args - Arguments to create many AdminSecurityEvents.
     * @example
     * // Create many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSecurityEventCreateManyArgs>(args?: SelectSubset<T, AdminSecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSecurityEvents and returns the data saved in the database.
     * @param {AdminSecurityEventCreateManyAndReturnArgs} args - Arguments to create many AdminSecurityEvents.
     * @example
     * // Create many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSecurityEvents and only return the `id`
     * const adminSecurityEventWithIdOnly = await prisma.adminSecurityEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminSecurityEvent.
     * @param {AdminSecurityEventDeleteArgs} args - Arguments to delete one AdminSecurityEvent.
     * @example
     * // Delete one AdminSecurityEvent
     * const AdminSecurityEvent = await prisma.adminSecurityEvent.delete({
     *   where: {
     *     // ... filter to delete one AdminSecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends AdminSecurityEventDeleteArgs>(args: SelectSubset<T, AdminSecurityEventDeleteArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminSecurityEvent.
     * @param {AdminSecurityEventUpdateArgs} args - Arguments to update one AdminSecurityEvent.
     * @example
     * // Update one AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSecurityEventUpdateArgs>(args: SelectSubset<T, AdminSecurityEventUpdateArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminSecurityEvents.
     * @param {AdminSecurityEventDeleteManyArgs} args - Arguments to filter AdminSecurityEvents to delete.
     * @example
     * // Delete a few AdminSecurityEvents
     * const { count } = await prisma.adminSecurityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSecurityEventDeleteManyArgs>(args?: SelectSubset<T, AdminSecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSecurityEventUpdateManyArgs>(args: SelectSubset<T, AdminSecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSecurityEvents and returns the data updated in the database.
     * @param {AdminSecurityEventUpdateManyAndReturnArgs} args - Arguments to update many AdminSecurityEvents.
     * @example
     * // Update many AdminSecurityEvents
     * const adminSecurityEvent = await prisma.adminSecurityEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminSecurityEvents and only return the `id`
     * const adminSecurityEventWithIdOnly = await prisma.adminSecurityEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminSecurityEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminSecurityEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminSecurityEvent.
     * @param {AdminSecurityEventUpsertArgs} args - Arguments to update or create a AdminSecurityEvent.
     * @example
     * // Update or create a AdminSecurityEvent
     * const adminSecurityEvent = await prisma.adminSecurityEvent.upsert({
     *   create: {
     *     // ... data to create a AdminSecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends AdminSecurityEventUpsertArgs>(args: SelectSubset<T, AdminSecurityEventUpsertArgs<ExtArgs>>): Prisma__AdminSecurityEventClient<$Result.GetResult<Prisma.$AdminSecurityEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminSecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventCountArgs} args - Arguments to filter AdminSecurityEvents to count.
     * @example
     * // Count the number of AdminSecurityEvents
     * const count = await prisma.adminSecurityEvent.count({
     *   where: {
     *     // ... the filter for the AdminSecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends AdminSecurityEventCountArgs>(
      args?: Subset<T, AdminSecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSecurityEventAggregateArgs>(args: Subset<T, AdminSecurityEventAggregateArgs>): Prisma.PrismaPromise<GetAdminSecurityEventAggregateType<T>>

    /**
     * Group by AdminSecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: AdminSecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSecurityEvent model
   */
  readonly fields: AdminSecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSecurityEvent model
   */
  interface AdminSecurityEventFieldRefs {
    readonly id: FieldRef<"AdminSecurityEvent", 'String'>
    readonly eventType: FieldRef<"AdminSecurityEvent", 'SecurityEventType'>
    readonly severity: FieldRef<"AdminSecurityEvent", 'SecuritySeverity'>
    readonly adminId: FieldRef<"AdminSecurityEvent", 'String'>
    readonly ipAddress: FieldRef<"AdminSecurityEvent", 'String'>
    readonly userAgent: FieldRef<"AdminSecurityEvent", 'String'>
    readonly description: FieldRef<"AdminSecurityEvent", 'String'>
    readonly metadata: FieldRef<"AdminSecurityEvent", 'Json'>
    readonly resolved: FieldRef<"AdminSecurityEvent", 'Boolean'>
    readonly resolvedAt: FieldRef<"AdminSecurityEvent", 'DateTime'>
    readonly resolvedBy: FieldRef<"AdminSecurityEvent", 'String'>
    readonly createdAt: FieldRef<"AdminSecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminSecurityEvent findUnique
   */
  export type AdminSecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent findUniqueOrThrow
   */
  export type AdminSecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent findFirst
   */
  export type AdminSecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSecurityEvents.
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSecurityEvents.
     */
    distinct?: AdminSecurityEventScalarFieldEnum | AdminSecurityEventScalarFieldEnum[]
  }

  /**
   * AdminSecurityEvent findFirstOrThrow
   */
  export type AdminSecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvent to fetch.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSecurityEvents.
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSecurityEvents.
     */
    distinct?: AdminSecurityEventScalarFieldEnum | AdminSecurityEventScalarFieldEnum[]
  }

  /**
   * AdminSecurityEvent findMany
   */
  export type AdminSecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminSecurityEvents to fetch.
     */
    where?: AdminSecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSecurityEvents to fetch.
     */
    orderBy?: AdminSecurityEventOrderByWithRelationInput | AdminSecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSecurityEvents.
     */
    cursor?: AdminSecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSecurityEvents.
     */
    skip?: number
    distinct?: AdminSecurityEventScalarFieldEnum | AdminSecurityEventScalarFieldEnum[]
  }

  /**
   * AdminSecurityEvent create
   */
  export type AdminSecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminSecurityEvent.
     */
    data: XOR<AdminSecurityEventCreateInput, AdminSecurityEventUncheckedCreateInput>
  }

  /**
   * AdminSecurityEvent createMany
   */
  export type AdminSecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSecurityEvents.
     */
    data: AdminSecurityEventCreateManyInput | AdminSecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSecurityEvent createManyAndReturn
   */
  export type AdminSecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data used to create many AdminSecurityEvents.
     */
    data: AdminSecurityEventCreateManyInput | AdminSecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSecurityEvent update
   */
  export type AdminSecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminSecurityEvent.
     */
    data: XOR<AdminSecurityEventUpdateInput, AdminSecurityEventUncheckedUpdateInput>
    /**
     * Choose, which AdminSecurityEvent to update.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent updateMany
   */
  export type AdminSecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSecurityEvents.
     */
    data: XOR<AdminSecurityEventUpdateManyMutationInput, AdminSecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminSecurityEvents to update
     */
    where?: AdminSecurityEventWhereInput
    /**
     * Limit how many AdminSecurityEvents to update.
     */
    limit?: number
  }

  /**
   * AdminSecurityEvent updateManyAndReturn
   */
  export type AdminSecurityEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The data used to update AdminSecurityEvents.
     */
    data: XOR<AdminSecurityEventUpdateManyMutationInput, AdminSecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminSecurityEvents to update
     */
    where?: AdminSecurityEventWhereInput
    /**
     * Limit how many AdminSecurityEvents to update.
     */
    limit?: number
  }

  /**
   * AdminSecurityEvent upsert
   */
  export type AdminSecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminSecurityEvent to update in case it exists.
     */
    where: AdminSecurityEventWhereUniqueInput
    /**
     * In case the AdminSecurityEvent found by the `where` argument doesn't exist, create a new AdminSecurityEvent with this data.
     */
    create: XOR<AdminSecurityEventCreateInput, AdminSecurityEventUncheckedCreateInput>
    /**
     * In case the AdminSecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSecurityEventUpdateInput, AdminSecurityEventUncheckedUpdateInput>
  }

  /**
   * AdminSecurityEvent delete
   */
  export type AdminSecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
    /**
     * Filter which AdminSecurityEvent to delete.
     */
    where: AdminSecurityEventWhereUniqueInput
  }

  /**
   * AdminSecurityEvent deleteMany
   */
  export type AdminSecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSecurityEvents to delete
     */
    where?: AdminSecurityEventWhereInput
    /**
     * Limit how many AdminSecurityEvents to delete.
     */
    limit?: number
  }

  /**
   * AdminSecurityEvent without action
   */
  export type AdminSecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSecurityEvent
     */
    select?: AdminSecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSecurityEvent
     */
    omit?: AdminSecurityEventOmit<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    credits: number | null
    monthlyCreditQuota: number | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    credits: number | null
    monthlyCreditQuota: number | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    credits: number | null
    monthlyCreditQuota: number | null
    creditResetDate: Date | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
    canInviteToWorkspace: boolean | null
    canInviteToCanvas: boolean | null
    canCreatePublicLinks: boolean | null
    canUseAdvancedModels: boolean | null
    canAccessAnalytics: boolean | null
    canExportData: boolean | null
    nextBillingDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    isByokMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    credits: number | null
    monthlyCreditQuota: number | null
    creditResetDate: Date | null
    maxCanvases: number | null
    maxActionPodsPerCanvas: number | null
    maxDocumentSizeInMB: number | null
    maxCollaboratorsPerCanvas: number | null
    canInviteToWorkspace: boolean | null
    canInviteToCanvas: boolean | null
    canCreatePublicLinks: boolean | null
    canUseAdvancedModels: boolean | null
    canAccessAnalytics: boolean | null
    canExportData: boolean | null
    nextBillingDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    isByokMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    workspaceId: number
    tier: number
    status: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    credits: number
    monthlyCreditQuota: number
    creditResetDate: number
    maxCanvases: number
    maxActionPodsPerCanvas: number
    maxDocumentSizeInMB: number
    maxCollaboratorsPerCanvas: number
    canInviteToWorkspace: number
    canInviteToCanvas: number
    canCreatePublicLinks: number
    canUseAdvancedModels: number
    canAccessAnalytics: number
    canExportData: number
    nextBillingDate: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    isByokMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    credits?: true
    monthlyCreditQuota?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
  }

  export type SubscriptionSumAggregateInputType = {
    credits?: true
    monthlyCreditQuota?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    credits?: true
    monthlyCreditQuota?: true
    creditResetDate?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
    canInviteToWorkspace?: true
    canInviteToCanvas?: true
    canCreatePublicLinks?: true
    canUseAdvancedModels?: true
    canAccessAnalytics?: true
    canExportData?: true
    nextBillingDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    isByokMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    credits?: true
    monthlyCreditQuota?: true
    creditResetDate?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
    canInviteToWorkspace?: true
    canInviteToCanvas?: true
    canCreatePublicLinks?: true
    canUseAdvancedModels?: true
    canAccessAnalytics?: true
    canExportData?: true
    nextBillingDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    isByokMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    credits?: true
    monthlyCreditQuota?: true
    creditResetDate?: true
    maxCanvases?: true
    maxActionPodsPerCanvas?: true
    maxDocumentSizeInMB?: true
    maxCollaboratorsPerCanvas?: true
    canInviteToWorkspace?: true
    canInviteToCanvas?: true
    canCreatePublicLinks?: true
    canUseAdvancedModels?: true
    canAccessAnalytics?: true
    canExportData?: true
    nextBillingDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    isByokMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    workspaceId: string
    tier: $Enums.SubscriptionTier
    status: $Enums.SubscriptionStatus
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    credits: number
    monthlyCreditQuota: number
    creditResetDate: Date | null
    maxCanvases: number
    maxActionPodsPerCanvas: number
    maxDocumentSizeInMB: number
    maxCollaboratorsPerCanvas: number
    canInviteToWorkspace: boolean
    canInviteToCanvas: boolean
    canCreatePublicLinks: boolean
    canUseAdvancedModels: boolean
    canAccessAnalytics: boolean
    canExportData: boolean
    nextBillingDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    isByokMode: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    usageLogs?: boolean | Subscription$usageLogsArgs<ExtArgs>
    creditPurchases?: boolean | Subscription$creditPurchasesArgs<ExtArgs>
    creditUsage?: boolean | Subscription$creditUsageArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    credits?: boolean
    monthlyCreditQuota?: boolean
    creditResetDate?: boolean
    maxCanvases?: boolean
    maxActionPodsPerCanvas?: boolean
    maxDocumentSizeInMB?: boolean
    maxCollaboratorsPerCanvas?: boolean
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "tier" | "status" | "stripeCustomerId" | "stripeSubscriptionId" | "credits" | "monthlyCreditQuota" | "creditResetDate" | "maxCanvases" | "maxActionPodsPerCanvas" | "maxDocumentSizeInMB" | "maxCollaboratorsPerCanvas" | "canInviteToWorkspace" | "canInviteToCanvas" | "canCreatePublicLinks" | "canUseAdvancedModels" | "canAccessAnalytics" | "canExportData" | "nextBillingDate" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "isByokMode" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    usageLogs?: boolean | Subscription$usageLogsArgs<ExtArgs>
    creditPurchases?: boolean | Subscription$creditPurchasesArgs<ExtArgs>
    creditUsage?: boolean | Subscription$creditUsageArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      usageLogs: Prisma.$PodUsageLogPayload<ExtArgs>[]
      creditPurchases: Prisma.$CreditPurchasePayload<ExtArgs>[]
      creditUsage: Prisma.$CreditUsageLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      tier: $Enums.SubscriptionTier
      status: $Enums.SubscriptionStatus
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      credits: number
      monthlyCreditQuota: number
      creditResetDate: Date | null
      maxCanvases: number
      maxActionPodsPerCanvas: number
      maxDocumentSizeInMB: number
      maxCollaboratorsPerCanvas: number
      canInviteToWorkspace: boolean
      canInviteToCanvas: boolean
      canCreatePublicLinks: boolean
      canUseAdvancedModels: boolean
      canAccessAnalytics: boolean
      canExportData: boolean
      nextBillingDate: Date | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      isByokMode: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usageLogs<T extends Subscription$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditPurchases<T extends Subscription$creditPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$creditPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditUsage<T extends Subscription$creditUsageArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$creditUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly workspaceId: FieldRef<"Subscription", 'String'>
    readonly tier: FieldRef<"Subscription", 'SubscriptionTier'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly credits: FieldRef<"Subscription", 'Int'>
    readonly monthlyCreditQuota: FieldRef<"Subscription", 'Int'>
    readonly creditResetDate: FieldRef<"Subscription", 'DateTime'>
    readonly maxCanvases: FieldRef<"Subscription", 'Int'>
    readonly maxActionPodsPerCanvas: FieldRef<"Subscription", 'Int'>
    readonly maxDocumentSizeInMB: FieldRef<"Subscription", 'Int'>
    readonly maxCollaboratorsPerCanvas: FieldRef<"Subscription", 'Int'>
    readonly canInviteToWorkspace: FieldRef<"Subscription", 'Boolean'>
    readonly canInviteToCanvas: FieldRef<"Subscription", 'Boolean'>
    readonly canCreatePublicLinks: FieldRef<"Subscription", 'Boolean'>
    readonly canUseAdvancedModels: FieldRef<"Subscription", 'Boolean'>
    readonly canAccessAnalytics: FieldRef<"Subscription", 'Boolean'>
    readonly canExportData: FieldRef<"Subscription", 'Boolean'>
    readonly nextBillingDate: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly isByokMode: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.usageLogs
   */
  export type Subscription$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    where?: PodUsageLogWhereInput
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    cursor?: PodUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * Subscription.creditPurchases
   */
  export type Subscription$creditPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    where?: CreditPurchaseWhereInput
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    cursor?: CreditPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * Subscription.creditUsage
   */
  export type Subscription$creditUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    where?: CreditUsageLogWhereInput
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    cursor?: CreditUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model CreditPurchase
   */

  export type AggregateCreditPurchase = {
    _count: CreditPurchaseCountAggregateOutputType | null
    _avg: CreditPurchaseAvgAggregateOutputType | null
    _sum: CreditPurchaseSumAggregateOutputType | null
    _min: CreditPurchaseMinAggregateOutputType | null
    _max: CreditPurchaseMaxAggregateOutputType | null
  }

  export type CreditPurchaseAvgAggregateOutputType = {
    creditsPurchased: number | null
    amountPaid: Decimal | null
  }

  export type CreditPurchaseSumAggregateOutputType = {
    creditsPurchased: number | null
    amountPaid: Decimal | null
  }

  export type CreditPurchaseMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    creditsPurchased: number | null
    amountPaid: Decimal | null
    currency: string | null
    stripeChargeId: string | null
    status: string | null
    purchasedAt: Date | null
  }

  export type CreditPurchaseMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    creditsPurchased: number | null
    amountPaid: Decimal | null
    currency: string | null
    stripeChargeId: string | null
    status: string | null
    purchasedAt: Date | null
  }

  export type CreditPurchaseCountAggregateOutputType = {
    id: number
    subscriptionId: number
    creditsPurchased: number
    amountPaid: number
    currency: number
    stripeChargeId: number
    status: number
    purchasedAt: number
    _all: number
  }


  export type CreditPurchaseAvgAggregateInputType = {
    creditsPurchased?: true
    amountPaid?: true
  }

  export type CreditPurchaseSumAggregateInputType = {
    creditsPurchased?: true
    amountPaid?: true
  }

  export type CreditPurchaseMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    creditsPurchased?: true
    amountPaid?: true
    currency?: true
    stripeChargeId?: true
    status?: true
    purchasedAt?: true
  }

  export type CreditPurchaseMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    creditsPurchased?: true
    amountPaid?: true
    currency?: true
    stripeChargeId?: true
    status?: true
    purchasedAt?: true
  }

  export type CreditPurchaseCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    creditsPurchased?: true
    amountPaid?: true
    currency?: true
    stripeChargeId?: true
    status?: true
    purchasedAt?: true
    _all?: true
  }

  export type CreditPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPurchase to aggregate.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditPurchases
    **/
    _count?: true | CreditPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditPurchaseMaxAggregateInputType
  }

  export type GetCreditPurchaseAggregateType<T extends CreditPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditPurchase[P]>
      : GetScalarType<T[P], AggregateCreditPurchase[P]>
  }




  export type CreditPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPurchaseWhereInput
    orderBy?: CreditPurchaseOrderByWithAggregationInput | CreditPurchaseOrderByWithAggregationInput[]
    by: CreditPurchaseScalarFieldEnum[] | CreditPurchaseScalarFieldEnum
    having?: CreditPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditPurchaseCountAggregateInputType | true
    _avg?: CreditPurchaseAvgAggregateInputType
    _sum?: CreditPurchaseSumAggregateInputType
    _min?: CreditPurchaseMinAggregateInputType
    _max?: CreditPurchaseMaxAggregateInputType
  }

  export type CreditPurchaseGroupByOutputType = {
    id: string
    subscriptionId: string
    creditsPurchased: number
    amountPaid: Decimal
    currency: string
    stripeChargeId: string
    status: string
    purchasedAt: Date
    _count: CreditPurchaseCountAggregateOutputType | null
    _avg: CreditPurchaseAvgAggregateOutputType | null
    _sum: CreditPurchaseSumAggregateOutputType | null
    _min: CreditPurchaseMinAggregateOutputType | null
    _max: CreditPurchaseMaxAggregateOutputType | null
  }

  type GetCreditPurchaseGroupByPayload<T extends CreditPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], CreditPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type CreditPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPurchase"]>

  export type CreditPurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPurchase"]>

  export type CreditPurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPurchase"]>

  export type CreditPurchaseSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    creditsPurchased?: boolean
    amountPaid?: boolean
    currency?: boolean
    stripeChargeId?: boolean
    status?: boolean
    purchasedAt?: boolean
  }

  export type CreditPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "creditsPurchased" | "amountPaid" | "currency" | "stripeChargeId" | "status" | "purchasedAt", ExtArgs["result"]["creditPurchase"]>
  export type CreditPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditPurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditPurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $CreditPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditPurchase"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      creditsPurchased: number
      amountPaid: Prisma.Decimal
      currency: string
      stripeChargeId: string
      status: string
      purchasedAt: Date
    }, ExtArgs["result"]["creditPurchase"]>
    composites: {}
  }

  type CreditPurchaseGetPayload<S extends boolean | null | undefined | CreditPurchaseDefaultArgs> = $Result.GetResult<Prisma.$CreditPurchasePayload, S>

  type CreditPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditPurchaseCountAggregateInputType | true
    }

  export interface CreditPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditPurchase'], meta: { name: 'CreditPurchase' } }
    /**
     * Find zero or one CreditPurchase that matches the filter.
     * @param {CreditPurchaseFindUniqueArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditPurchaseFindUniqueArgs>(args: SelectSubset<T, CreditPurchaseFindUniqueArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditPurchaseFindUniqueOrThrowArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseFindFirstArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditPurchaseFindFirstArgs>(args?: SelectSubset<T, CreditPurchaseFindFirstArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseFindFirstOrThrowArgs} args - Arguments to find a CreditPurchase
     * @example
     * // Get one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditPurchases
     * const creditPurchases = await prisma.creditPurchase.findMany()
     * 
     * // Get first 10 CreditPurchases
     * const creditPurchases = await prisma.creditPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditPurchaseWithIdOnly = await prisma.creditPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditPurchaseFindManyArgs>(args?: SelectSubset<T, CreditPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditPurchase.
     * @param {CreditPurchaseCreateArgs} args - Arguments to create a CreditPurchase.
     * @example
     * // Create one CreditPurchase
     * const CreditPurchase = await prisma.creditPurchase.create({
     *   data: {
     *     // ... data to create a CreditPurchase
     *   }
     * })
     * 
     */
    create<T extends CreditPurchaseCreateArgs>(args: SelectSubset<T, CreditPurchaseCreateArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditPurchases.
     * @param {CreditPurchaseCreateManyArgs} args - Arguments to create many CreditPurchases.
     * @example
     * // Create many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditPurchaseCreateManyArgs>(args?: SelectSubset<T, CreditPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditPurchases and returns the data saved in the database.
     * @param {CreditPurchaseCreateManyAndReturnArgs} args - Arguments to create many CreditPurchases.
     * @example
     * // Create many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditPurchases and only return the `id`
     * const creditPurchaseWithIdOnly = await prisma.creditPurchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditPurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditPurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditPurchase.
     * @param {CreditPurchaseDeleteArgs} args - Arguments to delete one CreditPurchase.
     * @example
     * // Delete one CreditPurchase
     * const CreditPurchase = await prisma.creditPurchase.delete({
     *   where: {
     *     // ... filter to delete one CreditPurchase
     *   }
     * })
     * 
     */
    delete<T extends CreditPurchaseDeleteArgs>(args: SelectSubset<T, CreditPurchaseDeleteArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditPurchase.
     * @param {CreditPurchaseUpdateArgs} args - Arguments to update one CreditPurchase.
     * @example
     * // Update one CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditPurchaseUpdateArgs>(args: SelectSubset<T, CreditPurchaseUpdateArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditPurchases.
     * @param {CreditPurchaseDeleteManyArgs} args - Arguments to filter CreditPurchases to delete.
     * @example
     * // Delete a few CreditPurchases
     * const { count } = await prisma.creditPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditPurchaseDeleteManyArgs>(args?: SelectSubset<T, CreditPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditPurchaseUpdateManyArgs>(args: SelectSubset<T, CreditPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditPurchases and returns the data updated in the database.
     * @param {CreditPurchaseUpdateManyAndReturnArgs} args - Arguments to update many CreditPurchases.
     * @example
     * // Update many CreditPurchases
     * const creditPurchase = await prisma.creditPurchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditPurchases and only return the `id`
     * const creditPurchaseWithIdOnly = await prisma.creditPurchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditPurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditPurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditPurchase.
     * @param {CreditPurchaseUpsertArgs} args - Arguments to update or create a CreditPurchase.
     * @example
     * // Update or create a CreditPurchase
     * const creditPurchase = await prisma.creditPurchase.upsert({
     *   create: {
     *     // ... data to create a CreditPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditPurchase we want to update
     *   }
     * })
     */
    upsert<T extends CreditPurchaseUpsertArgs>(args: SelectSubset<T, CreditPurchaseUpsertArgs<ExtArgs>>): Prisma__CreditPurchaseClient<$Result.GetResult<Prisma.$CreditPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseCountArgs} args - Arguments to filter CreditPurchases to count.
     * @example
     * // Count the number of CreditPurchases
     * const count = await prisma.creditPurchase.count({
     *   where: {
     *     // ... the filter for the CreditPurchases we want to count
     *   }
     * })
    **/
    count<T extends CreditPurchaseCountArgs>(
      args?: Subset<T, CreditPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditPurchaseAggregateArgs>(args: Subset<T, CreditPurchaseAggregateArgs>): Prisma.PrismaPromise<GetCreditPurchaseAggregateType<T>>

    /**
     * Group by CreditPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: CreditPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditPurchase model
   */
  readonly fields: CreditPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditPurchase model
   */
  interface CreditPurchaseFieldRefs {
    readonly id: FieldRef<"CreditPurchase", 'String'>
    readonly subscriptionId: FieldRef<"CreditPurchase", 'String'>
    readonly creditsPurchased: FieldRef<"CreditPurchase", 'Int'>
    readonly amountPaid: FieldRef<"CreditPurchase", 'Decimal'>
    readonly currency: FieldRef<"CreditPurchase", 'String'>
    readonly stripeChargeId: FieldRef<"CreditPurchase", 'String'>
    readonly status: FieldRef<"CreditPurchase", 'String'>
    readonly purchasedAt: FieldRef<"CreditPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditPurchase findUnique
   */
  export type CreditPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase findUniqueOrThrow
   */
  export type CreditPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase findFirst
   */
  export type CreditPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPurchases.
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPurchases.
     */
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * CreditPurchase findFirstOrThrow
   */
  export type CreditPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchase to fetch.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPurchases.
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPurchases.
     */
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * CreditPurchase findMany
   */
  export type CreditPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which CreditPurchases to fetch.
     */
    where?: CreditPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPurchases to fetch.
     */
    orderBy?: CreditPurchaseOrderByWithRelationInput | CreditPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditPurchases.
     */
    cursor?: CreditPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPurchases.
     */
    skip?: number
    distinct?: CreditPurchaseScalarFieldEnum | CreditPurchaseScalarFieldEnum[]
  }

  /**
   * CreditPurchase create
   */
  export type CreditPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditPurchase.
     */
    data: XOR<CreditPurchaseCreateInput, CreditPurchaseUncheckedCreateInput>
  }

  /**
   * CreditPurchase createMany
   */
  export type CreditPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditPurchases.
     */
    data: CreditPurchaseCreateManyInput | CreditPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditPurchase createManyAndReturn
   */
  export type CreditPurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many CreditPurchases.
     */
    data: CreditPurchaseCreateManyInput | CreditPurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditPurchase update
   */
  export type CreditPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditPurchase.
     */
    data: XOR<CreditPurchaseUpdateInput, CreditPurchaseUncheckedUpdateInput>
    /**
     * Choose, which CreditPurchase to update.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase updateMany
   */
  export type CreditPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditPurchases.
     */
    data: XOR<CreditPurchaseUpdateManyMutationInput, CreditPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which CreditPurchases to update
     */
    where?: CreditPurchaseWhereInput
    /**
     * Limit how many CreditPurchases to update.
     */
    limit?: number
  }

  /**
   * CreditPurchase updateManyAndReturn
   */
  export type CreditPurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * The data used to update CreditPurchases.
     */
    data: XOR<CreditPurchaseUpdateManyMutationInput, CreditPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which CreditPurchases to update
     */
    where?: CreditPurchaseWhereInput
    /**
     * Limit how many CreditPurchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditPurchase upsert
   */
  export type CreditPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditPurchase to update in case it exists.
     */
    where: CreditPurchaseWhereUniqueInput
    /**
     * In case the CreditPurchase found by the `where` argument doesn't exist, create a new CreditPurchase with this data.
     */
    create: XOR<CreditPurchaseCreateInput, CreditPurchaseUncheckedCreateInput>
    /**
     * In case the CreditPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditPurchaseUpdateInput, CreditPurchaseUncheckedUpdateInput>
  }

  /**
   * CreditPurchase delete
   */
  export type CreditPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
    /**
     * Filter which CreditPurchase to delete.
     */
    where: CreditPurchaseWhereUniqueInput
  }

  /**
   * CreditPurchase deleteMany
   */
  export type CreditPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPurchases to delete
     */
    where?: CreditPurchaseWhereInput
    /**
     * Limit how many CreditPurchases to delete.
     */
    limit?: number
  }

  /**
   * CreditPurchase without action
   */
  export type CreditPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPurchase
     */
    select?: CreditPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPurchase
     */
    omit?: CreditPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model CreditUsageLog
   */

  export type AggregateCreditUsageLog = {
    _count: CreditUsageLogCountAggregateOutputType | null
    _avg: CreditUsageLogAvgAggregateOutputType | null
    _sum: CreditUsageLogSumAggregateOutputType | null
    _min: CreditUsageLogMinAggregateOutputType | null
    _max: CreditUsageLogMaxAggregateOutputType | null
  }

  export type CreditUsageLogAvgAggregateOutputType = {
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type CreditUsageLogSumAggregateOutputType = {
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type CreditUsageLogMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    workspaceId: string | null
    canvasId: string | null
    podId: string | null
    executionId: string | null
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type CreditUsageLogMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    workspaceId: string | null
    canvasId: string | null
    podId: string | null
    executionId: string | null
    creditsUsed: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type CreditUsageLogCountAggregateOutputType = {
    id: number
    subscriptionId: number
    workspaceId: number
    canvasId: number
    podId: number
    executionId: number
    creditsUsed: number
    balanceBefore: number
    balanceAfter: number
    provider: number
    modelId: number
    modelName: number
    createdAt: number
    _all: number
  }


  export type CreditUsageLogAvgAggregateInputType = {
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type CreditUsageLogSumAggregateInputType = {
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type CreditUsageLogMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    workspaceId?: true
    canvasId?: true
    podId?: true
    executionId?: true
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
    provider?: true
    modelId?: true
    modelName?: true
    createdAt?: true
  }

  export type CreditUsageLogMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    workspaceId?: true
    canvasId?: true
    podId?: true
    executionId?: true
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
    provider?: true
    modelId?: true
    modelName?: true
    createdAt?: true
  }

  export type CreditUsageLogCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    workspaceId?: true
    canvasId?: true
    podId?: true
    executionId?: true
    creditsUsed?: true
    balanceBefore?: true
    balanceAfter?: true
    provider?: true
    modelId?: true
    modelName?: true
    createdAt?: true
    _all?: true
  }

  export type CreditUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditUsageLog to aggregate.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditUsageLogs
    **/
    _count?: true | CreditUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditUsageLogMaxAggregateInputType
  }

  export type GetCreditUsageLogAggregateType<T extends CreditUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditUsageLog[P]>
      : GetScalarType<T[P], AggregateCreditUsageLog[P]>
  }




  export type CreditUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditUsageLogWhereInput
    orderBy?: CreditUsageLogOrderByWithAggregationInput | CreditUsageLogOrderByWithAggregationInput[]
    by: CreditUsageLogScalarFieldEnum[] | CreditUsageLogScalarFieldEnum
    having?: CreditUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditUsageLogCountAggregateInputType | true
    _avg?: CreditUsageLogAvgAggregateInputType
    _sum?: CreditUsageLogSumAggregateInputType
    _min?: CreditUsageLogMinAggregateInputType
    _max?: CreditUsageLogMaxAggregateInputType
  }

  export type CreditUsageLogGroupByOutputType = {
    id: string
    subscriptionId: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName: string | null
    createdAt: Date
    _count: CreditUsageLogCountAggregateOutputType | null
    _avg: CreditUsageLogAvgAggregateOutputType | null
    _sum: CreditUsageLogSumAggregateOutputType | null
    _min: CreditUsageLogMinAggregateOutputType | null
    _max: CreditUsageLogMaxAggregateOutputType | null
  }

  type GetCreditUsageLogGroupByPayload<T extends CreditUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], CreditUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type CreditUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditUsageLog"]>

  export type CreditUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditUsageLog"]>

  export type CreditUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditUsageLog"]>

  export type CreditUsageLogSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    workspaceId?: boolean
    canvasId?: boolean
    podId?: boolean
    executionId?: boolean
    creditsUsed?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    createdAt?: boolean
  }

  export type CreditUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "workspaceId" | "canvasId" | "podId" | "executionId" | "creditsUsed" | "balanceBefore" | "balanceAfter" | "provider" | "modelId" | "modelName" | "createdAt", ExtArgs["result"]["creditUsageLog"]>
  export type CreditUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CreditUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $CreditUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditUsageLog"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      workspaceId: string
      canvasId: string
      podId: string
      executionId: string
      creditsUsed: number
      balanceBefore: number
      balanceAfter: number
      provider: $Enums.LLMProvider
      modelId: string
      modelName: string | null
      createdAt: Date
    }, ExtArgs["result"]["creditUsageLog"]>
    composites: {}
  }

  type CreditUsageLogGetPayload<S extends boolean | null | undefined | CreditUsageLogDefaultArgs> = $Result.GetResult<Prisma.$CreditUsageLogPayload, S>

  type CreditUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditUsageLogCountAggregateInputType | true
    }

  export interface CreditUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditUsageLog'], meta: { name: 'CreditUsageLog' } }
    /**
     * Find zero or one CreditUsageLog that matches the filter.
     * @param {CreditUsageLogFindUniqueArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditUsageLogFindUniqueArgs>(args: SelectSubset<T, CreditUsageLogFindUniqueArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditUsageLogFindUniqueOrThrowArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogFindFirstArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditUsageLogFindFirstArgs>(args?: SelectSubset<T, CreditUsageLogFindFirstArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogFindFirstOrThrowArgs} args - Arguments to find a CreditUsageLog
     * @example
     * // Get one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditUsageLogs
     * const creditUsageLogs = await prisma.creditUsageLog.findMany()
     * 
     * // Get first 10 CreditUsageLogs
     * const creditUsageLogs = await prisma.creditUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditUsageLogWithIdOnly = await prisma.creditUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditUsageLogFindManyArgs>(args?: SelectSubset<T, CreditUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditUsageLog.
     * @param {CreditUsageLogCreateArgs} args - Arguments to create a CreditUsageLog.
     * @example
     * // Create one CreditUsageLog
     * const CreditUsageLog = await prisma.creditUsageLog.create({
     *   data: {
     *     // ... data to create a CreditUsageLog
     *   }
     * })
     * 
     */
    create<T extends CreditUsageLogCreateArgs>(args: SelectSubset<T, CreditUsageLogCreateArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditUsageLogs.
     * @param {CreditUsageLogCreateManyArgs} args - Arguments to create many CreditUsageLogs.
     * @example
     * // Create many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditUsageLogCreateManyArgs>(args?: SelectSubset<T, CreditUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditUsageLogs and returns the data saved in the database.
     * @param {CreditUsageLogCreateManyAndReturnArgs} args - Arguments to create many CreditUsageLogs.
     * @example
     * // Create many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditUsageLogs and only return the `id`
     * const creditUsageLogWithIdOnly = await prisma.creditUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditUsageLog.
     * @param {CreditUsageLogDeleteArgs} args - Arguments to delete one CreditUsageLog.
     * @example
     * // Delete one CreditUsageLog
     * const CreditUsageLog = await prisma.creditUsageLog.delete({
     *   where: {
     *     // ... filter to delete one CreditUsageLog
     *   }
     * })
     * 
     */
    delete<T extends CreditUsageLogDeleteArgs>(args: SelectSubset<T, CreditUsageLogDeleteArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditUsageLog.
     * @param {CreditUsageLogUpdateArgs} args - Arguments to update one CreditUsageLog.
     * @example
     * // Update one CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditUsageLogUpdateArgs>(args: SelectSubset<T, CreditUsageLogUpdateArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditUsageLogs.
     * @param {CreditUsageLogDeleteManyArgs} args - Arguments to filter CreditUsageLogs to delete.
     * @example
     * // Delete a few CreditUsageLogs
     * const { count } = await prisma.creditUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditUsageLogDeleteManyArgs>(args?: SelectSubset<T, CreditUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditUsageLogUpdateManyArgs>(args: SelectSubset<T, CreditUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditUsageLogs and returns the data updated in the database.
     * @param {CreditUsageLogUpdateManyAndReturnArgs} args - Arguments to update many CreditUsageLogs.
     * @example
     * // Update many CreditUsageLogs
     * const creditUsageLog = await prisma.creditUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditUsageLogs and only return the `id`
     * const creditUsageLogWithIdOnly = await prisma.creditUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditUsageLog.
     * @param {CreditUsageLogUpsertArgs} args - Arguments to update or create a CreditUsageLog.
     * @example
     * // Update or create a CreditUsageLog
     * const creditUsageLog = await prisma.creditUsageLog.upsert({
     *   create: {
     *     // ... data to create a CreditUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends CreditUsageLogUpsertArgs>(args: SelectSubset<T, CreditUsageLogUpsertArgs<ExtArgs>>): Prisma__CreditUsageLogClient<$Result.GetResult<Prisma.$CreditUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogCountArgs} args - Arguments to filter CreditUsageLogs to count.
     * @example
     * // Count the number of CreditUsageLogs
     * const count = await prisma.creditUsageLog.count({
     *   where: {
     *     // ... the filter for the CreditUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends CreditUsageLogCountArgs>(
      args?: Subset<T, CreditUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditUsageLogAggregateArgs>(args: Subset<T, CreditUsageLogAggregateArgs>): Prisma.PrismaPromise<GetCreditUsageLogAggregateType<T>>

    /**
     * Group by CreditUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: CreditUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditUsageLog model
   */
  readonly fields: CreditUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditUsageLog model
   */
  interface CreditUsageLogFieldRefs {
    readonly id: FieldRef<"CreditUsageLog", 'String'>
    readonly subscriptionId: FieldRef<"CreditUsageLog", 'String'>
    readonly workspaceId: FieldRef<"CreditUsageLog", 'String'>
    readonly canvasId: FieldRef<"CreditUsageLog", 'String'>
    readonly podId: FieldRef<"CreditUsageLog", 'String'>
    readonly executionId: FieldRef<"CreditUsageLog", 'String'>
    readonly creditsUsed: FieldRef<"CreditUsageLog", 'Int'>
    readonly balanceBefore: FieldRef<"CreditUsageLog", 'Int'>
    readonly balanceAfter: FieldRef<"CreditUsageLog", 'Int'>
    readonly provider: FieldRef<"CreditUsageLog", 'LLMProvider'>
    readonly modelId: FieldRef<"CreditUsageLog", 'String'>
    readonly modelName: FieldRef<"CreditUsageLog", 'String'>
    readonly createdAt: FieldRef<"CreditUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditUsageLog findUnique
   */
  export type CreditUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog findUniqueOrThrow
   */
  export type CreditUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog findFirst
   */
  export type CreditUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditUsageLogs.
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditUsageLogs.
     */
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * CreditUsageLog findFirstOrThrow
   */
  export type CreditUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLog to fetch.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditUsageLogs.
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditUsageLogs.
     */
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * CreditUsageLog findMany
   */
  export type CreditUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which CreditUsageLogs to fetch.
     */
    where?: CreditUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditUsageLogs to fetch.
     */
    orderBy?: CreditUsageLogOrderByWithRelationInput | CreditUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditUsageLogs.
     */
    cursor?: CreditUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditUsageLogs.
     */
    skip?: number
    distinct?: CreditUsageLogScalarFieldEnum | CreditUsageLogScalarFieldEnum[]
  }

  /**
   * CreditUsageLog create
   */
  export type CreditUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditUsageLog.
     */
    data: XOR<CreditUsageLogCreateInput, CreditUsageLogUncheckedCreateInput>
  }

  /**
   * CreditUsageLog createMany
   */
  export type CreditUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditUsageLogs.
     */
    data: CreditUsageLogCreateManyInput | CreditUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditUsageLog createManyAndReturn
   */
  export type CreditUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many CreditUsageLogs.
     */
    data: CreditUsageLogCreateManyInput | CreditUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditUsageLog update
   */
  export type CreditUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditUsageLog.
     */
    data: XOR<CreditUsageLogUpdateInput, CreditUsageLogUncheckedUpdateInput>
    /**
     * Choose, which CreditUsageLog to update.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog updateMany
   */
  export type CreditUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditUsageLogs.
     */
    data: XOR<CreditUsageLogUpdateManyMutationInput, CreditUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which CreditUsageLogs to update
     */
    where?: CreditUsageLogWhereInput
    /**
     * Limit how many CreditUsageLogs to update.
     */
    limit?: number
  }

  /**
   * CreditUsageLog updateManyAndReturn
   */
  export type CreditUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update CreditUsageLogs.
     */
    data: XOR<CreditUsageLogUpdateManyMutationInput, CreditUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which CreditUsageLogs to update
     */
    where?: CreditUsageLogWhereInput
    /**
     * Limit how many CreditUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditUsageLog upsert
   */
  export type CreditUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditUsageLog to update in case it exists.
     */
    where: CreditUsageLogWhereUniqueInput
    /**
     * In case the CreditUsageLog found by the `where` argument doesn't exist, create a new CreditUsageLog with this data.
     */
    create: XOR<CreditUsageLogCreateInput, CreditUsageLogUncheckedCreateInput>
    /**
     * In case the CreditUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditUsageLogUpdateInput, CreditUsageLogUncheckedUpdateInput>
  }

  /**
   * CreditUsageLog delete
   */
  export type CreditUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
    /**
     * Filter which CreditUsageLog to delete.
     */
    where: CreditUsageLogWhereUniqueInput
  }

  /**
   * CreditUsageLog deleteMany
   */
  export type CreditUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditUsageLogs to delete
     */
    where?: CreditUsageLogWhereInput
    /**
     * Limit how many CreditUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * CreditUsageLog without action
   */
  export type CreditUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditUsageLog
     */
    select?: CreditUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditUsageLog
     */
    omit?: CreditUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ModelPricingTier
   */

  export type AggregateModelPricingTier = {
    _count: ModelPricingTierCountAggregateOutputType | null
    _avg: ModelPricingTierAvgAggregateOutputType | null
    _sum: ModelPricingTierSumAggregateOutputType | null
    _min: ModelPricingTierMinAggregateOutputType | null
    _max: ModelPricingTierMaxAggregateOutputType | null
  }

  export type ModelPricingTierAvgAggregateOutputType = {
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
  }

  export type ModelPricingTierSumAggregateOutputType = {
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
  }

  export type ModelPricingTierMinAggregateOutputType = {
    id: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    category: $Enums.ModelCategory | null
    displayName: string | null
    description: string | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
    supportsStreaming: boolean | null
    supportsVision: boolean | null
    supportsAudio: boolean | null
    supportsVideo: boolean | null
    supportsFunctions: boolean | null
    supportsJsonMode: boolean | null
    supportsSystemPrompt: boolean | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelPricingTierMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    category: $Enums.ModelCategory | null
    displayName: string | null
    description: string | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    creditsPerMillionInputTokens: number | null
    creditsPerMillionOutputTokens: number | null
    creditsPerMillionReasoningTokens: number | null
    maxTokens: number | null
    maxOutputTokens: number | null
    supportsStreaming: boolean | null
    supportsVision: boolean | null
    supportsAudio: boolean | null
    supportsVideo: boolean | null
    supportsFunctions: boolean | null
    supportsJsonMode: boolean | null
    supportsSystemPrompt: boolean | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelPricingTierCountAggregateOutputType = {
    id: number
    provider: number
    modelId: number
    category: number
    displayName: number
    description: number
    inputTokenCost: number
    outputTokenCost: number
    reasoningTokenCost: number
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens: number
    maxTokens: number
    maxOutputTokens: number
    supportsStreaming: number
    supportsVision: number
    supportsAudio: number
    supportsVideo: number
    supportsFunctions: number
    supportsJsonMode: number
    supportsSystemPrompt: number
    providerConfig: number
    isActive: number
    effectiveFrom: number
    effectiveUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelPricingTierAvgAggregateInputType = {
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
  }

  export type ModelPricingTierSumAggregateInputType = {
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
  }

  export type ModelPricingTierMinAggregateInputType = {
    id?: true
    provider?: true
    modelId?: true
    category?: true
    displayName?: true
    description?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
    supportsStreaming?: true
    supportsVision?: true
    supportsAudio?: true
    supportsVideo?: true
    supportsFunctions?: true
    supportsJsonMode?: true
    supportsSystemPrompt?: true
    isActive?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelPricingTierMaxAggregateInputType = {
    id?: true
    provider?: true
    modelId?: true
    category?: true
    displayName?: true
    description?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
    supportsStreaming?: true
    supportsVision?: true
    supportsAudio?: true
    supportsVideo?: true
    supportsFunctions?: true
    supportsJsonMode?: true
    supportsSystemPrompt?: true
    isActive?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelPricingTierCountAggregateInputType = {
    id?: true
    provider?: true
    modelId?: true
    category?: true
    displayName?: true
    description?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    creditsPerMillionInputTokens?: true
    creditsPerMillionOutputTokens?: true
    creditsPerMillionReasoningTokens?: true
    maxTokens?: true
    maxOutputTokens?: true
    supportsStreaming?: true
    supportsVision?: true
    supportsAudio?: true
    supportsVideo?: true
    supportsFunctions?: true
    supportsJsonMode?: true
    supportsSystemPrompt?: true
    providerConfig?: true
    isActive?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelPricingTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelPricingTier to aggregate.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelPricingTiers
    **/
    _count?: true | ModelPricingTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelPricingTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelPricingTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelPricingTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelPricingTierMaxAggregateInputType
  }

  export type GetModelPricingTierAggregateType<T extends ModelPricingTierAggregateArgs> = {
        [P in keyof T & keyof AggregateModelPricingTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelPricingTier[P]>
      : GetScalarType<T[P], AggregateModelPricingTier[P]>
  }




  export type ModelPricingTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelPricingTierWhereInput
    orderBy?: ModelPricingTierOrderByWithAggregationInput | ModelPricingTierOrderByWithAggregationInput[]
    by: ModelPricingTierScalarFieldEnum[] | ModelPricingTierScalarFieldEnum
    having?: ModelPricingTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelPricingTierCountAggregateInputType | true
    _avg?: ModelPricingTierAvgAggregateInputType
    _sum?: ModelPricingTierSumAggregateInputType
    _min?: ModelPricingTierMinAggregateInputType
    _max?: ModelPricingTierMaxAggregateInputType
  }

  export type ModelPricingTierGroupByOutputType = {
    id: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description: string | null
    inputTokenCost: Decimal
    outputTokenCost: Decimal
    reasoningTokenCost: Decimal
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens: number
    maxTokens: number | null
    maxOutputTokens: number | null
    supportsStreaming: boolean
    supportsVision: boolean
    supportsAudio: boolean
    supportsVideo: boolean
    supportsFunctions: boolean
    supportsJsonMode: boolean
    supportsSystemPrompt: boolean
    providerConfig: JsonValue | null
    isActive: boolean
    effectiveFrom: Date
    effectiveUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ModelPricingTierCountAggregateOutputType | null
    _avg: ModelPricingTierAvgAggregateOutputType | null
    _sum: ModelPricingTierSumAggregateOutputType | null
    _min: ModelPricingTierMinAggregateOutputType | null
    _max: ModelPricingTierMaxAggregateOutputType | null
  }

  type GetModelPricingTierGroupByPayload<T extends ModelPricingTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelPricingTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelPricingTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelPricingTierGroupByOutputType[P]>
            : GetScalarType<T[P], ModelPricingTierGroupByOutputType[P]>
        }
      >
    >


  export type ModelPricingTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelPricingTier"]>

  export type ModelPricingTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelPricingTier"]>

  export type ModelPricingTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelPricingTier"]>

  export type ModelPricingTierSelectScalar = {
    id?: boolean
    provider?: boolean
    modelId?: boolean
    category?: boolean
    displayName?: boolean
    description?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    creditsPerMillionInputTokens?: boolean
    creditsPerMillionOutputTokens?: boolean
    creditsPerMillionReasoningTokens?: boolean
    maxTokens?: boolean
    maxOutputTokens?: boolean
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelPricingTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "modelId" | "category" | "displayName" | "description" | "inputTokenCost" | "outputTokenCost" | "reasoningTokenCost" | "creditsPerMillionInputTokens" | "creditsPerMillionOutputTokens" | "creditsPerMillionReasoningTokens" | "maxTokens" | "maxOutputTokens" | "supportsStreaming" | "supportsVision" | "supportsAudio" | "supportsVideo" | "supportsFunctions" | "supportsJsonMode" | "supportsSystemPrompt" | "providerConfig" | "isActive" | "effectiveFrom" | "effectiveUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["modelPricingTier"]>

  export type $ModelPricingTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelPricingTier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.LLMProvider
      modelId: string
      category: $Enums.ModelCategory
      displayName: string
      description: string | null
      inputTokenCost: Prisma.Decimal
      outputTokenCost: Prisma.Decimal
      reasoningTokenCost: Prisma.Decimal
      creditsPerMillionInputTokens: number
      creditsPerMillionOutputTokens: number
      creditsPerMillionReasoningTokens: number
      maxTokens: number | null
      maxOutputTokens: number | null
      supportsStreaming: boolean
      supportsVision: boolean
      supportsAudio: boolean
      supportsVideo: boolean
      supportsFunctions: boolean
      supportsJsonMode: boolean
      supportsSystemPrompt: boolean
      providerConfig: Prisma.JsonValue | null
      isActive: boolean
      effectiveFrom: Date
      effectiveUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modelPricingTier"]>
    composites: {}
  }

  type ModelPricingTierGetPayload<S extends boolean | null | undefined | ModelPricingTierDefaultArgs> = $Result.GetResult<Prisma.$ModelPricingTierPayload, S>

  type ModelPricingTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelPricingTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelPricingTierCountAggregateInputType | true
    }

  export interface ModelPricingTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelPricingTier'], meta: { name: 'ModelPricingTier' } }
    /**
     * Find zero or one ModelPricingTier that matches the filter.
     * @param {ModelPricingTierFindUniqueArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelPricingTierFindUniqueArgs>(args: SelectSubset<T, ModelPricingTierFindUniqueArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelPricingTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelPricingTierFindUniqueOrThrowArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelPricingTierFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelPricingTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelPricingTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierFindFirstArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelPricingTierFindFirstArgs>(args?: SelectSubset<T, ModelPricingTierFindFirstArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelPricingTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierFindFirstOrThrowArgs} args - Arguments to find a ModelPricingTier
     * @example
     * // Get one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelPricingTierFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelPricingTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelPricingTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelPricingTiers
     * const modelPricingTiers = await prisma.modelPricingTier.findMany()
     * 
     * // Get first 10 ModelPricingTiers
     * const modelPricingTiers = await prisma.modelPricingTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelPricingTierWithIdOnly = await prisma.modelPricingTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelPricingTierFindManyArgs>(args?: SelectSubset<T, ModelPricingTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelPricingTier.
     * @param {ModelPricingTierCreateArgs} args - Arguments to create a ModelPricingTier.
     * @example
     * // Create one ModelPricingTier
     * const ModelPricingTier = await prisma.modelPricingTier.create({
     *   data: {
     *     // ... data to create a ModelPricingTier
     *   }
     * })
     * 
     */
    create<T extends ModelPricingTierCreateArgs>(args: SelectSubset<T, ModelPricingTierCreateArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelPricingTiers.
     * @param {ModelPricingTierCreateManyArgs} args - Arguments to create many ModelPricingTiers.
     * @example
     * // Create many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelPricingTierCreateManyArgs>(args?: SelectSubset<T, ModelPricingTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelPricingTiers and returns the data saved in the database.
     * @param {ModelPricingTierCreateManyAndReturnArgs} args - Arguments to create many ModelPricingTiers.
     * @example
     * // Create many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelPricingTiers and only return the `id`
     * const modelPricingTierWithIdOnly = await prisma.modelPricingTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelPricingTierCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelPricingTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModelPricingTier.
     * @param {ModelPricingTierDeleteArgs} args - Arguments to delete one ModelPricingTier.
     * @example
     * // Delete one ModelPricingTier
     * const ModelPricingTier = await prisma.modelPricingTier.delete({
     *   where: {
     *     // ... filter to delete one ModelPricingTier
     *   }
     * })
     * 
     */
    delete<T extends ModelPricingTierDeleteArgs>(args: SelectSubset<T, ModelPricingTierDeleteArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelPricingTier.
     * @param {ModelPricingTierUpdateArgs} args - Arguments to update one ModelPricingTier.
     * @example
     * // Update one ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelPricingTierUpdateArgs>(args: SelectSubset<T, ModelPricingTierUpdateArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelPricingTiers.
     * @param {ModelPricingTierDeleteManyArgs} args - Arguments to filter ModelPricingTiers to delete.
     * @example
     * // Delete a few ModelPricingTiers
     * const { count } = await prisma.modelPricingTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelPricingTierDeleteManyArgs>(args?: SelectSubset<T, ModelPricingTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelPricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelPricingTierUpdateManyArgs>(args: SelectSubset<T, ModelPricingTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelPricingTiers and returns the data updated in the database.
     * @param {ModelPricingTierUpdateManyAndReturnArgs} args - Arguments to update many ModelPricingTiers.
     * @example
     * // Update many ModelPricingTiers
     * const modelPricingTier = await prisma.modelPricingTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelPricingTiers and only return the `id`
     * const modelPricingTierWithIdOnly = await prisma.modelPricingTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelPricingTierUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelPricingTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModelPricingTier.
     * @param {ModelPricingTierUpsertArgs} args - Arguments to update or create a ModelPricingTier.
     * @example
     * // Update or create a ModelPricingTier
     * const modelPricingTier = await prisma.modelPricingTier.upsert({
     *   create: {
     *     // ... data to create a ModelPricingTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelPricingTier we want to update
     *   }
     * })
     */
    upsert<T extends ModelPricingTierUpsertArgs>(args: SelectSubset<T, ModelPricingTierUpsertArgs<ExtArgs>>): Prisma__ModelPricingTierClient<$Result.GetResult<Prisma.$ModelPricingTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelPricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierCountArgs} args - Arguments to filter ModelPricingTiers to count.
     * @example
     * // Count the number of ModelPricingTiers
     * const count = await prisma.modelPricingTier.count({
     *   where: {
     *     // ... the filter for the ModelPricingTiers we want to count
     *   }
     * })
    **/
    count<T extends ModelPricingTierCountArgs>(
      args?: Subset<T, ModelPricingTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelPricingTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelPricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelPricingTierAggregateArgs>(args: Subset<T, ModelPricingTierAggregateArgs>): Prisma.PrismaPromise<GetModelPricingTierAggregateType<T>>

    /**
     * Group by ModelPricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelPricingTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelPricingTierGroupByArgs['orderBy'] }
        : { orderBy?: ModelPricingTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelPricingTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelPricingTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelPricingTier model
   */
  readonly fields: ModelPricingTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelPricingTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelPricingTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelPricingTier model
   */
  interface ModelPricingTierFieldRefs {
    readonly id: FieldRef<"ModelPricingTier", 'String'>
    readonly provider: FieldRef<"ModelPricingTier", 'LLMProvider'>
    readonly modelId: FieldRef<"ModelPricingTier", 'String'>
    readonly category: FieldRef<"ModelPricingTier", 'ModelCategory'>
    readonly displayName: FieldRef<"ModelPricingTier", 'String'>
    readonly description: FieldRef<"ModelPricingTier", 'String'>
    readonly inputTokenCost: FieldRef<"ModelPricingTier", 'Decimal'>
    readonly outputTokenCost: FieldRef<"ModelPricingTier", 'Decimal'>
    readonly reasoningTokenCost: FieldRef<"ModelPricingTier", 'Decimal'>
    readonly creditsPerMillionInputTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly creditsPerMillionOutputTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly creditsPerMillionReasoningTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly maxTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly maxOutputTokens: FieldRef<"ModelPricingTier", 'Int'>
    readonly supportsStreaming: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsVision: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsAudio: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsVideo: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsFunctions: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsJsonMode: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly supportsSystemPrompt: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly providerConfig: FieldRef<"ModelPricingTier", 'Json'>
    readonly isActive: FieldRef<"ModelPricingTier", 'Boolean'>
    readonly effectiveFrom: FieldRef<"ModelPricingTier", 'DateTime'>
    readonly effectiveUntil: FieldRef<"ModelPricingTier", 'DateTime'>
    readonly createdAt: FieldRef<"ModelPricingTier", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelPricingTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelPricingTier findUnique
   */
  export type ModelPricingTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier findUniqueOrThrow
   */
  export type ModelPricingTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier findFirst
   */
  export type ModelPricingTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelPricingTiers.
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelPricingTiers.
     */
    distinct?: ModelPricingTierScalarFieldEnum | ModelPricingTierScalarFieldEnum[]
  }

  /**
   * ModelPricingTier findFirstOrThrow
   */
  export type ModelPricingTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTier to fetch.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelPricingTiers.
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelPricingTiers.
     */
    distinct?: ModelPricingTierScalarFieldEnum | ModelPricingTierScalarFieldEnum[]
  }

  /**
   * ModelPricingTier findMany
   */
  export type ModelPricingTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricingTiers to fetch.
     */
    where?: ModelPricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricingTiers to fetch.
     */
    orderBy?: ModelPricingTierOrderByWithRelationInput | ModelPricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelPricingTiers.
     */
    cursor?: ModelPricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelPricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricingTiers.
     */
    skip?: number
    distinct?: ModelPricingTierScalarFieldEnum | ModelPricingTierScalarFieldEnum[]
  }

  /**
   * ModelPricingTier create
   */
  export type ModelPricingTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data needed to create a ModelPricingTier.
     */
    data: XOR<ModelPricingTierCreateInput, ModelPricingTierUncheckedCreateInput>
  }

  /**
   * ModelPricingTier createMany
   */
  export type ModelPricingTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelPricingTiers.
     */
    data: ModelPricingTierCreateManyInput | ModelPricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelPricingTier createManyAndReturn
   */
  export type ModelPricingTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data used to create many ModelPricingTiers.
     */
    data: ModelPricingTierCreateManyInput | ModelPricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelPricingTier update
   */
  export type ModelPricingTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data needed to update a ModelPricingTier.
     */
    data: XOR<ModelPricingTierUpdateInput, ModelPricingTierUncheckedUpdateInput>
    /**
     * Choose, which ModelPricingTier to update.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier updateMany
   */
  export type ModelPricingTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelPricingTiers.
     */
    data: XOR<ModelPricingTierUpdateManyMutationInput, ModelPricingTierUncheckedUpdateManyInput>
    /**
     * Filter which ModelPricingTiers to update
     */
    where?: ModelPricingTierWhereInput
    /**
     * Limit how many ModelPricingTiers to update.
     */
    limit?: number
  }

  /**
   * ModelPricingTier updateManyAndReturn
   */
  export type ModelPricingTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The data used to update ModelPricingTiers.
     */
    data: XOR<ModelPricingTierUpdateManyMutationInput, ModelPricingTierUncheckedUpdateManyInput>
    /**
     * Filter which ModelPricingTiers to update
     */
    where?: ModelPricingTierWhereInput
    /**
     * Limit how many ModelPricingTiers to update.
     */
    limit?: number
  }

  /**
   * ModelPricingTier upsert
   */
  export type ModelPricingTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * The filter to search for the ModelPricingTier to update in case it exists.
     */
    where: ModelPricingTierWhereUniqueInput
    /**
     * In case the ModelPricingTier found by the `where` argument doesn't exist, create a new ModelPricingTier with this data.
     */
    create: XOR<ModelPricingTierCreateInput, ModelPricingTierUncheckedCreateInput>
    /**
     * In case the ModelPricingTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelPricingTierUpdateInput, ModelPricingTierUncheckedUpdateInput>
  }

  /**
   * ModelPricingTier delete
   */
  export type ModelPricingTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
    /**
     * Filter which ModelPricingTier to delete.
     */
    where: ModelPricingTierWhereUniqueInput
  }

  /**
   * ModelPricingTier deleteMany
   */
  export type ModelPricingTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelPricingTiers to delete
     */
    where?: ModelPricingTierWhereInput
    /**
     * Limit how many ModelPricingTiers to delete.
     */
    limit?: number
  }

  /**
   * ModelPricingTier without action
   */
  export type ModelPricingTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricingTier
     */
    select?: ModelPricingTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricingTier
     */
    omit?: ModelPricingTierOmit<ExtArgs> | null
  }


  /**
   * Model Canvas
   */

  export type AggregateCanvas = {
    _count: CanvasCountAggregateOutputType | null
    _avg: CanvasAvgAggregateOutputType | null
    _sum: CanvasSumAggregateOutputType | null
    _min: CanvasMinAggregateOutputType | null
    _max: CanvasMaxAggregateOutputType | null
  }

  export type CanvasAvgAggregateOutputType = {
    version: number | null
  }

  export type CanvasSumAggregateOutputType = {
    version: number | null
  }

  export type CanvasMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    version: number | null
    visibility: $Enums.CanvasVisibility | null
    createdBy: string | null
    thumbnailS3Key: string | null
    thumbnailGeneratedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    version: number | null
    visibility: $Enums.CanvasVisibility | null
    createdBy: string | null
    thumbnailS3Key: string | null
    thumbnailGeneratedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    version: number
    visibility: number
    createdBy: number
    thumbnailS3Key: number
    thumbnailGeneratedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CanvasAvgAggregateInputType = {
    version?: true
  }

  export type CanvasSumAggregateInputType = {
    version?: true
  }

  export type CanvasMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    version?: true
    visibility?: true
    createdBy?: true
    thumbnailS3Key?: true
    thumbnailGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    version?: true
    visibility?: true
    createdBy?: true
    thumbnailS3Key?: true
    thumbnailGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    version?: true
    visibility?: true
    createdBy?: true
    thumbnailS3Key?: true
    thumbnailGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CanvasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvas to aggregate.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Canvas
    **/
    _count?: true | CanvasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CanvasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CanvasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasMaxAggregateInputType
  }

  export type GetCanvasAggregateType<T extends CanvasAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvas[P]>
      : GetScalarType<T[P], AggregateCanvas[P]>
  }




  export type CanvasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasWhereInput
    orderBy?: CanvasOrderByWithAggregationInput | CanvasOrderByWithAggregationInput[]
    by: CanvasScalarFieldEnum[] | CanvasScalarFieldEnum
    having?: CanvasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasCountAggregateInputType | true
    _avg?: CanvasAvgAggregateInputType
    _sum?: CanvasSumAggregateInputType
    _min?: CanvasMinAggregateInputType
    _max?: CanvasMaxAggregateInputType
  }

  export type CanvasGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    version: number
    visibility: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key: string | null
    thumbnailGeneratedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CanvasCountAggregateOutputType | null
    _avg: CanvasAvgAggregateOutputType | null
    _sum: CanvasSumAggregateOutputType | null
    _min: CanvasMinAggregateOutputType | null
    _max: CanvasMaxAggregateOutputType | null
  }

  type GetCanvasGroupByPayload<T extends CanvasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasGroupByOutputType[P]>
        }
      >
    >


  export type CanvasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    actionPods?: boolean | Canvas$actionPodsArgs<ExtArgs>
    edges?: boolean | Canvas$edgesArgs<ExtArgs>
    contextualPods?: boolean | Canvas$contextualPodsArgs<ExtArgs>
    contextModules?: boolean | Canvas$contextModulesArgs<ExtArgs>
    collaborators?: boolean | Canvas$collaboratorsArgs<ExtArgs>
    invitations?: boolean | Canvas$invitationsArgs<ExtArgs>
    sessions?: boolean | Canvas$sessionsArgs<ExtArgs>
    activityLog?: boolean | Canvas$activityLogArgs<ExtArgs>
    comments?: boolean | Canvas$commentsArgs<ExtArgs>
    _count?: boolean | CanvasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvas"]>

  export type CanvasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvas"]>

  export type CanvasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvas"]>

  export type CanvasSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    visibility?: boolean
    createdBy?: boolean
    thumbnailS3Key?: boolean
    thumbnailGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CanvasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "version" | "visibility" | "createdBy" | "thumbnailS3Key" | "thumbnailGeneratedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["canvas"]>
  export type CanvasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    actionPods?: boolean | Canvas$actionPodsArgs<ExtArgs>
    edges?: boolean | Canvas$edgesArgs<ExtArgs>
    contextualPods?: boolean | Canvas$contextualPodsArgs<ExtArgs>
    contextModules?: boolean | Canvas$contextModulesArgs<ExtArgs>
    collaborators?: boolean | Canvas$collaboratorsArgs<ExtArgs>
    invitations?: boolean | Canvas$invitationsArgs<ExtArgs>
    sessions?: boolean | Canvas$sessionsArgs<ExtArgs>
    activityLog?: boolean | Canvas$activityLogArgs<ExtArgs>
    comments?: boolean | Canvas$commentsArgs<ExtArgs>
    _count?: boolean | CanvasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CanvasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type CanvasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $CanvasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Canvas"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      actionPods: Prisma.$ActionPodPayload<ExtArgs>[]
      edges: Prisma.$EdgePayload<ExtArgs>[]
      contextualPods: Prisma.$ActionPodPayload<ExtArgs>[]
      contextModules: Prisma.$ContextModulePayload<ExtArgs>[]
      collaborators: Prisma.$CanvasCollaboratorPayload<ExtArgs>[]
      invitations: Prisma.$CanvasInvitationPayload<ExtArgs>[]
      sessions: Prisma.$CanvasSessionPayload<ExtArgs>[]
      activityLog: Prisma.$CanvasActivityLogPayload<ExtArgs>[]
      comments: Prisma.$CanvasCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      version: number
      visibility: $Enums.CanvasVisibility
      createdBy: string
      thumbnailS3Key: string | null
      thumbnailGeneratedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["canvas"]>
    composites: {}
  }

  type CanvasGetPayload<S extends boolean | null | undefined | CanvasDefaultArgs> = $Result.GetResult<Prisma.$CanvasPayload, S>

  type CanvasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasCountAggregateInputType | true
    }

  export interface CanvasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Canvas'], meta: { name: 'Canvas' } }
    /**
     * Find zero or one Canvas that matches the filter.
     * @param {CanvasFindUniqueArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasFindUniqueArgs>(args: SelectSubset<T, CanvasFindUniqueArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Canvas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasFindUniqueOrThrowArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Canvas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasFindFirstArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasFindFirstArgs>(args?: SelectSubset<T, CanvasFindFirstArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Canvas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasFindFirstOrThrowArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Canvas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Canvas
     * const canvas = await prisma.canvas.findMany()
     * 
     * // Get first 10 Canvas
     * const canvas = await prisma.canvas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasWithIdOnly = await prisma.canvas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasFindManyArgs>(args?: SelectSubset<T, CanvasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Canvas.
     * @param {CanvasCreateArgs} args - Arguments to create a Canvas.
     * @example
     * // Create one Canvas
     * const Canvas = await prisma.canvas.create({
     *   data: {
     *     // ... data to create a Canvas
     *   }
     * })
     * 
     */
    create<T extends CanvasCreateArgs>(args: SelectSubset<T, CanvasCreateArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Canvas.
     * @param {CanvasCreateManyArgs} args - Arguments to create many Canvas.
     * @example
     * // Create many Canvas
     * const canvas = await prisma.canvas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasCreateManyArgs>(args?: SelectSubset<T, CanvasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Canvas and returns the data saved in the database.
     * @param {CanvasCreateManyAndReturnArgs} args - Arguments to create many Canvas.
     * @example
     * // Create many Canvas
     * const canvas = await prisma.canvas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Canvas and only return the `id`
     * const canvasWithIdOnly = await prisma.canvas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Canvas.
     * @param {CanvasDeleteArgs} args - Arguments to delete one Canvas.
     * @example
     * // Delete one Canvas
     * const Canvas = await prisma.canvas.delete({
     *   where: {
     *     // ... filter to delete one Canvas
     *   }
     * })
     * 
     */
    delete<T extends CanvasDeleteArgs>(args: SelectSubset<T, CanvasDeleteArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Canvas.
     * @param {CanvasUpdateArgs} args - Arguments to update one Canvas.
     * @example
     * // Update one Canvas
     * const canvas = await prisma.canvas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasUpdateArgs>(args: SelectSubset<T, CanvasUpdateArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Canvas.
     * @param {CanvasDeleteManyArgs} args - Arguments to filter Canvas to delete.
     * @example
     * // Delete a few Canvas
     * const { count } = await prisma.canvas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasDeleteManyArgs>(args?: SelectSubset<T, CanvasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Canvas
     * const canvas = await prisma.canvas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasUpdateManyArgs>(args: SelectSubset<T, CanvasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Canvas and returns the data updated in the database.
     * @param {CanvasUpdateManyAndReturnArgs} args - Arguments to update many Canvas.
     * @example
     * // Update many Canvas
     * const canvas = await prisma.canvas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Canvas and only return the `id`
     * const canvasWithIdOnly = await prisma.canvas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Canvas.
     * @param {CanvasUpsertArgs} args - Arguments to update or create a Canvas.
     * @example
     * // Update or create a Canvas
     * const canvas = await prisma.canvas.upsert({
     *   create: {
     *     // ... data to create a Canvas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Canvas we want to update
     *   }
     * })
     */
    upsert<T extends CanvasUpsertArgs>(args: SelectSubset<T, CanvasUpsertArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCountArgs} args - Arguments to filter Canvas to count.
     * @example
     * // Count the number of Canvas
     * const count = await prisma.canvas.count({
     *   where: {
     *     // ... the filter for the Canvas we want to count
     *   }
     * })
    **/
    count<T extends CanvasCountArgs>(
      args?: Subset<T, CanvasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasAggregateArgs>(args: Subset<T, CanvasAggregateArgs>): Prisma.PrismaPromise<GetCanvasAggregateType<T>>

    /**
     * Group by Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasGroupByArgs['orderBy'] }
        : { orderBy?: CanvasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Canvas model
   */
  readonly fields: CanvasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Canvas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actionPods<T extends Canvas$actionPodsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$actionPodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    edges<T extends Canvas$edgesArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$edgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contextualPods<T extends Canvas$contextualPodsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$contextualPodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contextModules<T extends Canvas$contextModulesArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$contextModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collaborators<T extends Canvas$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Canvas$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Canvas$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLog<T extends Canvas$activityLogArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$activityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Canvas$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Canvas model
   */
  interface CanvasFieldRefs {
    readonly id: FieldRef<"Canvas", 'String'>
    readonly workspaceId: FieldRef<"Canvas", 'String'>
    readonly name: FieldRef<"Canvas", 'String'>
    readonly description: FieldRef<"Canvas", 'String'>
    readonly version: FieldRef<"Canvas", 'Int'>
    readonly visibility: FieldRef<"Canvas", 'CanvasVisibility'>
    readonly createdBy: FieldRef<"Canvas", 'String'>
    readonly thumbnailS3Key: FieldRef<"Canvas", 'String'>
    readonly thumbnailGeneratedAt: FieldRef<"Canvas", 'DateTime'>
    readonly createdAt: FieldRef<"Canvas", 'DateTime'>
    readonly updatedAt: FieldRef<"Canvas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Canvas findUnique
   */
  export type CanvasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas findUniqueOrThrow
   */
  export type CanvasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas findFirst
   */
  export type CanvasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvas.
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvas.
     */
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Canvas findFirstOrThrow
   */
  export type CanvasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvas.
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvas.
     */
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Canvas findMany
   */
  export type CanvasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Canvas.
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Canvas create
   */
  export type CanvasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * The data needed to create a Canvas.
     */
    data: XOR<CanvasCreateInput, CanvasUncheckedCreateInput>
  }

  /**
   * Canvas createMany
   */
  export type CanvasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Canvas.
     */
    data: CanvasCreateManyInput | CanvasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Canvas createManyAndReturn
   */
  export type CanvasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * The data used to create many Canvas.
     */
    data: CanvasCreateManyInput | CanvasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Canvas update
   */
  export type CanvasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * The data needed to update a Canvas.
     */
    data: XOR<CanvasUpdateInput, CanvasUncheckedUpdateInput>
    /**
     * Choose, which Canvas to update.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas updateMany
   */
  export type CanvasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Canvas.
     */
    data: XOR<CanvasUpdateManyMutationInput, CanvasUncheckedUpdateManyInput>
    /**
     * Filter which Canvas to update
     */
    where?: CanvasWhereInput
    /**
     * Limit how many Canvas to update.
     */
    limit?: number
  }

  /**
   * Canvas updateManyAndReturn
   */
  export type CanvasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * The data used to update Canvas.
     */
    data: XOR<CanvasUpdateManyMutationInput, CanvasUncheckedUpdateManyInput>
    /**
     * Filter which Canvas to update
     */
    where?: CanvasWhereInput
    /**
     * Limit how many Canvas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Canvas upsert
   */
  export type CanvasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * The filter to search for the Canvas to update in case it exists.
     */
    where: CanvasWhereUniqueInput
    /**
     * In case the Canvas found by the `where` argument doesn't exist, create a new Canvas with this data.
     */
    create: XOR<CanvasCreateInput, CanvasUncheckedCreateInput>
    /**
     * In case the Canvas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasUpdateInput, CanvasUncheckedUpdateInput>
  }

  /**
   * Canvas delete
   */
  export type CanvasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter which Canvas to delete.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas deleteMany
   */
  export type CanvasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvas to delete
     */
    where?: CanvasWhereInput
    /**
     * Limit how many Canvas to delete.
     */
    limit?: number
  }

  /**
   * Canvas.actionPods
   */
  export type Canvas$actionPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    where?: ActionPodWhereInput
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    cursor?: ActionPodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionPodScalarFieldEnum | ActionPodScalarFieldEnum[]
  }

  /**
   * Canvas.edges
   */
  export type Canvas$edgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    cursor?: EdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Canvas.contextualPods
   */
  export type Canvas$contextualPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    where?: ActionPodWhereInput
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    cursor?: ActionPodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionPodScalarFieldEnum | ActionPodScalarFieldEnum[]
  }

  /**
   * Canvas.contextModules
   */
  export type Canvas$contextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    where?: ContextModuleWhereInput
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    cursor?: ContextModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * Canvas.collaborators
   */
  export type Canvas$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    where?: CanvasCollaboratorWhereInput
    orderBy?: CanvasCollaboratorOrderByWithRelationInput | CanvasCollaboratorOrderByWithRelationInput[]
    cursor?: CanvasCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasCollaboratorScalarFieldEnum | CanvasCollaboratorScalarFieldEnum[]
  }

  /**
   * Canvas.invitations
   */
  export type Canvas$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    where?: CanvasInvitationWhereInput
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    cursor?: CanvasInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasInvitationScalarFieldEnum | CanvasInvitationScalarFieldEnum[]
  }

  /**
   * Canvas.sessions
   */
  export type Canvas$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    where?: CanvasSessionWhereInput
    orderBy?: CanvasSessionOrderByWithRelationInput | CanvasSessionOrderByWithRelationInput[]
    cursor?: CanvasSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasSessionScalarFieldEnum | CanvasSessionScalarFieldEnum[]
  }

  /**
   * Canvas.activityLog
   */
  export type Canvas$activityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    where?: CanvasActivityLogWhereInput
    orderBy?: CanvasActivityLogOrderByWithRelationInput | CanvasActivityLogOrderByWithRelationInput[]
    cursor?: CanvasActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasActivityLogScalarFieldEnum | CanvasActivityLogScalarFieldEnum[]
  }

  /**
   * Canvas.comments
   */
  export type Canvas$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    where?: CanvasCommentWhereInput
    orderBy?: CanvasCommentOrderByWithRelationInput | CanvasCommentOrderByWithRelationInput[]
    cursor?: CanvasCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasCommentScalarFieldEnum | CanvasCommentScalarFieldEnum[]
  }

  /**
   * Canvas without action
   */
  export type CanvasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
  }


  /**
   * Model CanvasInvitation
   */

  export type AggregateCanvasInvitation = {
    _count: CanvasInvitationCountAggregateOutputType | null
    _min: CanvasInvitationMinAggregateOutputType | null
    _max: CanvasInvitationMaxAggregateOutputType | null
  }

  export type CanvasInvitationMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    email: string | null
    accessLevel: $Enums.CanvasAccessLevel | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type CanvasInvitationMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    email: string | null
    accessLevel: $Enums.CanvasAccessLevel | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type CanvasInvitationCountAggregateOutputType = {
    id: number
    canvasId: number
    email: number
    accessLevel: number
    permissions: number
    invitedBy: number
    invitedUserId: number
    token: number
    status: number
    createdAt: number
    expiresAt: number
    acceptedAt: number
    _all: number
  }


  export type CanvasInvitationMinAggregateInputType = {
    id?: true
    canvasId?: true
    email?: true
    accessLevel?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type CanvasInvitationMaxAggregateInputType = {
    id?: true
    canvasId?: true
    email?: true
    accessLevel?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type CanvasInvitationCountAggregateInputType = {
    id?: true
    canvasId?: true
    email?: true
    accessLevel?: true
    permissions?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type CanvasInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasInvitation to aggregate.
     */
    where?: CanvasInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasInvitations to fetch.
     */
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasInvitations
    **/
    _count?: true | CanvasInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasInvitationMaxAggregateInputType
  }

  export type GetCanvasInvitationAggregateType<T extends CanvasInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasInvitation[P]>
      : GetScalarType<T[P], AggregateCanvasInvitation[P]>
  }




  export type CanvasInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasInvitationWhereInput
    orderBy?: CanvasInvitationOrderByWithAggregationInput | CanvasInvitationOrderByWithAggregationInput[]
    by: CanvasInvitationScalarFieldEnum[] | CanvasInvitationScalarFieldEnum
    having?: CanvasInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasInvitationCountAggregateInputType | true
    _min?: CanvasInvitationMinAggregateInputType
    _max?: CanvasInvitationMaxAggregateInputType
  }

  export type CanvasInvitationGroupByOutputType = {
    id: string
    canvasId: string
    email: string
    accessLevel: $Enums.CanvasAccessLevel
    permissions: JsonValue | null
    invitedBy: string
    invitedUserId: string | null
    token: string
    status: $Enums.InvitationStatus
    createdAt: Date
    expiresAt: Date
    acceptedAt: Date | null
    _count: CanvasInvitationCountAggregateOutputType | null
    _min: CanvasInvitationMinAggregateOutputType | null
    _max: CanvasInvitationMaxAggregateOutputType | null
  }

  type GetCanvasInvitationGroupByPayload<T extends CanvasInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasInvitationGroupByOutputType[P]>
        }
      >
    >


  export type CanvasInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | CanvasInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["canvasInvitation"]>

  export type CanvasInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | CanvasInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["canvasInvitation"]>

  export type CanvasInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | CanvasInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["canvasInvitation"]>

  export type CanvasInvitationSelectScalar = {
    id?: boolean
    canvasId?: boolean
    email?: boolean
    accessLevel?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
  }

  export type CanvasInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "email" | "accessLevel" | "permissions" | "invitedBy" | "invitedUserId" | "token" | "status" | "createdAt" | "expiresAt" | "acceptedAt", ExtArgs["result"]["canvasInvitation"]>
  export type CanvasInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | CanvasInvitation$invitedUserArgs<ExtArgs>
  }
  export type CanvasInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | CanvasInvitation$invitedUserArgs<ExtArgs>
  }
  export type CanvasInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | CanvasInvitation$invitedUserArgs<ExtArgs>
  }

  export type $CanvasInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasInvitation"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      invitedUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      email: string
      accessLevel: $Enums.CanvasAccessLevel
      permissions: Prisma.JsonValue | null
      invitedBy: string
      invitedUserId: string | null
      token: string
      status: $Enums.InvitationStatus
      createdAt: Date
      expiresAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["canvasInvitation"]>
    composites: {}
  }

  type CanvasInvitationGetPayload<S extends boolean | null | undefined | CanvasInvitationDefaultArgs> = $Result.GetResult<Prisma.$CanvasInvitationPayload, S>

  type CanvasInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasInvitationCountAggregateInputType | true
    }

  export interface CanvasInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasInvitation'], meta: { name: 'CanvasInvitation' } }
    /**
     * Find zero or one CanvasInvitation that matches the filter.
     * @param {CanvasInvitationFindUniqueArgs} args - Arguments to find a CanvasInvitation
     * @example
     * // Get one CanvasInvitation
     * const canvasInvitation = await prisma.canvasInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasInvitationFindUniqueArgs>(args: SelectSubset<T, CanvasInvitationFindUniqueArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasInvitationFindUniqueOrThrowArgs} args - Arguments to find a CanvasInvitation
     * @example
     * // Get one CanvasInvitation
     * const canvasInvitation = await prisma.canvasInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationFindFirstArgs} args - Arguments to find a CanvasInvitation
     * @example
     * // Get one CanvasInvitation
     * const canvasInvitation = await prisma.canvasInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasInvitationFindFirstArgs>(args?: SelectSubset<T, CanvasInvitationFindFirstArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationFindFirstOrThrowArgs} args - Arguments to find a CanvasInvitation
     * @example
     * // Get one CanvasInvitation
     * const canvasInvitation = await prisma.canvasInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasInvitations
     * const canvasInvitations = await prisma.canvasInvitation.findMany()
     * 
     * // Get first 10 CanvasInvitations
     * const canvasInvitations = await prisma.canvasInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasInvitationWithIdOnly = await prisma.canvasInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasInvitationFindManyArgs>(args?: SelectSubset<T, CanvasInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasInvitation.
     * @param {CanvasInvitationCreateArgs} args - Arguments to create a CanvasInvitation.
     * @example
     * // Create one CanvasInvitation
     * const CanvasInvitation = await prisma.canvasInvitation.create({
     *   data: {
     *     // ... data to create a CanvasInvitation
     *   }
     * })
     * 
     */
    create<T extends CanvasInvitationCreateArgs>(args: SelectSubset<T, CanvasInvitationCreateArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasInvitations.
     * @param {CanvasInvitationCreateManyArgs} args - Arguments to create many CanvasInvitations.
     * @example
     * // Create many CanvasInvitations
     * const canvasInvitation = await prisma.canvasInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasInvitationCreateManyArgs>(args?: SelectSubset<T, CanvasInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasInvitations and returns the data saved in the database.
     * @param {CanvasInvitationCreateManyAndReturnArgs} args - Arguments to create many CanvasInvitations.
     * @example
     * // Create many CanvasInvitations
     * const canvasInvitation = await prisma.canvasInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasInvitations and only return the `id`
     * const canvasInvitationWithIdOnly = await prisma.canvasInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasInvitation.
     * @param {CanvasInvitationDeleteArgs} args - Arguments to delete one CanvasInvitation.
     * @example
     * // Delete one CanvasInvitation
     * const CanvasInvitation = await prisma.canvasInvitation.delete({
     *   where: {
     *     // ... filter to delete one CanvasInvitation
     *   }
     * })
     * 
     */
    delete<T extends CanvasInvitationDeleteArgs>(args: SelectSubset<T, CanvasInvitationDeleteArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasInvitation.
     * @param {CanvasInvitationUpdateArgs} args - Arguments to update one CanvasInvitation.
     * @example
     * // Update one CanvasInvitation
     * const canvasInvitation = await prisma.canvasInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasInvitationUpdateArgs>(args: SelectSubset<T, CanvasInvitationUpdateArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasInvitations.
     * @param {CanvasInvitationDeleteManyArgs} args - Arguments to filter CanvasInvitations to delete.
     * @example
     * // Delete a few CanvasInvitations
     * const { count } = await prisma.canvasInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasInvitationDeleteManyArgs>(args?: SelectSubset<T, CanvasInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasInvitations
     * const canvasInvitation = await prisma.canvasInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasInvitationUpdateManyArgs>(args: SelectSubset<T, CanvasInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasInvitations and returns the data updated in the database.
     * @param {CanvasInvitationUpdateManyAndReturnArgs} args - Arguments to update many CanvasInvitations.
     * @example
     * // Update many CanvasInvitations
     * const canvasInvitation = await prisma.canvasInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasInvitations and only return the `id`
     * const canvasInvitationWithIdOnly = await prisma.canvasInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasInvitation.
     * @param {CanvasInvitationUpsertArgs} args - Arguments to update or create a CanvasInvitation.
     * @example
     * // Update or create a CanvasInvitation
     * const canvasInvitation = await prisma.canvasInvitation.upsert({
     *   create: {
     *     // ... data to create a CanvasInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasInvitation we want to update
     *   }
     * })
     */
    upsert<T extends CanvasInvitationUpsertArgs>(args: SelectSubset<T, CanvasInvitationUpsertArgs<ExtArgs>>): Prisma__CanvasInvitationClient<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationCountArgs} args - Arguments to filter CanvasInvitations to count.
     * @example
     * // Count the number of CanvasInvitations
     * const count = await prisma.canvasInvitation.count({
     *   where: {
     *     // ... the filter for the CanvasInvitations we want to count
     *   }
     * })
    **/
    count<T extends CanvasInvitationCountArgs>(
      args?: Subset<T, CanvasInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasInvitationAggregateArgs>(args: Subset<T, CanvasInvitationAggregateArgs>): Prisma.PrismaPromise<GetCanvasInvitationAggregateType<T>>

    /**
     * Group by CanvasInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasInvitationGroupByArgs['orderBy'] }
        : { orderBy?: CanvasInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasInvitation model
   */
  readonly fields: CanvasInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitedUser<T extends CanvasInvitation$invitedUserArgs<ExtArgs> = {}>(args?: Subset<T, CanvasInvitation$invitedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasInvitation model
   */
  interface CanvasInvitationFieldRefs {
    readonly id: FieldRef<"CanvasInvitation", 'String'>
    readonly canvasId: FieldRef<"CanvasInvitation", 'String'>
    readonly email: FieldRef<"CanvasInvitation", 'String'>
    readonly accessLevel: FieldRef<"CanvasInvitation", 'CanvasAccessLevel'>
    readonly permissions: FieldRef<"CanvasInvitation", 'Json'>
    readonly invitedBy: FieldRef<"CanvasInvitation", 'String'>
    readonly invitedUserId: FieldRef<"CanvasInvitation", 'String'>
    readonly token: FieldRef<"CanvasInvitation", 'String'>
    readonly status: FieldRef<"CanvasInvitation", 'InvitationStatus'>
    readonly createdAt: FieldRef<"CanvasInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"CanvasInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"CanvasInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasInvitation findUnique
   */
  export type CanvasInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CanvasInvitation to fetch.
     */
    where: CanvasInvitationWhereUniqueInput
  }

  /**
   * CanvasInvitation findUniqueOrThrow
   */
  export type CanvasInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CanvasInvitation to fetch.
     */
    where: CanvasInvitationWhereUniqueInput
  }

  /**
   * CanvasInvitation findFirst
   */
  export type CanvasInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CanvasInvitation to fetch.
     */
    where?: CanvasInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasInvitations to fetch.
     */
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasInvitations.
     */
    cursor?: CanvasInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasInvitations.
     */
    distinct?: CanvasInvitationScalarFieldEnum | CanvasInvitationScalarFieldEnum[]
  }

  /**
   * CanvasInvitation findFirstOrThrow
   */
  export type CanvasInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CanvasInvitation to fetch.
     */
    where?: CanvasInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasInvitations to fetch.
     */
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasInvitations.
     */
    cursor?: CanvasInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasInvitations.
     */
    distinct?: CanvasInvitationScalarFieldEnum | CanvasInvitationScalarFieldEnum[]
  }

  /**
   * CanvasInvitation findMany
   */
  export type CanvasInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CanvasInvitations to fetch.
     */
    where?: CanvasInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasInvitations to fetch.
     */
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasInvitations.
     */
    cursor?: CanvasInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasInvitations.
     */
    skip?: number
    distinct?: CanvasInvitationScalarFieldEnum | CanvasInvitationScalarFieldEnum[]
  }

  /**
   * CanvasInvitation create
   */
  export type CanvasInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasInvitation.
     */
    data: XOR<CanvasInvitationCreateInput, CanvasInvitationUncheckedCreateInput>
  }

  /**
   * CanvasInvitation createMany
   */
  export type CanvasInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasInvitations.
     */
    data: CanvasInvitationCreateManyInput | CanvasInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasInvitation createManyAndReturn
   */
  export type CanvasInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasInvitations.
     */
    data: CanvasInvitationCreateManyInput | CanvasInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasInvitation update
   */
  export type CanvasInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasInvitation.
     */
    data: XOR<CanvasInvitationUpdateInput, CanvasInvitationUncheckedUpdateInput>
    /**
     * Choose, which CanvasInvitation to update.
     */
    where: CanvasInvitationWhereUniqueInput
  }

  /**
   * CanvasInvitation updateMany
   */
  export type CanvasInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasInvitations.
     */
    data: XOR<CanvasInvitationUpdateManyMutationInput, CanvasInvitationUncheckedUpdateManyInput>
    /**
     * Filter which CanvasInvitations to update
     */
    where?: CanvasInvitationWhereInput
    /**
     * Limit how many CanvasInvitations to update.
     */
    limit?: number
  }

  /**
   * CanvasInvitation updateManyAndReturn
   */
  export type CanvasInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * The data used to update CanvasInvitations.
     */
    data: XOR<CanvasInvitationUpdateManyMutationInput, CanvasInvitationUncheckedUpdateManyInput>
    /**
     * Filter which CanvasInvitations to update
     */
    where?: CanvasInvitationWhereInput
    /**
     * Limit how many CanvasInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasInvitation upsert
   */
  export type CanvasInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasInvitation to update in case it exists.
     */
    where: CanvasInvitationWhereUniqueInput
    /**
     * In case the CanvasInvitation found by the `where` argument doesn't exist, create a new CanvasInvitation with this data.
     */
    create: XOR<CanvasInvitationCreateInput, CanvasInvitationUncheckedCreateInput>
    /**
     * In case the CanvasInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasInvitationUpdateInput, CanvasInvitationUncheckedUpdateInput>
  }

  /**
   * CanvasInvitation delete
   */
  export type CanvasInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    /**
     * Filter which CanvasInvitation to delete.
     */
    where: CanvasInvitationWhereUniqueInput
  }

  /**
   * CanvasInvitation deleteMany
   */
  export type CanvasInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasInvitations to delete
     */
    where?: CanvasInvitationWhereInput
    /**
     * Limit how many CanvasInvitations to delete.
     */
    limit?: number
  }

  /**
   * CanvasInvitation.invitedUser
   */
  export type CanvasInvitation$invitedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CanvasInvitation without action
   */
  export type CanvasInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
  }


  /**
   * Model CanvasCollaborator
   */

  export type AggregateCanvasCollaborator = {
    _count: CanvasCollaboratorCountAggregateOutputType | null
    _min: CanvasCollaboratorMinAggregateOutputType | null
    _max: CanvasCollaboratorMaxAggregateOutputType | null
  }

  export type CanvasCollaboratorMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    accessLevel: $Enums.CanvasAccessLevel | null
    canEdit: boolean | null
    canExecute: boolean | null
    canDelete: boolean | null
    canShare: boolean | null
    canInvite: boolean | null
    invitedBy: string | null
    invitedAt: Date | null
    lastViewedAt: Date | null
  }

  export type CanvasCollaboratorMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    accessLevel: $Enums.CanvasAccessLevel | null
    canEdit: boolean | null
    canExecute: boolean | null
    canDelete: boolean | null
    canShare: boolean | null
    canInvite: boolean | null
    invitedBy: string | null
    invitedAt: Date | null
    lastViewedAt: Date | null
  }

  export type CanvasCollaboratorCountAggregateOutputType = {
    id: number
    canvasId: number
    userId: number
    accessLevel: number
    canEdit: number
    canExecute: number
    canDelete: number
    canShare: number
    canInvite: number
    invitedBy: number
    invitedAt: number
    lastViewedAt: number
    _all: number
  }


  export type CanvasCollaboratorMinAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    accessLevel?: true
    canEdit?: true
    canExecute?: true
    canDelete?: true
    canShare?: true
    canInvite?: true
    invitedBy?: true
    invitedAt?: true
    lastViewedAt?: true
  }

  export type CanvasCollaboratorMaxAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    accessLevel?: true
    canEdit?: true
    canExecute?: true
    canDelete?: true
    canShare?: true
    canInvite?: true
    invitedBy?: true
    invitedAt?: true
    lastViewedAt?: true
  }

  export type CanvasCollaboratorCountAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    accessLevel?: true
    canEdit?: true
    canExecute?: true
    canDelete?: true
    canShare?: true
    canInvite?: true
    invitedBy?: true
    invitedAt?: true
    lastViewedAt?: true
    _all?: true
  }

  export type CanvasCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasCollaborator to aggregate.
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasCollaborators to fetch.
     */
    orderBy?: CanvasCollaboratorOrderByWithRelationInput | CanvasCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasCollaborators
    **/
    _count?: true | CanvasCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasCollaboratorMaxAggregateInputType
  }

  export type GetCanvasCollaboratorAggregateType<T extends CanvasCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasCollaborator[P]>
      : GetScalarType<T[P], AggregateCanvasCollaborator[P]>
  }




  export type CanvasCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasCollaboratorWhereInput
    orderBy?: CanvasCollaboratorOrderByWithAggregationInput | CanvasCollaboratorOrderByWithAggregationInput[]
    by: CanvasCollaboratorScalarFieldEnum[] | CanvasCollaboratorScalarFieldEnum
    having?: CanvasCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasCollaboratorCountAggregateInputType | true
    _min?: CanvasCollaboratorMinAggregateInputType
    _max?: CanvasCollaboratorMaxAggregateInputType
  }

  export type CanvasCollaboratorGroupByOutputType = {
    id: string
    canvasId: string
    userId: string
    accessLevel: $Enums.CanvasAccessLevel
    canEdit: boolean
    canExecute: boolean
    canDelete: boolean
    canShare: boolean
    canInvite: boolean
    invitedBy: string | null
    invitedAt: Date
    lastViewedAt: Date | null
    _count: CanvasCollaboratorCountAggregateOutputType | null
    _min: CanvasCollaboratorMinAggregateOutputType | null
    _max: CanvasCollaboratorMaxAggregateOutputType | null
  }

  type GetCanvasCollaboratorGroupByPayload<T extends CanvasCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type CanvasCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasCollaborator"]>

  export type CanvasCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasCollaborator"]>

  export type CanvasCollaboratorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasCollaborator"]>

  export type CanvasCollaboratorSelectScalar = {
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    accessLevel?: boolean
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    lastViewedAt?: boolean
  }

  export type CanvasCollaboratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "userId" | "accessLevel" | "canEdit" | "canExecute" | "canDelete" | "canShare" | "canInvite" | "invitedBy" | "invitedAt" | "lastViewedAt", ExtArgs["result"]["canvasCollaborator"]>
  export type CanvasCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CanvasCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CanvasCollaboratorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CanvasCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasCollaborator"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      userId: string
      accessLevel: $Enums.CanvasAccessLevel
      canEdit: boolean
      canExecute: boolean
      canDelete: boolean
      canShare: boolean
      canInvite: boolean
      invitedBy: string | null
      invitedAt: Date
      lastViewedAt: Date | null
    }, ExtArgs["result"]["canvasCollaborator"]>
    composites: {}
  }

  type CanvasCollaboratorGetPayload<S extends boolean | null | undefined | CanvasCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$CanvasCollaboratorPayload, S>

  type CanvasCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasCollaboratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasCollaboratorCountAggregateInputType | true
    }

  export interface CanvasCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasCollaborator'], meta: { name: 'CanvasCollaborator' } }
    /**
     * Find zero or one CanvasCollaborator that matches the filter.
     * @param {CanvasCollaboratorFindUniqueArgs} args - Arguments to find a CanvasCollaborator
     * @example
     * // Get one CanvasCollaborator
     * const canvasCollaborator = await prisma.canvasCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasCollaboratorFindUniqueArgs>(args: SelectSubset<T, CanvasCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasCollaborator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a CanvasCollaborator
     * @example
     * // Get one CanvasCollaborator
     * const canvasCollaborator = await prisma.canvasCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorFindFirstArgs} args - Arguments to find a CanvasCollaborator
     * @example
     * // Get one CanvasCollaborator
     * const canvasCollaborator = await prisma.canvasCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasCollaboratorFindFirstArgs>(args?: SelectSubset<T, CanvasCollaboratorFindFirstArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorFindFirstOrThrowArgs} args - Arguments to find a CanvasCollaborator
     * @example
     * // Get one CanvasCollaborator
     * const canvasCollaborator = await prisma.canvasCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasCollaborators
     * const canvasCollaborators = await prisma.canvasCollaborator.findMany()
     * 
     * // Get first 10 CanvasCollaborators
     * const canvasCollaborators = await prisma.canvasCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasCollaboratorWithIdOnly = await prisma.canvasCollaborator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasCollaboratorFindManyArgs>(args?: SelectSubset<T, CanvasCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasCollaborator.
     * @param {CanvasCollaboratorCreateArgs} args - Arguments to create a CanvasCollaborator.
     * @example
     * // Create one CanvasCollaborator
     * const CanvasCollaborator = await prisma.canvasCollaborator.create({
     *   data: {
     *     // ... data to create a CanvasCollaborator
     *   }
     * })
     * 
     */
    create<T extends CanvasCollaboratorCreateArgs>(args: SelectSubset<T, CanvasCollaboratorCreateArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasCollaborators.
     * @param {CanvasCollaboratorCreateManyArgs} args - Arguments to create many CanvasCollaborators.
     * @example
     * // Create many CanvasCollaborators
     * const canvasCollaborator = await prisma.canvasCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasCollaboratorCreateManyArgs>(args?: SelectSubset<T, CanvasCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasCollaborators and returns the data saved in the database.
     * @param {CanvasCollaboratorCreateManyAndReturnArgs} args - Arguments to create many CanvasCollaborators.
     * @example
     * // Create many CanvasCollaborators
     * const canvasCollaborator = await prisma.canvasCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasCollaborators and only return the `id`
     * const canvasCollaboratorWithIdOnly = await prisma.canvasCollaborator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasCollaborator.
     * @param {CanvasCollaboratorDeleteArgs} args - Arguments to delete one CanvasCollaborator.
     * @example
     * // Delete one CanvasCollaborator
     * const CanvasCollaborator = await prisma.canvasCollaborator.delete({
     *   where: {
     *     // ... filter to delete one CanvasCollaborator
     *   }
     * })
     * 
     */
    delete<T extends CanvasCollaboratorDeleteArgs>(args: SelectSubset<T, CanvasCollaboratorDeleteArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasCollaborator.
     * @param {CanvasCollaboratorUpdateArgs} args - Arguments to update one CanvasCollaborator.
     * @example
     * // Update one CanvasCollaborator
     * const canvasCollaborator = await prisma.canvasCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasCollaboratorUpdateArgs>(args: SelectSubset<T, CanvasCollaboratorUpdateArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasCollaborators.
     * @param {CanvasCollaboratorDeleteManyArgs} args - Arguments to filter CanvasCollaborators to delete.
     * @example
     * // Delete a few CanvasCollaborators
     * const { count } = await prisma.canvasCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasCollaboratorDeleteManyArgs>(args?: SelectSubset<T, CanvasCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasCollaborators
     * const canvasCollaborator = await prisma.canvasCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasCollaboratorUpdateManyArgs>(args: SelectSubset<T, CanvasCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasCollaborators and returns the data updated in the database.
     * @param {CanvasCollaboratorUpdateManyAndReturnArgs} args - Arguments to update many CanvasCollaborators.
     * @example
     * // Update many CanvasCollaborators
     * const canvasCollaborator = await prisma.canvasCollaborator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasCollaborators and only return the `id`
     * const canvasCollaboratorWithIdOnly = await prisma.canvasCollaborator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasCollaboratorUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasCollaboratorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasCollaborator.
     * @param {CanvasCollaboratorUpsertArgs} args - Arguments to update or create a CanvasCollaborator.
     * @example
     * // Update or create a CanvasCollaborator
     * const canvasCollaborator = await prisma.canvasCollaborator.upsert({
     *   create: {
     *     // ... data to create a CanvasCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends CanvasCollaboratorUpsertArgs>(args: SelectSubset<T, CanvasCollaboratorUpsertArgs<ExtArgs>>): Prisma__CanvasCollaboratorClient<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorCountArgs} args - Arguments to filter CanvasCollaborators to count.
     * @example
     * // Count the number of CanvasCollaborators
     * const count = await prisma.canvasCollaborator.count({
     *   where: {
     *     // ... the filter for the CanvasCollaborators we want to count
     *   }
     * })
    **/
    count<T extends CanvasCollaboratorCountArgs>(
      args?: Subset<T, CanvasCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasCollaboratorAggregateArgs>(args: Subset<T, CanvasCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetCanvasCollaboratorAggregateType<T>>

    /**
     * Group by CanvasCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: CanvasCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasCollaborator model
   */
  readonly fields: CanvasCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasCollaborator model
   */
  interface CanvasCollaboratorFieldRefs {
    readonly id: FieldRef<"CanvasCollaborator", 'String'>
    readonly canvasId: FieldRef<"CanvasCollaborator", 'String'>
    readonly userId: FieldRef<"CanvasCollaborator", 'String'>
    readonly accessLevel: FieldRef<"CanvasCollaborator", 'CanvasAccessLevel'>
    readonly canEdit: FieldRef<"CanvasCollaborator", 'Boolean'>
    readonly canExecute: FieldRef<"CanvasCollaborator", 'Boolean'>
    readonly canDelete: FieldRef<"CanvasCollaborator", 'Boolean'>
    readonly canShare: FieldRef<"CanvasCollaborator", 'Boolean'>
    readonly canInvite: FieldRef<"CanvasCollaborator", 'Boolean'>
    readonly invitedBy: FieldRef<"CanvasCollaborator", 'String'>
    readonly invitedAt: FieldRef<"CanvasCollaborator", 'DateTime'>
    readonly lastViewedAt: FieldRef<"CanvasCollaborator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasCollaborator findUnique
   */
  export type CanvasCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which CanvasCollaborator to fetch.
     */
    where: CanvasCollaboratorWhereUniqueInput
  }

  /**
   * CanvasCollaborator findUniqueOrThrow
   */
  export type CanvasCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which CanvasCollaborator to fetch.
     */
    where: CanvasCollaboratorWhereUniqueInput
  }

  /**
   * CanvasCollaborator findFirst
   */
  export type CanvasCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which CanvasCollaborator to fetch.
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasCollaborators to fetch.
     */
    orderBy?: CanvasCollaboratorOrderByWithRelationInput | CanvasCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasCollaborators.
     */
    cursor?: CanvasCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasCollaborators.
     */
    distinct?: CanvasCollaboratorScalarFieldEnum | CanvasCollaboratorScalarFieldEnum[]
  }

  /**
   * CanvasCollaborator findFirstOrThrow
   */
  export type CanvasCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which CanvasCollaborator to fetch.
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasCollaborators to fetch.
     */
    orderBy?: CanvasCollaboratorOrderByWithRelationInput | CanvasCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasCollaborators.
     */
    cursor?: CanvasCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasCollaborators.
     */
    distinct?: CanvasCollaboratorScalarFieldEnum | CanvasCollaboratorScalarFieldEnum[]
  }

  /**
   * CanvasCollaborator findMany
   */
  export type CanvasCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which CanvasCollaborators to fetch.
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasCollaborators to fetch.
     */
    orderBy?: CanvasCollaboratorOrderByWithRelationInput | CanvasCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasCollaborators.
     */
    cursor?: CanvasCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasCollaborators.
     */
    skip?: number
    distinct?: CanvasCollaboratorScalarFieldEnum | CanvasCollaboratorScalarFieldEnum[]
  }

  /**
   * CanvasCollaborator create
   */
  export type CanvasCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasCollaborator.
     */
    data: XOR<CanvasCollaboratorCreateInput, CanvasCollaboratorUncheckedCreateInput>
  }

  /**
   * CanvasCollaborator createMany
   */
  export type CanvasCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasCollaborators.
     */
    data: CanvasCollaboratorCreateManyInput | CanvasCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasCollaborator createManyAndReturn
   */
  export type CanvasCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasCollaborators.
     */
    data: CanvasCollaboratorCreateManyInput | CanvasCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasCollaborator update
   */
  export type CanvasCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasCollaborator.
     */
    data: XOR<CanvasCollaboratorUpdateInput, CanvasCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which CanvasCollaborator to update.
     */
    where: CanvasCollaboratorWhereUniqueInput
  }

  /**
   * CanvasCollaborator updateMany
   */
  export type CanvasCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasCollaborators.
     */
    data: XOR<CanvasCollaboratorUpdateManyMutationInput, CanvasCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which CanvasCollaborators to update
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * Limit how many CanvasCollaborators to update.
     */
    limit?: number
  }

  /**
   * CanvasCollaborator updateManyAndReturn
   */
  export type CanvasCollaboratorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * The data used to update CanvasCollaborators.
     */
    data: XOR<CanvasCollaboratorUpdateManyMutationInput, CanvasCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which CanvasCollaborators to update
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * Limit how many CanvasCollaborators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasCollaborator upsert
   */
  export type CanvasCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasCollaborator to update in case it exists.
     */
    where: CanvasCollaboratorWhereUniqueInput
    /**
     * In case the CanvasCollaborator found by the `where` argument doesn't exist, create a new CanvasCollaborator with this data.
     */
    create: XOR<CanvasCollaboratorCreateInput, CanvasCollaboratorUncheckedCreateInput>
    /**
     * In case the CanvasCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasCollaboratorUpdateInput, CanvasCollaboratorUncheckedUpdateInput>
  }

  /**
   * CanvasCollaborator delete
   */
  export type CanvasCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which CanvasCollaborator to delete.
     */
    where: CanvasCollaboratorWhereUniqueInput
  }

  /**
   * CanvasCollaborator deleteMany
   */
  export type CanvasCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasCollaborators to delete
     */
    where?: CanvasCollaboratorWhereInput
    /**
     * Limit how many CanvasCollaborators to delete.
     */
    limit?: number
  }

  /**
   * CanvasCollaborator without action
   */
  export type CanvasCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model CanvasSession
   */

  export type AggregateCanvasSession = {
    _count: CanvasSessionCountAggregateOutputType | null
    _min: CanvasSessionMinAggregateOutputType | null
    _max: CanvasSessionMaxAggregateOutputType | null
  }

  export type CanvasSessionMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    anonymousName: string | null
    sessionToken: string | null
    socketId: string | null
    userColor: string | null
    userAgent: string | null
    ipAddress: string | null
    connectedAt: Date | null
    lastHeartbeatAt: Date | null
    disconnectedAt: Date | null
  }

  export type CanvasSessionMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    anonymousName: string | null
    sessionToken: string | null
    socketId: string | null
    userColor: string | null
    userAgent: string | null
    ipAddress: string | null
    connectedAt: Date | null
    lastHeartbeatAt: Date | null
    disconnectedAt: Date | null
  }

  export type CanvasSessionCountAggregateOutputType = {
    id: number
    canvasId: number
    userId: number
    anonymousName: number
    sessionToken: number
    socketId: number
    cursorPosition: number
    selectedPodIds: number
    viewportState: number
    userColor: number
    userAgent: number
    ipAddress: number
    connectedAt: number
    lastHeartbeatAt: number
    disconnectedAt: number
    _all: number
  }


  export type CanvasSessionMinAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    anonymousName?: true
    sessionToken?: true
    socketId?: true
    userColor?: true
    userAgent?: true
    ipAddress?: true
    connectedAt?: true
    lastHeartbeatAt?: true
    disconnectedAt?: true
  }

  export type CanvasSessionMaxAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    anonymousName?: true
    sessionToken?: true
    socketId?: true
    userColor?: true
    userAgent?: true
    ipAddress?: true
    connectedAt?: true
    lastHeartbeatAt?: true
    disconnectedAt?: true
  }

  export type CanvasSessionCountAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    anonymousName?: true
    sessionToken?: true
    socketId?: true
    cursorPosition?: true
    selectedPodIds?: true
    viewportState?: true
    userColor?: true
    userAgent?: true
    ipAddress?: true
    connectedAt?: true
    lastHeartbeatAt?: true
    disconnectedAt?: true
    _all?: true
  }

  export type CanvasSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasSession to aggregate.
     */
    where?: CanvasSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasSessions to fetch.
     */
    orderBy?: CanvasSessionOrderByWithRelationInput | CanvasSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasSessions
    **/
    _count?: true | CanvasSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasSessionMaxAggregateInputType
  }

  export type GetCanvasSessionAggregateType<T extends CanvasSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasSession[P]>
      : GetScalarType<T[P], AggregateCanvasSession[P]>
  }




  export type CanvasSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasSessionWhereInput
    orderBy?: CanvasSessionOrderByWithAggregationInput | CanvasSessionOrderByWithAggregationInput[]
    by: CanvasSessionScalarFieldEnum[] | CanvasSessionScalarFieldEnum
    having?: CanvasSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasSessionCountAggregateInputType | true
    _min?: CanvasSessionMinAggregateInputType
    _max?: CanvasSessionMaxAggregateInputType
  }

  export type CanvasSessionGroupByOutputType = {
    id: string
    canvasId: string
    userId: string | null
    anonymousName: string | null
    sessionToken: string | null
    socketId: string | null
    cursorPosition: JsonValue | null
    selectedPodIds: JsonValue | null
    viewportState: JsonValue | null
    userColor: string | null
    userAgent: string | null
    ipAddress: string | null
    connectedAt: Date
    lastHeartbeatAt: Date
    disconnectedAt: Date | null
    _count: CanvasSessionCountAggregateOutputType | null
    _min: CanvasSessionMinAggregateOutputType | null
    _max: CanvasSessionMaxAggregateOutputType | null
  }

  type GetCanvasSessionGroupByPayload<T extends CanvasSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasSessionGroupByOutputType[P]>
        }
      >
    >


  export type CanvasSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasSession"]>

  export type CanvasSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasSession"]>

  export type CanvasSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasSession"]>

  export type CanvasSessionSelectScalar = {
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    anonymousName?: boolean
    sessionToken?: boolean
    socketId?: boolean
    cursorPosition?: boolean
    selectedPodIds?: boolean
    viewportState?: boolean
    userColor?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    connectedAt?: boolean
    lastHeartbeatAt?: boolean
    disconnectedAt?: boolean
  }

  export type CanvasSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "userId" | "anonymousName" | "sessionToken" | "socketId" | "cursorPosition" | "selectedPodIds" | "viewportState" | "userColor" | "userAgent" | "ipAddress" | "connectedAt" | "lastHeartbeatAt" | "disconnectedAt", ExtArgs["result"]["canvasSession"]>
  export type CanvasSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }
  export type CanvasSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }
  export type CanvasSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }

  export type $CanvasSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasSession"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      userId: string | null
      anonymousName: string | null
      sessionToken: string | null
      socketId: string | null
      cursorPosition: Prisma.JsonValue | null
      selectedPodIds: Prisma.JsonValue | null
      viewportState: Prisma.JsonValue | null
      userColor: string | null
      userAgent: string | null
      ipAddress: string | null
      connectedAt: Date
      lastHeartbeatAt: Date
      disconnectedAt: Date | null
    }, ExtArgs["result"]["canvasSession"]>
    composites: {}
  }

  type CanvasSessionGetPayload<S extends boolean | null | undefined | CanvasSessionDefaultArgs> = $Result.GetResult<Prisma.$CanvasSessionPayload, S>

  type CanvasSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasSessionCountAggregateInputType | true
    }

  export interface CanvasSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasSession'], meta: { name: 'CanvasSession' } }
    /**
     * Find zero or one CanvasSession that matches the filter.
     * @param {CanvasSessionFindUniqueArgs} args - Arguments to find a CanvasSession
     * @example
     * // Get one CanvasSession
     * const canvasSession = await prisma.canvasSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasSessionFindUniqueArgs>(args: SelectSubset<T, CanvasSessionFindUniqueArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasSessionFindUniqueOrThrowArgs} args - Arguments to find a CanvasSession
     * @example
     * // Get one CanvasSession
     * const canvasSession = await prisma.canvasSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionFindFirstArgs} args - Arguments to find a CanvasSession
     * @example
     * // Get one CanvasSession
     * const canvasSession = await prisma.canvasSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasSessionFindFirstArgs>(args?: SelectSubset<T, CanvasSessionFindFirstArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionFindFirstOrThrowArgs} args - Arguments to find a CanvasSession
     * @example
     * // Get one CanvasSession
     * const canvasSession = await prisma.canvasSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasSessions
     * const canvasSessions = await prisma.canvasSession.findMany()
     * 
     * // Get first 10 CanvasSessions
     * const canvasSessions = await prisma.canvasSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasSessionWithIdOnly = await prisma.canvasSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasSessionFindManyArgs>(args?: SelectSubset<T, CanvasSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasSession.
     * @param {CanvasSessionCreateArgs} args - Arguments to create a CanvasSession.
     * @example
     * // Create one CanvasSession
     * const CanvasSession = await prisma.canvasSession.create({
     *   data: {
     *     // ... data to create a CanvasSession
     *   }
     * })
     * 
     */
    create<T extends CanvasSessionCreateArgs>(args: SelectSubset<T, CanvasSessionCreateArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasSessions.
     * @param {CanvasSessionCreateManyArgs} args - Arguments to create many CanvasSessions.
     * @example
     * // Create many CanvasSessions
     * const canvasSession = await prisma.canvasSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasSessionCreateManyArgs>(args?: SelectSubset<T, CanvasSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasSessions and returns the data saved in the database.
     * @param {CanvasSessionCreateManyAndReturnArgs} args - Arguments to create many CanvasSessions.
     * @example
     * // Create many CanvasSessions
     * const canvasSession = await prisma.canvasSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasSessions and only return the `id`
     * const canvasSessionWithIdOnly = await prisma.canvasSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasSession.
     * @param {CanvasSessionDeleteArgs} args - Arguments to delete one CanvasSession.
     * @example
     * // Delete one CanvasSession
     * const CanvasSession = await prisma.canvasSession.delete({
     *   where: {
     *     // ... filter to delete one CanvasSession
     *   }
     * })
     * 
     */
    delete<T extends CanvasSessionDeleteArgs>(args: SelectSubset<T, CanvasSessionDeleteArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasSession.
     * @param {CanvasSessionUpdateArgs} args - Arguments to update one CanvasSession.
     * @example
     * // Update one CanvasSession
     * const canvasSession = await prisma.canvasSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasSessionUpdateArgs>(args: SelectSubset<T, CanvasSessionUpdateArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasSessions.
     * @param {CanvasSessionDeleteManyArgs} args - Arguments to filter CanvasSessions to delete.
     * @example
     * // Delete a few CanvasSessions
     * const { count } = await prisma.canvasSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasSessionDeleteManyArgs>(args?: SelectSubset<T, CanvasSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasSessions
     * const canvasSession = await prisma.canvasSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasSessionUpdateManyArgs>(args: SelectSubset<T, CanvasSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasSessions and returns the data updated in the database.
     * @param {CanvasSessionUpdateManyAndReturnArgs} args - Arguments to update many CanvasSessions.
     * @example
     * // Update many CanvasSessions
     * const canvasSession = await prisma.canvasSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasSessions and only return the `id`
     * const canvasSessionWithIdOnly = await prisma.canvasSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasSession.
     * @param {CanvasSessionUpsertArgs} args - Arguments to update or create a CanvasSession.
     * @example
     * // Update or create a CanvasSession
     * const canvasSession = await prisma.canvasSession.upsert({
     *   create: {
     *     // ... data to create a CanvasSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasSession we want to update
     *   }
     * })
     */
    upsert<T extends CanvasSessionUpsertArgs>(args: SelectSubset<T, CanvasSessionUpsertArgs<ExtArgs>>): Prisma__CanvasSessionClient<$Result.GetResult<Prisma.$CanvasSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionCountArgs} args - Arguments to filter CanvasSessions to count.
     * @example
     * // Count the number of CanvasSessions
     * const count = await prisma.canvasSession.count({
     *   where: {
     *     // ... the filter for the CanvasSessions we want to count
     *   }
     * })
    **/
    count<T extends CanvasSessionCountArgs>(
      args?: Subset<T, CanvasSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasSessionAggregateArgs>(args: Subset<T, CanvasSessionAggregateArgs>): Prisma.PrismaPromise<GetCanvasSessionAggregateType<T>>

    /**
     * Group by CanvasSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasSessionGroupByArgs['orderBy'] }
        : { orderBy?: CanvasSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasSession model
   */
  readonly fields: CanvasSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasSession model
   */
  interface CanvasSessionFieldRefs {
    readonly id: FieldRef<"CanvasSession", 'String'>
    readonly canvasId: FieldRef<"CanvasSession", 'String'>
    readonly userId: FieldRef<"CanvasSession", 'String'>
    readonly anonymousName: FieldRef<"CanvasSession", 'String'>
    readonly sessionToken: FieldRef<"CanvasSession", 'String'>
    readonly socketId: FieldRef<"CanvasSession", 'String'>
    readonly cursorPosition: FieldRef<"CanvasSession", 'Json'>
    readonly selectedPodIds: FieldRef<"CanvasSession", 'Json'>
    readonly viewportState: FieldRef<"CanvasSession", 'Json'>
    readonly userColor: FieldRef<"CanvasSession", 'String'>
    readonly userAgent: FieldRef<"CanvasSession", 'String'>
    readonly ipAddress: FieldRef<"CanvasSession", 'String'>
    readonly connectedAt: FieldRef<"CanvasSession", 'DateTime'>
    readonly lastHeartbeatAt: FieldRef<"CanvasSession", 'DateTime'>
    readonly disconnectedAt: FieldRef<"CanvasSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasSession findUnique
   */
  export type CanvasSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * Filter, which CanvasSession to fetch.
     */
    where: CanvasSessionWhereUniqueInput
  }

  /**
   * CanvasSession findUniqueOrThrow
   */
  export type CanvasSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * Filter, which CanvasSession to fetch.
     */
    where: CanvasSessionWhereUniqueInput
  }

  /**
   * CanvasSession findFirst
   */
  export type CanvasSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * Filter, which CanvasSession to fetch.
     */
    where?: CanvasSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasSessions to fetch.
     */
    orderBy?: CanvasSessionOrderByWithRelationInput | CanvasSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasSessions.
     */
    cursor?: CanvasSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasSessions.
     */
    distinct?: CanvasSessionScalarFieldEnum | CanvasSessionScalarFieldEnum[]
  }

  /**
   * CanvasSession findFirstOrThrow
   */
  export type CanvasSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * Filter, which CanvasSession to fetch.
     */
    where?: CanvasSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasSessions to fetch.
     */
    orderBy?: CanvasSessionOrderByWithRelationInput | CanvasSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasSessions.
     */
    cursor?: CanvasSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasSessions.
     */
    distinct?: CanvasSessionScalarFieldEnum | CanvasSessionScalarFieldEnum[]
  }

  /**
   * CanvasSession findMany
   */
  export type CanvasSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * Filter, which CanvasSessions to fetch.
     */
    where?: CanvasSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasSessions to fetch.
     */
    orderBy?: CanvasSessionOrderByWithRelationInput | CanvasSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasSessions.
     */
    cursor?: CanvasSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasSessions.
     */
    skip?: number
    distinct?: CanvasSessionScalarFieldEnum | CanvasSessionScalarFieldEnum[]
  }

  /**
   * CanvasSession create
   */
  export type CanvasSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasSession.
     */
    data: XOR<CanvasSessionCreateInput, CanvasSessionUncheckedCreateInput>
  }

  /**
   * CanvasSession createMany
   */
  export type CanvasSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasSessions.
     */
    data: CanvasSessionCreateManyInput | CanvasSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasSession createManyAndReturn
   */
  export type CanvasSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasSessions.
     */
    data: CanvasSessionCreateManyInput | CanvasSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasSession update
   */
  export type CanvasSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasSession.
     */
    data: XOR<CanvasSessionUpdateInput, CanvasSessionUncheckedUpdateInput>
    /**
     * Choose, which CanvasSession to update.
     */
    where: CanvasSessionWhereUniqueInput
  }

  /**
   * CanvasSession updateMany
   */
  export type CanvasSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasSessions.
     */
    data: XOR<CanvasSessionUpdateManyMutationInput, CanvasSessionUncheckedUpdateManyInput>
    /**
     * Filter which CanvasSessions to update
     */
    where?: CanvasSessionWhereInput
    /**
     * Limit how many CanvasSessions to update.
     */
    limit?: number
  }

  /**
   * CanvasSession updateManyAndReturn
   */
  export type CanvasSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * The data used to update CanvasSessions.
     */
    data: XOR<CanvasSessionUpdateManyMutationInput, CanvasSessionUncheckedUpdateManyInput>
    /**
     * Filter which CanvasSessions to update
     */
    where?: CanvasSessionWhereInput
    /**
     * Limit how many CanvasSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasSession upsert
   */
  export type CanvasSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasSession to update in case it exists.
     */
    where: CanvasSessionWhereUniqueInput
    /**
     * In case the CanvasSession found by the `where` argument doesn't exist, create a new CanvasSession with this data.
     */
    create: XOR<CanvasSessionCreateInput, CanvasSessionUncheckedCreateInput>
    /**
     * In case the CanvasSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasSessionUpdateInput, CanvasSessionUncheckedUpdateInput>
  }

  /**
   * CanvasSession delete
   */
  export type CanvasSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
    /**
     * Filter which CanvasSession to delete.
     */
    where: CanvasSessionWhereUniqueInput
  }

  /**
   * CanvasSession deleteMany
   */
  export type CanvasSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasSessions to delete
     */
    where?: CanvasSessionWhereInput
    /**
     * Limit how many CanvasSessions to delete.
     */
    limit?: number
  }

  /**
   * CanvasSession without action
   */
  export type CanvasSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasSession
     */
    select?: CanvasSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasSession
     */
    omit?: CanvasSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasSessionInclude<ExtArgs> | null
  }


  /**
   * Model CanvasActivityLog
   */

  export type AggregateCanvasActivityLog = {
    _count: CanvasActivityLogCountAggregateOutputType | null
    _min: CanvasActivityLogMinAggregateOutputType | null
    _max: CanvasActivityLogMaxAggregateOutputType | null
  }

  export type CanvasActivityLogMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    action: $Enums.CanvasActivityAction | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type CanvasActivityLogMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    action: $Enums.CanvasActivityAction | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type CanvasActivityLogCountAggregateOutputType = {
    id: number
    canvasId: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changeData: number
    createdAt: number
    _all: number
  }


  export type CanvasActivityLogMinAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type CanvasActivityLogMaxAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type CanvasActivityLogCountAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changeData?: true
    createdAt?: true
    _all?: true
  }

  export type CanvasActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasActivityLog to aggregate.
     */
    where?: CanvasActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasActivityLogs to fetch.
     */
    orderBy?: CanvasActivityLogOrderByWithRelationInput | CanvasActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasActivityLogs
    **/
    _count?: true | CanvasActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasActivityLogMaxAggregateInputType
  }

  export type GetCanvasActivityLogAggregateType<T extends CanvasActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasActivityLog[P]>
      : GetScalarType<T[P], AggregateCanvasActivityLog[P]>
  }




  export type CanvasActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasActivityLogWhereInput
    orderBy?: CanvasActivityLogOrderByWithAggregationInput | CanvasActivityLogOrderByWithAggregationInput[]
    by: CanvasActivityLogScalarFieldEnum[] | CanvasActivityLogScalarFieldEnum
    having?: CanvasActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasActivityLogCountAggregateInputType | true
    _min?: CanvasActivityLogMinAggregateInputType
    _max?: CanvasActivityLogMaxAggregateInputType
  }

  export type CanvasActivityLogGroupByOutputType = {
    id: string
    canvasId: string
    userId: string | null
    action: $Enums.CanvasActivityAction
    entityType: string | null
    entityId: string | null
    changeData: JsonValue | null
    createdAt: Date
    _count: CanvasActivityLogCountAggregateOutputType | null
    _min: CanvasActivityLogMinAggregateOutputType | null
    _max: CanvasActivityLogMaxAggregateOutputType | null
  }

  type GetCanvasActivityLogGroupByPayload<T extends CanvasActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type CanvasActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasActivityLog"]>

  export type CanvasActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasActivityLog"]>

  export type CanvasActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasActivityLog"]>

  export type CanvasActivityLogSelectScalar = {
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changeData?: boolean
    createdAt?: boolean
  }

  export type CanvasActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "userId" | "action" | "entityType" | "entityId" | "changeData" | "createdAt", ExtArgs["result"]["canvasActivityLog"]>
  export type CanvasActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }
  export type CanvasActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }
  export type CanvasActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }

  export type $CanvasActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasActivityLog"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      userId: string | null
      action: $Enums.CanvasActivityAction
      entityType: string | null
      entityId: string | null
      changeData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["canvasActivityLog"]>
    composites: {}
  }

  type CanvasActivityLogGetPayload<S extends boolean | null | undefined | CanvasActivityLogDefaultArgs> = $Result.GetResult<Prisma.$CanvasActivityLogPayload, S>

  type CanvasActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasActivityLogCountAggregateInputType | true
    }

  export interface CanvasActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasActivityLog'], meta: { name: 'CanvasActivityLog' } }
    /**
     * Find zero or one CanvasActivityLog that matches the filter.
     * @param {CanvasActivityLogFindUniqueArgs} args - Arguments to find a CanvasActivityLog
     * @example
     * // Get one CanvasActivityLog
     * const canvasActivityLog = await prisma.canvasActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasActivityLogFindUniqueArgs>(args: SelectSubset<T, CanvasActivityLogFindUniqueArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasActivityLogFindUniqueOrThrowArgs} args - Arguments to find a CanvasActivityLog
     * @example
     * // Get one CanvasActivityLog
     * const canvasActivityLog = await prisma.canvasActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogFindFirstArgs} args - Arguments to find a CanvasActivityLog
     * @example
     * // Get one CanvasActivityLog
     * const canvasActivityLog = await prisma.canvasActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasActivityLogFindFirstArgs>(args?: SelectSubset<T, CanvasActivityLogFindFirstArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogFindFirstOrThrowArgs} args - Arguments to find a CanvasActivityLog
     * @example
     * // Get one CanvasActivityLog
     * const canvasActivityLog = await prisma.canvasActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasActivityLogs
     * const canvasActivityLogs = await prisma.canvasActivityLog.findMany()
     * 
     * // Get first 10 CanvasActivityLogs
     * const canvasActivityLogs = await prisma.canvasActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasActivityLogWithIdOnly = await prisma.canvasActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasActivityLogFindManyArgs>(args?: SelectSubset<T, CanvasActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasActivityLog.
     * @param {CanvasActivityLogCreateArgs} args - Arguments to create a CanvasActivityLog.
     * @example
     * // Create one CanvasActivityLog
     * const CanvasActivityLog = await prisma.canvasActivityLog.create({
     *   data: {
     *     // ... data to create a CanvasActivityLog
     *   }
     * })
     * 
     */
    create<T extends CanvasActivityLogCreateArgs>(args: SelectSubset<T, CanvasActivityLogCreateArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasActivityLogs.
     * @param {CanvasActivityLogCreateManyArgs} args - Arguments to create many CanvasActivityLogs.
     * @example
     * // Create many CanvasActivityLogs
     * const canvasActivityLog = await prisma.canvasActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasActivityLogCreateManyArgs>(args?: SelectSubset<T, CanvasActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasActivityLogs and returns the data saved in the database.
     * @param {CanvasActivityLogCreateManyAndReturnArgs} args - Arguments to create many CanvasActivityLogs.
     * @example
     * // Create many CanvasActivityLogs
     * const canvasActivityLog = await prisma.canvasActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasActivityLogs and only return the `id`
     * const canvasActivityLogWithIdOnly = await prisma.canvasActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasActivityLog.
     * @param {CanvasActivityLogDeleteArgs} args - Arguments to delete one CanvasActivityLog.
     * @example
     * // Delete one CanvasActivityLog
     * const CanvasActivityLog = await prisma.canvasActivityLog.delete({
     *   where: {
     *     // ... filter to delete one CanvasActivityLog
     *   }
     * })
     * 
     */
    delete<T extends CanvasActivityLogDeleteArgs>(args: SelectSubset<T, CanvasActivityLogDeleteArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasActivityLog.
     * @param {CanvasActivityLogUpdateArgs} args - Arguments to update one CanvasActivityLog.
     * @example
     * // Update one CanvasActivityLog
     * const canvasActivityLog = await prisma.canvasActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasActivityLogUpdateArgs>(args: SelectSubset<T, CanvasActivityLogUpdateArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasActivityLogs.
     * @param {CanvasActivityLogDeleteManyArgs} args - Arguments to filter CanvasActivityLogs to delete.
     * @example
     * // Delete a few CanvasActivityLogs
     * const { count } = await prisma.canvasActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasActivityLogDeleteManyArgs>(args?: SelectSubset<T, CanvasActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasActivityLogs
     * const canvasActivityLog = await prisma.canvasActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasActivityLogUpdateManyArgs>(args: SelectSubset<T, CanvasActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasActivityLogs and returns the data updated in the database.
     * @param {CanvasActivityLogUpdateManyAndReturnArgs} args - Arguments to update many CanvasActivityLogs.
     * @example
     * // Update many CanvasActivityLogs
     * const canvasActivityLog = await prisma.canvasActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasActivityLogs and only return the `id`
     * const canvasActivityLogWithIdOnly = await prisma.canvasActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasActivityLog.
     * @param {CanvasActivityLogUpsertArgs} args - Arguments to update or create a CanvasActivityLog.
     * @example
     * // Update or create a CanvasActivityLog
     * const canvasActivityLog = await prisma.canvasActivityLog.upsert({
     *   create: {
     *     // ... data to create a CanvasActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends CanvasActivityLogUpsertArgs>(args: SelectSubset<T, CanvasActivityLogUpsertArgs<ExtArgs>>): Prisma__CanvasActivityLogClient<$Result.GetResult<Prisma.$CanvasActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogCountArgs} args - Arguments to filter CanvasActivityLogs to count.
     * @example
     * // Count the number of CanvasActivityLogs
     * const count = await prisma.canvasActivityLog.count({
     *   where: {
     *     // ... the filter for the CanvasActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends CanvasActivityLogCountArgs>(
      args?: Subset<T, CanvasActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasActivityLogAggregateArgs>(args: Subset<T, CanvasActivityLogAggregateArgs>): Prisma.PrismaPromise<GetCanvasActivityLogAggregateType<T>>

    /**
     * Group by CanvasActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: CanvasActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasActivityLog model
   */
  readonly fields: CanvasActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasActivityLog model
   */
  interface CanvasActivityLogFieldRefs {
    readonly id: FieldRef<"CanvasActivityLog", 'String'>
    readonly canvasId: FieldRef<"CanvasActivityLog", 'String'>
    readonly userId: FieldRef<"CanvasActivityLog", 'String'>
    readonly action: FieldRef<"CanvasActivityLog", 'CanvasActivityAction'>
    readonly entityType: FieldRef<"CanvasActivityLog", 'String'>
    readonly entityId: FieldRef<"CanvasActivityLog", 'String'>
    readonly changeData: FieldRef<"CanvasActivityLog", 'Json'>
    readonly createdAt: FieldRef<"CanvasActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasActivityLog findUnique
   */
  export type CanvasActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which CanvasActivityLog to fetch.
     */
    where: CanvasActivityLogWhereUniqueInput
  }

  /**
   * CanvasActivityLog findUniqueOrThrow
   */
  export type CanvasActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which CanvasActivityLog to fetch.
     */
    where: CanvasActivityLogWhereUniqueInput
  }

  /**
   * CanvasActivityLog findFirst
   */
  export type CanvasActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which CanvasActivityLog to fetch.
     */
    where?: CanvasActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasActivityLogs to fetch.
     */
    orderBy?: CanvasActivityLogOrderByWithRelationInput | CanvasActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasActivityLogs.
     */
    cursor?: CanvasActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasActivityLogs.
     */
    distinct?: CanvasActivityLogScalarFieldEnum | CanvasActivityLogScalarFieldEnum[]
  }

  /**
   * CanvasActivityLog findFirstOrThrow
   */
  export type CanvasActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which CanvasActivityLog to fetch.
     */
    where?: CanvasActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasActivityLogs to fetch.
     */
    orderBy?: CanvasActivityLogOrderByWithRelationInput | CanvasActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasActivityLogs.
     */
    cursor?: CanvasActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasActivityLogs.
     */
    distinct?: CanvasActivityLogScalarFieldEnum | CanvasActivityLogScalarFieldEnum[]
  }

  /**
   * CanvasActivityLog findMany
   */
  export type CanvasActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which CanvasActivityLogs to fetch.
     */
    where?: CanvasActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasActivityLogs to fetch.
     */
    orderBy?: CanvasActivityLogOrderByWithRelationInput | CanvasActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasActivityLogs.
     */
    cursor?: CanvasActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasActivityLogs.
     */
    skip?: number
    distinct?: CanvasActivityLogScalarFieldEnum | CanvasActivityLogScalarFieldEnum[]
  }

  /**
   * CanvasActivityLog create
   */
  export type CanvasActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasActivityLog.
     */
    data: XOR<CanvasActivityLogCreateInput, CanvasActivityLogUncheckedCreateInput>
  }

  /**
   * CanvasActivityLog createMany
   */
  export type CanvasActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasActivityLogs.
     */
    data: CanvasActivityLogCreateManyInput | CanvasActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasActivityLog createManyAndReturn
   */
  export type CanvasActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasActivityLogs.
     */
    data: CanvasActivityLogCreateManyInput | CanvasActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasActivityLog update
   */
  export type CanvasActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasActivityLog.
     */
    data: XOR<CanvasActivityLogUpdateInput, CanvasActivityLogUncheckedUpdateInput>
    /**
     * Choose, which CanvasActivityLog to update.
     */
    where: CanvasActivityLogWhereUniqueInput
  }

  /**
   * CanvasActivityLog updateMany
   */
  export type CanvasActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasActivityLogs.
     */
    data: XOR<CanvasActivityLogUpdateManyMutationInput, CanvasActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which CanvasActivityLogs to update
     */
    where?: CanvasActivityLogWhereInput
    /**
     * Limit how many CanvasActivityLogs to update.
     */
    limit?: number
  }

  /**
   * CanvasActivityLog updateManyAndReturn
   */
  export type CanvasActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update CanvasActivityLogs.
     */
    data: XOR<CanvasActivityLogUpdateManyMutationInput, CanvasActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which CanvasActivityLogs to update
     */
    where?: CanvasActivityLogWhereInput
    /**
     * Limit how many CanvasActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasActivityLog upsert
   */
  export type CanvasActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasActivityLog to update in case it exists.
     */
    where: CanvasActivityLogWhereUniqueInput
    /**
     * In case the CanvasActivityLog found by the `where` argument doesn't exist, create a new CanvasActivityLog with this data.
     */
    create: XOR<CanvasActivityLogCreateInput, CanvasActivityLogUncheckedCreateInput>
    /**
     * In case the CanvasActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasActivityLogUpdateInput, CanvasActivityLogUncheckedUpdateInput>
  }

  /**
   * CanvasActivityLog delete
   */
  export type CanvasActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
    /**
     * Filter which CanvasActivityLog to delete.
     */
    where: CanvasActivityLogWhereUniqueInput
  }

  /**
   * CanvasActivityLog deleteMany
   */
  export type CanvasActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasActivityLogs to delete
     */
    where?: CanvasActivityLogWhereInput
    /**
     * Limit how many CanvasActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * CanvasActivityLog without action
   */
  export type CanvasActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasActivityLog
     */
    select?: CanvasActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasActivityLog
     */
    omit?: CanvasActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model CanvasComment
   */

  export type AggregateCanvasComment = {
    _count: CanvasCommentCountAggregateOutputType | null
    _min: CanvasCommentMinAggregateOutputType | null
    _max: CanvasCommentMaxAggregateOutputType | null
  }

  export type CanvasCommentMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    content: string | null
    podId: string | null
    parentId: string | null
    isResolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasCommentMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    userId: string | null
    content: string | null
    podId: string | null
    parentId: string | null
    isResolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasCommentCountAggregateOutputType = {
    id: number
    canvasId: number
    userId: number
    content: number
    position: number
    podId: number
    parentId: number
    isResolved: number
    resolvedBy: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CanvasCommentMinAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    content?: true
    podId?: true
    parentId?: true
    isResolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasCommentMaxAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    content?: true
    podId?: true
    parentId?: true
    isResolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasCommentCountAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
    content?: true
    position?: true
    podId?: true
    parentId?: true
    isResolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CanvasCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasComment to aggregate.
     */
    where?: CanvasCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasComments to fetch.
     */
    orderBy?: CanvasCommentOrderByWithRelationInput | CanvasCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasComments
    **/
    _count?: true | CanvasCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasCommentMaxAggregateInputType
  }

  export type GetCanvasCommentAggregateType<T extends CanvasCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasComment[P]>
      : GetScalarType<T[P], AggregateCanvasComment[P]>
  }




  export type CanvasCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasCommentWhereInput
    orderBy?: CanvasCommentOrderByWithAggregationInput | CanvasCommentOrderByWithAggregationInput[]
    by: CanvasCommentScalarFieldEnum[] | CanvasCommentScalarFieldEnum
    having?: CanvasCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasCommentCountAggregateInputType | true
    _min?: CanvasCommentMinAggregateInputType
    _max?: CanvasCommentMaxAggregateInputType
  }

  export type CanvasCommentGroupByOutputType = {
    id: string
    canvasId: string
    userId: string | null
    content: string
    position: JsonValue | null
    podId: string | null
    parentId: string | null
    isResolved: boolean
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CanvasCommentCountAggregateOutputType | null
    _min: CanvasCommentMinAggregateOutputType | null
    _max: CanvasCommentMaxAggregateOutputType | null
  }

  type GetCanvasCommentGroupByPayload<T extends CanvasCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasCommentGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasCommentGroupByOutputType[P]>
        }
      >
    >


  export type CanvasCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasComment"]>

  export type CanvasCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasComment"]>

  export type CanvasCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasComment"]>

  export type CanvasCommentSelectScalar = {
    id?: boolean
    canvasId?: boolean
    userId?: boolean
    content?: boolean
    position?: boolean
    podId?: boolean
    parentId?: boolean
    isResolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CanvasCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "userId" | "content" | "position" | "podId" | "parentId" | "isResolved" | "resolvedBy" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["canvasComment"]>
  export type CanvasCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }
  export type CanvasCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }
  export type CanvasCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
  }

  export type $CanvasCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasComment"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      userId: string | null
      content: string
      position: Prisma.JsonValue | null
      podId: string | null
      parentId: string | null
      isResolved: boolean
      resolvedBy: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["canvasComment"]>
    composites: {}
  }

  type CanvasCommentGetPayload<S extends boolean | null | undefined | CanvasCommentDefaultArgs> = $Result.GetResult<Prisma.$CanvasCommentPayload, S>

  type CanvasCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasCommentCountAggregateInputType | true
    }

  export interface CanvasCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasComment'], meta: { name: 'CanvasComment' } }
    /**
     * Find zero or one CanvasComment that matches the filter.
     * @param {CanvasCommentFindUniqueArgs} args - Arguments to find a CanvasComment
     * @example
     * // Get one CanvasComment
     * const canvasComment = await prisma.canvasComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasCommentFindUniqueArgs>(args: SelectSubset<T, CanvasCommentFindUniqueArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasCommentFindUniqueOrThrowArgs} args - Arguments to find a CanvasComment
     * @example
     * // Get one CanvasComment
     * const canvasComment = await prisma.canvasComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentFindFirstArgs} args - Arguments to find a CanvasComment
     * @example
     * // Get one CanvasComment
     * const canvasComment = await prisma.canvasComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasCommentFindFirstArgs>(args?: SelectSubset<T, CanvasCommentFindFirstArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentFindFirstOrThrowArgs} args - Arguments to find a CanvasComment
     * @example
     * // Get one CanvasComment
     * const canvasComment = await prisma.canvasComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasComments
     * const canvasComments = await prisma.canvasComment.findMany()
     * 
     * // Get first 10 CanvasComments
     * const canvasComments = await prisma.canvasComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasCommentWithIdOnly = await prisma.canvasComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasCommentFindManyArgs>(args?: SelectSubset<T, CanvasCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasComment.
     * @param {CanvasCommentCreateArgs} args - Arguments to create a CanvasComment.
     * @example
     * // Create one CanvasComment
     * const CanvasComment = await prisma.canvasComment.create({
     *   data: {
     *     // ... data to create a CanvasComment
     *   }
     * })
     * 
     */
    create<T extends CanvasCommentCreateArgs>(args: SelectSubset<T, CanvasCommentCreateArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasComments.
     * @param {CanvasCommentCreateManyArgs} args - Arguments to create many CanvasComments.
     * @example
     * // Create many CanvasComments
     * const canvasComment = await prisma.canvasComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasCommentCreateManyArgs>(args?: SelectSubset<T, CanvasCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasComments and returns the data saved in the database.
     * @param {CanvasCommentCreateManyAndReturnArgs} args - Arguments to create many CanvasComments.
     * @example
     * // Create many CanvasComments
     * const canvasComment = await prisma.canvasComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasComments and only return the `id`
     * const canvasCommentWithIdOnly = await prisma.canvasComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasComment.
     * @param {CanvasCommentDeleteArgs} args - Arguments to delete one CanvasComment.
     * @example
     * // Delete one CanvasComment
     * const CanvasComment = await prisma.canvasComment.delete({
     *   where: {
     *     // ... filter to delete one CanvasComment
     *   }
     * })
     * 
     */
    delete<T extends CanvasCommentDeleteArgs>(args: SelectSubset<T, CanvasCommentDeleteArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasComment.
     * @param {CanvasCommentUpdateArgs} args - Arguments to update one CanvasComment.
     * @example
     * // Update one CanvasComment
     * const canvasComment = await prisma.canvasComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasCommentUpdateArgs>(args: SelectSubset<T, CanvasCommentUpdateArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasComments.
     * @param {CanvasCommentDeleteManyArgs} args - Arguments to filter CanvasComments to delete.
     * @example
     * // Delete a few CanvasComments
     * const { count } = await prisma.canvasComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasCommentDeleteManyArgs>(args?: SelectSubset<T, CanvasCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasComments
     * const canvasComment = await prisma.canvasComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasCommentUpdateManyArgs>(args: SelectSubset<T, CanvasCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasComments and returns the data updated in the database.
     * @param {CanvasCommentUpdateManyAndReturnArgs} args - Arguments to update many CanvasComments.
     * @example
     * // Update many CanvasComments
     * const canvasComment = await prisma.canvasComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasComments and only return the `id`
     * const canvasCommentWithIdOnly = await prisma.canvasComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasComment.
     * @param {CanvasCommentUpsertArgs} args - Arguments to update or create a CanvasComment.
     * @example
     * // Update or create a CanvasComment
     * const canvasComment = await prisma.canvasComment.upsert({
     *   create: {
     *     // ... data to create a CanvasComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasComment we want to update
     *   }
     * })
     */
    upsert<T extends CanvasCommentUpsertArgs>(args: SelectSubset<T, CanvasCommentUpsertArgs<ExtArgs>>): Prisma__CanvasCommentClient<$Result.GetResult<Prisma.$CanvasCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentCountArgs} args - Arguments to filter CanvasComments to count.
     * @example
     * // Count the number of CanvasComments
     * const count = await prisma.canvasComment.count({
     *   where: {
     *     // ... the filter for the CanvasComments we want to count
     *   }
     * })
    **/
    count<T extends CanvasCommentCountArgs>(
      args?: Subset<T, CanvasCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasCommentAggregateArgs>(args: Subset<T, CanvasCommentAggregateArgs>): Prisma.PrismaPromise<GetCanvasCommentAggregateType<T>>

    /**
     * Group by CanvasComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasCommentGroupByArgs['orderBy'] }
        : { orderBy?: CanvasCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasComment model
   */
  readonly fields: CanvasCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasComment model
   */
  interface CanvasCommentFieldRefs {
    readonly id: FieldRef<"CanvasComment", 'String'>
    readonly canvasId: FieldRef<"CanvasComment", 'String'>
    readonly userId: FieldRef<"CanvasComment", 'String'>
    readonly content: FieldRef<"CanvasComment", 'String'>
    readonly position: FieldRef<"CanvasComment", 'Json'>
    readonly podId: FieldRef<"CanvasComment", 'String'>
    readonly parentId: FieldRef<"CanvasComment", 'String'>
    readonly isResolved: FieldRef<"CanvasComment", 'Boolean'>
    readonly resolvedBy: FieldRef<"CanvasComment", 'String'>
    readonly resolvedAt: FieldRef<"CanvasComment", 'DateTime'>
    readonly createdAt: FieldRef<"CanvasComment", 'DateTime'>
    readonly updatedAt: FieldRef<"CanvasComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasComment findUnique
   */
  export type CanvasCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * Filter, which CanvasComment to fetch.
     */
    where: CanvasCommentWhereUniqueInput
  }

  /**
   * CanvasComment findUniqueOrThrow
   */
  export type CanvasCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * Filter, which CanvasComment to fetch.
     */
    where: CanvasCommentWhereUniqueInput
  }

  /**
   * CanvasComment findFirst
   */
  export type CanvasCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * Filter, which CanvasComment to fetch.
     */
    where?: CanvasCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasComments to fetch.
     */
    orderBy?: CanvasCommentOrderByWithRelationInput | CanvasCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasComments.
     */
    cursor?: CanvasCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasComments.
     */
    distinct?: CanvasCommentScalarFieldEnum | CanvasCommentScalarFieldEnum[]
  }

  /**
   * CanvasComment findFirstOrThrow
   */
  export type CanvasCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * Filter, which CanvasComment to fetch.
     */
    where?: CanvasCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasComments to fetch.
     */
    orderBy?: CanvasCommentOrderByWithRelationInput | CanvasCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasComments.
     */
    cursor?: CanvasCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasComments.
     */
    distinct?: CanvasCommentScalarFieldEnum | CanvasCommentScalarFieldEnum[]
  }

  /**
   * CanvasComment findMany
   */
  export type CanvasCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * Filter, which CanvasComments to fetch.
     */
    where?: CanvasCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasComments to fetch.
     */
    orderBy?: CanvasCommentOrderByWithRelationInput | CanvasCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasComments.
     */
    cursor?: CanvasCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasComments.
     */
    skip?: number
    distinct?: CanvasCommentScalarFieldEnum | CanvasCommentScalarFieldEnum[]
  }

  /**
   * CanvasComment create
   */
  export type CanvasCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasComment.
     */
    data: XOR<CanvasCommentCreateInput, CanvasCommentUncheckedCreateInput>
  }

  /**
   * CanvasComment createMany
   */
  export type CanvasCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasComments.
     */
    data: CanvasCommentCreateManyInput | CanvasCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasComment createManyAndReturn
   */
  export type CanvasCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasComments.
     */
    data: CanvasCommentCreateManyInput | CanvasCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasComment update
   */
  export type CanvasCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasComment.
     */
    data: XOR<CanvasCommentUpdateInput, CanvasCommentUncheckedUpdateInput>
    /**
     * Choose, which CanvasComment to update.
     */
    where: CanvasCommentWhereUniqueInput
  }

  /**
   * CanvasComment updateMany
   */
  export type CanvasCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasComments.
     */
    data: XOR<CanvasCommentUpdateManyMutationInput, CanvasCommentUncheckedUpdateManyInput>
    /**
     * Filter which CanvasComments to update
     */
    where?: CanvasCommentWhereInput
    /**
     * Limit how many CanvasComments to update.
     */
    limit?: number
  }

  /**
   * CanvasComment updateManyAndReturn
   */
  export type CanvasCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * The data used to update CanvasComments.
     */
    data: XOR<CanvasCommentUpdateManyMutationInput, CanvasCommentUncheckedUpdateManyInput>
    /**
     * Filter which CanvasComments to update
     */
    where?: CanvasCommentWhereInput
    /**
     * Limit how many CanvasComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasComment upsert
   */
  export type CanvasCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasComment to update in case it exists.
     */
    where: CanvasCommentWhereUniqueInput
    /**
     * In case the CanvasComment found by the `where` argument doesn't exist, create a new CanvasComment with this data.
     */
    create: XOR<CanvasCommentCreateInput, CanvasCommentUncheckedCreateInput>
    /**
     * In case the CanvasComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasCommentUpdateInput, CanvasCommentUncheckedUpdateInput>
  }

  /**
   * CanvasComment delete
   */
  export type CanvasCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
    /**
     * Filter which CanvasComment to delete.
     */
    where: CanvasCommentWhereUniqueInput
  }

  /**
   * CanvasComment deleteMany
   */
  export type CanvasCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasComments to delete
     */
    where?: CanvasCommentWhereInput
    /**
     * Limit how many CanvasComments to delete.
     */
    limit?: number
  }

  /**
   * CanvasComment without action
   */
  export type CanvasCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasComment
     */
    select?: CanvasCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasComment
     */
    omit?: CanvasCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCommentInclude<ExtArgs> | null
  }


  /**
   * Model ActionPod
   */

  export type AggregateActionPod = {
    _count: ActionPodCountAggregateOutputType | null
    _min: ActionPodMinAggregateOutputType | null
    _max: ActionPodMaxAggregateOutputType | null
  }

  export type ActionPodMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    type: $Enums.ActionPodType | null
    executionStatus: $Enums.ActionPodExecutionStatus | null
    lastExecutionId: string | null
    contextCanvasId: string | null
    documentId: string | null
    lockedBy: string | null
    lockedAt: Date | null
    dynamoPartitionKey: string | null
    dynamoSortKey: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionPodMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    type: $Enums.ActionPodType | null
    executionStatus: $Enums.ActionPodExecutionStatus | null
    lastExecutionId: string | null
    contextCanvasId: string | null
    documentId: string | null
    lockedBy: string | null
    lockedAt: Date | null
    dynamoPartitionKey: string | null
    dynamoSortKey: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionPodCountAggregateOutputType = {
    id: number
    canvasId: number
    type: number
    position: number
    executionStatus: number
    lastExecutionId: number
    contextCanvasId: number
    documentId: number
    lockedBy: number
    lockedAt: number
    dynamoPartitionKey: number
    dynamoSortKey: number
    s3VectorBucket: number
    s3VectorKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionPodMinAggregateInputType = {
    id?: true
    canvasId?: true
    type?: true
    executionStatus?: true
    lastExecutionId?: true
    contextCanvasId?: true
    documentId?: true
    lockedBy?: true
    lockedAt?: true
    dynamoPartitionKey?: true
    dynamoSortKey?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionPodMaxAggregateInputType = {
    id?: true
    canvasId?: true
    type?: true
    executionStatus?: true
    lastExecutionId?: true
    contextCanvasId?: true
    documentId?: true
    lockedBy?: true
    lockedAt?: true
    dynamoPartitionKey?: true
    dynamoSortKey?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionPodCountAggregateInputType = {
    id?: true
    canvasId?: true
    type?: true
    position?: true
    executionStatus?: true
    lastExecutionId?: true
    contextCanvasId?: true
    documentId?: true
    lockedBy?: true
    lockedAt?: true
    dynamoPartitionKey?: true
    dynamoSortKey?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionPodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionPod to aggregate.
     */
    where?: ActionPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPods to fetch.
     */
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionPods
    **/
    _count?: true | ActionPodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionPodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionPodMaxAggregateInputType
  }

  export type GetActionPodAggregateType<T extends ActionPodAggregateArgs> = {
        [P in keyof T & keyof AggregateActionPod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionPod[P]>
      : GetScalarType<T[P], AggregateActionPod[P]>
  }




  export type ActionPodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPodWhereInput
    orderBy?: ActionPodOrderByWithAggregationInput | ActionPodOrderByWithAggregationInput[]
    by: ActionPodScalarFieldEnum[] | ActionPodScalarFieldEnum
    having?: ActionPodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionPodCountAggregateInputType | true
    _min?: ActionPodMinAggregateInputType
    _max?: ActionPodMaxAggregateInputType
  }

  export type ActionPodGroupByOutputType = {
    id: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonValue
    executionStatus: $Enums.ActionPodExecutionStatus
    lastExecutionId: string | null
    contextCanvasId: string | null
    documentId: string | null
    lockedBy: string | null
    lockedAt: Date | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket: string | null
    s3VectorKey: string | null
    createdAt: Date
    updatedAt: Date
    _count: ActionPodCountAggregateOutputType | null
    _min: ActionPodMinAggregateOutputType | null
    _max: ActionPodMaxAggregateOutputType | null
  }

  type GetActionPodGroupByPayload<T extends ActionPodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionPodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionPodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionPodGroupByOutputType[P]>
            : GetScalarType<T[P], ActionPodGroupByOutputType[P]>
        }
      >
    >


  export type ActionPodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextCanvasId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    contextCanvas?: boolean | ActionPod$contextCanvasArgs<ExtArgs>
    document?: boolean | ActionPod$documentArgs<ExtArgs>
    sourceEdges?: boolean | ActionPod$sourceEdgesArgs<ExtArgs>
    targetEdges?: boolean | ActionPod$targetEdgesArgs<ExtArgs>
    executions?: boolean | ActionPod$executionsArgs<ExtArgs>
    usageLogs?: boolean | ActionPod$usageLogsArgs<ExtArgs>
    _count?: boolean | ActionPodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionPod"]>

  export type ActionPodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextCanvasId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    contextCanvas?: boolean | ActionPod$contextCanvasArgs<ExtArgs>
    document?: boolean | ActionPod$documentArgs<ExtArgs>
  }, ExtArgs["result"]["actionPod"]>

  export type ActionPodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextCanvasId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    contextCanvas?: boolean | ActionPod$contextCanvasArgs<ExtArgs>
    document?: boolean | ActionPod$documentArgs<ExtArgs>
  }, ExtArgs["result"]["actionPod"]>

  export type ActionPodSelectScalar = {
    id?: boolean
    canvasId?: boolean
    type?: boolean
    position?: boolean
    executionStatus?: boolean
    lastExecutionId?: boolean
    contextCanvasId?: boolean
    documentId?: boolean
    lockedBy?: boolean
    lockedAt?: boolean
    dynamoPartitionKey?: boolean
    dynamoSortKey?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionPodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "type" | "position" | "executionStatus" | "lastExecutionId" | "contextCanvasId" | "documentId" | "lockedBy" | "lockedAt" | "dynamoPartitionKey" | "dynamoSortKey" | "s3VectorBucket" | "s3VectorKey" | "createdAt" | "updatedAt", ExtArgs["result"]["actionPod"]>
  export type ActionPodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    contextCanvas?: boolean | ActionPod$contextCanvasArgs<ExtArgs>
    document?: boolean | ActionPod$documentArgs<ExtArgs>
    sourceEdges?: boolean | ActionPod$sourceEdgesArgs<ExtArgs>
    targetEdges?: boolean | ActionPod$targetEdgesArgs<ExtArgs>
    executions?: boolean | ActionPod$executionsArgs<ExtArgs>
    usageLogs?: boolean | ActionPod$usageLogsArgs<ExtArgs>
    _count?: boolean | ActionPodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionPodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    contextCanvas?: boolean | ActionPod$contextCanvasArgs<ExtArgs>
    document?: boolean | ActionPod$documentArgs<ExtArgs>
  }
  export type ActionPodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    contextCanvas?: boolean | ActionPod$contextCanvasArgs<ExtArgs>
    document?: boolean | ActionPod$documentArgs<ExtArgs>
  }

  export type $ActionPodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionPod"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
      contextCanvas: Prisma.$CanvasPayload<ExtArgs> | null
      document: Prisma.$DocumentPayload<ExtArgs> | null
      sourceEdges: Prisma.$EdgePayload<ExtArgs>[]
      targetEdges: Prisma.$EdgePayload<ExtArgs>[]
      executions: Prisma.$ActionPodExecutionPayload<ExtArgs>[]
      usageLogs: Prisma.$PodUsageLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      type: $Enums.ActionPodType
      position: Prisma.JsonValue
      executionStatus: $Enums.ActionPodExecutionStatus
      lastExecutionId: string | null
      contextCanvasId: string | null
      documentId: string | null
      lockedBy: string | null
      lockedAt: Date | null
      dynamoPartitionKey: string
      dynamoSortKey: string
      s3VectorBucket: string | null
      s3VectorKey: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actionPod"]>
    composites: {}
  }

  type ActionPodGetPayload<S extends boolean | null | undefined | ActionPodDefaultArgs> = $Result.GetResult<Prisma.$ActionPodPayload, S>

  type ActionPodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionPodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionPodCountAggregateInputType | true
    }

  export interface ActionPodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionPod'], meta: { name: 'ActionPod' } }
    /**
     * Find zero or one ActionPod that matches the filter.
     * @param {ActionPodFindUniqueArgs} args - Arguments to find a ActionPod
     * @example
     * // Get one ActionPod
     * const actionPod = await prisma.actionPod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionPodFindUniqueArgs>(args: SelectSubset<T, ActionPodFindUniqueArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActionPod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionPodFindUniqueOrThrowArgs} args - Arguments to find a ActionPod
     * @example
     * // Get one ActionPod
     * const actionPod = await prisma.actionPod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionPodFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionPodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionPod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodFindFirstArgs} args - Arguments to find a ActionPod
     * @example
     * // Get one ActionPod
     * const actionPod = await prisma.actionPod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionPodFindFirstArgs>(args?: SelectSubset<T, ActionPodFindFirstArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionPod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodFindFirstOrThrowArgs} args - Arguments to find a ActionPod
     * @example
     * // Get one ActionPod
     * const actionPod = await prisma.actionPod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionPodFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionPodFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActionPods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionPods
     * const actionPods = await prisma.actionPod.findMany()
     * 
     * // Get first 10 ActionPods
     * const actionPods = await prisma.actionPod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionPodWithIdOnly = await prisma.actionPod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionPodFindManyArgs>(args?: SelectSubset<T, ActionPodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActionPod.
     * @param {ActionPodCreateArgs} args - Arguments to create a ActionPod.
     * @example
     * // Create one ActionPod
     * const ActionPod = await prisma.actionPod.create({
     *   data: {
     *     // ... data to create a ActionPod
     *   }
     * })
     * 
     */
    create<T extends ActionPodCreateArgs>(args: SelectSubset<T, ActionPodCreateArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActionPods.
     * @param {ActionPodCreateManyArgs} args - Arguments to create many ActionPods.
     * @example
     * // Create many ActionPods
     * const actionPod = await prisma.actionPod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionPodCreateManyArgs>(args?: SelectSubset<T, ActionPodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionPods and returns the data saved in the database.
     * @param {ActionPodCreateManyAndReturnArgs} args - Arguments to create many ActionPods.
     * @example
     * // Create many ActionPods
     * const actionPod = await prisma.actionPod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionPods and only return the `id`
     * const actionPodWithIdOnly = await prisma.actionPod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionPodCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionPodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActionPod.
     * @param {ActionPodDeleteArgs} args - Arguments to delete one ActionPod.
     * @example
     * // Delete one ActionPod
     * const ActionPod = await prisma.actionPod.delete({
     *   where: {
     *     // ... filter to delete one ActionPod
     *   }
     * })
     * 
     */
    delete<T extends ActionPodDeleteArgs>(args: SelectSubset<T, ActionPodDeleteArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActionPod.
     * @param {ActionPodUpdateArgs} args - Arguments to update one ActionPod.
     * @example
     * // Update one ActionPod
     * const actionPod = await prisma.actionPod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionPodUpdateArgs>(args: SelectSubset<T, ActionPodUpdateArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActionPods.
     * @param {ActionPodDeleteManyArgs} args - Arguments to filter ActionPods to delete.
     * @example
     * // Delete a few ActionPods
     * const { count } = await prisma.actionPod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionPodDeleteManyArgs>(args?: SelectSubset<T, ActionPodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionPods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionPods
     * const actionPod = await prisma.actionPod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionPodUpdateManyArgs>(args: SelectSubset<T, ActionPodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionPods and returns the data updated in the database.
     * @param {ActionPodUpdateManyAndReturnArgs} args - Arguments to update many ActionPods.
     * @example
     * // Update many ActionPods
     * const actionPod = await prisma.actionPod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActionPods and only return the `id`
     * const actionPodWithIdOnly = await prisma.actionPod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionPodUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionPodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActionPod.
     * @param {ActionPodUpsertArgs} args - Arguments to update or create a ActionPod.
     * @example
     * // Update or create a ActionPod
     * const actionPod = await prisma.actionPod.upsert({
     *   create: {
     *     // ... data to create a ActionPod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionPod we want to update
     *   }
     * })
     */
    upsert<T extends ActionPodUpsertArgs>(args: SelectSubset<T, ActionPodUpsertArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActionPods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodCountArgs} args - Arguments to filter ActionPods to count.
     * @example
     * // Count the number of ActionPods
     * const count = await prisma.actionPod.count({
     *   where: {
     *     // ... the filter for the ActionPods we want to count
     *   }
     * })
    **/
    count<T extends ActionPodCountArgs>(
      args?: Subset<T, ActionPodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionPodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionPod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionPodAggregateArgs>(args: Subset<T, ActionPodAggregateArgs>): Prisma.PrismaPromise<GetActionPodAggregateType<T>>

    /**
     * Group by ActionPod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionPodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionPodGroupByArgs['orderBy'] }
        : { orderBy?: ActionPodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionPodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionPodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionPod model
   */
  readonly fields: ActionPodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionPod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionPodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contextCanvas<T extends ActionPod$contextCanvasArgs<ExtArgs> = {}>(args?: Subset<T, ActionPod$contextCanvasArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    document<T extends ActionPod$documentArgs<ExtArgs> = {}>(args?: Subset<T, ActionPod$documentArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceEdges<T extends ActionPod$sourceEdgesArgs<ExtArgs> = {}>(args?: Subset<T, ActionPod$sourceEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetEdges<T extends ActionPod$targetEdgesArgs<ExtArgs> = {}>(args?: Subset<T, ActionPod$targetEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executions<T extends ActionPod$executionsArgs<ExtArgs> = {}>(args?: Subset<T, ActionPod$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends ActionPod$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ActionPod$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionPod model
   */
  interface ActionPodFieldRefs {
    readonly id: FieldRef<"ActionPod", 'String'>
    readonly canvasId: FieldRef<"ActionPod", 'String'>
    readonly type: FieldRef<"ActionPod", 'ActionPodType'>
    readonly position: FieldRef<"ActionPod", 'Json'>
    readonly executionStatus: FieldRef<"ActionPod", 'ActionPodExecutionStatus'>
    readonly lastExecutionId: FieldRef<"ActionPod", 'String'>
    readonly contextCanvasId: FieldRef<"ActionPod", 'String'>
    readonly documentId: FieldRef<"ActionPod", 'String'>
    readonly lockedBy: FieldRef<"ActionPod", 'String'>
    readonly lockedAt: FieldRef<"ActionPod", 'DateTime'>
    readonly dynamoPartitionKey: FieldRef<"ActionPod", 'String'>
    readonly dynamoSortKey: FieldRef<"ActionPod", 'String'>
    readonly s3VectorBucket: FieldRef<"ActionPod", 'String'>
    readonly s3VectorKey: FieldRef<"ActionPod", 'String'>
    readonly createdAt: FieldRef<"ActionPod", 'DateTime'>
    readonly updatedAt: FieldRef<"ActionPod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionPod findUnique
   */
  export type ActionPodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * Filter, which ActionPod to fetch.
     */
    where: ActionPodWhereUniqueInput
  }

  /**
   * ActionPod findUniqueOrThrow
   */
  export type ActionPodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * Filter, which ActionPod to fetch.
     */
    where: ActionPodWhereUniqueInput
  }

  /**
   * ActionPod findFirst
   */
  export type ActionPodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * Filter, which ActionPod to fetch.
     */
    where?: ActionPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPods to fetch.
     */
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionPods.
     */
    cursor?: ActionPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionPods.
     */
    distinct?: ActionPodScalarFieldEnum | ActionPodScalarFieldEnum[]
  }

  /**
   * ActionPod findFirstOrThrow
   */
  export type ActionPodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * Filter, which ActionPod to fetch.
     */
    where?: ActionPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPods to fetch.
     */
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionPods.
     */
    cursor?: ActionPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionPods.
     */
    distinct?: ActionPodScalarFieldEnum | ActionPodScalarFieldEnum[]
  }

  /**
   * ActionPod findMany
   */
  export type ActionPodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * Filter, which ActionPods to fetch.
     */
    where?: ActionPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPods to fetch.
     */
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionPods.
     */
    cursor?: ActionPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPods.
     */
    skip?: number
    distinct?: ActionPodScalarFieldEnum | ActionPodScalarFieldEnum[]
  }

  /**
   * ActionPod create
   */
  export type ActionPodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionPod.
     */
    data: XOR<ActionPodCreateInput, ActionPodUncheckedCreateInput>
  }

  /**
   * ActionPod createMany
   */
  export type ActionPodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionPods.
     */
    data: ActionPodCreateManyInput | ActionPodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionPod createManyAndReturn
   */
  export type ActionPodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * The data used to create many ActionPods.
     */
    data: ActionPodCreateManyInput | ActionPodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionPod update
   */
  export type ActionPodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionPod.
     */
    data: XOR<ActionPodUpdateInput, ActionPodUncheckedUpdateInput>
    /**
     * Choose, which ActionPod to update.
     */
    where: ActionPodWhereUniqueInput
  }

  /**
   * ActionPod updateMany
   */
  export type ActionPodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionPods.
     */
    data: XOR<ActionPodUpdateManyMutationInput, ActionPodUncheckedUpdateManyInput>
    /**
     * Filter which ActionPods to update
     */
    where?: ActionPodWhereInput
    /**
     * Limit how many ActionPods to update.
     */
    limit?: number
  }

  /**
   * ActionPod updateManyAndReturn
   */
  export type ActionPodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * The data used to update ActionPods.
     */
    data: XOR<ActionPodUpdateManyMutationInput, ActionPodUncheckedUpdateManyInput>
    /**
     * Filter which ActionPods to update
     */
    where?: ActionPodWhereInput
    /**
     * Limit how many ActionPods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionPod upsert
   */
  export type ActionPodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionPod to update in case it exists.
     */
    where: ActionPodWhereUniqueInput
    /**
     * In case the ActionPod found by the `where` argument doesn't exist, create a new ActionPod with this data.
     */
    create: XOR<ActionPodCreateInput, ActionPodUncheckedCreateInput>
    /**
     * In case the ActionPod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionPodUpdateInput, ActionPodUncheckedUpdateInput>
  }

  /**
   * ActionPod delete
   */
  export type ActionPodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    /**
     * Filter which ActionPod to delete.
     */
    where: ActionPodWhereUniqueInput
  }

  /**
   * ActionPod deleteMany
   */
  export type ActionPodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionPods to delete
     */
    where?: ActionPodWhereInput
    /**
     * Limit how many ActionPods to delete.
     */
    limit?: number
  }

  /**
   * ActionPod.contextCanvas
   */
  export type ActionPod$contextCanvasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    where?: CanvasWhereInput
  }

  /**
   * ActionPod.document
   */
  export type ActionPod$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }

  /**
   * ActionPod.sourceEdges
   */
  export type ActionPod$sourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    cursor?: EdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * ActionPod.targetEdges
   */
  export type ActionPod$targetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    cursor?: EdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * ActionPod.executions
   */
  export type ActionPod$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    where?: ActionPodExecutionWhereInput
    orderBy?: ActionPodExecutionOrderByWithRelationInput | ActionPodExecutionOrderByWithRelationInput[]
    cursor?: ActionPodExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionPodExecutionScalarFieldEnum | ActionPodExecutionScalarFieldEnum[]
  }

  /**
   * ActionPod.usageLogs
   */
  export type ActionPod$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    where?: PodUsageLogWhereInput
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    cursor?: PodUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * ActionPod without action
   */
  export type ActionPodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
  }


  /**
   * Model Edge
   */

  export type AggregateEdge = {
    _count: EdgeCountAggregateOutputType | null
    _min: EdgeMinAggregateOutputType | null
    _max: EdgeMaxAggregateOutputType | null
  }

  export type EdgeMinAggregateOutputType = {
    id: string | null
    canvasId: string | null
    sourcePodId: string | null
    targetPodId: string | null
    sourceHandle: string | null
    targetHandle: string | null
    animated: boolean | null
    createdAt: Date | null
  }

  export type EdgeMaxAggregateOutputType = {
    id: string | null
    canvasId: string | null
    sourcePodId: string | null
    targetPodId: string | null
    sourceHandle: string | null
    targetHandle: string | null
    animated: boolean | null
    createdAt: Date | null
  }

  export type EdgeCountAggregateOutputType = {
    id: number
    canvasId: number
    sourcePodId: number
    targetPodId: number
    sourceHandle: number
    targetHandle: number
    animated: number
    createdAt: number
    _all: number
  }


  export type EdgeMinAggregateInputType = {
    id?: true
    canvasId?: true
    sourcePodId?: true
    targetPodId?: true
    sourceHandle?: true
    targetHandle?: true
    animated?: true
    createdAt?: true
  }

  export type EdgeMaxAggregateInputType = {
    id?: true
    canvasId?: true
    sourcePodId?: true
    targetPodId?: true
    sourceHandle?: true
    targetHandle?: true
    animated?: true
    createdAt?: true
  }

  export type EdgeCountAggregateInputType = {
    id?: true
    canvasId?: true
    sourcePodId?: true
    targetPodId?: true
    sourceHandle?: true
    targetHandle?: true
    animated?: true
    createdAt?: true
    _all?: true
  }

  export type EdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Edge to aggregate.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Edges
    **/
    _count?: true | EdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeMaxAggregateInputType
  }

  export type GetEdgeAggregateType<T extends EdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdge[P]>
      : GetScalarType<T[P], AggregateEdge[P]>
  }




  export type EdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeWhereInput
    orderBy?: EdgeOrderByWithAggregationInput | EdgeOrderByWithAggregationInput[]
    by: EdgeScalarFieldEnum[] | EdgeScalarFieldEnum
    having?: EdgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeCountAggregateInputType | true
    _min?: EdgeMinAggregateInputType
    _max?: EdgeMaxAggregateInputType
  }

  export type EdgeGroupByOutputType = {
    id: string
    canvasId: string
    sourcePodId: string
    targetPodId: string
    sourceHandle: string | null
    targetHandle: string | null
    animated: boolean
    createdAt: Date
    _count: EdgeCountAggregateOutputType | null
    _min: EdgeMinAggregateOutputType | null
    _max: EdgeMaxAggregateOutputType | null
  }

  type GetEdgeGroupByPayload<T extends EdgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeGroupByOutputType[P]>
        }
      >
    >


  export type EdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    sourcePod?: boolean | ActionPodDefaultArgs<ExtArgs>
    targetPod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type EdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    sourcePod?: boolean | ActionPodDefaultArgs<ExtArgs>
    targetPod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type EdgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    sourcePod?: boolean | ActionPodDefaultArgs<ExtArgs>
    targetPod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type EdgeSelectScalar = {
    id?: boolean
    canvasId?: boolean
    sourcePodId?: boolean
    targetPodId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    animated?: boolean
    createdAt?: boolean
  }

  export type EdgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "sourcePodId" | "targetPodId" | "sourceHandle" | "targetHandle" | "animated" | "createdAt", ExtArgs["result"]["edge"]>
  export type EdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    sourcePod?: boolean | ActionPodDefaultArgs<ExtArgs>
    targetPod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }
  export type EdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    sourcePod?: boolean | ActionPodDefaultArgs<ExtArgs>
    targetPod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }
  export type EdgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    sourcePod?: boolean | ActionPodDefaultArgs<ExtArgs>
    targetPod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }

  export type $EdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Edge"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
      sourcePod: Prisma.$ActionPodPayload<ExtArgs>
      targetPod: Prisma.$ActionPodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvasId: string
      sourcePodId: string
      targetPodId: string
      sourceHandle: string | null
      targetHandle: string | null
      animated: boolean
      createdAt: Date
    }, ExtArgs["result"]["edge"]>
    composites: {}
  }

  type EdgeGetPayload<S extends boolean | null | undefined | EdgeDefaultArgs> = $Result.GetResult<Prisma.$EdgePayload, S>

  type EdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EdgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EdgeCountAggregateInputType | true
    }

  export interface EdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Edge'], meta: { name: 'Edge' } }
    /**
     * Find zero or one Edge that matches the filter.
     * @param {EdgeFindUniqueArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EdgeFindUniqueArgs>(args: SelectSubset<T, EdgeFindUniqueArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Edge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EdgeFindUniqueOrThrowArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EdgeFindUniqueOrThrowArgs>(args: SelectSubset<T, EdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeFindFirstArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EdgeFindFirstArgs>(args?: SelectSubset<T, EdgeFindFirstArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeFindFirstOrThrowArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EdgeFindFirstOrThrowArgs>(args?: SelectSubset<T, EdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Edges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Edges
     * const edges = await prisma.edge.findMany()
     * 
     * // Get first 10 Edges
     * const edges = await prisma.edge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeWithIdOnly = await prisma.edge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EdgeFindManyArgs>(args?: SelectSubset<T, EdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Edge.
     * @param {EdgeCreateArgs} args - Arguments to create a Edge.
     * @example
     * // Create one Edge
     * const Edge = await prisma.edge.create({
     *   data: {
     *     // ... data to create a Edge
     *   }
     * })
     * 
     */
    create<T extends EdgeCreateArgs>(args: SelectSubset<T, EdgeCreateArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Edges.
     * @param {EdgeCreateManyArgs} args - Arguments to create many Edges.
     * @example
     * // Create many Edges
     * const edge = await prisma.edge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EdgeCreateManyArgs>(args?: SelectSubset<T, EdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Edges and returns the data saved in the database.
     * @param {EdgeCreateManyAndReturnArgs} args - Arguments to create many Edges.
     * @example
     * // Create many Edges
     * const edge = await prisma.edge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Edges and only return the `id`
     * const edgeWithIdOnly = await prisma.edge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EdgeCreateManyAndReturnArgs>(args?: SelectSubset<T, EdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Edge.
     * @param {EdgeDeleteArgs} args - Arguments to delete one Edge.
     * @example
     * // Delete one Edge
     * const Edge = await prisma.edge.delete({
     *   where: {
     *     // ... filter to delete one Edge
     *   }
     * })
     * 
     */
    delete<T extends EdgeDeleteArgs>(args: SelectSubset<T, EdgeDeleteArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Edge.
     * @param {EdgeUpdateArgs} args - Arguments to update one Edge.
     * @example
     * // Update one Edge
     * const edge = await prisma.edge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EdgeUpdateArgs>(args: SelectSubset<T, EdgeUpdateArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Edges.
     * @param {EdgeDeleteManyArgs} args - Arguments to filter Edges to delete.
     * @example
     * // Delete a few Edges
     * const { count } = await prisma.edge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EdgeDeleteManyArgs>(args?: SelectSubset<T, EdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Edges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Edges
     * const edge = await prisma.edge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EdgeUpdateManyArgs>(args: SelectSubset<T, EdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Edges and returns the data updated in the database.
     * @param {EdgeUpdateManyAndReturnArgs} args - Arguments to update many Edges.
     * @example
     * // Update many Edges
     * const edge = await prisma.edge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Edges and only return the `id`
     * const edgeWithIdOnly = await prisma.edge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EdgeUpdateManyAndReturnArgs>(args: SelectSubset<T, EdgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Edge.
     * @param {EdgeUpsertArgs} args - Arguments to update or create a Edge.
     * @example
     * // Update or create a Edge
     * const edge = await prisma.edge.upsert({
     *   create: {
     *     // ... data to create a Edge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Edge we want to update
     *   }
     * })
     */
    upsert<T extends EdgeUpsertArgs>(args: SelectSubset<T, EdgeUpsertArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Edges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeCountArgs} args - Arguments to filter Edges to count.
     * @example
     * // Count the number of Edges
     * const count = await prisma.edge.count({
     *   where: {
     *     // ... the filter for the Edges we want to count
     *   }
     * })
    **/
    count<T extends EdgeCountArgs>(
      args?: Subset<T, EdgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Edge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeAggregateArgs>(args: Subset<T, EdgeAggregateArgs>): Prisma.PrismaPromise<GetEdgeAggregateType<T>>

    /**
     * Group by Edge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EdgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EdgeGroupByArgs['orderBy'] }
        : { orderBy?: EdgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Edge model
   */
  readonly fields: EdgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Edge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sourcePod<T extends ActionPodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionPodDefaultArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetPod<T extends ActionPodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionPodDefaultArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Edge model
   */
  interface EdgeFieldRefs {
    readonly id: FieldRef<"Edge", 'String'>
    readonly canvasId: FieldRef<"Edge", 'String'>
    readonly sourcePodId: FieldRef<"Edge", 'String'>
    readonly targetPodId: FieldRef<"Edge", 'String'>
    readonly sourceHandle: FieldRef<"Edge", 'String'>
    readonly targetHandle: FieldRef<"Edge", 'String'>
    readonly animated: FieldRef<"Edge", 'Boolean'>
    readonly createdAt: FieldRef<"Edge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Edge findUnique
   */
  export type EdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge findUniqueOrThrow
   */
  export type EdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge findFirst
   */
  export type EdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Edges.
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Edges.
     */
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Edge findFirstOrThrow
   */
  export type EdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edge to fetch.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Edges.
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Edges.
     */
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Edge findMany
   */
  export type EdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter, which Edges to fetch.
     */
    where?: EdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Edges to fetch.
     */
    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Edges.
     */
    cursor?: EdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Edges.
     */
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }

  /**
   * Edge create
   */
  export type EdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Edge.
     */
    data: XOR<EdgeCreateInput, EdgeUncheckedCreateInput>
  }

  /**
   * Edge createMany
   */
  export type EdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Edges.
     */
    data: EdgeCreateManyInput | EdgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Edge createManyAndReturn
   */
  export type EdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * The data used to create many Edges.
     */
    data: EdgeCreateManyInput | EdgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Edge update
   */
  export type EdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Edge.
     */
    data: XOR<EdgeUpdateInput, EdgeUncheckedUpdateInput>
    /**
     * Choose, which Edge to update.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge updateMany
   */
  export type EdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Edges.
     */
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyInput>
    /**
     * Filter which Edges to update
     */
    where?: EdgeWhereInput
    /**
     * Limit how many Edges to update.
     */
    limit?: number
  }

  /**
   * Edge updateManyAndReturn
   */
  export type EdgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * The data used to update Edges.
     */
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyInput>
    /**
     * Filter which Edges to update
     */
    where?: EdgeWhereInput
    /**
     * Limit how many Edges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Edge upsert
   */
  export type EdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Edge to update in case it exists.
     */
    where: EdgeWhereUniqueInput
    /**
     * In case the Edge found by the `where` argument doesn't exist, create a new Edge with this data.
     */
    create: XOR<EdgeCreateInput, EdgeUncheckedCreateInput>
    /**
     * In case the Edge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EdgeUpdateInput, EdgeUncheckedUpdateInput>
  }

  /**
   * Edge delete
   */
  export type EdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
    /**
     * Filter which Edge to delete.
     */
    where: EdgeWhereUniqueInput
  }

  /**
   * Edge deleteMany
   */
  export type EdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Edges to delete
     */
    where?: EdgeWhereInput
    /**
     * Limit how many Edges to delete.
     */
    limit?: number
  }

  /**
   * Edge without action
   */
  export type EdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edge
     */
    select?: EdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edge
     */
    omit?: EdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EdgeInclude<ExtArgs> | null
  }


  /**
   * Model ActionPodExecution
   */

  export type AggregateActionPodExecution = {
    _count: ActionPodExecutionCountAggregateOutputType | null
    _avg: ActionPodExecutionAvgAggregateOutputType | null
    _sum: ActionPodExecutionSumAggregateOutputType | null
    _min: ActionPodExecutionMinAggregateOutputType | null
    _max: ActionPodExecutionMaxAggregateOutputType | null
  }

  export type ActionPodExecutionAvgAggregateOutputType = {
    runtimeInMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type ActionPodExecutionSumAggregateOutputType = {
    runtimeInMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type ActionPodExecutionMinAggregateOutputType = {
    id: string | null
    podId: string | null
    canvasId: string | null
    workspaceId: string | null
    status: $Enums.ActionPodExecutionStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    runtimeInMs: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    errorMessage: string | null
    errorCode: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type ActionPodExecutionMaxAggregateOutputType = {
    id: string | null
    podId: string | null
    canvasId: string | null
    workspaceId: string | null
    status: $Enums.ActionPodExecutionStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    runtimeInMs: number | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    errorMessage: string | null
    errorCode: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    costInUsd: Decimal | null
  }

  export type ActionPodExecutionCountAggregateOutputType = {
    id: number
    podId: number
    canvasId: number
    workspaceId: number
    status: number
    startedAt: number
    finishedAt: number
    runtimeInMs: number
    provider: number
    modelId: number
    modelName: number
    providerMetadata: number
    requestMetadata: number
    responseMetadata: number
    errorMessage: number
    errorCode: number
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    costInUsd: number
    _all: number
  }


  export type ActionPodExecutionAvgAggregateInputType = {
    runtimeInMs?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type ActionPodExecutionSumAggregateInputType = {
    runtimeInMs?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type ActionPodExecutionMinAggregateInputType = {
    id?: true
    podId?: true
    canvasId?: true
    workspaceId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    runtimeInMs?: true
    provider?: true
    modelId?: true
    modelName?: true
    errorMessage?: true
    errorCode?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type ActionPodExecutionMaxAggregateInputType = {
    id?: true
    podId?: true
    canvasId?: true
    workspaceId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    runtimeInMs?: true
    provider?: true
    modelId?: true
    modelName?: true
    errorMessage?: true
    errorCode?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
  }

  export type ActionPodExecutionCountAggregateInputType = {
    id?: true
    podId?: true
    canvasId?: true
    workspaceId?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    runtimeInMs?: true
    provider?: true
    modelId?: true
    modelName?: true
    providerMetadata?: true
    requestMetadata?: true
    responseMetadata?: true
    errorMessage?: true
    errorCode?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    costInUsd?: true
    _all?: true
  }

  export type ActionPodExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionPodExecution to aggregate.
     */
    where?: ActionPodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPodExecutions to fetch.
     */
    orderBy?: ActionPodExecutionOrderByWithRelationInput | ActionPodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionPodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPodExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionPodExecutions
    **/
    _count?: true | ActionPodExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionPodExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionPodExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionPodExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionPodExecutionMaxAggregateInputType
  }

  export type GetActionPodExecutionAggregateType<T extends ActionPodExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateActionPodExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionPodExecution[P]>
      : GetScalarType<T[P], AggregateActionPodExecution[P]>
  }




  export type ActionPodExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPodExecutionWhereInput
    orderBy?: ActionPodExecutionOrderByWithAggregationInput | ActionPodExecutionOrderByWithAggregationInput[]
    by: ActionPodExecutionScalarFieldEnum[] | ActionPodExecutionScalarFieldEnum
    having?: ActionPodExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionPodExecutionCountAggregateInputType | true
    _avg?: ActionPodExecutionAvgAggregateInputType
    _sum?: ActionPodExecutionSumAggregateInputType
    _min?: ActionPodExecutionMinAggregateInputType
    _max?: ActionPodExecutionMaxAggregateInputType
  }

  export type ActionPodExecutionGroupByOutputType = {
    id: string
    podId: string
    canvasId: string
    workspaceId: string
    status: $Enums.ActionPodExecutionStatus
    startedAt: Date
    finishedAt: Date | null
    runtimeInMs: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName: string | null
    providerMetadata: JsonValue | null
    requestMetadata: JsonValue | null
    responseMetadata: JsonValue | null
    errorMessage: string | null
    errorCode: string | null
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    costInUsd: Decimal | null
    _count: ActionPodExecutionCountAggregateOutputType | null
    _avg: ActionPodExecutionAvgAggregateOutputType | null
    _sum: ActionPodExecutionSumAggregateOutputType | null
    _min: ActionPodExecutionMinAggregateOutputType | null
    _max: ActionPodExecutionMaxAggregateOutputType | null
  }

  type GetActionPodExecutionGroupByPayload<T extends ActionPodExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionPodExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionPodExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionPodExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionPodExecutionGroupByOutputType[P]>
        }
      >
    >


  export type ActionPodExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionPodExecution"]>

  export type ActionPodExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionPodExecution"]>

  export type ActionPodExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionPodExecution"]>

  export type ActionPodExecutionSelectScalar = {
    id?: boolean
    podId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    runtimeInMs?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    requestMetadata?: boolean
    responseMetadata?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    costInUsd?: boolean
  }

  export type ActionPodExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "podId" | "canvasId" | "workspaceId" | "status" | "startedAt" | "finishedAt" | "runtimeInMs" | "provider" | "modelId" | "modelName" | "providerMetadata" | "requestMetadata" | "responseMetadata" | "errorMessage" | "errorCode" | "inputTokens" | "outputTokens" | "reasoningTokens" | "creditsConsumed" | "costInUsd", ExtArgs["result"]["actionPodExecution"]>
  export type ActionPodExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }
  export type ActionPodExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }
  export type ActionPodExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
  }

  export type $ActionPodExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionPodExecution"
    objects: {
      pod: Prisma.$ActionPodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      podId: string
      canvasId: string
      workspaceId: string
      status: $Enums.ActionPodExecutionStatus
      startedAt: Date
      finishedAt: Date | null
      runtimeInMs: number | null
      provider: $Enums.LLMProvider
      modelId: string
      modelName: string | null
      providerMetadata: Prisma.JsonValue | null
      requestMetadata: Prisma.JsonValue | null
      responseMetadata: Prisma.JsonValue | null
      errorMessage: string | null
      errorCode: string | null
      inputTokens: number
      outputTokens: number
      reasoningTokens: number
      creditsConsumed: number
      costInUsd: Prisma.Decimal | null
    }, ExtArgs["result"]["actionPodExecution"]>
    composites: {}
  }

  type ActionPodExecutionGetPayload<S extends boolean | null | undefined | ActionPodExecutionDefaultArgs> = $Result.GetResult<Prisma.$ActionPodExecutionPayload, S>

  type ActionPodExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionPodExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionPodExecutionCountAggregateInputType | true
    }

  export interface ActionPodExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionPodExecution'], meta: { name: 'ActionPodExecution' } }
    /**
     * Find zero or one ActionPodExecution that matches the filter.
     * @param {ActionPodExecutionFindUniqueArgs} args - Arguments to find a ActionPodExecution
     * @example
     * // Get one ActionPodExecution
     * const actionPodExecution = await prisma.actionPodExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionPodExecutionFindUniqueArgs>(args: SelectSubset<T, ActionPodExecutionFindUniqueArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActionPodExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionPodExecutionFindUniqueOrThrowArgs} args - Arguments to find a ActionPodExecution
     * @example
     * // Get one ActionPodExecution
     * const actionPodExecution = await prisma.actionPodExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionPodExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionPodExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionPodExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionFindFirstArgs} args - Arguments to find a ActionPodExecution
     * @example
     * // Get one ActionPodExecution
     * const actionPodExecution = await prisma.actionPodExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionPodExecutionFindFirstArgs>(args?: SelectSubset<T, ActionPodExecutionFindFirstArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionPodExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionFindFirstOrThrowArgs} args - Arguments to find a ActionPodExecution
     * @example
     * // Get one ActionPodExecution
     * const actionPodExecution = await prisma.actionPodExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionPodExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionPodExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActionPodExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionPodExecutions
     * const actionPodExecutions = await prisma.actionPodExecution.findMany()
     * 
     * // Get first 10 ActionPodExecutions
     * const actionPodExecutions = await prisma.actionPodExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionPodExecutionWithIdOnly = await prisma.actionPodExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionPodExecutionFindManyArgs>(args?: SelectSubset<T, ActionPodExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActionPodExecution.
     * @param {ActionPodExecutionCreateArgs} args - Arguments to create a ActionPodExecution.
     * @example
     * // Create one ActionPodExecution
     * const ActionPodExecution = await prisma.actionPodExecution.create({
     *   data: {
     *     // ... data to create a ActionPodExecution
     *   }
     * })
     * 
     */
    create<T extends ActionPodExecutionCreateArgs>(args: SelectSubset<T, ActionPodExecutionCreateArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActionPodExecutions.
     * @param {ActionPodExecutionCreateManyArgs} args - Arguments to create many ActionPodExecutions.
     * @example
     * // Create many ActionPodExecutions
     * const actionPodExecution = await prisma.actionPodExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionPodExecutionCreateManyArgs>(args?: SelectSubset<T, ActionPodExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionPodExecutions and returns the data saved in the database.
     * @param {ActionPodExecutionCreateManyAndReturnArgs} args - Arguments to create many ActionPodExecutions.
     * @example
     * // Create many ActionPodExecutions
     * const actionPodExecution = await prisma.actionPodExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionPodExecutions and only return the `id`
     * const actionPodExecutionWithIdOnly = await prisma.actionPodExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionPodExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionPodExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActionPodExecution.
     * @param {ActionPodExecutionDeleteArgs} args - Arguments to delete one ActionPodExecution.
     * @example
     * // Delete one ActionPodExecution
     * const ActionPodExecution = await prisma.actionPodExecution.delete({
     *   where: {
     *     // ... filter to delete one ActionPodExecution
     *   }
     * })
     * 
     */
    delete<T extends ActionPodExecutionDeleteArgs>(args: SelectSubset<T, ActionPodExecutionDeleteArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActionPodExecution.
     * @param {ActionPodExecutionUpdateArgs} args - Arguments to update one ActionPodExecution.
     * @example
     * // Update one ActionPodExecution
     * const actionPodExecution = await prisma.actionPodExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionPodExecutionUpdateArgs>(args: SelectSubset<T, ActionPodExecutionUpdateArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActionPodExecutions.
     * @param {ActionPodExecutionDeleteManyArgs} args - Arguments to filter ActionPodExecutions to delete.
     * @example
     * // Delete a few ActionPodExecutions
     * const { count } = await prisma.actionPodExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionPodExecutionDeleteManyArgs>(args?: SelectSubset<T, ActionPodExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionPodExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionPodExecutions
     * const actionPodExecution = await prisma.actionPodExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionPodExecutionUpdateManyArgs>(args: SelectSubset<T, ActionPodExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionPodExecutions and returns the data updated in the database.
     * @param {ActionPodExecutionUpdateManyAndReturnArgs} args - Arguments to update many ActionPodExecutions.
     * @example
     * // Update many ActionPodExecutions
     * const actionPodExecution = await prisma.actionPodExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActionPodExecutions and only return the `id`
     * const actionPodExecutionWithIdOnly = await prisma.actionPodExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionPodExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionPodExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActionPodExecution.
     * @param {ActionPodExecutionUpsertArgs} args - Arguments to update or create a ActionPodExecution.
     * @example
     * // Update or create a ActionPodExecution
     * const actionPodExecution = await prisma.actionPodExecution.upsert({
     *   create: {
     *     // ... data to create a ActionPodExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionPodExecution we want to update
     *   }
     * })
     */
    upsert<T extends ActionPodExecutionUpsertArgs>(args: SelectSubset<T, ActionPodExecutionUpsertArgs<ExtArgs>>): Prisma__ActionPodExecutionClient<$Result.GetResult<Prisma.$ActionPodExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActionPodExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionCountArgs} args - Arguments to filter ActionPodExecutions to count.
     * @example
     * // Count the number of ActionPodExecutions
     * const count = await prisma.actionPodExecution.count({
     *   where: {
     *     // ... the filter for the ActionPodExecutions we want to count
     *   }
     * })
    **/
    count<T extends ActionPodExecutionCountArgs>(
      args?: Subset<T, ActionPodExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionPodExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionPodExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionPodExecutionAggregateArgs>(args: Subset<T, ActionPodExecutionAggregateArgs>): Prisma.PrismaPromise<GetActionPodExecutionAggregateType<T>>

    /**
     * Group by ActionPodExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPodExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionPodExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionPodExecutionGroupByArgs['orderBy'] }
        : { orderBy?: ActionPodExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionPodExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionPodExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionPodExecution model
   */
  readonly fields: ActionPodExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionPodExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionPodExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod<T extends ActionPodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionPodDefaultArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionPodExecution model
   */
  interface ActionPodExecutionFieldRefs {
    readonly id: FieldRef<"ActionPodExecution", 'String'>
    readonly podId: FieldRef<"ActionPodExecution", 'String'>
    readonly canvasId: FieldRef<"ActionPodExecution", 'String'>
    readonly workspaceId: FieldRef<"ActionPodExecution", 'String'>
    readonly status: FieldRef<"ActionPodExecution", 'ActionPodExecutionStatus'>
    readonly startedAt: FieldRef<"ActionPodExecution", 'DateTime'>
    readonly finishedAt: FieldRef<"ActionPodExecution", 'DateTime'>
    readonly runtimeInMs: FieldRef<"ActionPodExecution", 'Int'>
    readonly provider: FieldRef<"ActionPodExecution", 'LLMProvider'>
    readonly modelId: FieldRef<"ActionPodExecution", 'String'>
    readonly modelName: FieldRef<"ActionPodExecution", 'String'>
    readonly providerMetadata: FieldRef<"ActionPodExecution", 'Json'>
    readonly requestMetadata: FieldRef<"ActionPodExecution", 'Json'>
    readonly responseMetadata: FieldRef<"ActionPodExecution", 'Json'>
    readonly errorMessage: FieldRef<"ActionPodExecution", 'String'>
    readonly errorCode: FieldRef<"ActionPodExecution", 'String'>
    readonly inputTokens: FieldRef<"ActionPodExecution", 'Int'>
    readonly outputTokens: FieldRef<"ActionPodExecution", 'Int'>
    readonly reasoningTokens: FieldRef<"ActionPodExecution", 'Int'>
    readonly creditsConsumed: FieldRef<"ActionPodExecution", 'Int'>
    readonly costInUsd: FieldRef<"ActionPodExecution", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ActionPodExecution findUnique
   */
  export type ActionPodExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ActionPodExecution to fetch.
     */
    where: ActionPodExecutionWhereUniqueInput
  }

  /**
   * ActionPodExecution findUniqueOrThrow
   */
  export type ActionPodExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ActionPodExecution to fetch.
     */
    where: ActionPodExecutionWhereUniqueInput
  }

  /**
   * ActionPodExecution findFirst
   */
  export type ActionPodExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ActionPodExecution to fetch.
     */
    where?: ActionPodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPodExecutions to fetch.
     */
    orderBy?: ActionPodExecutionOrderByWithRelationInput | ActionPodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionPodExecutions.
     */
    cursor?: ActionPodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPodExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionPodExecutions.
     */
    distinct?: ActionPodExecutionScalarFieldEnum | ActionPodExecutionScalarFieldEnum[]
  }

  /**
   * ActionPodExecution findFirstOrThrow
   */
  export type ActionPodExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ActionPodExecution to fetch.
     */
    where?: ActionPodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPodExecutions to fetch.
     */
    orderBy?: ActionPodExecutionOrderByWithRelationInput | ActionPodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionPodExecutions.
     */
    cursor?: ActionPodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPodExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionPodExecutions.
     */
    distinct?: ActionPodExecutionScalarFieldEnum | ActionPodExecutionScalarFieldEnum[]
  }

  /**
   * ActionPodExecution findMany
   */
  export type ActionPodExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ActionPodExecutions to fetch.
     */
    where?: ActionPodExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPodExecutions to fetch.
     */
    orderBy?: ActionPodExecutionOrderByWithRelationInput | ActionPodExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionPodExecutions.
     */
    cursor?: ActionPodExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPodExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPodExecutions.
     */
    skip?: number
    distinct?: ActionPodExecutionScalarFieldEnum | ActionPodExecutionScalarFieldEnum[]
  }

  /**
   * ActionPodExecution create
   */
  export type ActionPodExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionPodExecution.
     */
    data: XOR<ActionPodExecutionCreateInput, ActionPodExecutionUncheckedCreateInput>
  }

  /**
   * ActionPodExecution createMany
   */
  export type ActionPodExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionPodExecutions.
     */
    data: ActionPodExecutionCreateManyInput | ActionPodExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionPodExecution createManyAndReturn
   */
  export type ActionPodExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many ActionPodExecutions.
     */
    data: ActionPodExecutionCreateManyInput | ActionPodExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionPodExecution update
   */
  export type ActionPodExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionPodExecution.
     */
    data: XOR<ActionPodExecutionUpdateInput, ActionPodExecutionUncheckedUpdateInput>
    /**
     * Choose, which ActionPodExecution to update.
     */
    where: ActionPodExecutionWhereUniqueInput
  }

  /**
   * ActionPodExecution updateMany
   */
  export type ActionPodExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionPodExecutions.
     */
    data: XOR<ActionPodExecutionUpdateManyMutationInput, ActionPodExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ActionPodExecutions to update
     */
    where?: ActionPodExecutionWhereInput
    /**
     * Limit how many ActionPodExecutions to update.
     */
    limit?: number
  }

  /**
   * ActionPodExecution updateManyAndReturn
   */
  export type ActionPodExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * The data used to update ActionPodExecutions.
     */
    data: XOR<ActionPodExecutionUpdateManyMutationInput, ActionPodExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ActionPodExecutions to update
     */
    where?: ActionPodExecutionWhereInput
    /**
     * Limit how many ActionPodExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionPodExecution upsert
   */
  export type ActionPodExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionPodExecution to update in case it exists.
     */
    where: ActionPodExecutionWhereUniqueInput
    /**
     * In case the ActionPodExecution found by the `where` argument doesn't exist, create a new ActionPodExecution with this data.
     */
    create: XOR<ActionPodExecutionCreateInput, ActionPodExecutionUncheckedCreateInput>
    /**
     * In case the ActionPodExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionPodExecutionUpdateInput, ActionPodExecutionUncheckedUpdateInput>
  }

  /**
   * ActionPodExecution delete
   */
  export type ActionPodExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
    /**
     * Filter which ActionPodExecution to delete.
     */
    where: ActionPodExecutionWhereUniqueInput
  }

  /**
   * ActionPodExecution deleteMany
   */
  export type ActionPodExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionPodExecutions to delete
     */
    where?: ActionPodExecutionWhereInput
    /**
     * Limit how many ActionPodExecutions to delete.
     */
    limit?: number
  }

  /**
   * ActionPodExecution without action
   */
  export type ActionPodExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPodExecution
     */
    select?: ActionPodExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPodExecution
     */
    omit?: ActionPodExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodExecutionInclude<ExtArgs> | null
  }


  /**
   * Model PodUsageLog
   */

  export type AggregatePodUsageLog = {
    _count: PodUsageLogCountAggregateOutputType | null
    _avg: PodUsageLogAvgAggregateOutputType | null
    _sum: PodUsageLogSumAggregateOutputType | null
    _min: PodUsageLogMinAggregateOutputType | null
    _max: PodUsageLogMaxAggregateOutputType | null
  }

  export type PodUsageLogAvgAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
  }

  export type PodUsageLogSumAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
  }

  export type PodUsageLogMinAggregateOutputType = {
    id: string | null
    podId: string | null
    executionId: string | null
    canvasId: string | null
    workspaceId: string | null
    subscriptionId: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
    executedAt: Date | null
  }

  export type PodUsageLogMaxAggregateOutputType = {
    id: string | null
    podId: string | null
    executionId: string | null
    canvasId: string | null
    workspaceId: string | null
    subscriptionId: string | null
    provider: $Enums.LLMProvider | null
    modelId: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    reasoningTokens: number | null
    creditsConsumed: number | null
    runtimeInMs: number | null
    inputTokenCost: Decimal | null
    outputTokenCost: Decimal | null
    reasoningTokenCost: Decimal | null
    totalCostInUsd: Decimal | null
    executedAt: Date | null
  }

  export type PodUsageLogCountAggregateOutputType = {
    id: number
    podId: number
    executionId: number
    canvasId: number
    workspaceId: number
    subscriptionId: number
    provider: number
    modelId: number
    modelName: number
    providerMetadata: number
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    runtimeInMs: number
    inputTokenCost: number
    outputTokenCost: number
    reasoningTokenCost: number
    totalCostInUsd: number
    executedAt: number
    _all: number
  }


  export type PodUsageLogAvgAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
  }

  export type PodUsageLogSumAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
  }

  export type PodUsageLogMinAggregateInputType = {
    id?: true
    podId?: true
    executionId?: true
    canvasId?: true
    workspaceId?: true
    subscriptionId?: true
    provider?: true
    modelId?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
    executedAt?: true
  }

  export type PodUsageLogMaxAggregateInputType = {
    id?: true
    podId?: true
    executionId?: true
    canvasId?: true
    workspaceId?: true
    subscriptionId?: true
    provider?: true
    modelId?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
    executedAt?: true
  }

  export type PodUsageLogCountAggregateInputType = {
    id?: true
    podId?: true
    executionId?: true
    canvasId?: true
    workspaceId?: true
    subscriptionId?: true
    provider?: true
    modelId?: true
    modelName?: true
    providerMetadata?: true
    inputTokens?: true
    outputTokens?: true
    reasoningTokens?: true
    creditsConsumed?: true
    runtimeInMs?: true
    inputTokenCost?: true
    outputTokenCost?: true
    reasoningTokenCost?: true
    totalCostInUsd?: true
    executedAt?: true
    _all?: true
  }

  export type PodUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodUsageLog to aggregate.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodUsageLogs
    **/
    _count?: true | PodUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodUsageLogMaxAggregateInputType
  }

  export type GetPodUsageLogAggregateType<T extends PodUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePodUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodUsageLog[P]>
      : GetScalarType<T[P], AggregatePodUsageLog[P]>
  }




  export type PodUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodUsageLogWhereInput
    orderBy?: PodUsageLogOrderByWithAggregationInput | PodUsageLogOrderByWithAggregationInput[]
    by: PodUsageLogScalarFieldEnum[] | PodUsageLogScalarFieldEnum
    having?: PodUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodUsageLogCountAggregateInputType | true
    _avg?: PodUsageLogAvgAggregateInputType
    _sum?: PodUsageLogSumAggregateInputType
    _min?: PodUsageLogMinAggregateInputType
    _max?: PodUsageLogMaxAggregateInputType
  }

  export type PodUsageLogGroupByOutputType = {
    id: string
    podId: string
    executionId: string
    canvasId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName: string | null
    providerMetadata: JsonValue | null
    inputTokens: number
    outputTokens: number
    reasoningTokens: number
    creditsConsumed: number
    runtimeInMs: number | null
    inputTokenCost: Decimal
    outputTokenCost: Decimal
    reasoningTokenCost: Decimal
    totalCostInUsd: Decimal
    executedAt: Date
    _count: PodUsageLogCountAggregateOutputType | null
    _avg: PodUsageLogAvgAggregateOutputType | null
    _sum: PodUsageLogSumAggregateOutputType | null
    _min: PodUsageLogMinAggregateOutputType | null
    _max: PodUsageLogMaxAggregateOutputType | null
  }

  type GetPodUsageLogGroupByPayload<T extends PodUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], PodUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type PodUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    executionId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podUsageLog"]>

  export type PodUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    executionId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podUsageLog"]>

  export type PodUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    podId?: boolean
    executionId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podUsageLog"]>

  export type PodUsageLogSelectScalar = {
    id?: boolean
    podId?: boolean
    executionId?: boolean
    canvasId?: boolean
    workspaceId?: boolean
    subscriptionId?: boolean
    provider?: boolean
    modelId?: boolean
    modelName?: boolean
    providerMetadata?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    reasoningTokens?: boolean
    creditsConsumed?: boolean
    runtimeInMs?: boolean
    inputTokenCost?: boolean
    outputTokenCost?: boolean
    reasoningTokenCost?: boolean
    totalCostInUsd?: boolean
    executedAt?: boolean
  }

  export type PodUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "podId" | "executionId" | "canvasId" | "workspaceId" | "subscriptionId" | "provider" | "modelId" | "modelName" | "providerMetadata" | "inputTokens" | "outputTokens" | "reasoningTokens" | "creditsConsumed" | "runtimeInMs" | "inputTokenCost" | "outputTokenCost" | "reasoningTokenCost" | "totalCostInUsd" | "executedAt", ExtArgs["result"]["podUsageLog"]>
  export type PodUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PodUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PodUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | ActionPodDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PodUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodUsageLog"
    objects: {
      pod: Prisma.$ActionPodPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      podId: string
      executionId: string
      canvasId: string
      workspaceId: string
      subscriptionId: string
      provider: $Enums.LLMProvider
      modelId: string
      modelName: string | null
      providerMetadata: Prisma.JsonValue | null
      inputTokens: number
      outputTokens: number
      reasoningTokens: number
      creditsConsumed: number
      runtimeInMs: number | null
      inputTokenCost: Prisma.Decimal
      outputTokenCost: Prisma.Decimal
      reasoningTokenCost: Prisma.Decimal
      totalCostInUsd: Prisma.Decimal
      executedAt: Date
    }, ExtArgs["result"]["podUsageLog"]>
    composites: {}
  }

  type PodUsageLogGetPayload<S extends boolean | null | undefined | PodUsageLogDefaultArgs> = $Result.GetResult<Prisma.$PodUsageLogPayload, S>

  type PodUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodUsageLogCountAggregateInputType | true
    }

  export interface PodUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodUsageLog'], meta: { name: 'PodUsageLog' } }
    /**
     * Find zero or one PodUsageLog that matches the filter.
     * @param {PodUsageLogFindUniqueArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodUsageLogFindUniqueArgs>(args: SelectSubset<T, PodUsageLogFindUniqueArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodUsageLogFindUniqueOrThrowArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PodUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogFindFirstArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodUsageLogFindFirstArgs>(args?: SelectSubset<T, PodUsageLogFindFirstArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogFindFirstOrThrowArgs} args - Arguments to find a PodUsageLog
     * @example
     * // Get one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PodUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodUsageLogs
     * const podUsageLogs = await prisma.podUsageLog.findMany()
     * 
     * // Get first 10 PodUsageLogs
     * const podUsageLogs = await prisma.podUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const podUsageLogWithIdOnly = await prisma.podUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PodUsageLogFindManyArgs>(args?: SelectSubset<T, PodUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodUsageLog.
     * @param {PodUsageLogCreateArgs} args - Arguments to create a PodUsageLog.
     * @example
     * // Create one PodUsageLog
     * const PodUsageLog = await prisma.podUsageLog.create({
     *   data: {
     *     // ... data to create a PodUsageLog
     *   }
     * })
     * 
     */
    create<T extends PodUsageLogCreateArgs>(args: SelectSubset<T, PodUsageLogCreateArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodUsageLogs.
     * @param {PodUsageLogCreateManyArgs} args - Arguments to create many PodUsageLogs.
     * @example
     * // Create many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodUsageLogCreateManyArgs>(args?: SelectSubset<T, PodUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodUsageLogs and returns the data saved in the database.
     * @param {PodUsageLogCreateManyAndReturnArgs} args - Arguments to create many PodUsageLogs.
     * @example
     * // Create many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodUsageLogs and only return the `id`
     * const podUsageLogWithIdOnly = await prisma.podUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PodUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodUsageLog.
     * @param {PodUsageLogDeleteArgs} args - Arguments to delete one PodUsageLog.
     * @example
     * // Delete one PodUsageLog
     * const PodUsageLog = await prisma.podUsageLog.delete({
     *   where: {
     *     // ... filter to delete one PodUsageLog
     *   }
     * })
     * 
     */
    delete<T extends PodUsageLogDeleteArgs>(args: SelectSubset<T, PodUsageLogDeleteArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodUsageLog.
     * @param {PodUsageLogUpdateArgs} args - Arguments to update one PodUsageLog.
     * @example
     * // Update one PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodUsageLogUpdateArgs>(args: SelectSubset<T, PodUsageLogUpdateArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodUsageLogs.
     * @param {PodUsageLogDeleteManyArgs} args - Arguments to filter PodUsageLogs to delete.
     * @example
     * // Delete a few PodUsageLogs
     * const { count } = await prisma.podUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodUsageLogDeleteManyArgs>(args?: SelectSubset<T, PodUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodUsageLogUpdateManyArgs>(args: SelectSubset<T, PodUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodUsageLogs and returns the data updated in the database.
     * @param {PodUsageLogUpdateManyAndReturnArgs} args - Arguments to update many PodUsageLogs.
     * @example
     * // Update many PodUsageLogs
     * const podUsageLog = await prisma.podUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodUsageLogs and only return the `id`
     * const podUsageLogWithIdOnly = await prisma.podUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PodUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodUsageLog.
     * @param {PodUsageLogUpsertArgs} args - Arguments to update or create a PodUsageLog.
     * @example
     * // Update or create a PodUsageLog
     * const podUsageLog = await prisma.podUsageLog.upsert({
     *   create: {
     *     // ... data to create a PodUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends PodUsageLogUpsertArgs>(args: SelectSubset<T, PodUsageLogUpsertArgs<ExtArgs>>): Prisma__PodUsageLogClient<$Result.GetResult<Prisma.$PodUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogCountArgs} args - Arguments to filter PodUsageLogs to count.
     * @example
     * // Count the number of PodUsageLogs
     * const count = await prisma.podUsageLog.count({
     *   where: {
     *     // ... the filter for the PodUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends PodUsageLogCountArgs>(
      args?: Subset<T, PodUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodUsageLogAggregateArgs>(args: Subset<T, PodUsageLogAggregateArgs>): Prisma.PrismaPromise<GetPodUsageLogAggregateType<T>>

    /**
     * Group by PodUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: PodUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodUsageLog model
   */
  readonly fields: PodUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod<T extends ActionPodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionPodDefaultArgs<ExtArgs>>): Prisma__ActionPodClient<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodUsageLog model
   */
  interface PodUsageLogFieldRefs {
    readonly id: FieldRef<"PodUsageLog", 'String'>
    readonly podId: FieldRef<"PodUsageLog", 'String'>
    readonly executionId: FieldRef<"PodUsageLog", 'String'>
    readonly canvasId: FieldRef<"PodUsageLog", 'String'>
    readonly workspaceId: FieldRef<"PodUsageLog", 'String'>
    readonly subscriptionId: FieldRef<"PodUsageLog", 'String'>
    readonly provider: FieldRef<"PodUsageLog", 'LLMProvider'>
    readonly modelId: FieldRef<"PodUsageLog", 'String'>
    readonly modelName: FieldRef<"PodUsageLog", 'String'>
    readonly providerMetadata: FieldRef<"PodUsageLog", 'Json'>
    readonly inputTokens: FieldRef<"PodUsageLog", 'Int'>
    readonly outputTokens: FieldRef<"PodUsageLog", 'Int'>
    readonly reasoningTokens: FieldRef<"PodUsageLog", 'Int'>
    readonly creditsConsumed: FieldRef<"PodUsageLog", 'Int'>
    readonly runtimeInMs: FieldRef<"PodUsageLog", 'Int'>
    readonly inputTokenCost: FieldRef<"PodUsageLog", 'Decimal'>
    readonly outputTokenCost: FieldRef<"PodUsageLog", 'Decimal'>
    readonly reasoningTokenCost: FieldRef<"PodUsageLog", 'Decimal'>
    readonly totalCostInUsd: FieldRef<"PodUsageLog", 'Decimal'>
    readonly executedAt: FieldRef<"PodUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PodUsageLog findUnique
   */
  export type PodUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog findUniqueOrThrow
   */
  export type PodUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog findFirst
   */
  export type PodUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodUsageLogs.
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodUsageLogs.
     */
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * PodUsageLog findFirstOrThrow
   */
  export type PodUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLog to fetch.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodUsageLogs.
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodUsageLogs.
     */
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * PodUsageLog findMany
   */
  export type PodUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which PodUsageLogs to fetch.
     */
    where?: PodUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodUsageLogs to fetch.
     */
    orderBy?: PodUsageLogOrderByWithRelationInput | PodUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodUsageLogs.
     */
    cursor?: PodUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodUsageLogs.
     */
    skip?: number
    distinct?: PodUsageLogScalarFieldEnum | PodUsageLogScalarFieldEnum[]
  }

  /**
   * PodUsageLog create
   */
  export type PodUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PodUsageLog.
     */
    data: XOR<PodUsageLogCreateInput, PodUsageLogUncheckedCreateInput>
  }

  /**
   * PodUsageLog createMany
   */
  export type PodUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodUsageLogs.
     */
    data: PodUsageLogCreateManyInput | PodUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodUsageLog createManyAndReturn
   */
  export type PodUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many PodUsageLogs.
     */
    data: PodUsageLogCreateManyInput | PodUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodUsageLog update
   */
  export type PodUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PodUsageLog.
     */
    data: XOR<PodUsageLogUpdateInput, PodUsageLogUncheckedUpdateInput>
    /**
     * Choose, which PodUsageLog to update.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog updateMany
   */
  export type PodUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodUsageLogs.
     */
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which PodUsageLogs to update
     */
    where?: PodUsageLogWhereInput
    /**
     * Limit how many PodUsageLogs to update.
     */
    limit?: number
  }

  /**
   * PodUsageLog updateManyAndReturn
   */
  export type PodUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update PodUsageLogs.
     */
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which PodUsageLogs to update
     */
    where?: PodUsageLogWhereInput
    /**
     * Limit how many PodUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodUsageLog upsert
   */
  export type PodUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PodUsageLog to update in case it exists.
     */
    where: PodUsageLogWhereUniqueInput
    /**
     * In case the PodUsageLog found by the `where` argument doesn't exist, create a new PodUsageLog with this data.
     */
    create: XOR<PodUsageLogCreateInput, PodUsageLogUncheckedCreateInput>
    /**
     * In case the PodUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodUsageLogUpdateInput, PodUsageLogUncheckedUpdateInput>
  }

  /**
   * PodUsageLog delete
   */
  export type PodUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
    /**
     * Filter which PodUsageLog to delete.
     */
    where: PodUsageLogWhereUniqueInput
  }

  /**
   * PodUsageLog deleteMany
   */
  export type PodUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodUsageLogs to delete
     */
    where?: PodUsageLogWhereInput
    /**
     * Limit how many PodUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * PodUsageLog without action
   */
  export type PodUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodUsageLog
     */
    select?: PodUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodUsageLog
     */
    omit?: PodUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ContextModule
   */

  export type AggregateContextModule = {
    _count: ContextModuleCountAggregateOutputType | null
    _avg: ContextModuleAvgAggregateOutputType | null
    _sum: ContextModuleSumAggregateOutputType | null
    _min: ContextModuleMinAggregateOutputType | null
    _max: ContextModuleMaxAggregateOutputType | null
  }

  export type ContextModuleAvgAggregateOutputType = {
    version: number | null
  }

  export type ContextModuleSumAggregateOutputType = {
    version: number | null
  }

  export type ContextModuleMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    originalCanvasId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextModuleMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    originalCanvasId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextModuleCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    definitionJson: number
    originalCanvasId: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContextModuleAvgAggregateInputType = {
    version?: true
  }

  export type ContextModuleSumAggregateInputType = {
    version?: true
  }

  export type ContextModuleMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    originalCanvasId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextModuleMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    originalCanvasId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextModuleCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    definitionJson?: true
    originalCanvasId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContextModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextModule to aggregate.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextModules
    **/
    _count?: true | ContextModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextModuleMaxAggregateInputType
  }

  export type GetContextModuleAggregateType<T extends ContextModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateContextModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextModule[P]>
      : GetScalarType<T[P], AggregateContextModule[P]>
  }




  export type ContextModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextModuleWhereInput
    orderBy?: ContextModuleOrderByWithAggregationInput | ContextModuleOrderByWithAggregationInput[]
    by: ContextModuleScalarFieldEnum[] | ContextModuleScalarFieldEnum
    having?: ContextModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextModuleCountAggregateInputType | true
    _avg?: ContextModuleAvgAggregateInputType
    _sum?: ContextModuleSumAggregateInputType
    _min?: ContextModuleMinAggregateInputType
    _max?: ContextModuleMaxAggregateInputType
  }

  export type ContextModuleGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    definitionJson: JsonValue
    originalCanvasId: string | null
    version: number
    createdAt: Date
    updatedAt: Date
    _count: ContextModuleCountAggregateOutputType | null
    _avg: ContextModuleAvgAggregateOutputType | null
    _sum: ContextModuleSumAggregateOutputType | null
    _min: ContextModuleMinAggregateOutputType | null
    _max: ContextModuleMaxAggregateOutputType | null
  }

  type GetContextModuleGroupByPayload<T extends ContextModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ContextModuleGroupByOutputType[P]>
        }
      >
    >


  export type ContextModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalCanvasId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalCanvas?: boolean | ContextModule$originalCanvasArgs<ExtArgs>
  }, ExtArgs["result"]["contextModule"]>

  export type ContextModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalCanvasId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalCanvas?: boolean | ContextModule$originalCanvasArgs<ExtArgs>
  }, ExtArgs["result"]["contextModule"]>

  export type ContextModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalCanvasId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalCanvas?: boolean | ContextModule$originalCanvasArgs<ExtArgs>
  }, ExtArgs["result"]["contextModule"]>

  export type ContextModuleSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    definitionJson?: boolean
    originalCanvasId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContextModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "definitionJson" | "originalCanvasId" | "version" | "createdAt" | "updatedAt", ExtArgs["result"]["contextModule"]>
  export type ContextModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalCanvas?: boolean | ContextModule$originalCanvasArgs<ExtArgs>
  }
  export type ContextModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalCanvas?: boolean | ContextModule$originalCanvasArgs<ExtArgs>
  }
  export type ContextModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    originalCanvas?: boolean | ContextModule$originalCanvasArgs<ExtArgs>
  }

  export type $ContextModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContextModule"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      originalCanvas: Prisma.$CanvasPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      definitionJson: Prisma.JsonValue
      originalCanvasId: string | null
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contextModule"]>
    composites: {}
  }

  type ContextModuleGetPayload<S extends boolean | null | undefined | ContextModuleDefaultArgs> = $Result.GetResult<Prisma.$ContextModulePayload, S>

  type ContextModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContextModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContextModuleCountAggregateInputType | true
    }

  export interface ContextModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextModule'], meta: { name: 'ContextModule' } }
    /**
     * Find zero or one ContextModule that matches the filter.
     * @param {ContextModuleFindUniqueArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContextModuleFindUniqueArgs>(args: SelectSubset<T, ContextModuleFindUniqueArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContextModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContextModuleFindUniqueOrThrowArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContextModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ContextModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContextModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleFindFirstArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContextModuleFindFirstArgs>(args?: SelectSubset<T, ContextModuleFindFirstArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContextModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleFindFirstOrThrowArgs} args - Arguments to find a ContextModule
     * @example
     * // Get one ContextModule
     * const contextModule = await prisma.contextModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContextModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ContextModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContextModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextModules
     * const contextModules = await prisma.contextModule.findMany()
     * 
     * // Get first 10 ContextModules
     * const contextModules = await prisma.contextModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextModuleWithIdOnly = await prisma.contextModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContextModuleFindManyArgs>(args?: SelectSubset<T, ContextModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContextModule.
     * @param {ContextModuleCreateArgs} args - Arguments to create a ContextModule.
     * @example
     * // Create one ContextModule
     * const ContextModule = await prisma.contextModule.create({
     *   data: {
     *     // ... data to create a ContextModule
     *   }
     * })
     * 
     */
    create<T extends ContextModuleCreateArgs>(args: SelectSubset<T, ContextModuleCreateArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContextModules.
     * @param {ContextModuleCreateManyArgs} args - Arguments to create many ContextModules.
     * @example
     * // Create many ContextModules
     * const contextModule = await prisma.contextModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContextModuleCreateManyArgs>(args?: SelectSubset<T, ContextModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContextModules and returns the data saved in the database.
     * @param {ContextModuleCreateManyAndReturnArgs} args - Arguments to create many ContextModules.
     * @example
     * // Create many ContextModules
     * const contextModule = await prisma.contextModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContextModules and only return the `id`
     * const contextModuleWithIdOnly = await prisma.contextModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContextModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ContextModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContextModule.
     * @param {ContextModuleDeleteArgs} args - Arguments to delete one ContextModule.
     * @example
     * // Delete one ContextModule
     * const ContextModule = await prisma.contextModule.delete({
     *   where: {
     *     // ... filter to delete one ContextModule
     *   }
     * })
     * 
     */
    delete<T extends ContextModuleDeleteArgs>(args: SelectSubset<T, ContextModuleDeleteArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContextModule.
     * @param {ContextModuleUpdateArgs} args - Arguments to update one ContextModule.
     * @example
     * // Update one ContextModule
     * const contextModule = await prisma.contextModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContextModuleUpdateArgs>(args: SelectSubset<T, ContextModuleUpdateArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContextModules.
     * @param {ContextModuleDeleteManyArgs} args - Arguments to filter ContextModules to delete.
     * @example
     * // Delete a few ContextModules
     * const { count } = await prisma.contextModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContextModuleDeleteManyArgs>(args?: SelectSubset<T, ContextModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextModules
     * const contextModule = await prisma.contextModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContextModuleUpdateManyArgs>(args: SelectSubset<T, ContextModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextModules and returns the data updated in the database.
     * @param {ContextModuleUpdateManyAndReturnArgs} args - Arguments to update many ContextModules.
     * @example
     * // Update many ContextModules
     * const contextModule = await prisma.contextModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContextModules and only return the `id`
     * const contextModuleWithIdOnly = await prisma.contextModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContextModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ContextModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContextModule.
     * @param {ContextModuleUpsertArgs} args - Arguments to update or create a ContextModule.
     * @example
     * // Update or create a ContextModule
     * const contextModule = await prisma.contextModule.upsert({
     *   create: {
     *     // ... data to create a ContextModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextModule we want to update
     *   }
     * })
     */
    upsert<T extends ContextModuleUpsertArgs>(args: SelectSubset<T, ContextModuleUpsertArgs<ExtArgs>>): Prisma__ContextModuleClient<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContextModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleCountArgs} args - Arguments to filter ContextModules to count.
     * @example
     * // Count the number of ContextModules
     * const count = await prisma.contextModule.count({
     *   where: {
     *     // ... the filter for the ContextModules we want to count
     *   }
     * })
    **/
    count<T extends ContextModuleCountArgs>(
      args?: Subset<T, ContextModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextModuleAggregateArgs>(args: Subset<T, ContextModuleAggregateArgs>): Prisma.PrismaPromise<GetContextModuleAggregateType<T>>

    /**
     * Group by ContextModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextModuleGroupByArgs['orderBy'] }
        : { orderBy?: ContextModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextModule model
   */
  readonly fields: ContextModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContextModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    originalCanvas<T extends ContextModule$originalCanvasArgs<ExtArgs> = {}>(args?: Subset<T, ContextModule$originalCanvasArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContextModule model
   */
  interface ContextModuleFieldRefs {
    readonly id: FieldRef<"ContextModule", 'String'>
    readonly workspaceId: FieldRef<"ContextModule", 'String'>
    readonly name: FieldRef<"ContextModule", 'String'>
    readonly description: FieldRef<"ContextModule", 'String'>
    readonly definitionJson: FieldRef<"ContextModule", 'Json'>
    readonly originalCanvasId: FieldRef<"ContextModule", 'String'>
    readonly version: FieldRef<"ContextModule", 'Int'>
    readonly createdAt: FieldRef<"ContextModule", 'DateTime'>
    readonly updatedAt: FieldRef<"ContextModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContextModule findUnique
   */
  export type ContextModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule findUniqueOrThrow
   */
  export type ContextModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule findFirst
   */
  export type ContextModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextModules.
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextModules.
     */
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * ContextModule findFirstOrThrow
   */
  export type ContextModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModule to fetch.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextModules.
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextModules.
     */
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * ContextModule findMany
   */
  export type ContextModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter, which ContextModules to fetch.
     */
    where?: ContextModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextModules to fetch.
     */
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextModules.
     */
    cursor?: ContextModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextModules.
     */
    skip?: number
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * ContextModule create
   */
  export type ContextModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextModule.
     */
    data: XOR<ContextModuleCreateInput, ContextModuleUncheckedCreateInput>
  }

  /**
   * ContextModule createMany
   */
  export type ContextModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextModules.
     */
    data: ContextModuleCreateManyInput | ContextModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContextModule createManyAndReturn
   */
  export type ContextModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * The data used to create many ContextModules.
     */
    data: ContextModuleCreateManyInput | ContextModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContextModule update
   */
  export type ContextModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextModule.
     */
    data: XOR<ContextModuleUpdateInput, ContextModuleUncheckedUpdateInput>
    /**
     * Choose, which ContextModule to update.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule updateMany
   */
  export type ContextModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextModules.
     */
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyInput>
    /**
     * Filter which ContextModules to update
     */
    where?: ContextModuleWhereInput
    /**
     * Limit how many ContextModules to update.
     */
    limit?: number
  }

  /**
   * ContextModule updateManyAndReturn
   */
  export type ContextModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * The data used to update ContextModules.
     */
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyInput>
    /**
     * Filter which ContextModules to update
     */
    where?: ContextModuleWhereInput
    /**
     * Limit how many ContextModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContextModule upsert
   */
  export type ContextModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextModule to update in case it exists.
     */
    where: ContextModuleWhereUniqueInput
    /**
     * In case the ContextModule found by the `where` argument doesn't exist, create a new ContextModule with this data.
     */
    create: XOR<ContextModuleCreateInput, ContextModuleUncheckedCreateInput>
    /**
     * In case the ContextModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextModuleUpdateInput, ContextModuleUncheckedUpdateInput>
  }

  /**
   * ContextModule delete
   */
  export type ContextModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    /**
     * Filter which ContextModule to delete.
     */
    where: ContextModuleWhereUniqueInput
  }

  /**
   * ContextModule deleteMany
   */
  export type ContextModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextModules to delete
     */
    where?: ContextModuleWhereInput
    /**
     * Limit how many ContextModules to delete.
     */
    limit?: number
  }

  /**
   * ContextModule.originalCanvas
   */
  export type ContextModule$originalCanvasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    where?: CanvasWhereInput
  }

  /**
   * ContextModule without action
   */
  export type ContextModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    hash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    hash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    image: number
    hash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    hash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    hash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    hash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    image: string | null
    hash: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    canvasCollaborations?: boolean | User$canvasCollaborationsArgs<ExtArgs>
    sentWorkspaceInvites?: boolean | User$sentWorkspaceInvitesArgs<ExtArgs>
    receivedWorkspaceInvites?: boolean | User$receivedWorkspaceInvitesArgs<ExtArgs>
    sentCanvasInvites?: boolean | User$sentCanvasInvitesArgs<ExtArgs>
    receivedCanvasInvites?: boolean | User$receivedCanvasInvitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    hash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "image" | "hash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    canvasCollaborations?: boolean | User$canvasCollaborationsArgs<ExtArgs>
    sentWorkspaceInvites?: boolean | User$sentWorkspaceInvitesArgs<ExtArgs>
    receivedWorkspaceInvites?: boolean | User$receivedWorkspaceInvitesArgs<ExtArgs>
    sentCanvasInvites?: boolean | User$sentCanvasInvitesArgs<ExtArgs>
    receivedCanvasInvites?: boolean | User$receivedCanvasInvitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      workspaces: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      canvasCollaborations: Prisma.$CanvasCollaboratorPayload<ExtArgs>[]
      sentWorkspaceInvites: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      receivedWorkspaceInvites: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      sentCanvasInvites: Prisma.$CanvasInvitationPayload<ExtArgs>[]
      receivedCanvasInvites: Prisma.$CanvasInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      image: string | null
      hash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    canvasCollaborations<T extends User$canvasCollaborationsArgs<ExtArgs> = {}>(args?: Subset<T, User$canvasCollaborationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentWorkspaceInvites<T extends User$sentWorkspaceInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentWorkspaceInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedWorkspaceInvites<T extends User$receivedWorkspaceInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedWorkspaceInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentCanvasInvites<T extends User$sentCanvasInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentCanvasInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedCanvasInvites<T extends User$receivedCanvasInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedCanvasInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly hash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.canvasCollaborations
   */
  export type User$canvasCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCollaborator
     */
    select?: CanvasCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasCollaborator
     */
    omit?: CanvasCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasCollaboratorInclude<ExtArgs> | null
    where?: CanvasCollaboratorWhereInput
    orderBy?: CanvasCollaboratorOrderByWithRelationInput | CanvasCollaboratorOrderByWithRelationInput[]
    cursor?: CanvasCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasCollaboratorScalarFieldEnum | CanvasCollaboratorScalarFieldEnum[]
  }

  /**
   * User.sentWorkspaceInvites
   */
  export type User$sentWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * User.receivedWorkspaceInvites
   */
  export type User$receivedWorkspaceInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * User.sentCanvasInvites
   */
  export type User$sentCanvasInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    where?: CanvasInvitationWhereInput
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    cursor?: CanvasInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasInvitationScalarFieldEnum | CanvasInvitationScalarFieldEnum[]
  }

  /**
   * User.receivedCanvasInvites
   */
  export type User$receivedCanvasInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasInvitation
     */
    select?: CanvasInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasInvitation
     */
    omit?: CanvasInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInvitationInclude<ExtArgs> | null
    where?: CanvasInvitationWhereInput
    orderBy?: CanvasInvitationOrderByWithRelationInput | CanvasInvitationOrderByWithRelationInput[]
    cursor?: CanvasInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasInvitationScalarFieldEnum | CanvasInvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    deviceName: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    deviceName: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    deviceName: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    deviceName?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    deviceName?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    deviceName?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    deviceName: string
    userId: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    deviceName?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "deviceName" | "userId" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      deviceName: string
      userId: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly deviceName: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.AuthProvider | null
    providerAccountId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.AuthProvider | null
    providerAccountId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerAccountId: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerAccountId" | "accessToken" | "refreshToken" | "expiresAt" | "createdAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: $Enums.AuthProvider
      providerAccountId: string
      accessToken: string | null
      refreshToken: string | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'AuthProvider'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.WorkspaceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.WorkspaceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    type: $Enums.WorkspaceType
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Workspace$membersArgs<ExtArgs>
    canvases?: boolean | Workspace$canvasesArgs<ExtArgs>
    documents?: boolean | Workspace$documentsArgs<ExtArgs>
    subscription?: boolean | Workspace$subscriptionArgs<ExtArgs>
    contextModules?: boolean | Workspace$contextModulesArgs<ExtArgs>
    shareLinks?: boolean | Workspace$shareLinksArgs<ExtArgs>
    apiKeys?: boolean | Workspace$apiKeysArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Workspace$membersArgs<ExtArgs>
    canvases?: boolean | Workspace$canvasesArgs<ExtArgs>
    documents?: boolean | Workspace$documentsArgs<ExtArgs>
    subscription?: boolean | Workspace$subscriptionArgs<ExtArgs>
    contextModules?: boolean | Workspace$contextModulesArgs<ExtArgs>
    shareLinks?: boolean | Workspace$shareLinksArgs<ExtArgs>
    apiKeys?: boolean | Workspace$apiKeysArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      members: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      canvases: Prisma.$CanvasPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      contextModules: Prisma.$ContextModulePayload<ExtArgs>[]
      shareLinks: Prisma.$ShareLinkPayload<ExtArgs>[]
      apiKeys: Prisma.$ProviderAPIKeyPayload<ExtArgs>[]
      invitations: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.WorkspaceType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Workspace$membersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    canvases<T extends Workspace$canvasesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$canvasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Workspace$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Workspace$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contextModules<T extends Workspace$contextModulesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$contextModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareLinks<T extends Workspace$shareLinksArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$shareLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends Workspace$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Workspace$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly type: FieldRef<"Workspace", 'WorkspaceType'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.members
   */
  export type Workspace$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * Workspace.canvases
   */
  export type Workspace$canvasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    where?: CanvasWhereInput
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    cursor?: CanvasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Workspace.documents
   */
  export type Workspace$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Workspace.subscription
   */
  export type Workspace$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Workspace.contextModules
   */
  export type Workspace$contextModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextModule
     */
    select?: ContextModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContextModule
     */
    omit?: ContextModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContextModuleInclude<ExtArgs> | null
    where?: ContextModuleWhereInput
    orderBy?: ContextModuleOrderByWithRelationInput | ContextModuleOrderByWithRelationInput[]
    cursor?: ContextModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextModuleScalarFieldEnum | ContextModuleScalarFieldEnum[]
  }

  /**
   * Workspace.shareLinks
   */
  export type Workspace$shareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    cursor?: ShareLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * Workspace.apiKeys
   */
  export type Workspace$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    where?: ProviderAPIKeyWhereInput
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    cursor?: ProviderAPIKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * Workspace.invitations
   */
  export type Workspace$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUser
   */

  export type AggregateWorkspaceUser = {
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  export type WorkspaceUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: $Enums.WorkspaceRole | null
    canCreateCanvas: boolean | null
    canDeleteCanvas: boolean | null
    canManageBilling: boolean | null
    canInviteMembers: boolean | null
    canManageMembers: boolean | null
    canManageApiKeys: boolean | null
    joinedAt: Date | null
    invitedBy: string | null
  }

  export type WorkspaceUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: $Enums.WorkspaceRole | null
    canCreateCanvas: boolean | null
    canDeleteCanvas: boolean | null
    canManageBilling: boolean | null
    canInviteMembers: boolean | null
    canManageMembers: boolean | null
    canManageApiKeys: boolean | null
    joinedAt: Date | null
    invitedBy: string | null
  }

  export type WorkspaceUserCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    role: number
    canCreateCanvas: number
    canDeleteCanvas: number
    canManageBilling: number
    canInviteMembers: number
    canManageMembers: number
    canManageApiKeys: number
    joinedAt: number
    invitedBy: number
    _all: number
  }


  export type WorkspaceUserMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    canCreateCanvas?: true
    canDeleteCanvas?: true
    canManageBilling?: true
    canInviteMembers?: true
    canManageMembers?: true
    canManageApiKeys?: true
    joinedAt?: true
    invitedBy?: true
  }

  export type WorkspaceUserMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    canCreateCanvas?: true
    canDeleteCanvas?: true
    canManageBilling?: true
    canInviteMembers?: true
    canManageMembers?: true
    canManageApiKeys?: true
    joinedAt?: true
    invitedBy?: true
  }

  export type WorkspaceUserCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    canCreateCanvas?: true
    canDeleteCanvas?: true
    canManageBilling?: true
    canInviteMembers?: true
    canManageMembers?: true
    canManageApiKeys?: true
    joinedAt?: true
    invitedBy?: true
    _all?: true
  }

  export type WorkspaceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUser to aggregate.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUsers
    **/
    _count?: true | WorkspaceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type GetWorkspaceUserAggregateType<T extends WorkspaceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUser[P]>
      : GetScalarType<T[P], AggregateWorkspaceUser[P]>
  }




  export type WorkspaceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithAggregationInput | WorkspaceUserOrderByWithAggregationInput[]
    by: WorkspaceUserScalarFieldEnum[] | WorkspaceUserScalarFieldEnum
    having?: WorkspaceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceUserCountAggregateInputType | true
    _min?: WorkspaceUserMinAggregateInputType
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type WorkspaceUserGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    role: $Enums.WorkspaceRole
    canCreateCanvas: boolean
    canDeleteCanvas: boolean
    canManageBilling: boolean
    canInviteMembers: boolean
    canManageMembers: boolean
    canManageApiKeys: boolean
    joinedAt: Date
    invitedBy: string | null
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  type GetWorkspaceUserGroupByPayload<T extends WorkspaceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
  }

  export type WorkspaceUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "workspaceId" | "role" | "canCreateCanvas" | "canDeleteCanvas" | "canManageBilling" | "canInviteMembers" | "canManageMembers" | "canManageApiKeys" | "joinedAt" | "invitedBy", ExtArgs["result"]["workspaceUser"]>
  export type WorkspaceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      role: $Enums.WorkspaceRole
      canCreateCanvas: boolean
      canDeleteCanvas: boolean
      canManageBilling: boolean
      canInviteMembers: boolean
      canManageMembers: boolean
      canManageApiKeys: boolean
      joinedAt: Date
      invitedBy: string | null
    }, ExtArgs["result"]["workspaceUser"]>
    composites: {}
  }

  type WorkspaceUserGetPayload<S extends boolean | null | undefined | WorkspaceUserDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserPayload, S>

  type WorkspaceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceUserCountAggregateInputType | true
    }

  export interface WorkspaceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUser'], meta: { name: 'WorkspaceUser' } }
    /**
     * Find zero or one WorkspaceUser that matches the filter.
     * @param {WorkspaceUserFindUniqueArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceUserFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany()
     * 
     * // Get first 10 WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserFindManyArgs>(args?: SelectSubset<T, WorkspaceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceUser.
     * @param {WorkspaceUserCreateArgs} args - Arguments to create a WorkspaceUser.
     * @example
     * // Create one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.create({
     *   data: {
     *     // ... data to create a WorkspaceUser
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserCreateArgs>(args: SelectSubset<T, WorkspaceUserCreateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceUsers.
     * @param {WorkspaceUserCreateManyArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUsers and returns the data saved in the database.
     * @param {WorkspaceUserCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceUser.
     * @param {WorkspaceUserDeleteArgs} args - Arguments to delete one WorkspaceUser.
     * @example
     * // Delete one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUser
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserDeleteArgs>(args: SelectSubset<T, WorkspaceUserDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceUser.
     * @param {WorkspaceUserUpdateArgs} args - Arguments to update one WorkspaceUser.
     * @example
     * // Update one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserUpdateArgs>(args: SelectSubset<T, WorkspaceUserUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceUsers.
     * @param {WorkspaceUserDeleteManyArgs} args - Arguments to filter WorkspaceUsers to delete.
     * @example
     * // Delete a few WorkspaceUsers
     * const { count } = await prisma.workspaceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers and returns the data updated in the database.
     * @param {WorkspaceUserUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceUsers.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUserUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceUser.
     * @param {WorkspaceUserUpsertArgs} args - Arguments to update or create a WorkspaceUser.
     * @example
     * // Update or create a WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUser we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserUpsertArgs>(args: SelectSubset<T, WorkspaceUserUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserCountArgs} args - Arguments to filter WorkspaceUsers to count.
     * @example
     * // Count the number of WorkspaceUsers
     * const count = await prisma.workspaceUser.count({
     *   where: {
     *     // ... the filter for the WorkspaceUsers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserCountArgs>(
      args?: Subset<T, WorkspaceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserAggregateArgs>(args: Subset<T, WorkspaceUserAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserAggregateType<T>>

    /**
     * Group by WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUser model
   */
  readonly fields: WorkspaceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUser model
   */
  interface WorkspaceUserFieldRefs {
    readonly id: FieldRef<"WorkspaceUser", 'String'>
    readonly userId: FieldRef<"WorkspaceUser", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceUser", 'String'>
    readonly role: FieldRef<"WorkspaceUser", 'WorkspaceRole'>
    readonly canCreateCanvas: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canDeleteCanvas: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canManageBilling: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canInviteMembers: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canManageMembers: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly canManageApiKeys: FieldRef<"WorkspaceUser", 'Boolean'>
    readonly joinedAt: FieldRef<"WorkspaceUser", 'DateTime'>
    readonly invitedBy: FieldRef<"WorkspaceUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUser findUnique
   */
  export type WorkspaceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findUniqueOrThrow
   */
  export type WorkspaceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findFirst
   */
  export type WorkspaceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findFirstOrThrow
   */
  export type WorkspaceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findMany
   */
  export type WorkspaceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUsers to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser create
   */
  export type WorkspaceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUser.
     */
    data: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
  }

  /**
   * WorkspaceUser createMany
   */
  export type WorkspaceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceUser createManyAndReturn
   */
  export type WorkspaceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser update
   */
  export type WorkspaceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUser.
     */
    data: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUser to update.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser updateMany
   */
  export type WorkspaceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to update.
     */
    limit?: number
  }

  /**
   * WorkspaceUser updateManyAndReturn
   */
  export type WorkspaceUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser upsert
   */
  export type WorkspaceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUser to update in case it exists.
     */
    where: WorkspaceUserWhereUniqueInput
    /**
     * In case the WorkspaceUser found by the `where` argument doesn't exist, create a new WorkspaceUser with this data.
     */
    create: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
    /**
     * In case the WorkspaceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
  }

  /**
   * WorkspaceUser delete
   */
  export type WorkspaceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUser to delete.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser deleteMany
   */
  export type WorkspaceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUsers to delete
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceUser without action
   */
  export type WorkspaceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceInvitation
   */

  export type AggregateWorkspaceInvitation = {
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  export type WorkspaceInvitationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: $Enums.WorkspaceRole | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type WorkspaceInvitationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: $Enums.WorkspaceRole | null
    invitedBy: string | null
    invitedUserId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    expiresAt: Date | null
    acceptedAt: Date | null
  }

  export type WorkspaceInvitationCountAggregateOutputType = {
    id: number
    workspaceId: number
    email: number
    role: number
    permissions: number
    invitedBy: number
    invitedUserId: number
    token: number
    status: number
    createdAt: number
    expiresAt: number
    acceptedAt: number
    _all: number
  }


  export type WorkspaceInvitationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type WorkspaceInvitationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
  }

  export type WorkspaceInvitationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    permissions?: true
    invitedBy?: true
    invitedUserId?: true
    token?: true
    status?: true
    createdAt?: true
    expiresAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type WorkspaceInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitation to aggregate.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceInvitations
    **/
    _count?: true | WorkspaceInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type GetWorkspaceInvitationAggregateType<T extends WorkspaceInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
      : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
  }




  export type WorkspaceInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithAggregationInput | WorkspaceInvitationOrderByWithAggregationInput[]
    by: WorkspaceInvitationScalarFieldEnum[] | WorkspaceInvitationScalarFieldEnum
    having?: WorkspaceInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceInvitationCountAggregateInputType | true
    _min?: WorkspaceInvitationMinAggregateInputType
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type WorkspaceInvitationGroupByOutputType = {
    id: string
    workspaceId: string
    email: string
    role: $Enums.WorkspaceRole
    permissions: JsonValue | null
    invitedBy: string
    invitedUserId: string | null
    token: string
    status: $Enums.InvitationStatus
    createdAt: Date
    expiresAt: Date
    acceptedAt: Date | null
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  type GetWorkspaceInvitationGroupByPayload<T extends WorkspaceInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    invitedUserId?: boolean
    token?: boolean
    status?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
  }

  export type WorkspaceInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "email" | "role" | "permissions" | "invitedBy" | "invitedUserId" | "token" | "status" | "createdAt" | "expiresAt" | "acceptedAt", ExtArgs["result"]["workspaceInvitation"]>
  export type WorkspaceInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitedUser?: boolean | WorkspaceInvitation$invitedUserArgs<ExtArgs>
  }

  export type $WorkspaceInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceInvitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      invitedUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      email: string
      role: $Enums.WorkspaceRole
      permissions: Prisma.JsonValue | null
      invitedBy: string
      invitedUserId: string | null
      token: string
      status: $Enums.InvitationStatus
      createdAt: Date
      expiresAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["workspaceInvitation"]>
    composites: {}
  }

  type WorkspaceInvitationGetPayload<S extends boolean | null | undefined | WorkspaceInvitationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceInvitationPayload, S>

  type WorkspaceInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceInvitationCountAggregateInputType | true
    }

  export interface WorkspaceInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceInvitation'], meta: { name: 'WorkspaceInvitation' } }
    /**
     * Find zero or one WorkspaceInvitation that matches the filter.
     * @param {WorkspaceInvitationFindUniqueArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceInvitationFindUniqueArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceInvitationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceInvitationFindFirstArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
     * 
     * // Get first 10 WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceInvitationFindManyArgs>(args?: SelectSubset<T, WorkspaceInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceInvitation.
     * @param {WorkspaceInvitationCreateArgs} args - Arguments to create a WorkspaceInvitation.
     * @example
     * // Create one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.create({
     *   data: {
     *     // ... data to create a WorkspaceInvitation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceInvitationCreateArgs>(args: SelectSubset<T, WorkspaceInvitationCreateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceInvitations.
     * @param {WorkspaceInvitationCreateManyArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceInvitationCreateManyArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceInvitations and returns the data saved in the database.
     * @param {WorkspaceInvitationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceInvitation.
     * @param {WorkspaceInvitationDeleteArgs} args - Arguments to delete one WorkspaceInvitation.
     * @example
     * // Delete one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceInvitation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceInvitationDeleteArgs>(args: SelectSubset<T, WorkspaceInvitationDeleteArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpdateArgs} args - Arguments to update one WorkspaceInvitation.
     * @example
     * // Update one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceInvitationUpdateArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceInvitations.
     * @param {WorkspaceInvitationDeleteManyArgs} args - Arguments to filter WorkspaceInvitations to delete.
     * @example
     * // Delete a few WorkspaceInvitations
     * const { count } = await prisma.workspaceInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceInvitationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceInvitationUpdateManyArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations and returns the data updated in the database.
     * @param {WorkspaceInvitationUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceInvitations.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpsertArgs} args - Arguments to update or create a WorkspaceInvitation.
     * @example
     * // Update or create a WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceInvitation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceInvitationUpsertArgs>(args: SelectSubset<T, WorkspaceInvitationUpsertArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationCountArgs} args - Arguments to filter WorkspaceInvitations to count.
     * @example
     * // Count the number of WorkspaceInvitations
     * const count = await prisma.workspaceInvitation.count({
     *   where: {
     *     // ... the filter for the WorkspaceInvitations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceInvitationCountArgs>(
      args?: Subset<T, WorkspaceInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceInvitationAggregateArgs>(args: Subset<T, WorkspaceInvitationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceInvitationAggregateType<T>>

    /**
     * Group by WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceInvitationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceInvitation model
   */
  readonly fields: WorkspaceInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitedUser<T extends WorkspaceInvitation$invitedUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceInvitation$invitedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceInvitation model
   */
  interface WorkspaceInvitationFieldRefs {
    readonly id: FieldRef<"WorkspaceInvitation", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceInvitation", 'String'>
    readonly email: FieldRef<"WorkspaceInvitation", 'String'>
    readonly role: FieldRef<"WorkspaceInvitation", 'WorkspaceRole'>
    readonly permissions: FieldRef<"WorkspaceInvitation", 'Json'>
    readonly invitedBy: FieldRef<"WorkspaceInvitation", 'String'>
    readonly invitedUserId: FieldRef<"WorkspaceInvitation", 'String'>
    readonly token: FieldRef<"WorkspaceInvitation", 'String'>
    readonly status: FieldRef<"WorkspaceInvitation", 'InvitationStatus'>
    readonly createdAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceInvitation findUnique
   */
  export type WorkspaceInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findUniqueOrThrow
   */
  export type WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findFirst
   */
  export type WorkspaceInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findFirstOrThrow
   */
  export type WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findMany
   */
  export type WorkspaceInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitations to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation create
   */
  export type WorkspaceInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
  }

  /**
   * WorkspaceInvitation createMany
   */
  export type WorkspaceInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceInvitation createManyAndReturn
   */
  export type WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation update
   */
  export type WorkspaceInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceInvitation to update.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation updateMany
   */
  export type WorkspaceInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to update.
     */
    limit?: number
  }

  /**
   * WorkspaceInvitation updateManyAndReturn
   */
  export type WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation upsert
   */
  export type WorkspaceInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceInvitation to update in case it exists.
     */
    where: WorkspaceInvitationWhereUniqueInput
    /**
     * In case the WorkspaceInvitation found by the `where` argument doesn't exist, create a new WorkspaceInvitation with this data.
     */
    create: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
    /**
     * In case the WorkspaceInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
  }

  /**
   * WorkspaceInvitation delete
   */
  export type WorkspaceInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceInvitation to delete.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation deleteMany
   */
  export type WorkspaceInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitations to delete
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceInvitation.invitedUser
   */
  export type WorkspaceInvitation$invitedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkspaceInvitation without action
   */
  export type WorkspaceInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
  }


  /**
   * Model ProviderAPIKey
   */

  export type AggregateProviderAPIKey = {
    _count: ProviderAPIKeyCountAggregateOutputType | null
    _min: ProviderAPIKeyMinAggregateOutputType | null
    _max: ProviderAPIKeyMaxAggregateOutputType | null
  }

  export type ProviderAPIKeyMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    provider: $Enums.LLMProvider | null
    displayName: string | null
    keyHash: string | null
    endpoint: string | null
    authType: $Enums.AuthType | null
    isActive: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ProviderAPIKeyMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    provider: $Enums.LLMProvider | null
    displayName: string | null
    keyHash: string | null
    endpoint: string | null
    authType: $Enums.AuthType | null
    isActive: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ProviderAPIKeyCountAggregateOutputType = {
    id: number
    workspaceId: number
    provider: number
    displayName: number
    keyHash: number
    providerConfig: number
    endpoint: number
    authType: number
    isActive: number
    lastUsedAt: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type ProviderAPIKeyMinAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    displayName?: true
    keyHash?: true
    endpoint?: true
    authType?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ProviderAPIKeyMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    displayName?: true
    keyHash?: true
    endpoint?: true
    authType?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ProviderAPIKeyCountAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    displayName?: true
    keyHash?: true
    providerConfig?: true
    endpoint?: true
    authType?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ProviderAPIKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderAPIKey to aggregate.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderAPIKeys
    **/
    _count?: true | ProviderAPIKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderAPIKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderAPIKeyMaxAggregateInputType
  }

  export type GetProviderAPIKeyAggregateType<T extends ProviderAPIKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderAPIKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderAPIKey[P]>
      : GetScalarType<T[P], AggregateProviderAPIKey[P]>
  }




  export type ProviderAPIKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderAPIKeyWhereInput
    orderBy?: ProviderAPIKeyOrderByWithAggregationInput | ProviderAPIKeyOrderByWithAggregationInput[]
    by: ProviderAPIKeyScalarFieldEnum[] | ProviderAPIKeyScalarFieldEnum
    having?: ProviderAPIKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderAPIKeyCountAggregateInputType | true
    _min?: ProviderAPIKeyMinAggregateInputType
    _max?: ProviderAPIKeyMaxAggregateInputType
  }

  export type ProviderAPIKeyGroupByOutputType = {
    id: string
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig: JsonValue | null
    endpoint: string | null
    authType: $Enums.AuthType
    isActive: boolean
    lastUsedAt: Date | null
    createdAt: Date
    expiresAt: Date | null
    _count: ProviderAPIKeyCountAggregateOutputType | null
    _min: ProviderAPIKeyMinAggregateOutputType | null
    _max: ProviderAPIKeyMaxAggregateOutputType | null
  }

  type GetProviderAPIKeyGroupByPayload<T extends ProviderAPIKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderAPIKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderAPIKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderAPIKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderAPIKeyGroupByOutputType[P]>
        }
      >
    >


  export type ProviderAPIKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerAPIKey"]>

  export type ProviderAPIKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerAPIKey"]>

  export type ProviderAPIKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerAPIKey"]>

  export type ProviderAPIKeySelectScalar = {
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    displayName?: boolean
    keyHash?: boolean
    providerConfig?: boolean
    endpoint?: boolean
    authType?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type ProviderAPIKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "provider" | "displayName" | "keyHash" | "providerConfig" | "endpoint" | "authType" | "isActive" | "lastUsedAt" | "createdAt" | "expiresAt", ExtArgs["result"]["providerAPIKey"]>
  export type ProviderAPIKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProviderAPIKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProviderAPIKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ProviderAPIKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderAPIKey"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      provider: $Enums.LLMProvider
      displayName: string
      keyHash: string
      providerConfig: Prisma.JsonValue | null
      endpoint: string | null
      authType: $Enums.AuthType
      isActive: boolean
      lastUsedAt: Date | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["providerAPIKey"]>
    composites: {}
  }

  type ProviderAPIKeyGetPayload<S extends boolean | null | undefined | ProviderAPIKeyDefaultArgs> = $Result.GetResult<Prisma.$ProviderAPIKeyPayload, S>

  type ProviderAPIKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderAPIKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderAPIKeyCountAggregateInputType | true
    }

  export interface ProviderAPIKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderAPIKey'], meta: { name: 'ProviderAPIKey' } }
    /**
     * Find zero or one ProviderAPIKey that matches the filter.
     * @param {ProviderAPIKeyFindUniqueArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderAPIKeyFindUniqueArgs>(args: SelectSubset<T, ProviderAPIKeyFindUniqueArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderAPIKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderAPIKeyFindUniqueOrThrowArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderAPIKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderAPIKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderAPIKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyFindFirstArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderAPIKeyFindFirstArgs>(args?: SelectSubset<T, ProviderAPIKeyFindFirstArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderAPIKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyFindFirstOrThrowArgs} args - Arguments to find a ProviderAPIKey
     * @example
     * // Get one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderAPIKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderAPIKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderAPIKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderAPIKeys
     * const providerAPIKeys = await prisma.providerAPIKey.findMany()
     * 
     * // Get first 10 ProviderAPIKeys
     * const providerAPIKeys = await prisma.providerAPIKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerAPIKeyWithIdOnly = await prisma.providerAPIKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderAPIKeyFindManyArgs>(args?: SelectSubset<T, ProviderAPIKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderAPIKey.
     * @param {ProviderAPIKeyCreateArgs} args - Arguments to create a ProviderAPIKey.
     * @example
     * // Create one ProviderAPIKey
     * const ProviderAPIKey = await prisma.providerAPIKey.create({
     *   data: {
     *     // ... data to create a ProviderAPIKey
     *   }
     * })
     * 
     */
    create<T extends ProviderAPIKeyCreateArgs>(args: SelectSubset<T, ProviderAPIKeyCreateArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderAPIKeys.
     * @param {ProviderAPIKeyCreateManyArgs} args - Arguments to create many ProviderAPIKeys.
     * @example
     * // Create many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderAPIKeyCreateManyArgs>(args?: SelectSubset<T, ProviderAPIKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderAPIKeys and returns the data saved in the database.
     * @param {ProviderAPIKeyCreateManyAndReturnArgs} args - Arguments to create many ProviderAPIKeys.
     * @example
     * // Create many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderAPIKeys and only return the `id`
     * const providerAPIKeyWithIdOnly = await prisma.providerAPIKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderAPIKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderAPIKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderAPIKey.
     * @param {ProviderAPIKeyDeleteArgs} args - Arguments to delete one ProviderAPIKey.
     * @example
     * // Delete one ProviderAPIKey
     * const ProviderAPIKey = await prisma.providerAPIKey.delete({
     *   where: {
     *     // ... filter to delete one ProviderAPIKey
     *   }
     * })
     * 
     */
    delete<T extends ProviderAPIKeyDeleteArgs>(args: SelectSubset<T, ProviderAPIKeyDeleteArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderAPIKey.
     * @param {ProviderAPIKeyUpdateArgs} args - Arguments to update one ProviderAPIKey.
     * @example
     * // Update one ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderAPIKeyUpdateArgs>(args: SelectSubset<T, ProviderAPIKeyUpdateArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderAPIKeys.
     * @param {ProviderAPIKeyDeleteManyArgs} args - Arguments to filter ProviderAPIKeys to delete.
     * @example
     * // Delete a few ProviderAPIKeys
     * const { count } = await prisma.providerAPIKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderAPIKeyDeleteManyArgs>(args?: SelectSubset<T, ProviderAPIKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderAPIKeyUpdateManyArgs>(args: SelectSubset<T, ProviderAPIKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderAPIKeys and returns the data updated in the database.
     * @param {ProviderAPIKeyUpdateManyAndReturnArgs} args - Arguments to update many ProviderAPIKeys.
     * @example
     * // Update many ProviderAPIKeys
     * const providerAPIKey = await prisma.providerAPIKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderAPIKeys and only return the `id`
     * const providerAPIKeyWithIdOnly = await prisma.providerAPIKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderAPIKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderAPIKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderAPIKey.
     * @param {ProviderAPIKeyUpsertArgs} args - Arguments to update or create a ProviderAPIKey.
     * @example
     * // Update or create a ProviderAPIKey
     * const providerAPIKey = await prisma.providerAPIKey.upsert({
     *   create: {
     *     // ... data to create a ProviderAPIKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderAPIKey we want to update
     *   }
     * })
     */
    upsert<T extends ProviderAPIKeyUpsertArgs>(args: SelectSubset<T, ProviderAPIKeyUpsertArgs<ExtArgs>>): Prisma__ProviderAPIKeyClient<$Result.GetResult<Prisma.$ProviderAPIKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderAPIKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyCountArgs} args - Arguments to filter ProviderAPIKeys to count.
     * @example
     * // Count the number of ProviderAPIKeys
     * const count = await prisma.providerAPIKey.count({
     *   where: {
     *     // ... the filter for the ProviderAPIKeys we want to count
     *   }
     * })
    **/
    count<T extends ProviderAPIKeyCountArgs>(
      args?: Subset<T, ProviderAPIKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderAPIKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAPIKeyAggregateArgs>(args: Subset<T, ProviderAPIKeyAggregateArgs>): Prisma.PrismaPromise<GetProviderAPIKeyAggregateType<T>>

    /**
     * Group by ProviderAPIKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAPIKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderAPIKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderAPIKeyGroupByArgs['orderBy'] }
        : { orderBy?: ProviderAPIKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderAPIKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderAPIKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderAPIKey model
   */
  readonly fields: ProviderAPIKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderAPIKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderAPIKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderAPIKey model
   */
  interface ProviderAPIKeyFieldRefs {
    readonly id: FieldRef<"ProviderAPIKey", 'String'>
    readonly workspaceId: FieldRef<"ProviderAPIKey", 'String'>
    readonly provider: FieldRef<"ProviderAPIKey", 'LLMProvider'>
    readonly displayName: FieldRef<"ProviderAPIKey", 'String'>
    readonly keyHash: FieldRef<"ProviderAPIKey", 'String'>
    readonly providerConfig: FieldRef<"ProviderAPIKey", 'Json'>
    readonly endpoint: FieldRef<"ProviderAPIKey", 'String'>
    readonly authType: FieldRef<"ProviderAPIKey", 'AuthType'>
    readonly isActive: FieldRef<"ProviderAPIKey", 'Boolean'>
    readonly lastUsedAt: FieldRef<"ProviderAPIKey", 'DateTime'>
    readonly createdAt: FieldRef<"ProviderAPIKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ProviderAPIKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderAPIKey findUnique
   */
  export type ProviderAPIKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey findUniqueOrThrow
   */
  export type ProviderAPIKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey findFirst
   */
  export type ProviderAPIKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderAPIKeys.
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderAPIKeys.
     */
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * ProviderAPIKey findFirstOrThrow
   */
  export type ProviderAPIKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKey to fetch.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderAPIKeys.
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderAPIKeys.
     */
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * ProviderAPIKey findMany
   */
  export type ProviderAPIKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderAPIKeys to fetch.
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAPIKeys to fetch.
     */
    orderBy?: ProviderAPIKeyOrderByWithRelationInput | ProviderAPIKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderAPIKeys.
     */
    cursor?: ProviderAPIKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAPIKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAPIKeys.
     */
    skip?: number
    distinct?: ProviderAPIKeyScalarFieldEnum | ProviderAPIKeyScalarFieldEnum[]
  }

  /**
   * ProviderAPIKey create
   */
  export type ProviderAPIKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderAPIKey.
     */
    data: XOR<ProviderAPIKeyCreateInput, ProviderAPIKeyUncheckedCreateInput>
  }

  /**
   * ProviderAPIKey createMany
   */
  export type ProviderAPIKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderAPIKeys.
     */
    data: ProviderAPIKeyCreateManyInput | ProviderAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderAPIKey createManyAndReturn
   */
  export type ProviderAPIKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderAPIKeys.
     */
    data: ProviderAPIKeyCreateManyInput | ProviderAPIKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderAPIKey update
   */
  export type ProviderAPIKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderAPIKey.
     */
    data: XOR<ProviderAPIKeyUpdateInput, ProviderAPIKeyUncheckedUpdateInput>
    /**
     * Choose, which ProviderAPIKey to update.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey updateMany
   */
  export type ProviderAPIKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderAPIKeys.
     */
    data: XOR<ProviderAPIKeyUpdateManyMutationInput, ProviderAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderAPIKeys to update
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * Limit how many ProviderAPIKeys to update.
     */
    limit?: number
  }

  /**
   * ProviderAPIKey updateManyAndReturn
   */
  export type ProviderAPIKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * The data used to update ProviderAPIKeys.
     */
    data: XOR<ProviderAPIKeyUpdateManyMutationInput, ProviderAPIKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderAPIKeys to update
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * Limit how many ProviderAPIKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderAPIKey upsert
   */
  export type ProviderAPIKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderAPIKey to update in case it exists.
     */
    where: ProviderAPIKeyWhereUniqueInput
    /**
     * In case the ProviderAPIKey found by the `where` argument doesn't exist, create a new ProviderAPIKey with this data.
     */
    create: XOR<ProviderAPIKeyCreateInput, ProviderAPIKeyUncheckedCreateInput>
    /**
     * In case the ProviderAPIKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderAPIKeyUpdateInput, ProviderAPIKeyUncheckedUpdateInput>
  }

  /**
   * ProviderAPIKey delete
   */
  export type ProviderAPIKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
    /**
     * Filter which ProviderAPIKey to delete.
     */
    where: ProviderAPIKeyWhereUniqueInput
  }

  /**
   * ProviderAPIKey deleteMany
   */
  export type ProviderAPIKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderAPIKeys to delete
     */
    where?: ProviderAPIKeyWhereInput
    /**
     * Limit how many ProviderAPIKeys to delete.
     */
    limit?: number
  }

  /**
   * ProviderAPIKey without action
   */
  export type ProviderAPIKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderAPIKey
     */
    select?: ProviderAPIKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderAPIKey
     */
    omit?: ProviderAPIKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderAPIKeyInclude<ExtArgs> | null
  }


  /**
   * Model ShareLink
   */

  export type AggregateShareLink = {
    _count: ShareLinkCountAggregateOutputType | null
    _avg: ShareLinkAvgAggregateOutputType | null
    _sum: ShareLinkSumAggregateOutputType | null
    _min: ShareLinkMinAggregateOutputType | null
    _max: ShareLinkMaxAggregateOutputType | null
  }

  export type ShareLinkAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type ShareLinkSumAggregateOutputType = {
    viewCount: number | null
  }

  export type ShareLinkMinAggregateOutputType = {
    id: string | null
    publicToken: string | null
    assetType: $Enums.ShareableAssetType | null
    assetId: string | null
    workspaceId: string | null
    createdBy: string | null
    accessLevel: $Enums.ShareAccessLevel | null
    password: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ShareLinkMaxAggregateOutputType = {
    id: string | null
    publicToken: string | null
    assetType: $Enums.ShareableAssetType | null
    assetId: string | null
    workspaceId: string | null
    createdBy: string | null
    accessLevel: $Enums.ShareAccessLevel | null
    password: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ShareLinkCountAggregateOutputType = {
    id: number
    publicToken: number
    assetType: number
    assetId: number
    workspaceId: number
    createdBy: number
    accessLevel: number
    password: number
    viewCount: number
    lastViewedAt: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type ShareLinkAvgAggregateInputType = {
    viewCount?: true
  }

  export type ShareLinkSumAggregateInputType = {
    viewCount?: true
  }

  export type ShareLinkMinAggregateInputType = {
    id?: true
    publicToken?: true
    assetType?: true
    assetId?: true
    workspaceId?: true
    createdBy?: true
    accessLevel?: true
    password?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ShareLinkMaxAggregateInputType = {
    id?: true
    publicToken?: true
    assetType?: true
    assetId?: true
    workspaceId?: true
    createdBy?: true
    accessLevel?: true
    password?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ShareLinkCountAggregateInputType = {
    id?: true
    publicToken?: true
    assetType?: true
    assetId?: true
    workspaceId?: true
    createdBy?: true
    accessLevel?: true
    password?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ShareLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareLink to aggregate.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareLinks
    **/
    _count?: true | ShareLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareLinkMaxAggregateInputType
  }

  export type GetShareLinkAggregateType<T extends ShareLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateShareLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareLink[P]>
      : GetScalarType<T[P], AggregateShareLink[P]>
  }




  export type ShareLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithAggregationInput | ShareLinkOrderByWithAggregationInput[]
    by: ShareLinkScalarFieldEnum[] | ShareLinkScalarFieldEnum
    having?: ShareLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareLinkCountAggregateInputType | true
    _avg?: ShareLinkAvgAggregateInputType
    _sum?: ShareLinkSumAggregateInputType
    _min?: ShareLinkMinAggregateInputType
    _max?: ShareLinkMaxAggregateInputType
  }

  export type ShareLinkGroupByOutputType = {
    id: string
    publicToken: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    workspaceId: string
    createdBy: string
    accessLevel: $Enums.ShareAccessLevel
    password: string | null
    viewCount: number
    lastViewedAt: Date | null
    createdAt: Date
    expiresAt: Date | null
    _count: ShareLinkCountAggregateOutputType | null
    _avg: ShareLinkAvgAggregateOutputType | null
    _sum: ShareLinkSumAggregateOutputType | null
    _min: ShareLinkMinAggregateOutputType | null
    _max: ShareLinkMaxAggregateOutputType | null
  }

  type GetShareLinkGroupByPayload<T extends ShareLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
        }
      >
    >


  export type ShareLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectScalar = {
    id?: boolean
    publicToken?: boolean
    assetType?: boolean
    assetId?: boolean
    workspaceId?: boolean
    createdBy?: boolean
    accessLevel?: boolean
    password?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type ShareLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicToken" | "assetType" | "assetId" | "workspaceId" | "createdBy" | "accessLevel" | "password" | "viewCount" | "lastViewedAt" | "createdAt" | "expiresAt", ExtArgs["result"]["shareLink"]>
  export type ShareLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ShareLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ShareLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ShareLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareLink"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publicToken: string
      assetType: $Enums.ShareableAssetType
      assetId: string
      workspaceId: string
      createdBy: string
      accessLevel: $Enums.ShareAccessLevel
      password: string | null
      viewCount: number
      lastViewedAt: Date | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["shareLink"]>
    composites: {}
  }

  type ShareLinkGetPayload<S extends boolean | null | undefined | ShareLinkDefaultArgs> = $Result.GetResult<Prisma.$ShareLinkPayload, S>

  type ShareLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareLinkCountAggregateInputType | true
    }

  export interface ShareLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareLink'], meta: { name: 'ShareLink' } }
    /**
     * Find zero or one ShareLink that matches the filter.
     * @param {ShareLinkFindUniqueArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareLinkFindUniqueArgs>(args: SelectSubset<T, ShareLinkFindUniqueArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShareLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareLinkFindUniqueOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareLinkFindFirstArgs>(args?: SelectSubset<T, ShareLinkFindFirstArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShareLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareLinks
     * const shareLinks = await prisma.shareLink.findMany()
     * 
     * // Get first 10 ShareLinks
     * const shareLinks = await prisma.shareLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareLinkFindManyArgs>(args?: SelectSubset<T, ShareLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShareLink.
     * @param {ShareLinkCreateArgs} args - Arguments to create a ShareLink.
     * @example
     * // Create one ShareLink
     * const ShareLink = await prisma.shareLink.create({
     *   data: {
     *     // ... data to create a ShareLink
     *   }
     * })
     * 
     */
    create<T extends ShareLinkCreateArgs>(args: SelectSubset<T, ShareLinkCreateArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShareLinks.
     * @param {ShareLinkCreateManyArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareLinkCreateManyArgs>(args?: SelectSubset<T, ShareLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShareLinks and returns the data saved in the database.
     * @param {ShareLinkCreateManyAndReturnArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShareLink.
     * @param {ShareLinkDeleteArgs} args - Arguments to delete one ShareLink.
     * @example
     * // Delete one ShareLink
     * const ShareLink = await prisma.shareLink.delete({
     *   where: {
     *     // ... filter to delete one ShareLink
     *   }
     * })
     * 
     */
    delete<T extends ShareLinkDeleteArgs>(args: SelectSubset<T, ShareLinkDeleteArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShareLink.
     * @param {ShareLinkUpdateArgs} args - Arguments to update one ShareLink.
     * @example
     * // Update one ShareLink
     * const shareLink = await prisma.shareLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareLinkUpdateArgs>(args: SelectSubset<T, ShareLinkUpdateArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShareLinks.
     * @param {ShareLinkDeleteManyArgs} args - Arguments to filter ShareLinks to delete.
     * @example
     * // Delete a few ShareLinks
     * const { count } = await prisma.shareLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareLinkDeleteManyArgs>(args?: SelectSubset<T, ShareLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareLinkUpdateManyArgs>(args: SelectSubset<T, ShareLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareLinks and returns the data updated in the database.
     * @param {ShareLinkUpdateManyAndReturnArgs} args - Arguments to update many ShareLinks.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShareLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, ShareLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShareLink.
     * @param {ShareLinkUpsertArgs} args - Arguments to update or create a ShareLink.
     * @example
     * // Update or create a ShareLink
     * const shareLink = await prisma.shareLink.upsert({
     *   create: {
     *     // ... data to create a ShareLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareLink we want to update
     *   }
     * })
     */
    upsert<T extends ShareLinkUpsertArgs>(args: SelectSubset<T, ShareLinkUpsertArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkCountArgs} args - Arguments to filter ShareLinks to count.
     * @example
     * // Count the number of ShareLinks
     * const count = await prisma.shareLink.count({
     *   where: {
     *     // ... the filter for the ShareLinks we want to count
     *   }
     * })
    **/
    count<T extends ShareLinkCountArgs>(
      args?: Subset<T, ShareLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareLinkAggregateArgs>(args: Subset<T, ShareLinkAggregateArgs>): Prisma.PrismaPromise<GetShareLinkAggregateType<T>>

    /**
     * Group by ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareLinkGroupByArgs['orderBy'] }
        : { orderBy?: ShareLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareLink model
   */
  readonly fields: ShareLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareLink model
   */
  interface ShareLinkFieldRefs {
    readonly id: FieldRef<"ShareLink", 'String'>
    readonly publicToken: FieldRef<"ShareLink", 'String'>
    readonly assetType: FieldRef<"ShareLink", 'ShareableAssetType'>
    readonly assetId: FieldRef<"ShareLink", 'String'>
    readonly workspaceId: FieldRef<"ShareLink", 'String'>
    readonly createdBy: FieldRef<"ShareLink", 'String'>
    readonly accessLevel: FieldRef<"ShareLink", 'ShareAccessLevel'>
    readonly password: FieldRef<"ShareLink", 'String'>
    readonly viewCount: FieldRef<"ShareLink", 'Int'>
    readonly lastViewedAt: FieldRef<"ShareLink", 'DateTime'>
    readonly createdAt: FieldRef<"ShareLink", 'DateTime'>
    readonly expiresAt: FieldRef<"ShareLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareLink findUnique
   */
  export type ShareLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink findUniqueOrThrow
   */
  export type ShareLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink findFirst
   */
  export type ShareLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink findFirstOrThrow
   */
  export type ShareLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink findMany
   */
  export type ShareLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLinks to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink create
   */
  export type ShareLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareLink.
     */
    data: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>
  }

  /**
   * ShareLink createMany
   */
  export type ShareLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShareLink createManyAndReturn
   */
  export type ShareLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareLink update
   */
  export type ShareLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareLink.
     */
    data: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>
    /**
     * Choose, which ShareLink to update.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink updateMany
   */
  export type ShareLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number
  }

  /**
   * ShareLink updateManyAndReturn
   */
  export type ShareLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareLink upsert
   */
  export type ShareLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareLink to update in case it exists.
     */
    where: ShareLinkWhereUniqueInput
    /**
     * In case the ShareLink found by the `where` argument doesn't exist, create a new ShareLink with this data.
     */
    create: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>
    /**
     * In case the ShareLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>
  }

  /**
   * ShareLink delete
   */
  export type ShareLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter which ShareLink to delete.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink deleteMany
   */
  export type ShareLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareLinks to delete
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to delete.
     */
    limit?: number
  }

  /**
   * ShareLink without action
   */
  export type ShareLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    sizeInBytes: number | null
  }

  export type DocumentSumAggregateOutputType = {
    sizeInBytes: bigint | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    storageKey: string | null
    s3Bucket: string | null
    fileType: string | null
    mimeType: string | null
    sizeInBytes: bigint | null
    status: $Enums.DocumentStatus | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    storageKey: string | null
    s3Bucket: string | null
    fileType: string | null
    mimeType: string | null
    sizeInBytes: bigint | null
    status: $Enums.DocumentStatus | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    storageKey: number
    s3Bucket: number
    fileType: number
    mimeType: number
    sizeInBytes: number
    status: number
    uploadedBy: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    sizeInBytes?: true
  }

  export type DocumentSumAggregateInputType = {
    sizeInBytes?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    storageKey?: true
    s3Bucket?: true
    fileType?: true
    mimeType?: true
    sizeInBytes?: true
    status?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    storageKey?: true
    s3Bucket?: true
    fileType?: true
    mimeType?: true
    sizeInBytes?: true
    status?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    storageKey?: true
    s3Bucket?: true
    fileType?: true
    mimeType?: true
    sizeInBytes?: true
    status?: true
    uploadedBy?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType: string | null
    sizeInBytes: bigint
    status: $Enums.DocumentStatus
    uploadedBy: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    embeddings?: boolean | Document$embeddingsArgs<ExtArgs>
    actionPods?: boolean | Document$actionPodsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    storageKey?: boolean
    s3Bucket?: boolean
    fileType?: boolean
    mimeType?: boolean
    sizeInBytes?: boolean
    status?: boolean
    uploadedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "storageKey" | "s3Bucket" | "fileType" | "mimeType" | "sizeInBytes" | "status" | "uploadedBy" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    embeddings?: boolean | Document$embeddingsArgs<ExtArgs>
    actionPods?: boolean | Document$actionPodsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      embeddings: Prisma.$EmbeddingPayload<ExtArgs>[]
      actionPods: Prisma.$ActionPodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      storageKey: string
      s3Bucket: string
      fileType: string
      mimeType: string | null
      sizeInBytes: bigint
      status: $Enums.DocumentStatus
      uploadedBy: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    embeddings<T extends Document$embeddingsArgs<ExtArgs> = {}>(args?: Subset<T, Document$embeddingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actionPods<T extends Document$actionPodsArgs<ExtArgs> = {}>(args?: Subset<T, Document$actionPodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly workspaceId: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly storageKey: FieldRef<"Document", 'String'>
    readonly s3Bucket: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly sizeInBytes: FieldRef<"Document", 'BigInt'>
    readonly status: FieldRef<"Document", 'DocumentStatus'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly metadata: FieldRef<"Document", 'Json'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.embeddings
   */
  export type Document$embeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    where?: EmbeddingWhereInput
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    cursor?: EmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Document.actionPods
   */
  export type Document$actionPodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPod
     */
    select?: ActionPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionPod
     */
    omit?: ActionPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPodInclude<ExtArgs> | null
    where?: ActionPodWhereInput
    orderBy?: ActionPodOrderByWithRelationInput | ActionPodOrderByWithRelationInput[]
    cursor?: ActionPodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionPodScalarFieldEnum | ActionPodScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Embedding
   */

  export type AggregateEmbedding = {
    _count: EmbeddingCountAggregateOutputType | null
    _avg: EmbeddingAvgAggregateOutputType | null
    _sum: EmbeddingSumAggregateOutputType | null
    _min: EmbeddingMinAggregateOutputType | null
    _max: EmbeddingMaxAggregateOutputType | null
  }

  export type EmbeddingAvgAggregateOutputType = {
    chunkIndex: number | null
    vectorDimension: number | null
  }

  export type EmbeddingSumAggregateOutputType = {
    chunkIndex: number | null
    vectorDimension: number | null
  }

  export type EmbeddingMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    model: string | null
    chunkIndex: number | null
    chunkText: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    vectorDimension: number | null
    createdAt: Date | null
  }

  export type EmbeddingMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    model: string | null
    chunkIndex: number | null
    chunkText: string | null
    s3VectorBucket: string | null
    s3VectorKey: string | null
    vectorDimension: number | null
    createdAt: Date | null
  }

  export type EmbeddingCountAggregateOutputType = {
    id: number
    documentId: number
    model: number
    chunkIndex: number
    chunkText: number
    s3VectorBucket: number
    s3VectorKey: number
    vectorDimension: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type EmbeddingAvgAggregateInputType = {
    chunkIndex?: true
    vectorDimension?: true
  }

  export type EmbeddingSumAggregateInputType = {
    chunkIndex?: true
    vectorDimension?: true
  }

  export type EmbeddingMinAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    chunkIndex?: true
    chunkText?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    vectorDimension?: true
    createdAt?: true
  }

  export type EmbeddingMaxAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    chunkIndex?: true
    chunkText?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    vectorDimension?: true
    createdAt?: true
  }

  export type EmbeddingCountAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    chunkIndex?: true
    chunkText?: true
    s3VectorBucket?: true
    s3VectorKey?: true
    vectorDimension?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type EmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Embedding to aggregate.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Embeddings
    **/
    _count?: true | EmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmbeddingMaxAggregateInputType
  }

  export type GetEmbeddingAggregateType<T extends EmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmbedding[P]>
      : GetScalarType<T[P], AggregateEmbedding[P]>
  }




  export type EmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbeddingWhereInput
    orderBy?: EmbeddingOrderByWithAggregationInput | EmbeddingOrderByWithAggregationInput[]
    by: EmbeddingScalarFieldEnum[] | EmbeddingScalarFieldEnum
    having?: EmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmbeddingCountAggregateInputType | true
    _avg?: EmbeddingAvgAggregateInputType
    _sum?: EmbeddingSumAggregateInputType
    _min?: EmbeddingMinAggregateInputType
    _max?: EmbeddingMaxAggregateInputType
  }

  export type EmbeddingGroupByOutputType = {
    id: string
    documentId: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension: number
    metadata: JsonValue | null
    createdAt: Date
    _count: EmbeddingCountAggregateOutputType | null
    _avg: EmbeddingAvgAggregateOutputType | null
    _sum: EmbeddingSumAggregateOutputType | null
    _min: EmbeddingMinAggregateOutputType | null
    _max: EmbeddingMaxAggregateOutputType | null
  }

  type GetEmbeddingGroupByPayload<T extends EmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], EmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type EmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectScalar = {
    id?: boolean
    documentId?: boolean
    model?: boolean
    chunkIndex?: boolean
    chunkText?: boolean
    s3VectorBucket?: boolean
    s3VectorKey?: boolean
    vectorDimension?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type EmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "model" | "chunkIndex" | "chunkText" | "s3VectorBucket" | "s3VectorKey" | "vectorDimension" | "metadata" | "createdAt", ExtArgs["result"]["embedding"]>
  export type EmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type EmbeddingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type EmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $EmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Embedding"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      model: string
      chunkIndex: number
      chunkText: string
      s3VectorBucket: string
      s3VectorKey: string
      vectorDimension: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["embedding"]>
    composites: {}
  }

  type EmbeddingGetPayload<S extends boolean | null | undefined | EmbeddingDefaultArgs> = $Result.GetResult<Prisma.$EmbeddingPayload, S>

  type EmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmbeddingCountAggregateInputType | true
    }

  export interface EmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Embedding'], meta: { name: 'Embedding' } }
    /**
     * Find zero or one Embedding that matches the filter.
     * @param {EmbeddingFindUniqueArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmbeddingFindUniqueArgs>(args: SelectSubset<T, EmbeddingFindUniqueArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Embedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmbeddingFindUniqueOrThrowArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, EmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Embedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindFirstArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmbeddingFindFirstArgs>(args?: SelectSubset<T, EmbeddingFindFirstArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Embedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindFirstOrThrowArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, EmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Embeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Embeddings
     * const embeddings = await prisma.embedding.findMany()
     * 
     * // Get first 10 Embeddings
     * const embeddings = await prisma.embedding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const embeddingWithIdOnly = await prisma.embedding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmbeddingFindManyArgs>(args?: SelectSubset<T, EmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Embedding.
     * @param {EmbeddingCreateArgs} args - Arguments to create a Embedding.
     * @example
     * // Create one Embedding
     * const Embedding = await prisma.embedding.create({
     *   data: {
     *     // ... data to create a Embedding
     *   }
     * })
     * 
     */
    create<T extends EmbeddingCreateArgs>(args: SelectSubset<T, EmbeddingCreateArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Embeddings.
     * @param {EmbeddingCreateManyArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embedding = await prisma.embedding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmbeddingCreateManyArgs>(args?: SelectSubset<T, EmbeddingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Embeddings and returns the data saved in the database.
     * @param {EmbeddingCreateManyAndReturnArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embedding = await prisma.embedding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Embeddings and only return the `id`
     * const embeddingWithIdOnly = await prisma.embedding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmbeddingCreateManyAndReturnArgs>(args?: SelectSubset<T, EmbeddingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Embedding.
     * @param {EmbeddingDeleteArgs} args - Arguments to delete one Embedding.
     * @example
     * // Delete one Embedding
     * const Embedding = await prisma.embedding.delete({
     *   where: {
     *     // ... filter to delete one Embedding
     *   }
     * })
     * 
     */
    delete<T extends EmbeddingDeleteArgs>(args: SelectSubset<T, EmbeddingDeleteArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Embedding.
     * @param {EmbeddingUpdateArgs} args - Arguments to update one Embedding.
     * @example
     * // Update one Embedding
     * const embedding = await prisma.embedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmbeddingUpdateArgs>(args: SelectSubset<T, EmbeddingUpdateArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Embeddings.
     * @param {EmbeddingDeleteManyArgs} args - Arguments to filter Embeddings to delete.
     * @example
     * // Delete a few Embeddings
     * const { count } = await prisma.embedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmbeddingDeleteManyArgs>(args?: SelectSubset<T, EmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Embeddings
     * const embedding = await prisma.embedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmbeddingUpdateManyArgs>(args: SelectSubset<T, EmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings and returns the data updated in the database.
     * @param {EmbeddingUpdateManyAndReturnArgs} args - Arguments to update many Embeddings.
     * @example
     * // Update many Embeddings
     * const embedding = await prisma.embedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Embeddings and only return the `id`
     * const embeddingWithIdOnly = await prisma.embedding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, EmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Embedding.
     * @param {EmbeddingUpsertArgs} args - Arguments to update or create a Embedding.
     * @example
     * // Update or create a Embedding
     * const embedding = await prisma.embedding.upsert({
     *   create: {
     *     // ... data to create a Embedding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Embedding we want to update
     *   }
     * })
     */
    upsert<T extends EmbeddingUpsertArgs>(args: SelectSubset<T, EmbeddingUpsertArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingCountArgs} args - Arguments to filter Embeddings to count.
     * @example
     * // Count the number of Embeddings
     * const count = await prisma.embedding.count({
     *   where: {
     *     // ... the filter for the Embeddings we want to count
     *   }
     * })
    **/
    count<T extends EmbeddingCountArgs>(
      args?: Subset<T, EmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Embedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmbeddingAggregateArgs>(args: Subset<T, EmbeddingAggregateArgs>): Prisma.PrismaPromise<GetEmbeddingAggregateType<T>>

    /**
     * Group by Embedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: EmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Embedding model
   */
  readonly fields: EmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Embedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Embedding model
   */
  interface EmbeddingFieldRefs {
    readonly id: FieldRef<"Embedding", 'String'>
    readonly documentId: FieldRef<"Embedding", 'String'>
    readonly model: FieldRef<"Embedding", 'String'>
    readonly chunkIndex: FieldRef<"Embedding", 'Int'>
    readonly chunkText: FieldRef<"Embedding", 'String'>
    readonly s3VectorBucket: FieldRef<"Embedding", 'String'>
    readonly s3VectorKey: FieldRef<"Embedding", 'String'>
    readonly vectorDimension: FieldRef<"Embedding", 'Int'>
    readonly metadata: FieldRef<"Embedding", 'Json'>
    readonly createdAt: FieldRef<"Embedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Embedding findUnique
   */
  export type EmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding findUniqueOrThrow
   */
  export type EmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding findFirst
   */
  export type EmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Embeddings.
     */
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding findFirstOrThrow
   */
  export type EmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Embeddings.
     */
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding findMany
   */
  export type EmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embeddings to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding create
   */
  export type EmbeddingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to create a Embedding.
     */
    data: XOR<EmbeddingCreateInput, EmbeddingUncheckedCreateInput>
  }

  /**
   * Embedding createMany
   */
  export type EmbeddingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Embeddings.
     */
    data: EmbeddingCreateManyInput | EmbeddingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Embedding createManyAndReturn
   */
  export type EmbeddingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * The data used to create many Embeddings.
     */
    data: EmbeddingCreateManyInput | EmbeddingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Embedding update
   */
  export type EmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a Embedding.
     */
    data: XOR<EmbeddingUpdateInput, EmbeddingUncheckedUpdateInput>
    /**
     * Choose, which Embedding to update.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding updateMany
   */
  export type EmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Embeddings.
     */
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which Embeddings to update
     */
    where?: EmbeddingWhereInput
    /**
     * Limit how many Embeddings to update.
     */
    limit?: number
  }

  /**
   * Embedding updateManyAndReturn
   */
  export type EmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update Embeddings.
     */
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which Embeddings to update
     */
    where?: EmbeddingWhereInput
    /**
     * Limit how many Embeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Embedding upsert
   */
  export type EmbeddingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The filter to search for the Embedding to update in case it exists.
     */
    where: EmbeddingWhereUniqueInput
    /**
     * In case the Embedding found by the `where` argument doesn't exist, create a new Embedding with this data.
     */
    create: XOR<EmbeddingCreateInput, EmbeddingUncheckedCreateInput>
    /**
     * In case the Embedding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmbeddingUpdateInput, EmbeddingUncheckedUpdateInput>
  }

  /**
   * Embedding delete
   */
  export type EmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter which Embedding to delete.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding deleteMany
   */
  export type EmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Embeddings to delete
     */
    where?: EmbeddingWhereInput
    /**
     * Limit how many Embeddings to delete.
     */
    limit?: number
  }

  /**
   * Embedding without action
   */
  export type EmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Embedding
     */
    omit?: EmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    status: 'status',
    isSuperAdmin: 'isSuperAdmin',
    requiresMfa: 'requiresMfa',
    mfaSecret: 'mfaSecret',
    mfaBackupCodes: 'mfaBackupCodes',
    mfaVerifiedAt: 'mfaVerifiedAt',
    allowedIpAddresses: 'allowedIpAddresses',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    passwordChangedAt: 'passwordChangedAt',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpiry: 'passwordResetExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    deactivatedAt: 'deactivatedAt',
    deactivatedBy: 'deactivatedBy'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminSessionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    lastActivityAt: 'lastActivityAt',
    revokedAt: 'revokedAt',
    revokedReason: 'revokedReason'
  };

  export type AdminSessionScalarFieldEnum = (typeof AdminSessionScalarFieldEnum)[keyof typeof AdminSessionScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    method: 'method',
    endpoint: 'endpoint',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    changesBefore: 'changesBefore',
    changesAfter: 'changesAfter',
    status: 'status',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    executionTimeMs: 'executionTimeMs',
    createdAt: 'createdAt'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const AdminPermissionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    permission: 'permission',
    resource: 'resource',
    grantedAt: 'grantedAt',
    grantedBy: 'grantedBy',
    expiresAt: 'expiresAt'
  };

  export type AdminPermissionScalarFieldEnum = (typeof AdminPermissionScalarFieldEnum)[keyof typeof AdminPermissionScalarFieldEnum]


  export const AdminAPIKeyScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    name: 'name',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix',
    scopes: 'scopes',
    rateLimit: 'rateLimit',
    allowedIps: 'allowedIps',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt'
  };

  export type AdminAPIKeyScalarFieldEnum = (typeof AdminAPIKeyScalarFieldEnum)[keyof typeof AdminAPIKeyScalarFieldEnum]


  export const AdminInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    role: 'role',
    token: 'token',
    invitedBy: 'invitedBy',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt'
  };

  export type AdminInvitationScalarFieldEnum = (typeof AdminInvitationScalarFieldEnum)[keyof typeof AdminInvitationScalarFieldEnum]


  export const AdminSecurityEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    severity: 'severity',
    adminId: 'adminId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    description: 'description',
    metadata: 'metadata',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt'
  };

  export type AdminSecurityEventScalarFieldEnum = (typeof AdminSecurityEventScalarFieldEnum)[keyof typeof AdminSecurityEventScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    tier: 'tier',
    status: 'status',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    credits: 'credits',
    monthlyCreditQuota: 'monthlyCreditQuota',
    creditResetDate: 'creditResetDate',
    maxCanvases: 'maxCanvases',
    maxActionPodsPerCanvas: 'maxActionPodsPerCanvas',
    maxDocumentSizeInMB: 'maxDocumentSizeInMB',
    maxCollaboratorsPerCanvas: 'maxCollaboratorsPerCanvas',
    canInviteToWorkspace: 'canInviteToWorkspace',
    canInviteToCanvas: 'canInviteToCanvas',
    canCreatePublicLinks: 'canCreatePublicLinks',
    canUseAdvancedModels: 'canUseAdvancedModels',
    canAccessAnalytics: 'canAccessAnalytics',
    canExportData: 'canExportData',
    nextBillingDate: 'nextBillingDate',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    isByokMode: 'isByokMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const CreditPurchaseScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    creditsPurchased: 'creditsPurchased',
    amountPaid: 'amountPaid',
    currency: 'currency',
    stripeChargeId: 'stripeChargeId',
    status: 'status',
    purchasedAt: 'purchasedAt'
  };

  export type CreditPurchaseScalarFieldEnum = (typeof CreditPurchaseScalarFieldEnum)[keyof typeof CreditPurchaseScalarFieldEnum]


  export const CreditUsageLogScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    workspaceId: 'workspaceId',
    canvasId: 'canvasId',
    podId: 'podId',
    executionId: 'executionId',
    creditsUsed: 'creditsUsed',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    provider: 'provider',
    modelId: 'modelId',
    modelName: 'modelName',
    createdAt: 'createdAt'
  };

  export type CreditUsageLogScalarFieldEnum = (typeof CreditUsageLogScalarFieldEnum)[keyof typeof CreditUsageLogScalarFieldEnum]


  export const ModelPricingTierScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    modelId: 'modelId',
    category: 'category',
    displayName: 'displayName',
    description: 'description',
    inputTokenCost: 'inputTokenCost',
    outputTokenCost: 'outputTokenCost',
    reasoningTokenCost: 'reasoningTokenCost',
    creditsPerMillionInputTokens: 'creditsPerMillionInputTokens',
    creditsPerMillionOutputTokens: 'creditsPerMillionOutputTokens',
    creditsPerMillionReasoningTokens: 'creditsPerMillionReasoningTokens',
    maxTokens: 'maxTokens',
    maxOutputTokens: 'maxOutputTokens',
    supportsStreaming: 'supportsStreaming',
    supportsVision: 'supportsVision',
    supportsAudio: 'supportsAudio',
    supportsVideo: 'supportsVideo',
    supportsFunctions: 'supportsFunctions',
    supportsJsonMode: 'supportsJsonMode',
    supportsSystemPrompt: 'supportsSystemPrompt',
    providerConfig: 'providerConfig',
    isActive: 'isActive',
    effectiveFrom: 'effectiveFrom',
    effectiveUntil: 'effectiveUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelPricingTierScalarFieldEnum = (typeof ModelPricingTierScalarFieldEnum)[keyof typeof ModelPricingTierScalarFieldEnum]


  export const CanvasScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    version: 'version',
    visibility: 'visibility',
    createdBy: 'createdBy',
    thumbnailS3Key: 'thumbnailS3Key',
    thumbnailGeneratedAt: 'thumbnailGeneratedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CanvasScalarFieldEnum = (typeof CanvasScalarFieldEnum)[keyof typeof CanvasScalarFieldEnum]


  export const CanvasInvitationScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    email: 'email',
    accessLevel: 'accessLevel',
    permissions: 'permissions',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token',
    status: 'status',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt'
  };

  export type CanvasInvitationScalarFieldEnum = (typeof CanvasInvitationScalarFieldEnum)[keyof typeof CanvasInvitationScalarFieldEnum]


  export const CanvasCollaboratorScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    accessLevel: 'accessLevel',
    canEdit: 'canEdit',
    canExecute: 'canExecute',
    canDelete: 'canDelete',
    canShare: 'canShare',
    canInvite: 'canInvite',
    invitedBy: 'invitedBy',
    invitedAt: 'invitedAt',
    lastViewedAt: 'lastViewedAt'
  };

  export type CanvasCollaboratorScalarFieldEnum = (typeof CanvasCollaboratorScalarFieldEnum)[keyof typeof CanvasCollaboratorScalarFieldEnum]


  export const CanvasSessionScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    anonymousName: 'anonymousName',
    sessionToken: 'sessionToken',
    socketId: 'socketId',
    cursorPosition: 'cursorPosition',
    selectedPodIds: 'selectedPodIds',
    viewportState: 'viewportState',
    userColor: 'userColor',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    connectedAt: 'connectedAt',
    lastHeartbeatAt: 'lastHeartbeatAt',
    disconnectedAt: 'disconnectedAt'
  };

  export type CanvasSessionScalarFieldEnum = (typeof CanvasSessionScalarFieldEnum)[keyof typeof CanvasSessionScalarFieldEnum]


  export const CanvasActivityLogScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changeData: 'changeData',
    createdAt: 'createdAt'
  };

  export type CanvasActivityLogScalarFieldEnum = (typeof CanvasActivityLogScalarFieldEnum)[keyof typeof CanvasActivityLogScalarFieldEnum]


  export const CanvasCommentScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    content: 'content',
    position: 'position',
    podId: 'podId',
    parentId: 'parentId',
    isResolved: 'isResolved',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CanvasCommentScalarFieldEnum = (typeof CanvasCommentScalarFieldEnum)[keyof typeof CanvasCommentScalarFieldEnum]


  export const ActionPodScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    type: 'type',
    position: 'position',
    executionStatus: 'executionStatus',
    lastExecutionId: 'lastExecutionId',
    contextCanvasId: 'contextCanvasId',
    documentId: 'documentId',
    lockedBy: 'lockedBy',
    lockedAt: 'lockedAt',
    dynamoPartitionKey: 'dynamoPartitionKey',
    dynamoSortKey: 'dynamoSortKey',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionPodScalarFieldEnum = (typeof ActionPodScalarFieldEnum)[keyof typeof ActionPodScalarFieldEnum]


  export const EdgeScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    sourcePodId: 'sourcePodId',
    targetPodId: 'targetPodId',
    sourceHandle: 'sourceHandle',
    targetHandle: 'targetHandle',
    animated: 'animated',
    createdAt: 'createdAt'
  };

  export type EdgeScalarFieldEnum = (typeof EdgeScalarFieldEnum)[keyof typeof EdgeScalarFieldEnum]


  export const ActionPodExecutionScalarFieldEnum: {
    id: 'id',
    podId: 'podId',
    canvasId: 'canvasId',
    workspaceId: 'workspaceId',
    status: 'status',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    runtimeInMs: 'runtimeInMs',
    provider: 'provider',
    modelId: 'modelId',
    modelName: 'modelName',
    providerMetadata: 'providerMetadata',
    requestMetadata: 'requestMetadata',
    responseMetadata: 'responseMetadata',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    reasoningTokens: 'reasoningTokens',
    creditsConsumed: 'creditsConsumed',
    costInUsd: 'costInUsd'
  };

  export type ActionPodExecutionScalarFieldEnum = (typeof ActionPodExecutionScalarFieldEnum)[keyof typeof ActionPodExecutionScalarFieldEnum]


  export const PodUsageLogScalarFieldEnum: {
    id: 'id',
    podId: 'podId',
    executionId: 'executionId',
    canvasId: 'canvasId',
    workspaceId: 'workspaceId',
    subscriptionId: 'subscriptionId',
    provider: 'provider',
    modelId: 'modelId',
    modelName: 'modelName',
    providerMetadata: 'providerMetadata',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    reasoningTokens: 'reasoningTokens',
    creditsConsumed: 'creditsConsumed',
    runtimeInMs: 'runtimeInMs',
    inputTokenCost: 'inputTokenCost',
    outputTokenCost: 'outputTokenCost',
    reasoningTokenCost: 'reasoningTokenCost',
    totalCostInUsd: 'totalCostInUsd',
    executedAt: 'executedAt'
  };

  export type PodUsageLogScalarFieldEnum = (typeof PodUsageLogScalarFieldEnum)[keyof typeof PodUsageLogScalarFieldEnum]


  export const ContextModuleScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    definitionJson: 'definitionJson',
    originalCanvasId: 'originalCanvasId',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContextModuleScalarFieldEnum = (typeof ContextModuleScalarFieldEnum)[keyof typeof ContextModuleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    hash: 'hash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    deviceName: 'deviceName',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    role: 'role',
    canCreateCanvas: 'canCreateCanvas',
    canDeleteCanvas: 'canDeleteCanvas',
    canManageBilling: 'canManageBilling',
    canInviteMembers: 'canInviteMembers',
    canManageMembers: 'canManageMembers',
    canManageApiKeys: 'canManageApiKeys',
    joinedAt: 'joinedAt',
    invitedBy: 'invitedBy'
  };

  export type WorkspaceUserScalarFieldEnum = (typeof WorkspaceUserScalarFieldEnum)[keyof typeof WorkspaceUserScalarFieldEnum]


  export const WorkspaceInvitationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    role: 'role',
    permissions: 'permissions',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token',
    status: 'status',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt'
  };

  export type WorkspaceInvitationScalarFieldEnum = (typeof WorkspaceInvitationScalarFieldEnum)[keyof typeof WorkspaceInvitationScalarFieldEnum]


  export const ProviderAPIKeyScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    provider: 'provider',
    displayName: 'displayName',
    keyHash: 'keyHash',
    providerConfig: 'providerConfig',
    endpoint: 'endpoint',
    authType: 'authType',
    isActive: 'isActive',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type ProviderAPIKeyScalarFieldEnum = (typeof ProviderAPIKeyScalarFieldEnum)[keyof typeof ProviderAPIKeyScalarFieldEnum]


  export const ShareLinkScalarFieldEnum: {
    id: 'id',
    publicToken: 'publicToken',
    assetType: 'assetType',
    assetId: 'assetId',
    workspaceId: 'workspaceId',
    createdBy: 'createdBy',
    accessLevel: 'accessLevel',
    password: 'password',
    viewCount: 'viewCount',
    lastViewedAt: 'lastViewedAt',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type ShareLinkScalarFieldEnum = (typeof ShareLinkScalarFieldEnum)[keyof typeof ShareLinkScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    storageKey: 'storageKey',
    s3Bucket: 's3Bucket',
    fileType: 'fileType',
    mimeType: 'mimeType',
    sizeInBytes: 'sizeInBytes',
    status: 'status',
    uploadedBy: 'uploadedBy',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const EmbeddingScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    model: 'model',
    chunkIndex: 'chunkIndex',
    chunkText: 'chunkText',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey',
    vectorDimension: 'vectorDimension',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type EmbeddingScalarFieldEnum = (typeof EmbeddingScalarFieldEnum)[keyof typeof EmbeddingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AdminOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    mfaSecret: 'mfaSecret',
    lastLoginIp: 'lastLoginIp',
    passwordResetToken: 'passwordResetToken',
    createdBy: 'createdBy',
    deactivatedBy: 'deactivatedBy'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const AdminSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    revokedReason: 'revokedReason'
  };

  export type AdminSessionOrderByRelevanceFieldEnum = (typeof AdminSessionOrderByRelevanceFieldEnum)[keyof typeof AdminSessionOrderByRelevanceFieldEnum]


  export const AdminAuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    resourceId: 'resourceId',
    method: 'method',
    endpoint: 'endpoint',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    errorMessage: 'errorMessage'
  };

  export type AdminAuditLogOrderByRelevanceFieldEnum = (typeof AdminAuditLogOrderByRelevanceFieldEnum)[keyof typeof AdminAuditLogOrderByRelevanceFieldEnum]


  export const AdminPermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    grantedBy: 'grantedBy'
  };

  export type AdminPermissionOrderByRelevanceFieldEnum = (typeof AdminPermissionOrderByRelevanceFieldEnum)[keyof typeof AdminPermissionOrderByRelevanceFieldEnum]


  export const AdminAPIKeyOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    name: 'name',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix'
  };

  export type AdminAPIKeyOrderByRelevanceFieldEnum = (typeof AdminAPIKeyOrderByRelevanceFieldEnum)[keyof typeof AdminAPIKeyOrderByRelevanceFieldEnum]


  export const AdminInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    invitedBy: 'invitedBy'
  };

  export type AdminInvitationOrderByRelevanceFieldEnum = (typeof AdminInvitationOrderByRelevanceFieldEnum)[keyof typeof AdminInvitationOrderByRelevanceFieldEnum]


  export const AdminSecurityEventOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    description: 'description',
    resolvedBy: 'resolvedBy'
  };

  export type AdminSecurityEventOrderByRelevanceFieldEnum = (typeof AdminSecurityEventOrderByRelevanceFieldEnum)[keyof typeof AdminSecurityEventOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  export const CreditPurchaseOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    currency: 'currency',
    stripeChargeId: 'stripeChargeId',
    status: 'status'
  };

  export type CreditPurchaseOrderByRelevanceFieldEnum = (typeof CreditPurchaseOrderByRelevanceFieldEnum)[keyof typeof CreditPurchaseOrderByRelevanceFieldEnum]


  export const CreditUsageLogOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    workspaceId: 'workspaceId',
    canvasId: 'canvasId',
    podId: 'podId',
    executionId: 'executionId',
    modelId: 'modelId',
    modelName: 'modelName'
  };

  export type CreditUsageLogOrderByRelevanceFieldEnum = (typeof CreditUsageLogOrderByRelevanceFieldEnum)[keyof typeof CreditUsageLogOrderByRelevanceFieldEnum]


  export const ModelPricingTierOrderByRelevanceFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    displayName: 'displayName',
    description: 'description'
  };

  export type ModelPricingTierOrderByRelevanceFieldEnum = (typeof ModelPricingTierOrderByRelevanceFieldEnum)[keyof typeof ModelPricingTierOrderByRelevanceFieldEnum]


  export const CanvasOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    thumbnailS3Key: 'thumbnailS3Key'
  };

  export type CanvasOrderByRelevanceFieldEnum = (typeof CanvasOrderByRelevanceFieldEnum)[keyof typeof CanvasOrderByRelevanceFieldEnum]


  export const CanvasInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    email: 'email',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token'
  };

  export type CanvasInvitationOrderByRelevanceFieldEnum = (typeof CanvasInvitationOrderByRelevanceFieldEnum)[keyof typeof CanvasInvitationOrderByRelevanceFieldEnum]


  export const CanvasCollaboratorOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    invitedBy: 'invitedBy'
  };

  export type CanvasCollaboratorOrderByRelevanceFieldEnum = (typeof CanvasCollaboratorOrderByRelevanceFieldEnum)[keyof typeof CanvasCollaboratorOrderByRelevanceFieldEnum]


  export const CanvasSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    anonymousName: 'anonymousName',
    sessionToken: 'sessionToken',
    socketId: 'socketId',
    userColor: 'userColor',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress'
  };

  export type CanvasSessionOrderByRelevanceFieldEnum = (typeof CanvasSessionOrderByRelevanceFieldEnum)[keyof typeof CanvasSessionOrderByRelevanceFieldEnum]


  export const CanvasActivityLogOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    entityType: 'entityType',
    entityId: 'entityId'
  };

  export type CanvasActivityLogOrderByRelevanceFieldEnum = (typeof CanvasActivityLogOrderByRelevanceFieldEnum)[keyof typeof CanvasActivityLogOrderByRelevanceFieldEnum]


  export const CanvasCommentOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    userId: 'userId',
    content: 'content',
    podId: 'podId',
    parentId: 'parentId',
    resolvedBy: 'resolvedBy'
  };

  export type CanvasCommentOrderByRelevanceFieldEnum = (typeof CanvasCommentOrderByRelevanceFieldEnum)[keyof typeof CanvasCommentOrderByRelevanceFieldEnum]


  export const ActionPodOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    lastExecutionId: 'lastExecutionId',
    contextCanvasId: 'contextCanvasId',
    documentId: 'documentId',
    lockedBy: 'lockedBy',
    dynamoPartitionKey: 'dynamoPartitionKey',
    dynamoSortKey: 'dynamoSortKey',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey'
  };

  export type ActionPodOrderByRelevanceFieldEnum = (typeof ActionPodOrderByRelevanceFieldEnum)[keyof typeof ActionPodOrderByRelevanceFieldEnum]


  export const EdgeOrderByRelevanceFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    sourcePodId: 'sourcePodId',
    targetPodId: 'targetPodId',
    sourceHandle: 'sourceHandle',
    targetHandle: 'targetHandle'
  };

  export type EdgeOrderByRelevanceFieldEnum = (typeof EdgeOrderByRelevanceFieldEnum)[keyof typeof EdgeOrderByRelevanceFieldEnum]


  export const ActionPodExecutionOrderByRelevanceFieldEnum: {
    id: 'id',
    podId: 'podId',
    canvasId: 'canvasId',
    workspaceId: 'workspaceId',
    modelId: 'modelId',
    modelName: 'modelName',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode'
  };

  export type ActionPodExecutionOrderByRelevanceFieldEnum = (typeof ActionPodExecutionOrderByRelevanceFieldEnum)[keyof typeof ActionPodExecutionOrderByRelevanceFieldEnum]


  export const PodUsageLogOrderByRelevanceFieldEnum: {
    id: 'id',
    podId: 'podId',
    executionId: 'executionId',
    canvasId: 'canvasId',
    workspaceId: 'workspaceId',
    subscriptionId: 'subscriptionId',
    modelId: 'modelId',
    modelName: 'modelName'
  };

  export type PodUsageLogOrderByRelevanceFieldEnum = (typeof PodUsageLogOrderByRelevanceFieldEnum)[keyof typeof PodUsageLogOrderByRelevanceFieldEnum]


  export const ContextModuleOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    originalCanvasId: 'originalCanvasId'
  };

  export type ContextModuleOrderByRelevanceFieldEnum = (typeof ContextModuleOrderByRelevanceFieldEnum)[keyof typeof ContextModuleOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    hash: 'hash'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RefreshTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    deviceName: 'deviceName',
    userId: 'userId'
  };

  export type RefreshTokenOrderByRelevanceFieldEnum = (typeof RefreshTokenOrderByRelevanceFieldEnum)[keyof typeof RefreshTokenOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    providerAccountId: 'providerAccountId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const WorkspaceOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WorkspaceOrderByRelevanceFieldEnum = (typeof WorkspaceOrderByRelevanceFieldEnum)[keyof typeof WorkspaceOrderByRelevanceFieldEnum]


  export const WorkspaceUserOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    invitedBy: 'invitedBy'
  };

  export type WorkspaceUserOrderByRelevanceFieldEnum = (typeof WorkspaceUserOrderByRelevanceFieldEnum)[keyof typeof WorkspaceUserOrderByRelevanceFieldEnum]


  export const WorkspaceInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    invitedBy: 'invitedBy',
    invitedUserId: 'invitedUserId',
    token: 'token'
  };

  export type WorkspaceInvitationOrderByRelevanceFieldEnum = (typeof WorkspaceInvitationOrderByRelevanceFieldEnum)[keyof typeof WorkspaceInvitationOrderByRelevanceFieldEnum]


  export const ProviderAPIKeyOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    displayName: 'displayName',
    keyHash: 'keyHash',
    endpoint: 'endpoint'
  };

  export type ProviderAPIKeyOrderByRelevanceFieldEnum = (typeof ProviderAPIKeyOrderByRelevanceFieldEnum)[keyof typeof ProviderAPIKeyOrderByRelevanceFieldEnum]


  export const ShareLinkOrderByRelevanceFieldEnum: {
    id: 'id',
    publicToken: 'publicToken',
    assetId: 'assetId',
    workspaceId: 'workspaceId',
    createdBy: 'createdBy',
    password: 'password'
  };

  export type ShareLinkOrderByRelevanceFieldEnum = (typeof ShareLinkOrderByRelevanceFieldEnum)[keyof typeof ShareLinkOrderByRelevanceFieldEnum]


  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    storageKey: 'storageKey',
    s3Bucket: 's3Bucket',
    fileType: 'fileType',
    mimeType: 'mimeType',
    uploadedBy: 'uploadedBy'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const EmbeddingOrderByRelevanceFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    model: 'model',
    chunkText: 'chunkText',
    s3VectorBucket: 's3VectorBucket',
    s3VectorKey: 's3VectorKey'
  };

  export type EmbeddingOrderByRelevanceFieldEnum = (typeof EmbeddingOrderByRelevanceFieldEnum)[keyof typeof EmbeddingOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'AdminStatus'
   */
  export type EnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus'>
    


  /**
   * Reference to a field of type 'AdminStatus[]'
   */
  export type ListEnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AdminAction'
   */
  export type EnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction'>
    


  /**
   * Reference to a field of type 'AdminAction[]'
   */
  export type ListEnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction[]'>
    


  /**
   * Reference to a field of type 'AdminResource'
   */
  export type EnumAdminResourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminResource'>
    


  /**
   * Reference to a field of type 'AdminResource[]'
   */
  export type ListEnumAdminResourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminResource[]'>
    


  /**
   * Reference to a field of type 'SpecificPermission'
   */
  export type EnumSpecificPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpecificPermission'>
    


  /**
   * Reference to a field of type 'SpecificPermission[]'
   */
  export type ListEnumSpecificPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpecificPermission[]'>
    


  /**
   * Reference to a field of type 'SecurityEventType'
   */
  export type EnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType'>
    


  /**
   * Reference to a field of type 'SecurityEventType[]'
   */
  export type ListEnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType[]'>
    


  /**
   * Reference to a field of type 'SecuritySeverity'
   */
  export type EnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity'>
    


  /**
   * Reference to a field of type 'SecuritySeverity[]'
   */
  export type ListEnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LLMProvider'
   */
  export type EnumLLMProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LLMProvider'>
    


  /**
   * Reference to a field of type 'LLMProvider[]'
   */
  export type ListEnumLLMProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LLMProvider[]'>
    


  /**
   * Reference to a field of type 'ModelCategory'
   */
  export type EnumModelCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelCategory'>
    


  /**
   * Reference to a field of type 'ModelCategory[]'
   */
  export type ListEnumModelCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelCategory[]'>
    


  /**
   * Reference to a field of type 'CanvasVisibility'
   */
  export type EnumCanvasVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CanvasVisibility'>
    


  /**
   * Reference to a field of type 'CanvasVisibility[]'
   */
  export type ListEnumCanvasVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CanvasVisibility[]'>
    


  /**
   * Reference to a field of type 'CanvasAccessLevel'
   */
  export type EnumCanvasAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CanvasAccessLevel'>
    


  /**
   * Reference to a field of type 'CanvasAccessLevel[]'
   */
  export type ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CanvasAccessLevel[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'CanvasActivityAction'
   */
  export type EnumCanvasActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CanvasActivityAction'>
    


  /**
   * Reference to a field of type 'CanvasActivityAction[]'
   */
  export type ListEnumCanvasActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CanvasActivityAction[]'>
    


  /**
   * Reference to a field of type 'ActionPodType'
   */
  export type EnumActionPodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionPodType'>
    


  /**
   * Reference to a field of type 'ActionPodType[]'
   */
  export type ListEnumActionPodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionPodType[]'>
    


  /**
   * Reference to a field of type 'ActionPodExecutionStatus'
   */
  export type EnumActionPodExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionPodExecutionStatus'>
    


  /**
   * Reference to a field of type 'ActionPodExecutionStatus[]'
   */
  export type ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionPodExecutionStatus[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'WorkspaceType'
   */
  export type EnumWorkspaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceType'>
    


  /**
   * Reference to a field of type 'WorkspaceType[]'
   */
  export type ListEnumWorkspaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceType[]'>
    


  /**
   * Reference to a field of type 'WorkspaceRole'
   */
  export type EnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole'>
    


  /**
   * Reference to a field of type 'WorkspaceRole[]'
   */
  export type ListEnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole[]'>
    


  /**
   * Reference to a field of type 'AuthType'
   */
  export type EnumAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthType'>
    


  /**
   * Reference to a field of type 'AuthType[]'
   */
  export type ListEnumAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthType[]'>
    


  /**
   * Reference to a field of type 'ShareableAssetType'
   */
  export type EnumShareableAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareableAssetType'>
    


  /**
   * Reference to a field of type 'ShareableAssetType[]'
   */
  export type ListEnumShareableAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareableAssetType[]'>
    


  /**
   * Reference to a field of type 'ShareAccessLevel'
   */
  export type EnumShareAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareAccessLevel'>
    


  /**
   * Reference to a field of type 'ShareAccessLevel[]'
   */
  export type ListEnumShareAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareAccessLevel[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    username?: StringFilter<"Admin"> | string
    passwordHash?: StringFilter<"Admin"> | string
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    isSuperAdmin?: BoolFilter<"Admin"> | boolean
    requiresMfa?: BoolFilter<"Admin"> | boolean
    mfaSecret?: StringNullableFilter<"Admin"> | string | null
    mfaBackupCodes?: JsonNullableFilter<"Admin">
    mfaVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    allowedIpAddresses?: JsonNullableFilter<"Admin">
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"Admin"> | string | null
    failedLoginAttempts?: IntFilter<"Admin"> | number
    lockedUntil?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"Admin"> | string | null
    passwordResetExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    createdBy?: StringNullableFilter<"Admin"> | string | null
    deactivatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deactivatedBy?: StringNullableFilter<"Admin"> | string | null
    sessions?: AdminSessionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    permissions?: AdminPermissionListRelationFilter
    apiKeys?: AdminAPIKeyListRelationFilter
    invitations?: AdminInvitationListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodes?: SortOrderInput | SortOrder
    mfaVerifiedAt?: SortOrderInput | SortOrder
    allowedIpAddresses?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    sessions?: AdminSessionOrderByRelationAggregateInput
    auditLogs?: AdminAuditLogOrderByRelationAggregateInput
    permissions?: AdminPermissionOrderByRelationAggregateInput
    apiKeys?: AdminAPIKeyOrderByRelationAggregateInput
    invitations?: AdminInvitationOrderByRelationAggregateInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    passwordResetToken?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    passwordHash?: StringFilter<"Admin"> | string
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    isSuperAdmin?: BoolFilter<"Admin"> | boolean
    requiresMfa?: BoolFilter<"Admin"> | boolean
    mfaSecret?: StringNullableFilter<"Admin"> | string | null
    mfaBackupCodes?: JsonNullableFilter<"Admin">
    mfaVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    allowedIpAddresses?: JsonNullableFilter<"Admin">
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"Admin"> | string | null
    failedLoginAttempts?: IntFilter<"Admin"> | number
    lockedUntil?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    passwordResetExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    createdBy?: StringNullableFilter<"Admin"> | string | null
    deactivatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deactivatedBy?: StringNullableFilter<"Admin"> | string | null
    sessions?: AdminSessionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    permissions?: AdminPermissionListRelationFilter
    apiKeys?: AdminAPIKeyListRelationFilter
    invitations?: AdminInvitationListRelationFilter
  }, "id" | "email" | "username" | "passwordResetToken">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodes?: SortOrderInput | SortOrder
    mfaVerifiedAt?: SortOrderInput | SortOrder
    allowedIpAddresses?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    username?: StringWithAggregatesFilter<"Admin"> | string
    passwordHash?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAdminStatusWithAggregatesFilter<"Admin"> | $Enums.AdminStatus
    isSuperAdmin?: BoolWithAggregatesFilter<"Admin"> | boolean
    requiresMfa?: BoolWithAggregatesFilter<"Admin"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    mfaBackupCodes?: JsonNullableWithAggregatesFilter<"Admin">
    mfaVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    allowedIpAddresses?: JsonNullableWithAggregatesFilter<"Admin">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"Admin"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    passwordResetExpiry?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    deactivatedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    deactivatedBy?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type AdminSessionWhereInput = {
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    token?: StringFilter<"AdminSession"> | string
    refreshToken?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableFilter<"AdminSession"> | string | null
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableFilter<"AdminSession"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminSessionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminSessionOrderByRelevanceInput
  }

  export type AdminSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    adminId?: StringFilter<"AdminSession"> | string
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableFilter<"AdminSession"> | string | null
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableFilter<"AdminSession"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "token" | "refreshToken">

  export type AdminSessionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    _count?: AdminSessionCountOrderByAggregateInput
    _max?: AdminSessionMaxOrderByAggregateInput
    _min?: AdminSessionMinOrderByAggregateInput
  }

  export type AdminSessionScalarWhereWithAggregatesInput = {
    AND?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    OR?: AdminSessionScalarWhereWithAggregatesInput[]
    NOT?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSession"> | string
    adminId?: StringWithAggregatesFilter<"AdminSession"> | string
    token?: StringWithAggregatesFilter<"AdminSession"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    ipAddress?: StringWithAggregatesFilter<"AdminSession"> | string
    userAgent?: StringWithAggregatesFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringNullableFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    method?: StringFilter<"AdminAuditLog"> | string
    endpoint?: StringFilter<"AdminAuditLog"> | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableFilter<"AdminAuditLog">
    changesAfter?: JsonNullableFilter<"AdminAuditLog">
    status?: IntFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    changesBefore?: SortOrderInput | SortOrder
    changesAfter?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminAuditLogOrderByRelevanceInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    adminId?: StringNullableFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    method?: StringFilter<"AdminAuditLog"> | string
    endpoint?: StringFilter<"AdminAuditLog"> | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableFilter<"AdminAuditLog">
    changesAfter?: JsonNullableFilter<"AdminAuditLog">
    status?: IntFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    changesBefore?: SortOrderInput | SortOrder
    changesAfter?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _avg?: AdminAuditLogAvgOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
    _sum?: AdminAuditLogSumOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    adminId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionWithAggregatesFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceWithAggregatesFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    method?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    endpoint?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    ipAddress?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    changesAfter?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    status?: IntWithAggregatesFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableWithAggregatesFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminPermissionWhereInput = {
    AND?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    OR?: AdminPermissionWhereInput[]
    NOT?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    id?: StringFilter<"AdminPermission"> | string
    adminId?: StringFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableFilter<"AdminPermission"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminPermissionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminPermissionOrderByRelevanceInput
  }

  export type AdminPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId_permission_resource?: AdminPermissionAdminIdPermissionResourceCompoundUniqueInput
    AND?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    OR?: AdminPermissionWhereInput[]
    NOT?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    adminId?: StringFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableFilter<"AdminPermission"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "adminId_permission_resource">

  export type AdminPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: AdminPermissionCountOrderByAggregateInput
    _max?: AdminPermissionMaxOrderByAggregateInput
    _min?: AdminPermissionMinOrderByAggregateInput
  }

  export type AdminPermissionScalarWhereWithAggregatesInput = {
    AND?: AdminPermissionScalarWhereWithAggregatesInput | AdminPermissionScalarWhereWithAggregatesInput[]
    OR?: AdminPermissionScalarWhereWithAggregatesInput[]
    NOT?: AdminPermissionScalarWhereWithAggregatesInput | AdminPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminPermission"> | string
    adminId?: StringWithAggregatesFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionWithAggregatesFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableWithAggregatesFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeWithAggregatesFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableWithAggregatesFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AdminPermission"> | Date | string | null
  }

  export type AdminAPIKeyWhereInput = {
    AND?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    OR?: AdminAPIKeyWhereInput[]
    NOT?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    id?: StringFilter<"AdminAPIKey"> | string
    adminId?: StringFilter<"AdminAPIKey"> | string
    name?: StringFilter<"AdminAPIKey"> | string
    keyHash?: StringFilter<"AdminAPIKey"> | string
    keyPrefix?: StringFilter<"AdminAPIKey"> | string
    scopes?: JsonFilter<"AdminAPIKey">
    rateLimit?: IntNullableFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableFilter<"AdminAPIKey">
    createdAt?: DateTimeFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminAPIKeyOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    allowedIps?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminAPIKeyOrderByRelevanceInput
  }

  export type AdminAPIKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    OR?: AdminAPIKeyWhereInput[]
    NOT?: AdminAPIKeyWhereInput | AdminAPIKeyWhereInput[]
    adminId?: StringFilter<"AdminAPIKey"> | string
    name?: StringFilter<"AdminAPIKey"> | string
    keyPrefix?: StringFilter<"AdminAPIKey"> | string
    scopes?: JsonFilter<"AdminAPIKey">
    rateLimit?: IntNullableFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableFilter<"AdminAPIKey">
    createdAt?: DateTimeFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "keyHash">

  export type AdminAPIKeyOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    allowedIps?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: AdminAPIKeyCountOrderByAggregateInput
    _avg?: AdminAPIKeyAvgOrderByAggregateInput
    _max?: AdminAPIKeyMaxOrderByAggregateInput
    _min?: AdminAPIKeyMinOrderByAggregateInput
    _sum?: AdminAPIKeySumOrderByAggregateInput
  }

  export type AdminAPIKeyScalarWhereWithAggregatesInput = {
    AND?: AdminAPIKeyScalarWhereWithAggregatesInput | AdminAPIKeyScalarWhereWithAggregatesInput[]
    OR?: AdminAPIKeyScalarWhereWithAggregatesInput[]
    NOT?: AdminAPIKeyScalarWhereWithAggregatesInput | AdminAPIKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    adminId?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    name?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    keyHash?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    keyPrefix?: StringWithAggregatesFilter<"AdminAPIKey"> | string
    scopes?: JsonWithAggregatesFilter<"AdminAPIKey">
    rateLimit?: IntNullableWithAggregatesFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableWithAggregatesFilter<"AdminAPIKey">
    createdAt?: DateTimeWithAggregatesFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"AdminAPIKey"> | Date | string | null
  }

  export type AdminInvitationWhereInput = {
    AND?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    OR?: AdminInvitationWhereInput[]
    NOT?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    id?: StringFilter<"AdminInvitation"> | string
    email?: StringFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleFilter<"AdminInvitation"> | $Enums.AdminRole
    token?: StringFilter<"AdminInvitation"> | string
    invitedBy?: StringFilter<"AdminInvitation"> | string
    createdAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"AdminInvitation"> | Date | string | null
    inviter?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminInvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    inviter?: AdminOrderByWithRelationInput
    _relevance?: AdminInvitationOrderByRelevanceInput
  }

  export type AdminInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    OR?: AdminInvitationWhereInput[]
    NOT?: AdminInvitationWhereInput | AdminInvitationWhereInput[]
    email?: StringFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleFilter<"AdminInvitation"> | $Enums.AdminRole
    invitedBy?: StringFilter<"AdminInvitation"> | string
    createdAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"AdminInvitation"> | Date | string | null
    inviter?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "token">

  export type AdminInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: AdminInvitationCountOrderByAggregateInput
    _max?: AdminInvitationMaxOrderByAggregateInput
    _min?: AdminInvitationMinOrderByAggregateInput
  }

  export type AdminInvitationScalarWhereWithAggregatesInput = {
    AND?: AdminInvitationScalarWhereWithAggregatesInput | AdminInvitationScalarWhereWithAggregatesInput[]
    OR?: AdminInvitationScalarWhereWithAggregatesInput[]
    NOT?: AdminInvitationScalarWhereWithAggregatesInput | AdminInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminInvitation"> | string
    email?: StringWithAggregatesFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"AdminInvitation"> | $Enums.AdminRole
    token?: StringWithAggregatesFilter<"AdminInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"AdminInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"AdminInvitation"> | Date | string | null
  }

  export type AdminSecurityEventWhereInput = {
    AND?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    OR?: AdminSecurityEventWhereInput[]
    NOT?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    id?: StringFilter<"AdminSecurityEvent"> | string
    eventType?: EnumSecurityEventTypeFilter<"AdminSecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"AdminSecurityEvent"> | $Enums.SecuritySeverity
    adminId?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    ipAddress?: StringFilter<"AdminSecurityEvent"> | string
    userAgent?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    description?: StringFilter<"AdminSecurityEvent"> | string
    metadata?: JsonNullableFilter<"AdminSecurityEvent">
    resolved?: BoolFilter<"AdminSecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AdminSecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"AdminSecurityEvent"> | Date | string
  }

  export type AdminSecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: AdminSecurityEventOrderByRelevanceInput
  }

  export type AdminSecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    OR?: AdminSecurityEventWhereInput[]
    NOT?: AdminSecurityEventWhereInput | AdminSecurityEventWhereInput[]
    eventType?: EnumSecurityEventTypeFilter<"AdminSecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"AdminSecurityEvent"> | $Enums.SecuritySeverity
    adminId?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    ipAddress?: StringFilter<"AdminSecurityEvent"> | string
    userAgent?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    description?: StringFilter<"AdminSecurityEvent"> | string
    metadata?: JsonNullableFilter<"AdminSecurityEvent">
    resolved?: BoolFilter<"AdminSecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AdminSecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"AdminSecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"AdminSecurityEvent"> | Date | string
  }, "id">

  export type AdminSecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminSecurityEventCountOrderByAggregateInput
    _max?: AdminSecurityEventMaxOrderByAggregateInput
    _min?: AdminSecurityEventMinOrderByAggregateInput
  }

  export type AdminSecurityEventScalarWhereWithAggregatesInput = {
    AND?: AdminSecurityEventScalarWhereWithAggregatesInput | AdminSecurityEventScalarWhereWithAggregatesInput[]
    OR?: AdminSecurityEventScalarWhereWithAggregatesInput[]
    NOT?: AdminSecurityEventScalarWhereWithAggregatesInput | AdminSecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSecurityEvent"> | string
    eventType?: EnumSecurityEventTypeWithAggregatesFilter<"AdminSecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityWithAggregatesFilter<"AdminSecurityEvent"> | $Enums.SecuritySeverity
    adminId?: StringNullableWithAggregatesFilter<"AdminSecurityEvent"> | string | null
    ipAddress?: StringWithAggregatesFilter<"AdminSecurityEvent"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AdminSecurityEvent"> | string | null
    description?: StringWithAggregatesFilter<"AdminSecurityEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AdminSecurityEvent">
    resolved?: BoolWithAggregatesFilter<"AdminSecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"AdminSecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"AdminSecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminSecurityEvent"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    workspaceId?: StringFilter<"Subscription"> | string
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    credits?: IntFilter<"Subscription"> | number
    monthlyCreditQuota?: IntFilter<"Subscription"> | number
    creditResetDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    maxCanvases?: IntFilter<"Subscription"> | number
    maxActionPodsPerCanvas?: IntFilter<"Subscription"> | number
    maxDocumentSizeInMB?: IntFilter<"Subscription"> | number
    maxCollaboratorsPerCanvas?: IntFilter<"Subscription"> | number
    canInviteToWorkspace?: BoolFilter<"Subscription"> | boolean
    canInviteToCanvas?: BoolFilter<"Subscription"> | boolean
    canCreatePublicLinks?: BoolFilter<"Subscription"> | boolean
    canUseAdvancedModels?: BoolFilter<"Subscription"> | boolean
    canAccessAnalytics?: BoolFilter<"Subscription"> | boolean
    canExportData?: BoolFilter<"Subscription"> | boolean
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    isByokMode?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    usageLogs?: PodUsageLogListRelationFilter
    creditPurchases?: CreditPurchaseListRelationFilter
    creditUsage?: CreditUsageLogListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrderInput | SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    usageLogs?: PodUsageLogOrderByRelationAggregateInput
    creditPurchases?: CreditPurchaseOrderByRelationAggregateInput
    creditUsage?: CreditUsageLogOrderByRelationAggregateInput
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    credits?: IntFilter<"Subscription"> | number
    monthlyCreditQuota?: IntFilter<"Subscription"> | number
    creditResetDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    maxCanvases?: IntFilter<"Subscription"> | number
    maxActionPodsPerCanvas?: IntFilter<"Subscription"> | number
    maxDocumentSizeInMB?: IntFilter<"Subscription"> | number
    maxCollaboratorsPerCanvas?: IntFilter<"Subscription"> | number
    canInviteToWorkspace?: BoolFilter<"Subscription"> | boolean
    canInviteToCanvas?: BoolFilter<"Subscription"> | boolean
    canCreatePublicLinks?: BoolFilter<"Subscription"> | boolean
    canUseAdvancedModels?: BoolFilter<"Subscription"> | boolean
    canAccessAnalytics?: BoolFilter<"Subscription"> | boolean
    canExportData?: BoolFilter<"Subscription"> | boolean
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    isByokMode?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    usageLogs?: PodUsageLogListRelationFilter
    creditPurchases?: CreditPurchaseListRelationFilter
    creditUsage?: CreditUsageLogListRelationFilter
  }, "id" | "workspaceId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrderInput | SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    workspaceId?: StringWithAggregatesFilter<"Subscription"> | string
    tier?: EnumSubscriptionTierWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    credits?: IntWithAggregatesFilter<"Subscription"> | number
    monthlyCreditQuota?: IntWithAggregatesFilter<"Subscription"> | number
    creditResetDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    maxCanvases?: IntWithAggregatesFilter<"Subscription"> | number
    maxActionPodsPerCanvas?: IntWithAggregatesFilter<"Subscription"> | number
    maxDocumentSizeInMB?: IntWithAggregatesFilter<"Subscription"> | number
    maxCollaboratorsPerCanvas?: IntWithAggregatesFilter<"Subscription"> | number
    canInviteToWorkspace?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canInviteToCanvas?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canCreatePublicLinks?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canUseAdvancedModels?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canAccessAnalytics?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canExportData?: BoolWithAggregatesFilter<"Subscription"> | boolean
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    isByokMode?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type CreditPurchaseWhereInput = {
    AND?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    OR?: CreditPurchaseWhereInput[]
    NOT?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    id?: StringFilter<"CreditPurchase"> | string
    subscriptionId?: StringFilter<"CreditPurchase"> | string
    creditsPurchased?: IntFilter<"CreditPurchase"> | number
    amountPaid?: DecimalFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"CreditPurchase"> | string
    stripeChargeId?: StringFilter<"CreditPurchase"> | string
    status?: StringFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeFilter<"CreditPurchase"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type CreditPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: CreditPurchaseOrderByRelevanceInput
  }

  export type CreditPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeChargeId?: string
    AND?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    OR?: CreditPurchaseWhereInput[]
    NOT?: CreditPurchaseWhereInput | CreditPurchaseWhereInput[]
    subscriptionId?: StringFilter<"CreditPurchase"> | string
    creditsPurchased?: IntFilter<"CreditPurchase"> | number
    amountPaid?: DecimalFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"CreditPurchase"> | string
    status?: StringFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeFilter<"CreditPurchase"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id" | "stripeChargeId">

  export type CreditPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    _count?: CreditPurchaseCountOrderByAggregateInput
    _avg?: CreditPurchaseAvgOrderByAggregateInput
    _max?: CreditPurchaseMaxOrderByAggregateInput
    _min?: CreditPurchaseMinOrderByAggregateInput
    _sum?: CreditPurchaseSumOrderByAggregateInput
  }

  export type CreditPurchaseScalarWhereWithAggregatesInput = {
    AND?: CreditPurchaseScalarWhereWithAggregatesInput | CreditPurchaseScalarWhereWithAggregatesInput[]
    OR?: CreditPurchaseScalarWhereWithAggregatesInput[]
    NOT?: CreditPurchaseScalarWhereWithAggregatesInput | CreditPurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditPurchase"> | string
    subscriptionId?: StringWithAggregatesFilter<"CreditPurchase"> | string
    creditsPurchased?: IntWithAggregatesFilter<"CreditPurchase"> | number
    amountPaid?: DecimalWithAggregatesFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"CreditPurchase"> | string
    stripeChargeId?: StringWithAggregatesFilter<"CreditPurchase"> | string
    status?: StringWithAggregatesFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeWithAggregatesFilter<"CreditPurchase"> | Date | string
  }

  export type CreditUsageLogWhereInput = {
    AND?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    OR?: CreditUsageLogWhereInput[]
    NOT?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    id?: StringFilter<"CreditUsageLog"> | string
    subscriptionId?: StringFilter<"CreditUsageLog"> | string
    workspaceId?: StringFilter<"CreditUsageLog"> | string
    canvasId?: StringFilter<"CreditUsageLog"> | string
    podId?: StringFilter<"CreditUsageLog"> | string
    executionId?: StringFilter<"CreditUsageLog"> | string
    creditsUsed?: IntFilter<"CreditUsageLog"> | number
    balanceBefore?: IntFilter<"CreditUsageLog"> | number
    balanceAfter?: IntFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"CreditUsageLog"> | string
    modelName?: StringNullableFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeFilter<"CreditUsageLog"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type CreditUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: CreditUsageLogOrderByRelevanceInput
  }

  export type CreditUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    OR?: CreditUsageLogWhereInput[]
    NOT?: CreditUsageLogWhereInput | CreditUsageLogWhereInput[]
    subscriptionId?: StringFilter<"CreditUsageLog"> | string
    workspaceId?: StringFilter<"CreditUsageLog"> | string
    canvasId?: StringFilter<"CreditUsageLog"> | string
    podId?: StringFilter<"CreditUsageLog"> | string
    executionId?: StringFilter<"CreditUsageLog"> | string
    creditsUsed?: IntFilter<"CreditUsageLog"> | number
    balanceBefore?: IntFilter<"CreditUsageLog"> | number
    balanceAfter?: IntFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"CreditUsageLog"> | string
    modelName?: StringNullableFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeFilter<"CreditUsageLog"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type CreditUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CreditUsageLogCountOrderByAggregateInput
    _avg?: CreditUsageLogAvgOrderByAggregateInput
    _max?: CreditUsageLogMaxOrderByAggregateInput
    _min?: CreditUsageLogMinOrderByAggregateInput
    _sum?: CreditUsageLogSumOrderByAggregateInput
  }

  export type CreditUsageLogScalarWhereWithAggregatesInput = {
    AND?: CreditUsageLogScalarWhereWithAggregatesInput | CreditUsageLogScalarWhereWithAggregatesInput[]
    OR?: CreditUsageLogScalarWhereWithAggregatesInput[]
    NOT?: CreditUsageLogScalarWhereWithAggregatesInput | CreditUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    subscriptionId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    workspaceId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    canvasId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    podId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    executionId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    creditsUsed?: IntWithAggregatesFilter<"CreditUsageLog"> | number
    balanceBefore?: IntWithAggregatesFilter<"CreditUsageLog"> | number
    balanceAfter?: IntWithAggregatesFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderWithAggregatesFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"CreditUsageLog"> | string
    modelName?: StringNullableWithAggregatesFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CreditUsageLog"> | Date | string
  }

  export type ModelPricingTierWhereInput = {
    AND?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    OR?: ModelPricingTierWhereInput[]
    NOT?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    id?: StringFilter<"ModelPricingTier"> | string
    provider?: EnumLLMProviderFilter<"ModelPricingTier"> | $Enums.LLMProvider
    modelId?: StringFilter<"ModelPricingTier"> | string
    category?: EnumModelCategoryFilter<"ModelPricingTier"> | $Enums.ModelCategory
    displayName?: StringFilter<"ModelPricingTier"> | string
    description?: StringNullableFilter<"ModelPricingTier"> | string | null
    inputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionOutputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionReasoningTokens?: IntFilter<"ModelPricingTier"> | number
    maxTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    maxOutputTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    supportsStreaming?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVision?: BoolFilter<"ModelPricingTier"> | boolean
    supportsAudio?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVideo?: BoolFilter<"ModelPricingTier"> | boolean
    supportsFunctions?: BoolFilter<"ModelPricingTier"> | boolean
    supportsJsonMode?: BoolFilter<"ModelPricingTier"> | boolean
    supportsSystemPrompt?: BoolFilter<"ModelPricingTier"> | boolean
    providerConfig?: JsonNullableFilter<"ModelPricingTier">
    isActive?: BoolFilter<"ModelPricingTier"> | boolean
    effectiveFrom?: DateTimeFilter<"ModelPricingTier"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"ModelPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
    updatedAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
  }

  export type ModelPricingTierOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrderInput | SortOrder
    maxOutputTokens?: SortOrderInput | SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ModelPricingTierOrderByRelevanceInput
  }

  export type ModelPricingTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_modelId_effectiveFrom?: ModelPricingTierProviderModelIdEffectiveFromCompoundUniqueInput
    AND?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    OR?: ModelPricingTierWhereInput[]
    NOT?: ModelPricingTierWhereInput | ModelPricingTierWhereInput[]
    provider?: EnumLLMProviderFilter<"ModelPricingTier"> | $Enums.LLMProvider
    modelId?: StringFilter<"ModelPricingTier"> | string
    category?: EnumModelCategoryFilter<"ModelPricingTier"> | $Enums.ModelCategory
    displayName?: StringFilter<"ModelPricingTier"> | string
    description?: StringNullableFilter<"ModelPricingTier"> | string | null
    inputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionOutputTokens?: IntFilter<"ModelPricingTier"> | number
    creditsPerMillionReasoningTokens?: IntFilter<"ModelPricingTier"> | number
    maxTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    maxOutputTokens?: IntNullableFilter<"ModelPricingTier"> | number | null
    supportsStreaming?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVision?: BoolFilter<"ModelPricingTier"> | boolean
    supportsAudio?: BoolFilter<"ModelPricingTier"> | boolean
    supportsVideo?: BoolFilter<"ModelPricingTier"> | boolean
    supportsFunctions?: BoolFilter<"ModelPricingTier"> | boolean
    supportsJsonMode?: BoolFilter<"ModelPricingTier"> | boolean
    supportsSystemPrompt?: BoolFilter<"ModelPricingTier"> | boolean
    providerConfig?: JsonNullableFilter<"ModelPricingTier">
    isActive?: BoolFilter<"ModelPricingTier"> | boolean
    effectiveFrom?: DateTimeFilter<"ModelPricingTier"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"ModelPricingTier"> | Date | string | null
    createdAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
    updatedAt?: DateTimeFilter<"ModelPricingTier"> | Date | string
  }, "id" | "provider_modelId_effectiveFrom">

  export type ModelPricingTierOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrderInput | SortOrder
    maxOutputTokens?: SortOrderInput | SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelPricingTierCountOrderByAggregateInput
    _avg?: ModelPricingTierAvgOrderByAggregateInput
    _max?: ModelPricingTierMaxOrderByAggregateInput
    _min?: ModelPricingTierMinOrderByAggregateInput
    _sum?: ModelPricingTierSumOrderByAggregateInput
  }

  export type ModelPricingTierScalarWhereWithAggregatesInput = {
    AND?: ModelPricingTierScalarWhereWithAggregatesInput | ModelPricingTierScalarWhereWithAggregatesInput[]
    OR?: ModelPricingTierScalarWhereWithAggregatesInput[]
    NOT?: ModelPricingTierScalarWhereWithAggregatesInput | ModelPricingTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelPricingTier"> | string
    provider?: EnumLLMProviderWithAggregatesFilter<"ModelPricingTier"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"ModelPricingTier"> | string
    category?: EnumModelCategoryWithAggregatesFilter<"ModelPricingTier"> | $Enums.ModelCategory
    displayName?: StringWithAggregatesFilter<"ModelPricingTier"> | string
    description?: StringNullableWithAggregatesFilter<"ModelPricingTier"> | string | null
    inputTokenCost?: DecimalWithAggregatesFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalWithAggregatesFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalWithAggregatesFilter<"ModelPricingTier"> | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntWithAggregatesFilter<"ModelPricingTier"> | number
    creditsPerMillionOutputTokens?: IntWithAggregatesFilter<"ModelPricingTier"> | number
    creditsPerMillionReasoningTokens?: IntWithAggregatesFilter<"ModelPricingTier"> | number
    maxTokens?: IntNullableWithAggregatesFilter<"ModelPricingTier"> | number | null
    maxOutputTokens?: IntNullableWithAggregatesFilter<"ModelPricingTier"> | number | null
    supportsStreaming?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsVision?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsAudio?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsVideo?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsFunctions?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsJsonMode?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    supportsSystemPrompt?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    providerConfig?: JsonNullableWithAggregatesFilter<"ModelPricingTier">
    isActive?: BoolWithAggregatesFilter<"ModelPricingTier"> | boolean
    effectiveFrom?: DateTimeWithAggregatesFilter<"ModelPricingTier"> | Date | string
    effectiveUntil?: DateTimeNullableWithAggregatesFilter<"ModelPricingTier"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModelPricingTier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelPricingTier"> | Date | string
  }

  export type CanvasWhereInput = {
    AND?: CanvasWhereInput | CanvasWhereInput[]
    OR?: CanvasWhereInput[]
    NOT?: CanvasWhereInput | CanvasWhereInput[]
    id?: StringFilter<"Canvas"> | string
    workspaceId?: StringFilter<"Canvas"> | string
    name?: StringFilter<"Canvas"> | string
    description?: StringNullableFilter<"Canvas"> | string | null
    version?: IntFilter<"Canvas"> | number
    visibility?: EnumCanvasVisibilityFilter<"Canvas"> | $Enums.CanvasVisibility
    createdBy?: StringFilter<"Canvas"> | string
    thumbnailS3Key?: StringNullableFilter<"Canvas"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableFilter<"Canvas"> | Date | string | null
    createdAt?: DateTimeFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeFilter<"Canvas"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    actionPods?: ActionPodListRelationFilter
    edges?: EdgeListRelationFilter
    contextualPods?: ActionPodListRelationFilter
    contextModules?: ContextModuleListRelationFilter
    collaborators?: CanvasCollaboratorListRelationFilter
    invitations?: CanvasInvitationListRelationFilter
    sessions?: CanvasSessionListRelationFilter
    activityLog?: CanvasActivityLogListRelationFilter
    comments?: CanvasCommentListRelationFilter
  }

  export type CanvasOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrderInput | SortOrder
    thumbnailGeneratedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    actionPods?: ActionPodOrderByRelationAggregateInput
    edges?: EdgeOrderByRelationAggregateInput
    contextualPods?: ActionPodOrderByRelationAggregateInput
    contextModules?: ContextModuleOrderByRelationAggregateInput
    collaborators?: CanvasCollaboratorOrderByRelationAggregateInput
    invitations?: CanvasInvitationOrderByRelationAggregateInput
    sessions?: CanvasSessionOrderByRelationAggregateInput
    activityLog?: CanvasActivityLogOrderByRelationAggregateInput
    comments?: CanvasCommentOrderByRelationAggregateInput
    _relevance?: CanvasOrderByRelevanceInput
  }

  export type CanvasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CanvasWhereInput | CanvasWhereInput[]
    OR?: CanvasWhereInput[]
    NOT?: CanvasWhereInput | CanvasWhereInput[]
    workspaceId?: StringFilter<"Canvas"> | string
    name?: StringFilter<"Canvas"> | string
    description?: StringNullableFilter<"Canvas"> | string | null
    version?: IntFilter<"Canvas"> | number
    visibility?: EnumCanvasVisibilityFilter<"Canvas"> | $Enums.CanvasVisibility
    createdBy?: StringFilter<"Canvas"> | string
    thumbnailS3Key?: StringNullableFilter<"Canvas"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableFilter<"Canvas"> | Date | string | null
    createdAt?: DateTimeFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeFilter<"Canvas"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    actionPods?: ActionPodListRelationFilter
    edges?: EdgeListRelationFilter
    contextualPods?: ActionPodListRelationFilter
    contextModules?: ContextModuleListRelationFilter
    collaborators?: CanvasCollaboratorListRelationFilter
    invitations?: CanvasInvitationListRelationFilter
    sessions?: CanvasSessionListRelationFilter
    activityLog?: CanvasActivityLogListRelationFilter
    comments?: CanvasCommentListRelationFilter
  }, "id">

  export type CanvasOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrderInput | SortOrder
    thumbnailGeneratedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CanvasCountOrderByAggregateInput
    _avg?: CanvasAvgOrderByAggregateInput
    _max?: CanvasMaxOrderByAggregateInput
    _min?: CanvasMinOrderByAggregateInput
    _sum?: CanvasSumOrderByAggregateInput
  }

  export type CanvasScalarWhereWithAggregatesInput = {
    AND?: CanvasScalarWhereWithAggregatesInput | CanvasScalarWhereWithAggregatesInput[]
    OR?: CanvasScalarWhereWithAggregatesInput[]
    NOT?: CanvasScalarWhereWithAggregatesInput | CanvasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Canvas"> | string
    workspaceId?: StringWithAggregatesFilter<"Canvas"> | string
    name?: StringWithAggregatesFilter<"Canvas"> | string
    description?: StringNullableWithAggregatesFilter<"Canvas"> | string | null
    version?: IntWithAggregatesFilter<"Canvas"> | number
    visibility?: EnumCanvasVisibilityWithAggregatesFilter<"Canvas"> | $Enums.CanvasVisibility
    createdBy?: StringWithAggregatesFilter<"Canvas"> | string
    thumbnailS3Key?: StringNullableWithAggregatesFilter<"Canvas"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableWithAggregatesFilter<"Canvas"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Canvas"> | Date | string
  }

  export type CanvasInvitationWhereInput = {
    AND?: CanvasInvitationWhereInput | CanvasInvitationWhereInput[]
    OR?: CanvasInvitationWhereInput[]
    NOT?: CanvasInvitationWhereInput | CanvasInvitationWhereInput[]
    id?: StringFilter<"CanvasInvitation"> | string
    canvasId?: StringFilter<"CanvasInvitation"> | string
    email?: StringFilter<"CanvasInvitation"> | string
    accessLevel?: EnumCanvasAccessLevelFilter<"CanvasInvitation"> | $Enums.CanvasAccessLevel
    permissions?: JsonNullableFilter<"CanvasInvitation">
    invitedBy?: StringFilter<"CanvasInvitation"> | string
    invitedUserId?: StringNullableFilter<"CanvasInvitation"> | string | null
    token?: StringFilter<"CanvasInvitation"> | string
    status?: EnumInvitationStatusFilter<"CanvasInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"CanvasInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"CanvasInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CanvasInvitation"> | Date | string | null
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CanvasInvitationOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    canvas?: CanvasOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
    _relevance?: CanvasInvitationOrderByRelevanceInput
  }

  export type CanvasInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: CanvasInvitationWhereInput | CanvasInvitationWhereInput[]
    OR?: CanvasInvitationWhereInput[]
    NOT?: CanvasInvitationWhereInput | CanvasInvitationWhereInput[]
    canvasId?: StringFilter<"CanvasInvitation"> | string
    email?: StringFilter<"CanvasInvitation"> | string
    accessLevel?: EnumCanvasAccessLevelFilter<"CanvasInvitation"> | $Enums.CanvasAccessLevel
    permissions?: JsonNullableFilter<"CanvasInvitation">
    invitedBy?: StringFilter<"CanvasInvitation"> | string
    invitedUserId?: StringNullableFilter<"CanvasInvitation"> | string | null
    status?: EnumInvitationStatusFilter<"CanvasInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"CanvasInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"CanvasInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CanvasInvitation"> | Date | string | null
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "token">

  export type CanvasInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: CanvasInvitationCountOrderByAggregateInput
    _max?: CanvasInvitationMaxOrderByAggregateInput
    _min?: CanvasInvitationMinOrderByAggregateInput
  }

  export type CanvasInvitationScalarWhereWithAggregatesInput = {
    AND?: CanvasInvitationScalarWhereWithAggregatesInput | CanvasInvitationScalarWhereWithAggregatesInput[]
    OR?: CanvasInvitationScalarWhereWithAggregatesInput[]
    NOT?: CanvasInvitationScalarWhereWithAggregatesInput | CanvasInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvasInvitation"> | string
    canvasId?: StringWithAggregatesFilter<"CanvasInvitation"> | string
    email?: StringWithAggregatesFilter<"CanvasInvitation"> | string
    accessLevel?: EnumCanvasAccessLevelWithAggregatesFilter<"CanvasInvitation"> | $Enums.CanvasAccessLevel
    permissions?: JsonNullableWithAggregatesFilter<"CanvasInvitation">
    invitedBy?: StringWithAggregatesFilter<"CanvasInvitation"> | string
    invitedUserId?: StringNullableWithAggregatesFilter<"CanvasInvitation"> | string | null
    token?: StringWithAggregatesFilter<"CanvasInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"CanvasInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeWithAggregatesFilter<"CanvasInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"CanvasInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"CanvasInvitation"> | Date | string | null
  }

  export type CanvasCollaboratorWhereInput = {
    AND?: CanvasCollaboratorWhereInput | CanvasCollaboratorWhereInput[]
    OR?: CanvasCollaboratorWhereInput[]
    NOT?: CanvasCollaboratorWhereInput | CanvasCollaboratorWhereInput[]
    id?: StringFilter<"CanvasCollaborator"> | string
    canvasId?: StringFilter<"CanvasCollaborator"> | string
    userId?: StringFilter<"CanvasCollaborator"> | string
    accessLevel?: EnumCanvasAccessLevelFilter<"CanvasCollaborator"> | $Enums.CanvasAccessLevel
    canEdit?: BoolFilter<"CanvasCollaborator"> | boolean
    canExecute?: BoolFilter<"CanvasCollaborator"> | boolean
    canDelete?: BoolFilter<"CanvasCollaborator"> | boolean
    canShare?: BoolFilter<"CanvasCollaborator"> | boolean
    canInvite?: BoolFilter<"CanvasCollaborator"> | boolean
    invitedBy?: StringNullableFilter<"CanvasCollaborator"> | string | null
    invitedAt?: DateTimeFilter<"CanvasCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"CanvasCollaborator"> | Date | string | null
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CanvasCollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    canvas?: CanvasOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: CanvasCollaboratorOrderByRelevanceInput
  }

  export type CanvasCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    canvasId_userId?: CanvasCollaboratorCanvasIdUserIdCompoundUniqueInput
    AND?: CanvasCollaboratorWhereInput | CanvasCollaboratorWhereInput[]
    OR?: CanvasCollaboratorWhereInput[]
    NOT?: CanvasCollaboratorWhereInput | CanvasCollaboratorWhereInput[]
    canvasId?: StringFilter<"CanvasCollaborator"> | string
    userId?: StringFilter<"CanvasCollaborator"> | string
    accessLevel?: EnumCanvasAccessLevelFilter<"CanvasCollaborator"> | $Enums.CanvasAccessLevel
    canEdit?: BoolFilter<"CanvasCollaborator"> | boolean
    canExecute?: BoolFilter<"CanvasCollaborator"> | boolean
    canDelete?: BoolFilter<"CanvasCollaborator"> | boolean
    canShare?: BoolFilter<"CanvasCollaborator"> | boolean
    canInvite?: BoolFilter<"CanvasCollaborator"> | boolean
    invitedBy?: StringNullableFilter<"CanvasCollaborator"> | string | null
    invitedAt?: DateTimeFilter<"CanvasCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"CanvasCollaborator"> | Date | string | null
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "canvasId_userId">

  export type CanvasCollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    _count?: CanvasCollaboratorCountOrderByAggregateInput
    _max?: CanvasCollaboratorMaxOrderByAggregateInput
    _min?: CanvasCollaboratorMinOrderByAggregateInput
  }

  export type CanvasCollaboratorScalarWhereWithAggregatesInput = {
    AND?: CanvasCollaboratorScalarWhereWithAggregatesInput | CanvasCollaboratorScalarWhereWithAggregatesInput[]
    OR?: CanvasCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: CanvasCollaboratorScalarWhereWithAggregatesInput | CanvasCollaboratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvasCollaborator"> | string
    canvasId?: StringWithAggregatesFilter<"CanvasCollaborator"> | string
    userId?: StringWithAggregatesFilter<"CanvasCollaborator"> | string
    accessLevel?: EnumCanvasAccessLevelWithAggregatesFilter<"CanvasCollaborator"> | $Enums.CanvasAccessLevel
    canEdit?: BoolWithAggregatesFilter<"CanvasCollaborator"> | boolean
    canExecute?: BoolWithAggregatesFilter<"CanvasCollaborator"> | boolean
    canDelete?: BoolWithAggregatesFilter<"CanvasCollaborator"> | boolean
    canShare?: BoolWithAggregatesFilter<"CanvasCollaborator"> | boolean
    canInvite?: BoolWithAggregatesFilter<"CanvasCollaborator"> | boolean
    invitedBy?: StringNullableWithAggregatesFilter<"CanvasCollaborator"> | string | null
    invitedAt?: DateTimeWithAggregatesFilter<"CanvasCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"CanvasCollaborator"> | Date | string | null
  }

  export type CanvasSessionWhereInput = {
    AND?: CanvasSessionWhereInput | CanvasSessionWhereInput[]
    OR?: CanvasSessionWhereInput[]
    NOT?: CanvasSessionWhereInput | CanvasSessionWhereInput[]
    id?: StringFilter<"CanvasSession"> | string
    canvasId?: StringFilter<"CanvasSession"> | string
    userId?: StringNullableFilter<"CanvasSession"> | string | null
    anonymousName?: StringNullableFilter<"CanvasSession"> | string | null
    sessionToken?: StringNullableFilter<"CanvasSession"> | string | null
    socketId?: StringNullableFilter<"CanvasSession"> | string | null
    cursorPosition?: JsonNullableFilter<"CanvasSession">
    selectedPodIds?: JsonNullableFilter<"CanvasSession">
    viewportState?: JsonNullableFilter<"CanvasSession">
    userColor?: StringNullableFilter<"CanvasSession"> | string | null
    userAgent?: StringNullableFilter<"CanvasSession"> | string | null
    ipAddress?: StringNullableFilter<"CanvasSession"> | string | null
    connectedAt?: DateTimeFilter<"CanvasSession"> | Date | string
    lastHeartbeatAt?: DateTimeFilter<"CanvasSession"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"CanvasSession"> | Date | string | null
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
  }

  export type CanvasSessionOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousName?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    socketId?: SortOrderInput | SortOrder
    cursorPosition?: SortOrderInput | SortOrder
    selectedPodIds?: SortOrderInput | SortOrder
    viewportState?: SortOrderInput | SortOrder
    userColor?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    canvas?: CanvasOrderByWithRelationInput
    _relevance?: CanvasSessionOrderByRelevanceInput
  }

  export type CanvasSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: CanvasSessionWhereInput | CanvasSessionWhereInput[]
    OR?: CanvasSessionWhereInput[]
    NOT?: CanvasSessionWhereInput | CanvasSessionWhereInput[]
    canvasId?: StringFilter<"CanvasSession"> | string
    userId?: StringNullableFilter<"CanvasSession"> | string | null
    anonymousName?: StringNullableFilter<"CanvasSession"> | string | null
    socketId?: StringNullableFilter<"CanvasSession"> | string | null
    cursorPosition?: JsonNullableFilter<"CanvasSession">
    selectedPodIds?: JsonNullableFilter<"CanvasSession">
    viewportState?: JsonNullableFilter<"CanvasSession">
    userColor?: StringNullableFilter<"CanvasSession"> | string | null
    userAgent?: StringNullableFilter<"CanvasSession"> | string | null
    ipAddress?: StringNullableFilter<"CanvasSession"> | string | null
    connectedAt?: DateTimeFilter<"CanvasSession"> | Date | string
    lastHeartbeatAt?: DateTimeFilter<"CanvasSession"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"CanvasSession"> | Date | string | null
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
  }, "id" | "sessionToken">

  export type CanvasSessionOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousName?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    socketId?: SortOrderInput | SortOrder
    cursorPosition?: SortOrderInput | SortOrder
    selectedPodIds?: SortOrderInput | SortOrder
    viewportState?: SortOrderInput | SortOrder
    userColor?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    _count?: CanvasSessionCountOrderByAggregateInput
    _max?: CanvasSessionMaxOrderByAggregateInput
    _min?: CanvasSessionMinOrderByAggregateInput
  }

  export type CanvasSessionScalarWhereWithAggregatesInput = {
    AND?: CanvasSessionScalarWhereWithAggregatesInput | CanvasSessionScalarWhereWithAggregatesInput[]
    OR?: CanvasSessionScalarWhereWithAggregatesInput[]
    NOT?: CanvasSessionScalarWhereWithAggregatesInput | CanvasSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvasSession"> | string
    canvasId?: StringWithAggregatesFilter<"CanvasSession"> | string
    userId?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    anonymousName?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    sessionToken?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    socketId?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    cursorPosition?: JsonNullableWithAggregatesFilter<"CanvasSession">
    selectedPodIds?: JsonNullableWithAggregatesFilter<"CanvasSession">
    viewportState?: JsonNullableWithAggregatesFilter<"CanvasSession">
    userColor?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"CanvasSession"> | string | null
    connectedAt?: DateTimeWithAggregatesFilter<"CanvasSession"> | Date | string
    lastHeartbeatAt?: DateTimeWithAggregatesFilter<"CanvasSession"> | Date | string
    disconnectedAt?: DateTimeNullableWithAggregatesFilter<"CanvasSession"> | Date | string | null
  }

  export type CanvasActivityLogWhereInput = {
    AND?: CanvasActivityLogWhereInput | CanvasActivityLogWhereInput[]
    OR?: CanvasActivityLogWhereInput[]
    NOT?: CanvasActivityLogWhereInput | CanvasActivityLogWhereInput[]
    id?: StringFilter<"CanvasActivityLog"> | string
    canvasId?: StringFilter<"CanvasActivityLog"> | string
    userId?: StringNullableFilter<"CanvasActivityLog"> | string | null
    action?: EnumCanvasActivityActionFilter<"CanvasActivityLog"> | $Enums.CanvasActivityAction
    entityType?: StringNullableFilter<"CanvasActivityLog"> | string | null
    entityId?: StringNullableFilter<"CanvasActivityLog"> | string | null
    changeData?: JsonNullableFilter<"CanvasActivityLog">
    createdAt?: DateTimeFilter<"CanvasActivityLog"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
  }

  export type CanvasActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    changeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    canvas?: CanvasOrderByWithRelationInput
    _relevance?: CanvasActivityLogOrderByRelevanceInput
  }

  export type CanvasActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CanvasActivityLogWhereInput | CanvasActivityLogWhereInput[]
    OR?: CanvasActivityLogWhereInput[]
    NOT?: CanvasActivityLogWhereInput | CanvasActivityLogWhereInput[]
    canvasId?: StringFilter<"CanvasActivityLog"> | string
    userId?: StringNullableFilter<"CanvasActivityLog"> | string | null
    action?: EnumCanvasActivityActionFilter<"CanvasActivityLog"> | $Enums.CanvasActivityAction
    entityType?: StringNullableFilter<"CanvasActivityLog"> | string | null
    entityId?: StringNullableFilter<"CanvasActivityLog"> | string | null
    changeData?: JsonNullableFilter<"CanvasActivityLog">
    createdAt?: DateTimeFilter<"CanvasActivityLog"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
  }, "id">

  export type CanvasActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    changeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CanvasActivityLogCountOrderByAggregateInput
    _max?: CanvasActivityLogMaxOrderByAggregateInput
    _min?: CanvasActivityLogMinOrderByAggregateInput
  }

  export type CanvasActivityLogScalarWhereWithAggregatesInput = {
    AND?: CanvasActivityLogScalarWhereWithAggregatesInput | CanvasActivityLogScalarWhereWithAggregatesInput[]
    OR?: CanvasActivityLogScalarWhereWithAggregatesInput[]
    NOT?: CanvasActivityLogScalarWhereWithAggregatesInput | CanvasActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvasActivityLog"> | string
    canvasId?: StringWithAggregatesFilter<"CanvasActivityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"CanvasActivityLog"> | string | null
    action?: EnumCanvasActivityActionWithAggregatesFilter<"CanvasActivityLog"> | $Enums.CanvasActivityAction
    entityType?: StringNullableWithAggregatesFilter<"CanvasActivityLog"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"CanvasActivityLog"> | string | null
    changeData?: JsonNullableWithAggregatesFilter<"CanvasActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"CanvasActivityLog"> | Date | string
  }

  export type CanvasCommentWhereInput = {
    AND?: CanvasCommentWhereInput | CanvasCommentWhereInput[]
    OR?: CanvasCommentWhereInput[]
    NOT?: CanvasCommentWhereInput | CanvasCommentWhereInput[]
    id?: StringFilter<"CanvasComment"> | string
    canvasId?: StringFilter<"CanvasComment"> | string
    userId?: StringNullableFilter<"CanvasComment"> | string | null
    content?: StringFilter<"CanvasComment"> | string
    position?: JsonNullableFilter<"CanvasComment">
    podId?: StringNullableFilter<"CanvasComment"> | string | null
    parentId?: StringNullableFilter<"CanvasComment"> | string | null
    isResolved?: BoolFilter<"CanvasComment"> | boolean
    resolvedBy?: StringNullableFilter<"CanvasComment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"CanvasComment"> | Date | string | null
    createdAt?: DateTimeFilter<"CanvasComment"> | Date | string
    updatedAt?: DateTimeFilter<"CanvasComment"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
  }

  export type CanvasCommentOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    position?: SortOrderInput | SortOrder
    podId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canvas?: CanvasOrderByWithRelationInput
    _relevance?: CanvasCommentOrderByRelevanceInput
  }

  export type CanvasCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CanvasCommentWhereInput | CanvasCommentWhereInput[]
    OR?: CanvasCommentWhereInput[]
    NOT?: CanvasCommentWhereInput | CanvasCommentWhereInput[]
    canvasId?: StringFilter<"CanvasComment"> | string
    userId?: StringNullableFilter<"CanvasComment"> | string | null
    content?: StringFilter<"CanvasComment"> | string
    position?: JsonNullableFilter<"CanvasComment">
    podId?: StringNullableFilter<"CanvasComment"> | string | null
    parentId?: StringNullableFilter<"CanvasComment"> | string | null
    isResolved?: BoolFilter<"CanvasComment"> | boolean
    resolvedBy?: StringNullableFilter<"CanvasComment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"CanvasComment"> | Date | string | null
    createdAt?: DateTimeFilter<"CanvasComment"> | Date | string
    updatedAt?: DateTimeFilter<"CanvasComment"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
  }, "id">

  export type CanvasCommentOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    position?: SortOrderInput | SortOrder
    podId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CanvasCommentCountOrderByAggregateInput
    _max?: CanvasCommentMaxOrderByAggregateInput
    _min?: CanvasCommentMinOrderByAggregateInput
  }

  export type CanvasCommentScalarWhereWithAggregatesInput = {
    AND?: CanvasCommentScalarWhereWithAggregatesInput | CanvasCommentScalarWhereWithAggregatesInput[]
    OR?: CanvasCommentScalarWhereWithAggregatesInput[]
    NOT?: CanvasCommentScalarWhereWithAggregatesInput | CanvasCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvasComment"> | string
    canvasId?: StringWithAggregatesFilter<"CanvasComment"> | string
    userId?: StringNullableWithAggregatesFilter<"CanvasComment"> | string | null
    content?: StringWithAggregatesFilter<"CanvasComment"> | string
    position?: JsonNullableWithAggregatesFilter<"CanvasComment">
    podId?: StringNullableWithAggregatesFilter<"CanvasComment"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"CanvasComment"> | string | null
    isResolved?: BoolWithAggregatesFilter<"CanvasComment"> | boolean
    resolvedBy?: StringNullableWithAggregatesFilter<"CanvasComment"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"CanvasComment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CanvasComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CanvasComment"> | Date | string
  }

  export type ActionPodWhereInput = {
    AND?: ActionPodWhereInput | ActionPodWhereInput[]
    OR?: ActionPodWhereInput[]
    NOT?: ActionPodWhereInput | ActionPodWhereInput[]
    id?: StringFilter<"ActionPod"> | string
    canvasId?: StringFilter<"ActionPod"> | string
    type?: EnumActionPodTypeFilter<"ActionPod"> | $Enums.ActionPodType
    position?: JsonFilter<"ActionPod">
    executionStatus?: EnumActionPodExecutionStatusFilter<"ActionPod"> | $Enums.ActionPodExecutionStatus
    lastExecutionId?: StringNullableFilter<"ActionPod"> | string | null
    contextCanvasId?: StringNullableFilter<"ActionPod"> | string | null
    documentId?: StringNullableFilter<"ActionPod"> | string | null
    lockedBy?: StringNullableFilter<"ActionPod"> | string | null
    lockedAt?: DateTimeNullableFilter<"ActionPod"> | Date | string | null
    dynamoPartitionKey?: StringFilter<"ActionPod"> | string
    dynamoSortKey?: StringFilter<"ActionPod"> | string
    s3VectorBucket?: StringNullableFilter<"ActionPod"> | string | null
    s3VectorKey?: StringNullableFilter<"ActionPod"> | string | null
    createdAt?: DateTimeFilter<"ActionPod"> | Date | string
    updatedAt?: DateTimeFilter<"ActionPod"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    contextCanvas?: XOR<CanvasNullableScalarRelationFilter, CanvasWhereInput> | null
    document?: XOR<DocumentNullableScalarRelationFilter, DocumentWhereInput> | null
    sourceEdges?: EdgeListRelationFilter
    targetEdges?: EdgeListRelationFilter
    executions?: ActionPodExecutionListRelationFilter
    usageLogs?: PodUsageLogListRelationFilter
  }

  export type ActionPodOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    type?: SortOrder
    position?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrderInput | SortOrder
    contextCanvasId?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrderInput | SortOrder
    s3VectorKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canvas?: CanvasOrderByWithRelationInput
    contextCanvas?: CanvasOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
    sourceEdges?: EdgeOrderByRelationAggregateInput
    targetEdges?: EdgeOrderByRelationAggregateInput
    executions?: ActionPodExecutionOrderByRelationAggregateInput
    usageLogs?: PodUsageLogOrderByRelationAggregateInput
    _relevance?: ActionPodOrderByRelevanceInput
  }

  export type ActionPodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dynamoPartitionKey_dynamoSortKey?: ActionPodDynamoPartitionKeyDynamoSortKeyCompoundUniqueInput
    AND?: ActionPodWhereInput | ActionPodWhereInput[]
    OR?: ActionPodWhereInput[]
    NOT?: ActionPodWhereInput | ActionPodWhereInput[]
    canvasId?: StringFilter<"ActionPod"> | string
    type?: EnumActionPodTypeFilter<"ActionPod"> | $Enums.ActionPodType
    position?: JsonFilter<"ActionPod">
    executionStatus?: EnumActionPodExecutionStatusFilter<"ActionPod"> | $Enums.ActionPodExecutionStatus
    lastExecutionId?: StringNullableFilter<"ActionPod"> | string | null
    contextCanvasId?: StringNullableFilter<"ActionPod"> | string | null
    documentId?: StringNullableFilter<"ActionPod"> | string | null
    lockedBy?: StringNullableFilter<"ActionPod"> | string | null
    lockedAt?: DateTimeNullableFilter<"ActionPod"> | Date | string | null
    dynamoPartitionKey?: StringFilter<"ActionPod"> | string
    dynamoSortKey?: StringFilter<"ActionPod"> | string
    s3VectorBucket?: StringNullableFilter<"ActionPod"> | string | null
    s3VectorKey?: StringNullableFilter<"ActionPod"> | string | null
    createdAt?: DateTimeFilter<"ActionPod"> | Date | string
    updatedAt?: DateTimeFilter<"ActionPod"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    contextCanvas?: XOR<CanvasNullableScalarRelationFilter, CanvasWhereInput> | null
    document?: XOR<DocumentNullableScalarRelationFilter, DocumentWhereInput> | null
    sourceEdges?: EdgeListRelationFilter
    targetEdges?: EdgeListRelationFilter
    executions?: ActionPodExecutionListRelationFilter
    usageLogs?: PodUsageLogListRelationFilter
  }, "id" | "dynamoPartitionKey_dynamoSortKey">

  export type ActionPodOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    type?: SortOrder
    position?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrderInput | SortOrder
    contextCanvasId?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrderInput | SortOrder
    s3VectorKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionPodCountOrderByAggregateInput
    _max?: ActionPodMaxOrderByAggregateInput
    _min?: ActionPodMinOrderByAggregateInput
  }

  export type ActionPodScalarWhereWithAggregatesInput = {
    AND?: ActionPodScalarWhereWithAggregatesInput | ActionPodScalarWhereWithAggregatesInput[]
    OR?: ActionPodScalarWhereWithAggregatesInput[]
    NOT?: ActionPodScalarWhereWithAggregatesInput | ActionPodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionPod"> | string
    canvasId?: StringWithAggregatesFilter<"ActionPod"> | string
    type?: EnumActionPodTypeWithAggregatesFilter<"ActionPod"> | $Enums.ActionPodType
    position?: JsonWithAggregatesFilter<"ActionPod">
    executionStatus?: EnumActionPodExecutionStatusWithAggregatesFilter<"ActionPod"> | $Enums.ActionPodExecutionStatus
    lastExecutionId?: StringNullableWithAggregatesFilter<"ActionPod"> | string | null
    contextCanvasId?: StringNullableWithAggregatesFilter<"ActionPod"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"ActionPod"> | string | null
    lockedBy?: StringNullableWithAggregatesFilter<"ActionPod"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"ActionPod"> | Date | string | null
    dynamoPartitionKey?: StringWithAggregatesFilter<"ActionPod"> | string
    dynamoSortKey?: StringWithAggregatesFilter<"ActionPod"> | string
    s3VectorBucket?: StringNullableWithAggregatesFilter<"ActionPod"> | string | null
    s3VectorKey?: StringNullableWithAggregatesFilter<"ActionPod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActionPod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActionPod"> | Date | string
  }

  export type EdgeWhereInput = {
    AND?: EdgeWhereInput | EdgeWhereInput[]
    OR?: EdgeWhereInput[]
    NOT?: EdgeWhereInput | EdgeWhereInput[]
    id?: StringFilter<"Edge"> | string
    canvasId?: StringFilter<"Edge"> | string
    sourcePodId?: StringFilter<"Edge"> | string
    targetPodId?: StringFilter<"Edge"> | string
    sourceHandle?: StringNullableFilter<"Edge"> | string | null
    targetHandle?: StringNullableFilter<"Edge"> | string | null
    animated?: BoolFilter<"Edge"> | boolean
    createdAt?: DateTimeFilter<"Edge"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    sourcePod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
    targetPod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
  }

  export type EdgeOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrderInput | SortOrder
    targetHandle?: SortOrderInput | SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
    canvas?: CanvasOrderByWithRelationInput
    sourcePod?: ActionPodOrderByWithRelationInput
    targetPod?: ActionPodOrderByWithRelationInput
    _relevance?: EdgeOrderByRelevanceInput
  }

  export type EdgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    canvasId_sourcePodId_sourceHandle_targetPodId_targetHandle?: EdgeCanvasIdSourcePodIdSourceHandleTargetPodIdTargetHandleCompoundUniqueInput
    AND?: EdgeWhereInput | EdgeWhereInput[]
    OR?: EdgeWhereInput[]
    NOT?: EdgeWhereInput | EdgeWhereInput[]
    canvasId?: StringFilter<"Edge"> | string
    sourcePodId?: StringFilter<"Edge"> | string
    targetPodId?: StringFilter<"Edge"> | string
    sourceHandle?: StringNullableFilter<"Edge"> | string | null
    targetHandle?: StringNullableFilter<"Edge"> | string | null
    animated?: BoolFilter<"Edge"> | boolean
    createdAt?: DateTimeFilter<"Edge"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    sourcePod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
    targetPod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
  }, "id" | "canvasId_sourcePodId_sourceHandle_targetPodId_targetHandle">

  export type EdgeOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrderInput | SortOrder
    targetHandle?: SortOrderInput | SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
    _count?: EdgeCountOrderByAggregateInput
    _max?: EdgeMaxOrderByAggregateInput
    _min?: EdgeMinOrderByAggregateInput
  }

  export type EdgeScalarWhereWithAggregatesInput = {
    AND?: EdgeScalarWhereWithAggregatesInput | EdgeScalarWhereWithAggregatesInput[]
    OR?: EdgeScalarWhereWithAggregatesInput[]
    NOT?: EdgeScalarWhereWithAggregatesInput | EdgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Edge"> | string
    canvasId?: StringWithAggregatesFilter<"Edge"> | string
    sourcePodId?: StringWithAggregatesFilter<"Edge"> | string
    targetPodId?: StringWithAggregatesFilter<"Edge"> | string
    sourceHandle?: StringNullableWithAggregatesFilter<"Edge"> | string | null
    targetHandle?: StringNullableWithAggregatesFilter<"Edge"> | string | null
    animated?: BoolWithAggregatesFilter<"Edge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Edge"> | Date | string
  }

  export type ActionPodExecutionWhereInput = {
    AND?: ActionPodExecutionWhereInput | ActionPodExecutionWhereInput[]
    OR?: ActionPodExecutionWhereInput[]
    NOT?: ActionPodExecutionWhereInput | ActionPodExecutionWhereInput[]
    id?: StringFilter<"ActionPodExecution"> | string
    podId?: StringFilter<"ActionPodExecution"> | string
    canvasId?: StringFilter<"ActionPodExecution"> | string
    workspaceId?: StringFilter<"ActionPodExecution"> | string
    status?: EnumActionPodExecutionStatusFilter<"ActionPodExecution"> | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFilter<"ActionPodExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"ActionPodExecution"> | Date | string | null
    runtimeInMs?: IntNullableFilter<"ActionPodExecution"> | number | null
    provider?: EnumLLMProviderFilter<"ActionPodExecution"> | $Enums.LLMProvider
    modelId?: StringFilter<"ActionPodExecution"> | string
    modelName?: StringNullableFilter<"ActionPodExecution"> | string | null
    providerMetadata?: JsonNullableFilter<"ActionPodExecution">
    requestMetadata?: JsonNullableFilter<"ActionPodExecution">
    responseMetadata?: JsonNullableFilter<"ActionPodExecution">
    errorMessage?: StringNullableFilter<"ActionPodExecution"> | string | null
    errorCode?: StringNullableFilter<"ActionPodExecution"> | string | null
    inputTokens?: IntFilter<"ActionPodExecution"> | number
    outputTokens?: IntFilter<"ActionPodExecution"> | number
    reasoningTokens?: IntFilter<"ActionPodExecution"> | number
    creditsConsumed?: IntFilter<"ActionPodExecution"> | number
    costInUsd?: DecimalNullableFilter<"ActionPodExecution"> | Decimal | DecimalJsLike | number | string | null
    pod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
  }

  export type ActionPodExecutionOrderByWithRelationInput = {
    id?: SortOrder
    podId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    requestMetadata?: SortOrderInput | SortOrder
    responseMetadata?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrderInput | SortOrder
    pod?: ActionPodOrderByWithRelationInput
    _relevance?: ActionPodExecutionOrderByRelevanceInput
  }

  export type ActionPodExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionPodExecutionWhereInput | ActionPodExecutionWhereInput[]
    OR?: ActionPodExecutionWhereInput[]
    NOT?: ActionPodExecutionWhereInput | ActionPodExecutionWhereInput[]
    podId?: StringFilter<"ActionPodExecution"> | string
    canvasId?: StringFilter<"ActionPodExecution"> | string
    workspaceId?: StringFilter<"ActionPodExecution"> | string
    status?: EnumActionPodExecutionStatusFilter<"ActionPodExecution"> | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFilter<"ActionPodExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"ActionPodExecution"> | Date | string | null
    runtimeInMs?: IntNullableFilter<"ActionPodExecution"> | number | null
    provider?: EnumLLMProviderFilter<"ActionPodExecution"> | $Enums.LLMProvider
    modelId?: StringFilter<"ActionPodExecution"> | string
    modelName?: StringNullableFilter<"ActionPodExecution"> | string | null
    providerMetadata?: JsonNullableFilter<"ActionPodExecution">
    requestMetadata?: JsonNullableFilter<"ActionPodExecution">
    responseMetadata?: JsonNullableFilter<"ActionPodExecution">
    errorMessage?: StringNullableFilter<"ActionPodExecution"> | string | null
    errorCode?: StringNullableFilter<"ActionPodExecution"> | string | null
    inputTokens?: IntFilter<"ActionPodExecution"> | number
    outputTokens?: IntFilter<"ActionPodExecution"> | number
    reasoningTokens?: IntFilter<"ActionPodExecution"> | number
    creditsConsumed?: IntFilter<"ActionPodExecution"> | number
    costInUsd?: DecimalNullableFilter<"ActionPodExecution"> | Decimal | DecimalJsLike | number | string | null
    pod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
  }, "id">

  export type ActionPodExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    podId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    requestMetadata?: SortOrderInput | SortOrder
    responseMetadata?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrderInput | SortOrder
    _count?: ActionPodExecutionCountOrderByAggregateInput
    _avg?: ActionPodExecutionAvgOrderByAggregateInput
    _max?: ActionPodExecutionMaxOrderByAggregateInput
    _min?: ActionPodExecutionMinOrderByAggregateInput
    _sum?: ActionPodExecutionSumOrderByAggregateInput
  }

  export type ActionPodExecutionScalarWhereWithAggregatesInput = {
    AND?: ActionPodExecutionScalarWhereWithAggregatesInput | ActionPodExecutionScalarWhereWithAggregatesInput[]
    OR?: ActionPodExecutionScalarWhereWithAggregatesInput[]
    NOT?: ActionPodExecutionScalarWhereWithAggregatesInput | ActionPodExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionPodExecution"> | string
    podId?: StringWithAggregatesFilter<"ActionPodExecution"> | string
    canvasId?: StringWithAggregatesFilter<"ActionPodExecution"> | string
    workspaceId?: StringWithAggregatesFilter<"ActionPodExecution"> | string
    status?: EnumActionPodExecutionStatusWithAggregatesFilter<"ActionPodExecution"> | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeWithAggregatesFilter<"ActionPodExecution"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"ActionPodExecution"> | Date | string | null
    runtimeInMs?: IntNullableWithAggregatesFilter<"ActionPodExecution"> | number | null
    provider?: EnumLLMProviderWithAggregatesFilter<"ActionPodExecution"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"ActionPodExecution"> | string
    modelName?: StringNullableWithAggregatesFilter<"ActionPodExecution"> | string | null
    providerMetadata?: JsonNullableWithAggregatesFilter<"ActionPodExecution">
    requestMetadata?: JsonNullableWithAggregatesFilter<"ActionPodExecution">
    responseMetadata?: JsonNullableWithAggregatesFilter<"ActionPodExecution">
    errorMessage?: StringNullableWithAggregatesFilter<"ActionPodExecution"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"ActionPodExecution"> | string | null
    inputTokens?: IntWithAggregatesFilter<"ActionPodExecution"> | number
    outputTokens?: IntWithAggregatesFilter<"ActionPodExecution"> | number
    reasoningTokens?: IntWithAggregatesFilter<"ActionPodExecution"> | number
    creditsConsumed?: IntWithAggregatesFilter<"ActionPodExecution"> | number
    costInUsd?: DecimalNullableWithAggregatesFilter<"ActionPodExecution"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogWhereInput = {
    AND?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    OR?: PodUsageLogWhereInput[]
    NOT?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    id?: StringFilter<"PodUsageLog"> | string
    podId?: StringFilter<"PodUsageLog"> | string
    executionId?: StringFilter<"PodUsageLog"> | string
    canvasId?: StringFilter<"PodUsageLog"> | string
    workspaceId?: StringFilter<"PodUsageLog"> | string
    subscriptionId?: StringFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodUsageLog"> | string
    modelName?: StringNullableFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableFilter<"PodUsageLog">
    inputTokens?: IntFilter<"PodUsageLog"> | number
    outputTokens?: IntFilter<"PodUsageLog"> | number
    reasoningTokens?: IntFilter<"PodUsageLog"> | number
    creditsConsumed?: IntFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFilter<"PodUsageLog"> | Date | string
    pod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type PodUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
    pod?: ActionPodOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: PodUsageLogOrderByRelevanceInput
  }

  export type PodUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    OR?: PodUsageLogWhereInput[]
    NOT?: PodUsageLogWhereInput | PodUsageLogWhereInput[]
    podId?: StringFilter<"PodUsageLog"> | string
    executionId?: StringFilter<"PodUsageLog"> | string
    canvasId?: StringFilter<"PodUsageLog"> | string
    workspaceId?: StringFilter<"PodUsageLog"> | string
    subscriptionId?: StringFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodUsageLog"> | string
    modelName?: StringNullableFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableFilter<"PodUsageLog">
    inputTokens?: IntFilter<"PodUsageLog"> | number
    outputTokens?: IntFilter<"PodUsageLog"> | number
    reasoningTokens?: IntFilter<"PodUsageLog"> | number
    creditsConsumed?: IntFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFilter<"PodUsageLog"> | Date | string
    pod?: XOR<ActionPodScalarRelationFilter, ActionPodWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type PodUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrderInput | SortOrder
    providerMetadata?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrderInput | SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
    _count?: PodUsageLogCountOrderByAggregateInput
    _avg?: PodUsageLogAvgOrderByAggregateInput
    _max?: PodUsageLogMaxOrderByAggregateInput
    _min?: PodUsageLogMinOrderByAggregateInput
    _sum?: PodUsageLogSumOrderByAggregateInput
  }

  export type PodUsageLogScalarWhereWithAggregatesInput = {
    AND?: PodUsageLogScalarWhereWithAggregatesInput | PodUsageLogScalarWhereWithAggregatesInput[]
    OR?: PodUsageLogScalarWhereWithAggregatesInput[]
    NOT?: PodUsageLogScalarWhereWithAggregatesInput | PodUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PodUsageLog"> | string
    podId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    executionId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    canvasId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    workspaceId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    subscriptionId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderWithAggregatesFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringWithAggregatesFilter<"PodUsageLog"> | string
    modelName?: StringNullableWithAggregatesFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableWithAggregatesFilter<"PodUsageLog">
    inputTokens?: IntWithAggregatesFilter<"PodUsageLog"> | number
    outputTokens?: IntWithAggregatesFilter<"PodUsageLog"> | number
    reasoningTokens?: IntWithAggregatesFilter<"PodUsageLog"> | number
    creditsConsumed?: IntWithAggregatesFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableWithAggregatesFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalWithAggregatesFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeWithAggregatesFilter<"PodUsageLog"> | Date | string
  }

  export type ContextModuleWhereInput = {
    AND?: ContextModuleWhereInput | ContextModuleWhereInput[]
    OR?: ContextModuleWhereInput[]
    NOT?: ContextModuleWhereInput | ContextModuleWhereInput[]
    id?: StringFilter<"ContextModule"> | string
    workspaceId?: StringFilter<"ContextModule"> | string
    name?: StringFilter<"ContextModule"> | string
    description?: StringNullableFilter<"ContextModule"> | string | null
    definitionJson?: JsonFilter<"ContextModule">
    originalCanvasId?: StringNullableFilter<"ContextModule"> | string | null
    version?: IntFilter<"ContextModule"> | number
    createdAt?: DateTimeFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeFilter<"ContextModule"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    originalCanvas?: XOR<CanvasNullableScalarRelationFilter, CanvasWhereInput> | null
  }

  export type ContextModuleOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    definitionJson?: SortOrder
    originalCanvasId?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    originalCanvas?: CanvasOrderByWithRelationInput
    _relevance?: ContextModuleOrderByRelevanceInput
  }

  export type ContextModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextModuleWhereInput | ContextModuleWhereInput[]
    OR?: ContextModuleWhereInput[]
    NOT?: ContextModuleWhereInput | ContextModuleWhereInput[]
    workspaceId?: StringFilter<"ContextModule"> | string
    name?: StringFilter<"ContextModule"> | string
    description?: StringNullableFilter<"ContextModule"> | string | null
    definitionJson?: JsonFilter<"ContextModule">
    originalCanvasId?: StringNullableFilter<"ContextModule"> | string | null
    version?: IntFilter<"ContextModule"> | number
    createdAt?: DateTimeFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeFilter<"ContextModule"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    originalCanvas?: XOR<CanvasNullableScalarRelationFilter, CanvasWhereInput> | null
  }, "id">

  export type ContextModuleOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    definitionJson?: SortOrder
    originalCanvasId?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContextModuleCountOrderByAggregateInput
    _avg?: ContextModuleAvgOrderByAggregateInput
    _max?: ContextModuleMaxOrderByAggregateInput
    _min?: ContextModuleMinOrderByAggregateInput
    _sum?: ContextModuleSumOrderByAggregateInput
  }

  export type ContextModuleScalarWhereWithAggregatesInput = {
    AND?: ContextModuleScalarWhereWithAggregatesInput | ContextModuleScalarWhereWithAggregatesInput[]
    OR?: ContextModuleScalarWhereWithAggregatesInput[]
    NOT?: ContextModuleScalarWhereWithAggregatesInput | ContextModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextModule"> | string
    workspaceId?: StringWithAggregatesFilter<"ContextModule"> | string
    name?: StringWithAggregatesFilter<"ContextModule"> | string
    description?: StringNullableWithAggregatesFilter<"ContextModule"> | string | null
    definitionJson?: JsonWithAggregatesFilter<"ContextModule">
    originalCanvasId?: StringNullableWithAggregatesFilter<"ContextModule"> | string | null
    version?: IntWithAggregatesFilter<"ContextModule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContextModule"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    workspaces?: WorkspaceUserListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    canvasCollaborations?: CanvasCollaboratorListRelationFilter
    sentWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    receivedWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    sentCanvasInvites?: CanvasInvitationListRelationFilter
    receivedCanvasInvites?: CanvasInvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    workspaces?: WorkspaceUserOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    canvasCollaborations?: CanvasCollaboratorOrderByRelationAggregateInput
    sentWorkspaceInvites?: WorkspaceInvitationOrderByRelationAggregateInput
    receivedWorkspaceInvites?: WorkspaceInvitationOrderByRelationAggregateInput
    sentCanvasInvites?: CanvasInvitationOrderByRelationAggregateInput
    receivedCanvasInvites?: CanvasInvitationOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    workspaces?: WorkspaceUserListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    canvasCollaborations?: CanvasCollaboratorListRelationFilter
    sentWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    receivedWorkspaceInvites?: WorkspaceInvitationListRelationFilter
    sentCanvasInvites?: CanvasInvitationListRelationFilter
    receivedCanvasInvites?: CanvasInvitationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    hash?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    deviceName?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: RefreshTokenOrderByRelevanceInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    userId_deviceName?: RefreshTokenUserIdDeviceNameCompoundUniqueInput
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    deviceName?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "userId_deviceName">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    deviceName?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    provider?: EnumAuthProviderFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    provider?: EnumAuthProviderFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    provider?: EnumAuthProviderWithAggregatesFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    type?: EnumWorkspaceTypeFilter<"Workspace"> | $Enums.WorkspaceType
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceUserListRelationFilter
    canvases?: CanvasListRelationFilter
    documents?: DocumentListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    contextModules?: ContextModuleListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
    apiKeys?: ProviderAPIKeyListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: WorkspaceUserOrderByRelationAggregateInput
    canvases?: CanvasOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    contextModules?: ContextModuleOrderByRelationAggregateInput
    shareLinks?: ShareLinkOrderByRelationAggregateInput
    apiKeys?: ProviderAPIKeyOrderByRelationAggregateInput
    invitations?: WorkspaceInvitationOrderByRelationAggregateInput
    _relevance?: WorkspaceOrderByRelevanceInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    type?: EnumWorkspaceTypeFilter<"Workspace"> | $Enums.WorkspaceType
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceUserListRelationFilter
    canvases?: CanvasListRelationFilter
    documents?: DocumentListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    contextModules?: ContextModuleListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
    apiKeys?: ProviderAPIKeyListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
  }, "id">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    type?: EnumWorkspaceTypeWithAggregatesFilter<"Workspace"> | $Enums.WorkspaceType
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceUserWhereInput = {
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceUser"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    _relevance?: WorkspaceUserOrderByRelevanceInput
  }

  export type WorkspaceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_workspaceId?: WorkspaceUserUserIdWorkspaceIdCompoundUniqueInput
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    userId?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceUser"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "userId_workspaceId">

  export type WorkspaceUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    _count?: WorkspaceUserCountOrderByAggregateInput
    _max?: WorkspaceUserMaxOrderByAggregateInput
    _min?: WorkspaceUserMinOrderByAggregateInput
  }

  export type WorkspaceUserScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    OR?: WorkspaceUserScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleWithAggregatesFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolWithAggregatesFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableWithAggregatesFilter<"WorkspaceUser"> | string | null
  }

  export type WorkspaceInvitationWhereInput = {
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableFilter<"WorkspaceInvitation">
    invitedBy?: StringFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    token?: StringFilter<"WorkspaceInvitation"> | string
    status?: EnumInvitationStatusFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WorkspaceInvitationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
    _relevance?: WorkspaceInvitationOrderByRelevanceInput
  }

  export type WorkspaceInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableFilter<"WorkspaceInvitation">
    invitedBy?: StringFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    status?: EnumInvitationStatusFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "token">

  export type WorkspaceInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: WorkspaceInvitationCountOrderByAggregateInput
    _max?: WorkspaceInvitationMaxOrderByAggregateInput
    _min?: WorkspaceInvitationMinOrderByAggregateInput
  }

  export type WorkspaceInvitationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    OR?: WorkspaceInvitationScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    email?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleWithAggregatesFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableWithAggregatesFilter<"WorkspaceInvitation">
    invitedBy?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableWithAggregatesFilter<"WorkspaceInvitation"> | string | null
    token?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceInvitation"> | Date | string | null
  }

  export type ProviderAPIKeyWhereInput = {
    AND?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    OR?: ProviderAPIKeyWhereInput[]
    NOT?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    id?: StringFilter<"ProviderAPIKey"> | string
    workspaceId?: StringFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringFilter<"ProviderAPIKey"> | string
    keyHash?: StringFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableFilter<"ProviderAPIKey">
    endpoint?: StringNullableFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type ProviderAPIKeyOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    _relevance?: ProviderAPIKeyOrderByRelevanceInput
  }

  export type ProviderAPIKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_provider_displayName?: ProviderAPIKeyWorkspaceIdProviderDisplayNameCompoundUniqueInput
    AND?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    OR?: ProviderAPIKeyWhereInput[]
    NOT?: ProviderAPIKeyWhereInput | ProviderAPIKeyWhereInput[]
    workspaceId?: StringFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringFilter<"ProviderAPIKey"> | string
    keyHash?: StringFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableFilter<"ProviderAPIKey">
    endpoint?: StringNullableFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_provider_displayName">

  export type ProviderAPIKeyOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    providerConfig?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ProviderAPIKeyCountOrderByAggregateInput
    _max?: ProviderAPIKeyMaxOrderByAggregateInput
    _min?: ProviderAPIKeyMinOrderByAggregateInput
  }

  export type ProviderAPIKeyScalarWhereWithAggregatesInput = {
    AND?: ProviderAPIKeyScalarWhereWithAggregatesInput | ProviderAPIKeyScalarWhereWithAggregatesInput[]
    OR?: ProviderAPIKeyScalarWhereWithAggregatesInput[]
    NOT?: ProviderAPIKeyScalarWhereWithAggregatesInput | ProviderAPIKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    workspaceId?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderWithAggregatesFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    keyHash?: StringWithAggregatesFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableWithAggregatesFilter<"ProviderAPIKey">
    endpoint?: StringNullableWithAggregatesFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeWithAggregatesFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolWithAggregatesFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProviderAPIKey"> | Date | string | null
  }

  export type ShareLinkWhereInput = {
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[]
    OR?: ShareLinkWhereInput[]
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[]
    id?: StringFilter<"ShareLink"> | string
    publicToken?: StringFilter<"ShareLink"> | string
    assetType?: EnumShareableAssetTypeFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringFilter<"ShareLink"> | string
    workspaceId?: StringFilter<"ShareLink"> | string
    createdBy?: StringFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableFilter<"ShareLink"> | string | null
    viewCount?: IntFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type ShareLinkOrderByWithRelationInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    _relevance?: ShareLinkOrderByRelevanceInput
  }

  export type ShareLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicToken?: string
    assetType_assetId?: ShareLinkAssetTypeAssetIdCompoundUniqueInput
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[]
    OR?: ShareLinkWhereInput[]
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[]
    assetType?: EnumShareableAssetTypeFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringFilter<"ShareLink"> | string
    workspaceId?: StringFilter<"ShareLink"> | string
    createdBy?: StringFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableFilter<"ShareLink"> | string | null
    viewCount?: IntFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "publicToken" | "assetType_assetId">

  export type ShareLinkOrderByWithAggregationInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ShareLinkCountOrderByAggregateInput
    _avg?: ShareLinkAvgOrderByAggregateInput
    _max?: ShareLinkMaxOrderByAggregateInput
    _min?: ShareLinkMinOrderByAggregateInput
    _sum?: ShareLinkSumOrderByAggregateInput
  }

  export type ShareLinkScalarWhereWithAggregatesInput = {
    AND?: ShareLinkScalarWhereWithAggregatesInput | ShareLinkScalarWhereWithAggregatesInput[]
    OR?: ShareLinkScalarWhereWithAggregatesInput[]
    NOT?: ShareLinkScalarWhereWithAggregatesInput | ShareLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShareLink"> | string
    publicToken?: StringWithAggregatesFilter<"ShareLink"> | string
    assetType?: EnumShareableAssetTypeWithAggregatesFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringWithAggregatesFilter<"ShareLink"> | string
    workspaceId?: StringWithAggregatesFilter<"ShareLink"> | string
    createdBy?: StringWithAggregatesFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelWithAggregatesFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableWithAggregatesFilter<"ShareLink"> | string | null
    viewCount?: IntWithAggregatesFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ShareLink"> | Date | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    workspaceId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    storageKey?: StringFilter<"Document"> | string
    s3Bucket?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    sizeInBytes?: BigIntFilter<"Document"> | bigint | number
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    embeddings?: EmbeddingListRelationFilter
    actionPods?: ActionPodListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    embeddings?: EmbeddingOrderByRelationAggregateInput
    actionPods?: ActionPodOrderByRelationAggregateInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storageKey?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    workspaceId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    s3Bucket?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    sizeInBytes?: BigIntFilter<"Document"> | bigint | number
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    embeddings?: EmbeddingListRelationFilter
    actionPods?: ActionPodListRelationFilter
  }, "id" | "storageKey">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    workspaceId?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    storageKey?: StringWithAggregatesFilter<"Document"> | string
    s3Bucket?: StringWithAggregatesFilter<"Document"> | string
    fileType?: StringWithAggregatesFilter<"Document"> | string
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    sizeInBytes?: BigIntWithAggregatesFilter<"Document"> | bigint | number
    status?: EnumDocumentStatusWithAggregatesFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Document">
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type EmbeddingWhereInput = {
    AND?: EmbeddingWhereInput | EmbeddingWhereInput[]
    OR?: EmbeddingWhereInput[]
    NOT?: EmbeddingWhereInput | EmbeddingWhereInput[]
    id?: StringFilter<"Embedding"> | string
    documentId?: StringFilter<"Embedding"> | string
    model?: StringFilter<"Embedding"> | string
    chunkIndex?: IntFilter<"Embedding"> | number
    chunkText?: StringFilter<"Embedding"> | string
    s3VectorBucket?: StringFilter<"Embedding"> | string
    s3VectorKey?: StringFilter<"Embedding"> | string
    vectorDimension?: IntFilter<"Embedding"> | number
    metadata?: JsonNullableFilter<"Embedding">
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type EmbeddingOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    _relevance?: EmbeddingOrderByRelevanceInput
  }

  export type EmbeddingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId_chunkIndex?: EmbeddingDocumentIdChunkIndexCompoundUniqueInput
    s3VectorBucket_s3VectorKey?: EmbeddingS3VectorBucketS3VectorKeyCompoundUniqueInput
    AND?: EmbeddingWhereInput | EmbeddingWhereInput[]
    OR?: EmbeddingWhereInput[]
    NOT?: EmbeddingWhereInput | EmbeddingWhereInput[]
    documentId?: StringFilter<"Embedding"> | string
    model?: StringFilter<"Embedding"> | string
    chunkIndex?: IntFilter<"Embedding"> | number
    chunkText?: StringFilter<"Embedding"> | string
    s3VectorBucket?: StringFilter<"Embedding"> | string
    s3VectorKey?: StringFilter<"Embedding"> | string
    vectorDimension?: IntFilter<"Embedding"> | number
    metadata?: JsonNullableFilter<"Embedding">
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id" | "documentId_chunkIndex" | "s3VectorBucket_s3VectorKey">

  export type EmbeddingOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmbeddingCountOrderByAggregateInput
    _avg?: EmbeddingAvgOrderByAggregateInput
    _max?: EmbeddingMaxOrderByAggregateInput
    _min?: EmbeddingMinOrderByAggregateInput
    _sum?: EmbeddingSumOrderByAggregateInput
  }

  export type EmbeddingScalarWhereWithAggregatesInput = {
    AND?: EmbeddingScalarWhereWithAggregatesInput | EmbeddingScalarWhereWithAggregatesInput[]
    OR?: EmbeddingScalarWhereWithAggregatesInput[]
    NOT?: EmbeddingScalarWhereWithAggregatesInput | EmbeddingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Embedding"> | string
    documentId?: StringWithAggregatesFilter<"Embedding"> | string
    model?: StringWithAggregatesFilter<"Embedding"> | string
    chunkIndex?: IntWithAggregatesFilter<"Embedding"> | number
    chunkText?: StringWithAggregatesFilter<"Embedding"> | string
    s3VectorBucket?: StringWithAggregatesFilter<"Embedding"> | string
    s3VectorKey?: StringWithAggregatesFilter<"Embedding"> | string
    vectorDimension?: IntWithAggregatesFilter<"Embedding"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Embedding">
    createdAt?: DateTimeWithAggregatesFilter<"Embedding"> | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionCreateInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
    admin: AdminCreateNestedOneWithoutSessionsInput
  }

  export type AdminSessionUncheckedCreateInput = {
    id?: string
    adminId: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type AdminSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionCreateManyInput = {
    id?: string
    adminId: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
    admin?: AdminCreateNestedOneWithoutAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    adminId?: string | null
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    adminId?: string | null
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionCreateInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutPermissionsInput
  }

  export type AdminPermissionUncheckedCreateInput = {
    id?: string
    adminId: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type AdminPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionCreateManyInput = {
    id?: string
    adminId: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyCreateInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutApiKeysInput
  }

  export type AdminAPIKeyUncheckedCreateInput = {
    id?: string
    adminId: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type AdminAPIKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyCreateManyInput = {
    id?: string
    adminId: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationCreateInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    inviter: AdminCreateNestedOneWithoutInvitationsInput
  }

  export type AdminInvitationUncheckedCreateInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    invitedBy: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviter?: AdminUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type AdminInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationCreateManyInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    invitedBy: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminSecurityEventCreateInput = {
    id?: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId?: string | null
    ipAddress: string
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type AdminSecurityEventUncheckedCreateInput = {
    id?: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId?: string | null
    ipAddress: string
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type AdminSecurityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSecurityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSecurityEventCreateManyInput = {
    id?: string
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    adminId?: string | null
    ipAddress: string
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type AdminSecurityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSecurityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseCreateInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutCreditPurchasesInput
  }

  export type CreditPurchaseUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutCreditPurchasesNestedInput
  }

  export type CreditPurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseCreateManyInput = {
    id?: string
    subscriptionId: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogCreateInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutCreditUsageInput
  }

  export type CreditUsageLogUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutCreditUsageNestedInput
  }

  export type CreditUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogCreateManyInput = {
    id?: string
    subscriptionId: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierCreateInput = {
    id?: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description?: string | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens?: number
    maxTokens?: number | null
    maxOutputTokens?: number | null
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelPricingTierUncheckedCreateInput = {
    id?: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description?: string | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens?: number
    maxTokens?: number | null
    maxOutputTokens?: number | null
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelPricingTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierCreateManyInput = {
    id?: string
    provider: $Enums.LLMProvider
    modelId: string
    category: $Enums.ModelCategory
    displayName: string
    description?: string | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens: number
    creditsPerMillionOutputTokens: number
    creditsPerMillionReasoningTokens?: number
    maxTokens?: number | null
    maxOutputTokens?: number | null
    supportsStreaming?: boolean
    supportsVision?: boolean
    supportsAudio?: boolean
    supportsVideo?: boolean
    supportsFunctions?: boolean
    supportsJsonMode?: boolean
    supportsSystemPrompt?: boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelPricingTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    category?: EnumModelCategoryFieldUpdateOperationsInput | $Enums.ModelCategory
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsPerMillionInputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionOutputTokens?: IntFieldUpdateOperationsInput | number
    creditsPerMillionReasoningTokens?: IntFieldUpdateOperationsInput | number
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    maxOutputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsAudio?: BoolFieldUpdateOperationsInput | boolean
    supportsVideo?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctions?: BoolFieldUpdateOperationsInput | boolean
    supportsJsonMode?: BoolFieldUpdateOperationsInput | boolean
    supportsSystemPrompt?: BoolFieldUpdateOperationsInput | boolean
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasInvitationCreateInput = {
    id?: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    canvas: CanvasCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentCanvasInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedCanvasInvitesInput
  }

  export type CanvasInvitationUncheckedCreateInput = {
    id?: string
    canvasId: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canvas?: CanvasUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentCanvasInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedCanvasInvitesNestedInput
  }

  export type CanvasInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationCreateManyInput = {
    id?: string
    canvasId: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasCollaboratorCreateInput = {
    id?: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
    canvas: CanvasCreateNestedOneWithoutCollaboratorsInput
    user: UserCreateNestedOneWithoutCanvasCollaborationsInput
  }

  export type CanvasCollaboratorUncheckedCreateInput = {
    id?: string
    canvasId: string
    userId: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type CanvasCollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canvas?: CanvasUpdateOneRequiredWithoutCollaboratorsNestedInput
    user?: UserUpdateOneRequiredWithoutCanvasCollaborationsNestedInput
  }

  export type CanvasCollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasCollaboratorCreateManyInput = {
    id?: string
    canvasId: string
    userId: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type CanvasCollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasCollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasSessionCreateInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
    canvas: CanvasCreateNestedOneWithoutSessionsInput
  }

  export type CanvasSessionUncheckedCreateInput = {
    id?: string
    canvasId: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type CanvasSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canvas?: CanvasUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type CanvasSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasSessionCreateManyInput = {
    id?: string
    canvasId: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type CanvasSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasActivityLogCreateInput = {
    id?: string
    userId?: string | null
    action: $Enums.CanvasActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActivityLogInput
  }

  export type CanvasActivityLogUncheckedCreateInput = {
    id?: string
    canvasId: string
    userId?: string | null
    action: $Enums.CanvasActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CanvasActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type CanvasActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasActivityLogCreateManyInput = {
    id?: string
    canvasId: string
    userId?: string | null
    action: $Enums.CanvasActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CanvasActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCommentCreateInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutCommentsInput
  }

  export type CanvasCommentUncheckedCreateInput = {
    id?: string
    canvasId: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CanvasCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCommentCreateManyInput = {
    id?: string
    canvasId: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodCreateInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodCreateManyInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionPodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeCreateInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutEdgesInput
    sourcePod: ActionPodCreateNestedOneWithoutSourceEdgesInput
    targetPod: ActionPodCreateNestedOneWithoutTargetEdgesInput
  }

  export type EdgeUncheckedCreateInput = {
    id?: string
    canvasId: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutEdgesNestedInput
    sourcePod?: ActionPodUpdateOneRequiredWithoutSourceEdgesNestedInput
    targetPod?: ActionPodUpdateOneRequiredWithoutTargetEdgesNestedInput
  }

  export type EdgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeCreateManyInput = {
    id?: string
    canvasId: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodExecutionCreateInput = {
    id?: string
    canvasId: string
    workspaceId: string
    status?: $Enums.ActionPodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
    pod: ActionPodCreateNestedOneWithoutExecutionsInput
  }

  export type ActionPodExecutionUncheckedCreateInput = {
    id?: string
    podId: string
    canvasId: string
    workspaceId: string
    status?: $Enums.ActionPodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pod?: ActionPodUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type ActionPodExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionCreateManyInput = {
    id?: string
    podId: string
    canvasId: string
    workspaceId: string
    status?: $Enums.ActionPodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogCreateInput = {
    id?: string
    executionId: string
    canvasId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
    pod: ActionPodCreateNestedOneWithoutUsageLogsInput
    subscription: SubscriptionCreateNestedOneWithoutUsageLogsInput
  }

  export type PodUsageLogUncheckedCreateInput = {
    id?: string
    podId: string
    executionId: string
    canvasId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: ActionPodUpdateOneRequiredWithoutUsageLogsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type PodUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogCreateManyInput = {
    id?: string
    podId: string
    executionId: string
    canvasId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutContextModulesInput
    originalCanvas?: CanvasCreateNestedOneWithoutContextModulesInput
  }

  export type ContextModuleUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalCanvasId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutContextModulesNestedInput
    originalCanvas?: CanvasUpdateOneWithoutContextModulesNestedInput
  }

  export type ContextModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalCanvasId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    deviceName: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    deviceName: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserCreateInput = {
    id?: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceUserUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInvitationCreateInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentWorkspaceInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationCreateManyInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyCreateInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutApiKeysInput
  }

  export type ProviderAPIKeyUncheckedCreateInput = {
    id?: string
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ProviderAPIKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyCreateManyInput = {
    id?: string
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkCreateInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutShareLinksInput
  }

  export type ShareLinkUncheckedCreateInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    workspaceId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutShareLinksNestedInput
  }

  export type ShareLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkCreateManyInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    workspaceId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    actionPods?: ActionPodCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    actionPods?: ActionPodUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    actionPods?: ActionPodUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutEmbeddingsInput
  }

  export type EmbeddingUncheckedCreateInput = {
    id?: string
    documentId: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutEmbeddingsNestedInput
  }

  export type EmbeddingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateManyInput = {
    id?: string
    documentId: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type EnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminSessionListRelationFilter = {
    every?: AdminSessionWhereInput
    some?: AdminSessionWhereInput
    none?: AdminSessionWhereInput
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type AdminPermissionListRelationFilter = {
    every?: AdminPermissionWhereInput
    some?: AdminPermissionWhereInput
    none?: AdminPermissionWhereInput
  }

  export type AdminAPIKeyListRelationFilter = {
    every?: AdminAPIKeyWhereInput
    some?: AdminAPIKeyWhereInput
    none?: AdminAPIKeyWhereInput
  }

  export type AdminInvitationListRelationFilter = {
    every?: AdminInvitationWhereInput
    some?: AdminInvitationWhereInput
    none?: AdminInvitationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAPIKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrder
    mfaBackupCodes?: SortOrder
    mfaVerifiedAt?: SortOrder
    allowedIpAddresses?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrder
    mfaVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    isSuperAdmin?: SortOrder
    requiresMfa?: SortOrder
    mfaSecret?: SortOrder
    mfaVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type EnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AdminSessionOrderByRelevanceInput = {
    fields: AdminSessionOrderByRelevanceFieldEnum | AdminSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminSessionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
  }

  export type AdminSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
  }

  export type AdminSessionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
  }

  export type EnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type EnumAdminResourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceFilter<$PrismaModel> | $Enums.AdminResource
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AdminAuditLogOrderByRelevanceInput = {
    fields: AdminAuditLogOrderByRelevanceFieldEnum | AdminAuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    changesBefore?: SortOrder
    changesAfter?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogAvgOrderByAggregateInput = {
    status?: SortOrder
    executionTimeMs?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    method?: SortOrder
    endpoint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogSumOrderByAggregateInput = {
    status?: SortOrder
    executionTimeMs?: SortOrder
  }

  export type EnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type EnumAdminResourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSpecificPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionFilter<$PrismaModel> | $Enums.SpecificPermission
  }

  export type EnumAdminResourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableFilter<$PrismaModel> | $Enums.AdminResource | null
  }

  export type AdminPermissionOrderByRelevanceInput = {
    fields: AdminPermissionOrderByRelevanceFieldEnum | AdminPermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminPermissionAdminIdPermissionResourceCompoundUniqueInput = {
    adminId: string
    permission: $Enums.SpecificPermission
    resource: $Enums.AdminResource
  }

  export type AdminPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
  }

  export type AdminPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
  }

  export type AdminPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    resource?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumSpecificPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionWithAggregatesFilter<$PrismaModel> | $Enums.SpecificPermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecificPermissionFilter<$PrismaModel>
    _max?: NestedEnumSpecificPermissionFilter<$PrismaModel>
  }

  export type EnumAdminResourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminAPIKeyOrderByRelevanceInput = {
    fields: AdminAPIKeyOrderByRelevanceFieldEnum | AdminAPIKeyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminAPIKeyCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    allowedIps?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type AdminAPIKeyAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type AdminAPIKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type AdminAPIKeyMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type AdminAPIKeySumOrderByAggregateInput = {
    rateLimit?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AdminInvitationOrderByRelevanceInput = {
    fields: AdminInvitationOrderByRelevanceFieldEnum | AdminInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type AdminInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type AdminInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type AdminSecurityEventOrderByRelevanceInput = {
    fields: AdminSecurityEventOrderByRelevanceFieldEnum | AdminSecurityEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminSecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type EnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type PodUsageLogListRelationFilter = {
    every?: PodUsageLogWhereInput
    some?: PodUsageLogWhereInput
    none?: PodUsageLogWhereInput
  }

  export type CreditPurchaseListRelationFilter = {
    every?: CreditPurchaseWhereInput
    some?: CreditPurchaseWhereInput
    none?: CreditPurchaseWhereInput
  }

  export type CreditUsageLogListRelationFilter = {
    every?: CreditUsageLogWhereInput
    some?: CreditUsageLogWhereInput
    none?: CreditUsageLogWhereInput
  }

  export type PodUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    creditResetDate?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
    canInviteToWorkspace?: SortOrder
    canInviteToCanvas?: SortOrder
    canCreatePublicLinks?: SortOrder
    canUseAdvancedModels?: SortOrder
    canAccessAnalytics?: SortOrder
    canExportData?: SortOrder
    nextBillingDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    isByokMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    credits?: SortOrder
    monthlyCreditQuota?: SortOrder
    maxCanvases?: SortOrder
    maxActionPodsPerCanvas?: SortOrder
    maxDocumentSizeInMB?: SortOrder
    maxCollaboratorsPerCanvas?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type CreditPurchaseOrderByRelevanceInput = {
    fields: CreditPurchaseOrderByRelevanceFieldEnum | CreditPurchaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CreditPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
  }

  export type CreditPurchaseAvgOrderByAggregateInput = {
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
  }

  export type CreditPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
  }

  export type CreditPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
  }

  export type CreditPurchaseSumOrderByAggregateInput = {
    creditsPurchased?: SortOrder
    amountPaid?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumLLMProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderFilter<$PrismaModel> | $Enums.LLMProvider
  }

  export type CreditUsageLogOrderByRelevanceInput = {
    fields: CreditUsageLogOrderByRelevanceFieldEnum | CreditUsageLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CreditUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditUsageLogAvgOrderByAggregateInput = {
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type CreditUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    workspaceId?: SortOrder
    canvasId?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditUsageLogSumOrderByAggregateInput = {
    creditsUsed?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type EnumLLMProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderWithAggregatesFilter<$PrismaModel> | $Enums.LLMProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLLMProviderFilter<$PrismaModel>
    _max?: NestedEnumLLMProviderFilter<$PrismaModel>
  }

  export type EnumModelCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryFilter<$PrismaModel> | $Enums.ModelCategory
  }

  export type ModelPricingTierOrderByRelevanceInput = {
    fields: ModelPricingTierOrderByRelevanceFieldEnum | ModelPricingTierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ModelPricingTierProviderModelIdEffectiveFromCompoundUniqueInput = {
    provider: $Enums.LLMProvider
    modelId: string
    effectiveFrom: Date | string
  }

  export type ModelPricingTierCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    providerConfig?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelPricingTierAvgOrderByAggregateInput = {
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
  }

  export type ModelPricingTierMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelPricingTierMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    category?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
    supportsStreaming?: SortOrder
    supportsVision?: SortOrder
    supportsAudio?: SortOrder
    supportsVideo?: SortOrder
    supportsFunctions?: SortOrder
    supportsJsonMode?: SortOrder
    supportsSystemPrompt?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelPricingTierSumOrderByAggregateInput = {
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    creditsPerMillionInputTokens?: SortOrder
    creditsPerMillionOutputTokens?: SortOrder
    creditsPerMillionReasoningTokens?: SortOrder
    maxTokens?: SortOrder
    maxOutputTokens?: SortOrder
  }

  export type EnumModelCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ModelCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelCategoryFilter<$PrismaModel>
    _max?: NestedEnumModelCategoryFilter<$PrismaModel>
  }

  export type EnumCanvasVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasVisibility | EnumCanvasVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasVisibilityFilter<$PrismaModel> | $Enums.CanvasVisibility
  }

  export type ActionPodListRelationFilter = {
    every?: ActionPodWhereInput
    some?: ActionPodWhereInput
    none?: ActionPodWhereInput
  }

  export type EdgeListRelationFilter = {
    every?: EdgeWhereInput
    some?: EdgeWhereInput
    none?: EdgeWhereInput
  }

  export type ContextModuleListRelationFilter = {
    every?: ContextModuleWhereInput
    some?: ContextModuleWhereInput
    none?: ContextModuleWhereInput
  }

  export type CanvasCollaboratorListRelationFilter = {
    every?: CanvasCollaboratorWhereInput
    some?: CanvasCollaboratorWhereInput
    none?: CanvasCollaboratorWhereInput
  }

  export type CanvasInvitationListRelationFilter = {
    every?: CanvasInvitationWhereInput
    some?: CanvasInvitationWhereInput
    none?: CanvasInvitationWhereInput
  }

  export type CanvasSessionListRelationFilter = {
    every?: CanvasSessionWhereInput
    some?: CanvasSessionWhereInput
    none?: CanvasSessionWhereInput
  }

  export type CanvasActivityLogListRelationFilter = {
    every?: CanvasActivityLogWhereInput
    some?: CanvasActivityLogWhereInput
    none?: CanvasActivityLogWhereInput
  }

  export type CanvasCommentListRelationFilter = {
    every?: CanvasCommentWhereInput
    some?: CanvasCommentWhereInput
    none?: CanvasCommentWhereInput
  }

  export type ActionPodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EdgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContextModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasOrderByRelevanceInput = {
    fields: CanvasOrderByRelevanceFieldEnum | CanvasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CanvasCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrder
    thumbnailGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CanvasMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrder
    thumbnailGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    thumbnailS3Key?: SortOrder
    thumbnailGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumCanvasVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasVisibility | EnumCanvasVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.CanvasVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCanvasVisibilityFilter<$PrismaModel>
    _max?: NestedEnumCanvasVisibilityFilter<$PrismaModel>
  }

  export type EnumCanvasAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasAccessLevel | EnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasAccessLevelFilter<$PrismaModel> | $Enums.CanvasAccessLevel
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type CanvasScalarRelationFilter = {
    is?: CanvasWhereInput
    isNot?: CanvasWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CanvasInvitationOrderByRelevanceInput = {
    fields: CanvasInvitationOrderByRelevanceFieldEnum | CanvasInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CanvasInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type CanvasInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type CanvasInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    email?: SortOrder
    accessLevel?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumCanvasAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasAccessLevel | EnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.CanvasAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCanvasAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumCanvasAccessLevelFilter<$PrismaModel>
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type CanvasCollaboratorOrderByRelevanceInput = {
    fields: CanvasCollaboratorOrderByRelevanceFieldEnum | CanvasCollaboratorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CanvasCollaboratorCanvasIdUserIdCompoundUniqueInput = {
    canvasId: string
    userId: string
  }

  export type CanvasCollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type CanvasCollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type CanvasCollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    canEdit?: SortOrder
    canExecute?: SortOrder
    canDelete?: SortOrder
    canShare?: SortOrder
    canInvite?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type CanvasSessionOrderByRelevanceInput = {
    fields: CanvasSessionOrderByRelevanceFieldEnum | CanvasSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CanvasSessionCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    anonymousName?: SortOrder
    sessionToken?: SortOrder
    socketId?: SortOrder
    cursorPosition?: SortOrder
    selectedPodIds?: SortOrder
    viewportState?: SortOrder
    userColor?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrder
  }

  export type CanvasSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    anonymousName?: SortOrder
    sessionToken?: SortOrder
    socketId?: SortOrder
    userColor?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrder
  }

  export type CanvasSessionMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    anonymousName?: SortOrder
    sessionToken?: SortOrder
    socketId?: SortOrder
    userColor?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    connectedAt?: SortOrder
    lastHeartbeatAt?: SortOrder
    disconnectedAt?: SortOrder
  }

  export type EnumCanvasActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasActivityAction | EnumCanvasActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasActivityActionFilter<$PrismaModel> | $Enums.CanvasActivityAction
  }

  export type CanvasActivityLogOrderByRelevanceInput = {
    fields: CanvasActivityLogOrderByRelevanceFieldEnum | CanvasActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CanvasActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changeData?: SortOrder
    createdAt?: SortOrder
  }

  export type CanvasActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type CanvasActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCanvasActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasActivityAction | EnumCanvasActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.CanvasActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCanvasActivityActionFilter<$PrismaModel>
    _max?: NestedEnumCanvasActivityActionFilter<$PrismaModel>
  }

  export type CanvasCommentOrderByRelevanceInput = {
    fields: CanvasCommentOrderByRelevanceFieldEnum | CanvasCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CanvasCommentCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    position?: SortOrder
    podId?: SortOrder
    parentId?: SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    podId?: SortOrder
    parentId?: SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasCommentMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    podId?: SortOrder
    parentId?: SortOrder
    isResolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActionPodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodType | EnumActionPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodTypeFilter<$PrismaModel> | $Enums.ActionPodType
  }

  export type EnumActionPodExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodExecutionStatus | EnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodExecutionStatusFilter<$PrismaModel> | $Enums.ActionPodExecutionStatus
  }

  export type CanvasNullableScalarRelationFilter = {
    is?: CanvasWhereInput | null
    isNot?: CanvasWhereInput | null
  }

  export type DocumentNullableScalarRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type ActionPodExecutionListRelationFilter = {
    every?: ActionPodExecutionWhereInput
    some?: ActionPodExecutionWhereInput
    none?: ActionPodExecutionWhereInput
  }

  export type ActionPodExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionPodOrderByRelevanceInput = {
    fields: ActionPodOrderByRelevanceFieldEnum | ActionPodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActionPodDynamoPartitionKeyDynamoSortKeyCompoundUniqueInput = {
    dynamoPartitionKey: string
    dynamoSortKey: string
  }

  export type ActionPodCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    type?: SortOrder
    position?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrder
    contextCanvasId?: SortOrder
    documentId?: SortOrder
    lockedBy?: SortOrder
    lockedAt?: SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionPodMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    type?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrder
    contextCanvasId?: SortOrder
    documentId?: SortOrder
    lockedBy?: SortOrder
    lockedAt?: SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionPodMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    type?: SortOrder
    executionStatus?: SortOrder
    lastExecutionId?: SortOrder
    contextCanvasId?: SortOrder
    documentId?: SortOrder
    lockedBy?: SortOrder
    lockedAt?: SortOrder
    dynamoPartitionKey?: SortOrder
    dynamoSortKey?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActionPodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodType | EnumActionPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionPodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionPodTypeFilter<$PrismaModel>
    _max?: NestedEnumActionPodTypeFilter<$PrismaModel>
  }

  export type EnumActionPodExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodExecutionStatus | EnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionPodExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionPodExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumActionPodExecutionStatusFilter<$PrismaModel>
  }

  export type ActionPodScalarRelationFilter = {
    is?: ActionPodWhereInput
    isNot?: ActionPodWhereInput
  }

  export type EdgeOrderByRelevanceInput = {
    fields: EdgeOrderByRelevanceFieldEnum | EdgeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EdgeCanvasIdSourcePodIdSourceHandleTargetPodIdTargetHandleCompoundUniqueInput = {
    canvasId: string
    sourcePodId: string
    sourceHandle: string
    targetPodId: string
    targetHandle: string
  }

  export type EdgeCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
  }

  export type EdgeMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
  }

  export type EdgeMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    sourcePodId?: SortOrder
    targetPodId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    animated?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionOrderByRelevanceInput = {
    fields: ActionPodExecutionOrderByRelevanceFieldEnum | ActionPodExecutionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActionPodExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    runtimeInMs?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    providerMetadata?: SortOrder
    requestMetadata?: SortOrder
    responseMetadata?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type ActionPodExecutionAvgOrderByAggregateInput = {
    runtimeInMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type ActionPodExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    runtimeInMs?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type ActionPodExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    runtimeInMs?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type ActionPodExecutionSumOrderByAggregateInput = {
    runtimeInMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    costInUsd?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type PodUsageLogOrderByRelevanceInput = {
    fields: PodUsageLogOrderByRelevanceFieldEnum | PodUsageLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PodUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    providerMetadata?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
  }

  export type PodUsageLogAvgOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
  }

  export type PodUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
  }

  export type PodUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    podId?: SortOrder
    executionId?: SortOrder
    canvasId?: SortOrder
    workspaceId?: SortOrder
    subscriptionId?: SortOrder
    provider?: SortOrder
    modelId?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
    executedAt?: SortOrder
  }

  export type PodUsageLogSumOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    reasoningTokens?: SortOrder
    creditsConsumed?: SortOrder
    runtimeInMs?: SortOrder
    inputTokenCost?: SortOrder
    outputTokenCost?: SortOrder
    reasoningTokenCost?: SortOrder
    totalCostInUsd?: SortOrder
  }

  export type ContextModuleOrderByRelevanceInput = {
    fields: ContextModuleOrderByRelevanceFieldEnum | ContextModuleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContextModuleCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    definitionJson?: SortOrder
    originalCanvasId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextModuleAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ContextModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    originalCanvasId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextModuleMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    originalCanvasId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextModuleSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type WorkspaceUserListRelationFilter = {
    every?: WorkspaceUserWhereInput
    some?: WorkspaceUserWhereInput
    none?: WorkspaceUserWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type WorkspaceInvitationListRelationFilter = {
    every?: WorkspaceInvitationWhereInput
    some?: WorkspaceInvitationWhereInput
    none?: WorkspaceInvitationWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenOrderByRelevanceInput = {
    fields: RefreshTokenOrderByRelevanceFieldEnum | RefreshTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefreshTokenUserIdDeviceNameCompoundUniqueInput = {
    userId: string
    deviceName: string
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    deviceName?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: $Enums.AuthProvider
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type EnumWorkspaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeFilter<$PrismaModel> | $Enums.WorkspaceType
  }

  export type CanvasListRelationFilter = {
    every?: CanvasWhereInput
    some?: CanvasWhereInput
    none?: CanvasWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type ShareLinkListRelationFilter = {
    every?: ShareLinkWhereInput
    some?: ShareLinkWhereInput
    none?: ShareLinkWhereInput
  }

  export type ProviderAPIKeyListRelationFilter = {
    every?: ProviderAPIKeyWhereInput
    some?: ProviderAPIKeyWhereInput
    none?: ProviderAPIKeyWhereInput
  }

  export type CanvasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderAPIKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceOrderByRelevanceInput = {
    fields: WorkspaceOrderByRelevanceFieldEnum | WorkspaceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkspaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
  }

  export type EnumWorkspaceRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleFilter<$PrismaModel> | $Enums.WorkspaceRole
  }

  export type WorkspaceUserOrderByRelevanceInput = {
    fields: WorkspaceUserOrderByRelevanceFieldEnum | WorkspaceUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WorkspaceUserUserIdWorkspaceIdCompoundUniqueInput = {
    userId: string
    workspaceId: string
  }

  export type WorkspaceUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type WorkspaceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type WorkspaceUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    canCreateCanvas?: SortOrder
    canDeleteCanvas?: SortOrder
    canManageBilling?: SortOrder
    canInviteMembers?: SortOrder
    canManageMembers?: SortOrder
    canManageApiKeys?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type EnumWorkspaceRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
  }

  export type WorkspaceInvitationOrderByRelevanceInput = {
    fields: WorkspaceInvitationOrderByRelevanceFieldEnum | WorkspaceInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WorkspaceInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type WorkspaceInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type WorkspaceInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    invitedUserId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeFilter<$PrismaModel> | $Enums.AuthType
  }

  export type ProviderAPIKeyOrderByRelevanceInput = {
    fields: ProviderAPIKeyOrderByRelevanceFieldEnum | ProviderAPIKeyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProviderAPIKeyWorkspaceIdProviderDisplayNameCompoundUniqueInput = {
    workspaceId: string
    provider: $Enums.LLMProvider
    displayName: string
  }

  export type ProviderAPIKeyCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    providerConfig?: SortOrder
    endpoint?: SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ProviderAPIKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    endpoint?: SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ProviderAPIKeyMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    keyHash?: SortOrder
    endpoint?: SortOrder
    authType?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTypeFilter<$PrismaModel>
  }

  export type EnumShareableAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeFilter<$PrismaModel> | $Enums.ShareableAssetType
  }

  export type EnumShareAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelFilter<$PrismaModel> | $Enums.ShareAccessLevel
  }

  export type ShareLinkOrderByRelevanceInput = {
    fields: ShareLinkOrderByRelevanceFieldEnum | ShareLinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShareLinkAssetTypeAssetIdCompoundUniqueInput = {
    assetType: $Enums.ShareableAssetType
    assetId: string
  }

  export type ShareLinkCountOrderByAggregateInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShareLinkAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type ShareLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShareLinkMinOrderByAggregateInput = {
    id?: SortOrder
    publicToken?: SortOrder
    assetType?: SortOrder
    assetId?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
    accessLevel?: SortOrder
    password?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShareLinkSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumShareableAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShareableAssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
  }

  export type EnumShareAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.ShareAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumShareAccessLevelFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type EmbeddingListRelationFilter = {
    every?: EmbeddingWhereInput
    some?: EmbeddingWhereInput
    none?: EmbeddingWhereInput
  }

  export type EmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    sizeInBytes?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    storageKey?: SortOrder
    s3Bucket?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    sizeInBytes?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    sizeInBytes?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type EmbeddingOrderByRelevanceInput = {
    fields: EmbeddingOrderByRelevanceFieldEnum | EmbeddingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmbeddingDocumentIdChunkIndexCompoundUniqueInput = {
    documentId: string
    chunkIndex: number
  }

  export type EmbeddingS3VectorBucketS3VectorKeyCompoundUniqueInput = {
    s3VectorBucket: string
    s3VectorKey: string
  }

  export type EmbeddingCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    vectorDimension?: SortOrder
  }

  export type EmbeddingMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    chunkIndex?: SortOrder
    chunkText?: SortOrder
    s3VectorBucket?: SortOrder
    s3VectorKey?: SortOrder
    vectorDimension?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    vectorDimension?: SortOrder
  }

  export type AdminSessionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminPermissionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
  }

  export type AdminAPIKeyCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
  }

  export type AdminInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
  }

  export type AdminSessionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminPermissionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
  }

  export type AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
  }

  export type AdminInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type EnumAdminStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdminStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminSessionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminPermissionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminPermissionUpsertWithWhereUniqueWithoutAdminInput | AdminPermissionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    set?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    disconnect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    delete?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    update?: AdminPermissionUpdateWithWhereUniqueWithoutAdminInput | AdminPermissionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminPermissionUpdateManyWithWhereWithoutAdminInput | AdminPermissionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
  }

  export type AdminAPIKeyUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    set?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    disconnect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    delete?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    update?: AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAPIKeyUpdateManyWithWhereWithoutAdminInput | AdminAPIKeyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
  }

  export type AdminInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: AdminInvitationUpsertWithWhereUniqueWithoutInviterInput | AdminInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    set?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    disconnect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    delete?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    update?: AdminInvitationUpdateWithWhereUniqueWithoutInviterInput | AdminInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: AdminInvitationUpdateManyWithWhereWithoutInviterInput | AdminInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput> | AdminPermissionCreateWithoutAdminInput[] | AdminPermissionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminInput | AdminPermissionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminPermissionUpsertWithWhereUniqueWithoutAdminInput | AdminPermissionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminPermissionCreateManyAdminInputEnvelope
    set?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    disconnect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    delete?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    update?: AdminPermissionUpdateWithWhereUniqueWithoutAdminInput | AdminPermissionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminPermissionUpdateManyWithWhereWithoutAdminInput | AdminPermissionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
  }

  export type AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput> | AdminAPIKeyCreateWithoutAdminInput[] | AdminAPIKeyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAPIKeyCreateOrConnectWithoutAdminInput | AdminAPIKeyCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAPIKeyCreateManyAdminInputEnvelope
    set?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    disconnect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    delete?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    connect?: AdminAPIKeyWhereUniqueInput | AdminAPIKeyWhereUniqueInput[]
    update?: AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput | AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAPIKeyUpdateManyWithWhereWithoutAdminInput | AdminAPIKeyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
  }

  export type AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput> | AdminInvitationCreateWithoutInviterInput[] | AdminInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: AdminInvitationCreateOrConnectWithoutInviterInput | AdminInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: AdminInvitationUpsertWithWhereUniqueWithoutInviterInput | AdminInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: AdminInvitationCreateManyInviterInputEnvelope
    set?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    disconnect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    delete?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    connect?: AdminInvitationWhereUniqueInput | AdminInvitationWhereUniqueInput[]
    update?: AdminInvitationUpdateWithWhereUniqueWithoutInviterInput | AdminInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: AdminInvitationUpdateManyWithWhereWithoutInviterInput | AdminInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSessionsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSessionsInput
    upsert?: AdminUpsertWithoutSessionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSessionsInput, AdminUpdateWithoutSessionsInput>, AdminUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuditLogsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumAdminActionFieldUpdateOperationsInput = {
    set?: $Enums.AdminAction
  }

  export type EnumAdminResourceFieldUpdateOperationsInput = {
    set?: $Enums.AdminResource
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuditLogsInput
    upsert?: AdminUpsertWithoutAuditLogsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuditLogsInput, AdminUpdateWithoutAuditLogsInput>, AdminUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPermissionsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumSpecificPermissionFieldUpdateOperationsInput = {
    set?: $Enums.SpecificPermission
  }

  export type NullableEnumAdminResourceFieldUpdateOperationsInput = {
    set?: $Enums.AdminResource | null
  }

  export type AdminUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPermissionsInput
    upsert?: AdminUpsertWithoutPermissionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutPermissionsInput, AdminUpdateWithoutPermissionsInput>, AdminUncheckedUpdateWithoutPermissionsInput>
  }

  export type AdminCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: AdminCreateOrConnectWithoutApiKeysInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: AdminCreateOrConnectWithoutApiKeysInput
    upsert?: AdminUpsertWithoutApiKeysInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutApiKeysInput, AdminUpdateWithoutApiKeysInput>, AdminUncheckedUpdateWithoutApiKeysInput>
  }

  export type AdminCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutInvitationsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutInvitationsInput
    upsert?: AdminUpsertWithoutInvitationsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutInvitationsInput, AdminUpdateWithoutInvitationsInput>, AdminUncheckedUpdateWithoutInvitationsInput>
  }

  export type EnumSecurityEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFieldUpdateOperationsInput = {
    set?: $Enums.SecuritySeverity
  }

  export type WorkspaceCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type PodUsageLogCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type CreditPurchaseCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
  }

  export type CreditUsageLogCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
  }

  export type PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
  }

  export type CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionInput
    upsert?: WorkspaceUpsertWithoutSubscriptionInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSubscriptionInput, WorkspaceUpdateWithoutSubscriptionInput>, WorkspaceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PodUsageLogUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput | PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type CreditPurchaseUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    set?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    disconnect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    delete?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    update?: CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput | CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
  }

  export type CreditUsageLogUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    set?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    disconnect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    delete?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    update?: CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput | CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
  }

  export type PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput> | PodUsageLogCreateWithoutSubscriptionInput[] | PodUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutSubscriptionInput | PodUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PodUsageLogCreateManySubscriptionInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput | PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput> | CreditPurchaseCreateWithoutSubscriptionInput[] | CreditPurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditPurchaseCreateOrConnectWithoutSubscriptionInput | CreditPurchaseCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditPurchaseCreateManySubscriptionInputEnvelope
    set?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    disconnect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    delete?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    connect?: CreditPurchaseWhereUniqueInput | CreditPurchaseWhereUniqueInput[]
    update?: CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput | CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput | CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
  }

  export type CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput> | CreditUsageLogCreateWithoutSubscriptionInput[] | CreditUsageLogUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CreditUsageLogCreateOrConnectWithoutSubscriptionInput | CreditUsageLogCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CreditUsageLogCreateManySubscriptionInputEnvelope
    set?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    disconnect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    delete?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    connect?: CreditUsageLogWhereUniqueInput | CreditUsageLogWhereUniqueInput[]
    update?: CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput | CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput | CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutCreditPurchasesInput = {
    create?: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditPurchasesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionUpdateOneRequiredWithoutCreditPurchasesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditPurchasesInput
    upsert?: SubscriptionUpsertWithoutCreditPurchasesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCreditPurchasesInput, SubscriptionUpdateWithoutCreditPurchasesInput>, SubscriptionUncheckedUpdateWithoutCreditPurchasesInput>
  }

  export type SubscriptionCreateNestedOneWithoutCreditUsageInput = {
    create?: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditUsageInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumLLMProviderFieldUpdateOperationsInput = {
    set?: $Enums.LLMProvider
  }

  export type SubscriptionUpdateOneRequiredWithoutCreditUsageNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreditUsageInput
    upsert?: SubscriptionUpsertWithoutCreditUsageInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCreditUsageInput, SubscriptionUpdateWithoutCreditUsageInput>, SubscriptionUncheckedUpdateWithoutCreditUsageInput>
  }

  export type EnumModelCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ModelCategory
  }

  export type WorkspaceCreateNestedOneWithoutCanvasesInput = {
    create?: XOR<WorkspaceCreateWithoutCanvasesInput, WorkspaceUncheckedCreateWithoutCanvasesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCanvasesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ActionPodCreateNestedManyWithoutCanvasInput = {
    create?: XOR<ActionPodCreateWithoutCanvasInput, ActionPodUncheckedCreateWithoutCanvasInput> | ActionPodCreateWithoutCanvasInput[] | ActionPodUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutCanvasInput | ActionPodCreateOrConnectWithoutCanvasInput[]
    createMany?: ActionPodCreateManyCanvasInputEnvelope
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
  }

  export type EdgeCreateNestedManyWithoutCanvasInput = {
    create?: XOR<EdgeCreateWithoutCanvasInput, EdgeUncheckedCreateWithoutCanvasInput> | EdgeCreateWithoutCanvasInput[] | EdgeUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutCanvasInput | EdgeCreateOrConnectWithoutCanvasInput[]
    createMany?: EdgeCreateManyCanvasInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type ActionPodCreateNestedManyWithoutContextCanvasInput = {
    create?: XOR<ActionPodCreateWithoutContextCanvasInput, ActionPodUncheckedCreateWithoutContextCanvasInput> | ActionPodCreateWithoutContextCanvasInput[] | ActionPodUncheckedCreateWithoutContextCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutContextCanvasInput | ActionPodCreateOrConnectWithoutContextCanvasInput[]
    createMany?: ActionPodCreateManyContextCanvasInputEnvelope
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
  }

  export type ContextModuleCreateNestedManyWithoutOriginalCanvasInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalCanvasInput, ContextModuleUncheckedCreateWithoutOriginalCanvasInput> | ContextModuleCreateWithoutOriginalCanvasInput[] | ContextModuleUncheckedCreateWithoutOriginalCanvasInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalCanvasInput | ContextModuleCreateOrConnectWithoutOriginalCanvasInput[]
    createMany?: ContextModuleCreateManyOriginalCanvasInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type CanvasCollaboratorCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutCanvasInput, CanvasCollaboratorUncheckedCreateWithoutCanvasInput> | CanvasCollaboratorCreateWithoutCanvasInput[] | CanvasCollaboratorUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutCanvasInput | CanvasCollaboratorCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasCollaboratorCreateManyCanvasInputEnvelope
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
  }

  export type CanvasInvitationCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasInvitationCreateWithoutCanvasInput, CanvasInvitationUncheckedCreateWithoutCanvasInput> | CanvasInvitationCreateWithoutCanvasInput[] | CanvasInvitationUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutCanvasInput | CanvasInvitationCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasInvitationCreateManyCanvasInputEnvelope
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
  }

  export type CanvasSessionCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasSessionCreateWithoutCanvasInput, CanvasSessionUncheckedCreateWithoutCanvasInput> | CanvasSessionCreateWithoutCanvasInput[] | CanvasSessionUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasSessionCreateOrConnectWithoutCanvasInput | CanvasSessionCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasSessionCreateManyCanvasInputEnvelope
    connect?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
  }

  export type CanvasActivityLogCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasActivityLogCreateWithoutCanvasInput, CanvasActivityLogUncheckedCreateWithoutCanvasInput> | CanvasActivityLogCreateWithoutCanvasInput[] | CanvasActivityLogUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasActivityLogCreateOrConnectWithoutCanvasInput | CanvasActivityLogCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasActivityLogCreateManyCanvasInputEnvelope
    connect?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
  }

  export type CanvasCommentCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasCommentCreateWithoutCanvasInput, CanvasCommentUncheckedCreateWithoutCanvasInput> | CanvasCommentCreateWithoutCanvasInput[] | CanvasCommentUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCommentCreateOrConnectWithoutCanvasInput | CanvasCommentCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasCommentCreateManyCanvasInputEnvelope
    connect?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
  }

  export type ActionPodUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<ActionPodCreateWithoutCanvasInput, ActionPodUncheckedCreateWithoutCanvasInput> | ActionPodCreateWithoutCanvasInput[] | ActionPodUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutCanvasInput | ActionPodCreateOrConnectWithoutCanvasInput[]
    createMany?: ActionPodCreateManyCanvasInputEnvelope
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
  }

  export type EdgeUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<EdgeCreateWithoutCanvasInput, EdgeUncheckedCreateWithoutCanvasInput> | EdgeCreateWithoutCanvasInput[] | EdgeUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutCanvasInput | EdgeCreateOrConnectWithoutCanvasInput[]
    createMany?: EdgeCreateManyCanvasInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput = {
    create?: XOR<ActionPodCreateWithoutContextCanvasInput, ActionPodUncheckedCreateWithoutContextCanvasInput> | ActionPodCreateWithoutContextCanvasInput[] | ActionPodUncheckedCreateWithoutContextCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutContextCanvasInput | ActionPodCreateOrConnectWithoutContextCanvasInput[]
    createMany?: ActionPodCreateManyContextCanvasInputEnvelope
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
  }

  export type ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalCanvasInput, ContextModuleUncheckedCreateWithoutOriginalCanvasInput> | ContextModuleCreateWithoutOriginalCanvasInput[] | ContextModuleUncheckedCreateWithoutOriginalCanvasInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalCanvasInput | ContextModuleCreateOrConnectWithoutOriginalCanvasInput[]
    createMany?: ContextModuleCreateManyOriginalCanvasInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutCanvasInput, CanvasCollaboratorUncheckedCreateWithoutCanvasInput> | CanvasCollaboratorCreateWithoutCanvasInput[] | CanvasCollaboratorUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutCanvasInput | CanvasCollaboratorCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasCollaboratorCreateManyCanvasInputEnvelope
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
  }

  export type CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasInvitationCreateWithoutCanvasInput, CanvasInvitationUncheckedCreateWithoutCanvasInput> | CanvasInvitationCreateWithoutCanvasInput[] | CanvasInvitationUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutCanvasInput | CanvasInvitationCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasInvitationCreateManyCanvasInputEnvelope
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
  }

  export type CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasSessionCreateWithoutCanvasInput, CanvasSessionUncheckedCreateWithoutCanvasInput> | CanvasSessionCreateWithoutCanvasInput[] | CanvasSessionUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasSessionCreateOrConnectWithoutCanvasInput | CanvasSessionCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasSessionCreateManyCanvasInputEnvelope
    connect?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
  }

  export type CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasActivityLogCreateWithoutCanvasInput, CanvasActivityLogUncheckedCreateWithoutCanvasInput> | CanvasActivityLogCreateWithoutCanvasInput[] | CanvasActivityLogUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasActivityLogCreateOrConnectWithoutCanvasInput | CanvasActivityLogCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasActivityLogCreateManyCanvasInputEnvelope
    connect?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
  }

  export type CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasCommentCreateWithoutCanvasInput, CanvasCommentUncheckedCreateWithoutCanvasInput> | CanvasCommentCreateWithoutCanvasInput[] | CanvasCommentUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCommentCreateOrConnectWithoutCanvasInput | CanvasCommentCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasCommentCreateManyCanvasInputEnvelope
    connect?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
  }

  export type EnumCanvasVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.CanvasVisibility
  }

  export type WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCanvasesInput, WorkspaceUncheckedCreateWithoutCanvasesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCanvasesInput
    upsert?: WorkspaceUpsertWithoutCanvasesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutCanvasesInput, WorkspaceUpdateWithoutCanvasesInput>, WorkspaceUncheckedUpdateWithoutCanvasesInput>
  }

  export type ActionPodUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<ActionPodCreateWithoutCanvasInput, ActionPodUncheckedCreateWithoutCanvasInput> | ActionPodCreateWithoutCanvasInput[] | ActionPodUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutCanvasInput | ActionPodCreateOrConnectWithoutCanvasInput[]
    upsert?: ActionPodUpsertWithWhereUniqueWithoutCanvasInput | ActionPodUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: ActionPodCreateManyCanvasInputEnvelope
    set?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    disconnect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    delete?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    update?: ActionPodUpdateWithWhereUniqueWithoutCanvasInput | ActionPodUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: ActionPodUpdateManyWithWhereWithoutCanvasInput | ActionPodUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
  }

  export type EdgeUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<EdgeCreateWithoutCanvasInput, EdgeUncheckedCreateWithoutCanvasInput> | EdgeCreateWithoutCanvasInput[] | EdgeUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutCanvasInput | EdgeCreateOrConnectWithoutCanvasInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutCanvasInput | EdgeUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: EdgeCreateManyCanvasInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutCanvasInput | EdgeUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutCanvasInput | EdgeUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type ActionPodUpdateManyWithoutContextCanvasNestedInput = {
    create?: XOR<ActionPodCreateWithoutContextCanvasInput, ActionPodUncheckedCreateWithoutContextCanvasInput> | ActionPodCreateWithoutContextCanvasInput[] | ActionPodUncheckedCreateWithoutContextCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutContextCanvasInput | ActionPodCreateOrConnectWithoutContextCanvasInput[]
    upsert?: ActionPodUpsertWithWhereUniqueWithoutContextCanvasInput | ActionPodUpsertWithWhereUniqueWithoutContextCanvasInput[]
    createMany?: ActionPodCreateManyContextCanvasInputEnvelope
    set?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    disconnect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    delete?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    update?: ActionPodUpdateWithWhereUniqueWithoutContextCanvasInput | ActionPodUpdateWithWhereUniqueWithoutContextCanvasInput[]
    updateMany?: ActionPodUpdateManyWithWhereWithoutContextCanvasInput | ActionPodUpdateManyWithWhereWithoutContextCanvasInput[]
    deleteMany?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
  }

  export type ContextModuleUpdateManyWithoutOriginalCanvasNestedInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalCanvasInput, ContextModuleUncheckedCreateWithoutOriginalCanvasInput> | ContextModuleCreateWithoutOriginalCanvasInput[] | ContextModuleUncheckedCreateWithoutOriginalCanvasInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalCanvasInput | ContextModuleCreateOrConnectWithoutOriginalCanvasInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutOriginalCanvasInput | ContextModuleUpsertWithWhereUniqueWithoutOriginalCanvasInput[]
    createMany?: ContextModuleCreateManyOriginalCanvasInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutOriginalCanvasInput | ContextModuleUpdateWithWhereUniqueWithoutOriginalCanvasInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutOriginalCanvasInput | ContextModuleUpdateManyWithWhereWithoutOriginalCanvasInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type CanvasCollaboratorUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutCanvasInput, CanvasCollaboratorUncheckedCreateWithoutCanvasInput> | CanvasCollaboratorCreateWithoutCanvasInput[] | CanvasCollaboratorUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutCanvasInput | CanvasCollaboratorCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasCollaboratorUpsertWithWhereUniqueWithoutCanvasInput | CanvasCollaboratorUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasCollaboratorCreateManyCanvasInputEnvelope
    set?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    disconnect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    delete?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    update?: CanvasCollaboratorUpdateWithWhereUniqueWithoutCanvasInput | CanvasCollaboratorUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasCollaboratorUpdateManyWithWhereWithoutCanvasInput | CanvasCollaboratorUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasCollaboratorScalarWhereInput | CanvasCollaboratorScalarWhereInput[]
  }

  export type CanvasInvitationUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasInvitationCreateWithoutCanvasInput, CanvasInvitationUncheckedCreateWithoutCanvasInput> | CanvasInvitationCreateWithoutCanvasInput[] | CanvasInvitationUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutCanvasInput | CanvasInvitationCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasInvitationUpsertWithWhereUniqueWithoutCanvasInput | CanvasInvitationUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasInvitationCreateManyCanvasInputEnvelope
    set?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    disconnect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    delete?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    update?: CanvasInvitationUpdateWithWhereUniqueWithoutCanvasInput | CanvasInvitationUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasInvitationUpdateManyWithWhereWithoutCanvasInput | CanvasInvitationUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
  }

  export type CanvasSessionUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasSessionCreateWithoutCanvasInput, CanvasSessionUncheckedCreateWithoutCanvasInput> | CanvasSessionCreateWithoutCanvasInput[] | CanvasSessionUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasSessionCreateOrConnectWithoutCanvasInput | CanvasSessionCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasSessionUpsertWithWhereUniqueWithoutCanvasInput | CanvasSessionUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasSessionCreateManyCanvasInputEnvelope
    set?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    disconnect?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    delete?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    connect?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    update?: CanvasSessionUpdateWithWhereUniqueWithoutCanvasInput | CanvasSessionUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasSessionUpdateManyWithWhereWithoutCanvasInput | CanvasSessionUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasSessionScalarWhereInput | CanvasSessionScalarWhereInput[]
  }

  export type CanvasActivityLogUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasActivityLogCreateWithoutCanvasInput, CanvasActivityLogUncheckedCreateWithoutCanvasInput> | CanvasActivityLogCreateWithoutCanvasInput[] | CanvasActivityLogUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasActivityLogCreateOrConnectWithoutCanvasInput | CanvasActivityLogCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasActivityLogUpsertWithWhereUniqueWithoutCanvasInput | CanvasActivityLogUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasActivityLogCreateManyCanvasInputEnvelope
    set?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    disconnect?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    delete?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    connect?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    update?: CanvasActivityLogUpdateWithWhereUniqueWithoutCanvasInput | CanvasActivityLogUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasActivityLogUpdateManyWithWhereWithoutCanvasInput | CanvasActivityLogUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasActivityLogScalarWhereInput | CanvasActivityLogScalarWhereInput[]
  }

  export type CanvasCommentUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasCommentCreateWithoutCanvasInput, CanvasCommentUncheckedCreateWithoutCanvasInput> | CanvasCommentCreateWithoutCanvasInput[] | CanvasCommentUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCommentCreateOrConnectWithoutCanvasInput | CanvasCommentCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasCommentUpsertWithWhereUniqueWithoutCanvasInput | CanvasCommentUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasCommentCreateManyCanvasInputEnvelope
    set?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    disconnect?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    delete?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    connect?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    update?: CanvasCommentUpdateWithWhereUniqueWithoutCanvasInput | CanvasCommentUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasCommentUpdateManyWithWhereWithoutCanvasInput | CanvasCommentUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasCommentScalarWhereInput | CanvasCommentScalarWhereInput[]
  }

  export type ActionPodUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<ActionPodCreateWithoutCanvasInput, ActionPodUncheckedCreateWithoutCanvasInput> | ActionPodCreateWithoutCanvasInput[] | ActionPodUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutCanvasInput | ActionPodCreateOrConnectWithoutCanvasInput[]
    upsert?: ActionPodUpsertWithWhereUniqueWithoutCanvasInput | ActionPodUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: ActionPodCreateManyCanvasInputEnvelope
    set?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    disconnect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    delete?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    update?: ActionPodUpdateWithWhereUniqueWithoutCanvasInput | ActionPodUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: ActionPodUpdateManyWithWhereWithoutCanvasInput | ActionPodUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
  }

  export type EdgeUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<EdgeCreateWithoutCanvasInput, EdgeUncheckedCreateWithoutCanvasInput> | EdgeCreateWithoutCanvasInput[] | EdgeUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutCanvasInput | EdgeCreateOrConnectWithoutCanvasInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutCanvasInput | EdgeUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: EdgeCreateManyCanvasInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutCanvasInput | EdgeUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutCanvasInput | EdgeUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput = {
    create?: XOR<ActionPodCreateWithoutContextCanvasInput, ActionPodUncheckedCreateWithoutContextCanvasInput> | ActionPodCreateWithoutContextCanvasInput[] | ActionPodUncheckedCreateWithoutContextCanvasInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutContextCanvasInput | ActionPodCreateOrConnectWithoutContextCanvasInput[]
    upsert?: ActionPodUpsertWithWhereUniqueWithoutContextCanvasInput | ActionPodUpsertWithWhereUniqueWithoutContextCanvasInput[]
    createMany?: ActionPodCreateManyContextCanvasInputEnvelope
    set?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    disconnect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    delete?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    update?: ActionPodUpdateWithWhereUniqueWithoutContextCanvasInput | ActionPodUpdateWithWhereUniqueWithoutContextCanvasInput[]
    updateMany?: ActionPodUpdateManyWithWhereWithoutContextCanvasInput | ActionPodUpdateManyWithWhereWithoutContextCanvasInput[]
    deleteMany?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
  }

  export type ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput = {
    create?: XOR<ContextModuleCreateWithoutOriginalCanvasInput, ContextModuleUncheckedCreateWithoutOriginalCanvasInput> | ContextModuleCreateWithoutOriginalCanvasInput[] | ContextModuleUncheckedCreateWithoutOriginalCanvasInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutOriginalCanvasInput | ContextModuleCreateOrConnectWithoutOriginalCanvasInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutOriginalCanvasInput | ContextModuleUpsertWithWhereUniqueWithoutOriginalCanvasInput[]
    createMany?: ContextModuleCreateManyOriginalCanvasInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutOriginalCanvasInput | ContextModuleUpdateWithWhereUniqueWithoutOriginalCanvasInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutOriginalCanvasInput | ContextModuleUpdateManyWithWhereWithoutOriginalCanvasInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutCanvasInput, CanvasCollaboratorUncheckedCreateWithoutCanvasInput> | CanvasCollaboratorCreateWithoutCanvasInput[] | CanvasCollaboratorUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutCanvasInput | CanvasCollaboratorCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasCollaboratorUpsertWithWhereUniqueWithoutCanvasInput | CanvasCollaboratorUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasCollaboratorCreateManyCanvasInputEnvelope
    set?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    disconnect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    delete?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    update?: CanvasCollaboratorUpdateWithWhereUniqueWithoutCanvasInput | CanvasCollaboratorUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasCollaboratorUpdateManyWithWhereWithoutCanvasInput | CanvasCollaboratorUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasCollaboratorScalarWhereInput | CanvasCollaboratorScalarWhereInput[]
  }

  export type CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasInvitationCreateWithoutCanvasInput, CanvasInvitationUncheckedCreateWithoutCanvasInput> | CanvasInvitationCreateWithoutCanvasInput[] | CanvasInvitationUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutCanvasInput | CanvasInvitationCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasInvitationUpsertWithWhereUniqueWithoutCanvasInput | CanvasInvitationUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasInvitationCreateManyCanvasInputEnvelope
    set?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    disconnect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    delete?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    update?: CanvasInvitationUpdateWithWhereUniqueWithoutCanvasInput | CanvasInvitationUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasInvitationUpdateManyWithWhereWithoutCanvasInput | CanvasInvitationUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
  }

  export type CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasSessionCreateWithoutCanvasInput, CanvasSessionUncheckedCreateWithoutCanvasInput> | CanvasSessionCreateWithoutCanvasInput[] | CanvasSessionUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasSessionCreateOrConnectWithoutCanvasInput | CanvasSessionCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasSessionUpsertWithWhereUniqueWithoutCanvasInput | CanvasSessionUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasSessionCreateManyCanvasInputEnvelope
    set?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    disconnect?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    delete?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    connect?: CanvasSessionWhereUniqueInput | CanvasSessionWhereUniqueInput[]
    update?: CanvasSessionUpdateWithWhereUniqueWithoutCanvasInput | CanvasSessionUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasSessionUpdateManyWithWhereWithoutCanvasInput | CanvasSessionUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasSessionScalarWhereInput | CanvasSessionScalarWhereInput[]
  }

  export type CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasActivityLogCreateWithoutCanvasInput, CanvasActivityLogUncheckedCreateWithoutCanvasInput> | CanvasActivityLogCreateWithoutCanvasInput[] | CanvasActivityLogUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasActivityLogCreateOrConnectWithoutCanvasInput | CanvasActivityLogCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasActivityLogUpsertWithWhereUniqueWithoutCanvasInput | CanvasActivityLogUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasActivityLogCreateManyCanvasInputEnvelope
    set?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    disconnect?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    delete?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    connect?: CanvasActivityLogWhereUniqueInput | CanvasActivityLogWhereUniqueInput[]
    update?: CanvasActivityLogUpdateWithWhereUniqueWithoutCanvasInput | CanvasActivityLogUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasActivityLogUpdateManyWithWhereWithoutCanvasInput | CanvasActivityLogUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasActivityLogScalarWhereInput | CanvasActivityLogScalarWhereInput[]
  }

  export type CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasCommentCreateWithoutCanvasInput, CanvasCommentUncheckedCreateWithoutCanvasInput> | CanvasCommentCreateWithoutCanvasInput[] | CanvasCommentUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasCommentCreateOrConnectWithoutCanvasInput | CanvasCommentCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasCommentUpsertWithWhereUniqueWithoutCanvasInput | CanvasCommentUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasCommentCreateManyCanvasInputEnvelope
    set?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    disconnect?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    delete?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    connect?: CanvasCommentWhereUniqueInput | CanvasCommentWhereUniqueInput[]
    update?: CanvasCommentUpdateWithWhereUniqueWithoutCanvasInput | CanvasCommentUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasCommentUpdateManyWithWhereWithoutCanvasInput | CanvasCommentUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasCommentScalarWhereInput | CanvasCommentScalarWhereInput[]
  }

  export type CanvasCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<CanvasCreateWithoutInvitationsInput, CanvasUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutInvitationsInput
    connect?: CanvasWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentCanvasInvitesInput = {
    create?: XOR<UserCreateWithoutSentCanvasInvitesInput, UserUncheckedCreateWithoutSentCanvasInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentCanvasInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedCanvasInvitesInput = {
    create?: XOR<UserCreateWithoutReceivedCanvasInvitesInput, UserUncheckedCreateWithoutReceivedCanvasInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedCanvasInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCanvasAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.CanvasAccessLevel
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type CanvasUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<CanvasCreateWithoutInvitationsInput, CanvasUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutInvitationsInput
    upsert?: CanvasUpsertWithoutInvitationsInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutInvitationsInput, CanvasUpdateWithoutInvitationsInput>, CanvasUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentCanvasInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentCanvasInvitesInput, UserUncheckedCreateWithoutSentCanvasInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentCanvasInvitesInput
    upsert?: UserUpsertWithoutSentCanvasInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentCanvasInvitesInput, UserUpdateWithoutSentCanvasInvitesInput>, UserUncheckedUpdateWithoutSentCanvasInvitesInput>
  }

  export type UserUpdateOneWithoutReceivedCanvasInvitesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedCanvasInvitesInput, UserUncheckedCreateWithoutReceivedCanvasInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedCanvasInvitesInput
    upsert?: UserUpsertWithoutReceivedCanvasInvitesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedCanvasInvitesInput, UserUpdateWithoutReceivedCanvasInvitesInput>, UserUncheckedUpdateWithoutReceivedCanvasInvitesInput>
  }

  export type CanvasCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<CanvasCreateWithoutCollaboratorsInput, CanvasUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutCollaboratorsInput
    connect?: CanvasWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCanvasCollaborationsInput = {
    create?: XOR<UserCreateWithoutCanvasCollaborationsInput, UserUncheckedCreateWithoutCanvasCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCanvasCollaborationsInput
    connect?: UserWhereUniqueInput
  }

  export type CanvasUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<CanvasCreateWithoutCollaboratorsInput, CanvasUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutCollaboratorsInput
    upsert?: CanvasUpsertWithoutCollaboratorsInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutCollaboratorsInput, CanvasUpdateWithoutCollaboratorsInput>, CanvasUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type UserUpdateOneRequiredWithoutCanvasCollaborationsNestedInput = {
    create?: XOR<UserCreateWithoutCanvasCollaborationsInput, UserUncheckedCreateWithoutCanvasCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCanvasCollaborationsInput
    upsert?: UserUpsertWithoutCanvasCollaborationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCanvasCollaborationsInput, UserUpdateWithoutCanvasCollaborationsInput>, UserUncheckedUpdateWithoutCanvasCollaborationsInput>
  }

  export type CanvasCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CanvasCreateWithoutSessionsInput, CanvasUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutSessionsInput
    connect?: CanvasWhereUniqueInput
  }

  export type CanvasUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<CanvasCreateWithoutSessionsInput, CanvasUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutSessionsInput
    upsert?: CanvasUpsertWithoutSessionsInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutSessionsInput, CanvasUpdateWithoutSessionsInput>, CanvasUncheckedUpdateWithoutSessionsInput>
  }

  export type CanvasCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<CanvasCreateWithoutActivityLogInput, CanvasUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutActivityLogInput
    connect?: CanvasWhereUniqueInput
  }

  export type EnumCanvasActivityActionFieldUpdateOperationsInput = {
    set?: $Enums.CanvasActivityAction
  }

  export type CanvasUpdateOneRequiredWithoutActivityLogNestedInput = {
    create?: XOR<CanvasCreateWithoutActivityLogInput, CanvasUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutActivityLogInput
    upsert?: CanvasUpsertWithoutActivityLogInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutActivityLogInput, CanvasUpdateWithoutActivityLogInput>, CanvasUncheckedUpdateWithoutActivityLogInput>
  }

  export type CanvasCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CanvasCreateWithoutCommentsInput, CanvasUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutCommentsInput
    connect?: CanvasWhereUniqueInput
  }

  export type CanvasUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<CanvasCreateWithoutCommentsInput, CanvasUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutCommentsInput
    upsert?: CanvasUpsertWithoutCommentsInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutCommentsInput, CanvasUpdateWithoutCommentsInput>, CanvasUncheckedUpdateWithoutCommentsInput>
  }

  export type CanvasCreateNestedOneWithoutActionPodsInput = {
    create?: XOR<CanvasCreateWithoutActionPodsInput, CanvasUncheckedCreateWithoutActionPodsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutActionPodsInput
    connect?: CanvasWhereUniqueInput
  }

  export type CanvasCreateNestedOneWithoutContextualPodsInput = {
    create?: XOR<CanvasCreateWithoutContextualPodsInput, CanvasUncheckedCreateWithoutContextualPodsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutContextualPodsInput
    connect?: CanvasWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutActionPodsInput = {
    create?: XOR<DocumentCreateWithoutActionPodsInput, DocumentUncheckedCreateWithoutActionPodsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutActionPodsInput
    connect?: DocumentWhereUniqueInput
  }

  export type EdgeCreateNestedManyWithoutSourcePodInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type EdgeCreateNestedManyWithoutTargetPodInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type ActionPodExecutionCreateNestedManyWithoutPodInput = {
    create?: XOR<ActionPodExecutionCreateWithoutPodInput, ActionPodExecutionUncheckedCreateWithoutPodInput> | ActionPodExecutionCreateWithoutPodInput[] | ActionPodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: ActionPodExecutionCreateOrConnectWithoutPodInput | ActionPodExecutionCreateOrConnectWithoutPodInput[]
    createMany?: ActionPodExecutionCreateManyPodInputEnvelope
    connect?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
  }

  export type PodUsageLogCreateNestedManyWithoutPodInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type EdgeUncheckedCreateNestedManyWithoutSourcePodInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type EdgeUncheckedCreateNestedManyWithoutTargetPodInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
  }

  export type ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<ActionPodExecutionCreateWithoutPodInput, ActionPodExecutionUncheckedCreateWithoutPodInput> | ActionPodExecutionCreateWithoutPodInput[] | ActionPodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: ActionPodExecutionCreateOrConnectWithoutPodInput | ActionPodExecutionCreateOrConnectWithoutPodInput[]
    createMany?: ActionPodExecutionCreateManyPodInputEnvelope
    connect?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
  }

  export type PodUsageLogUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
  }

  export type EnumActionPodTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionPodType
  }

  export type EnumActionPodExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActionPodExecutionStatus
  }

  export type CanvasUpdateOneRequiredWithoutActionPodsNestedInput = {
    create?: XOR<CanvasCreateWithoutActionPodsInput, CanvasUncheckedCreateWithoutActionPodsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutActionPodsInput
    upsert?: CanvasUpsertWithoutActionPodsInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutActionPodsInput, CanvasUpdateWithoutActionPodsInput>, CanvasUncheckedUpdateWithoutActionPodsInput>
  }

  export type CanvasUpdateOneWithoutContextualPodsNestedInput = {
    create?: XOR<CanvasCreateWithoutContextualPodsInput, CanvasUncheckedCreateWithoutContextualPodsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutContextualPodsInput
    upsert?: CanvasUpsertWithoutContextualPodsInput
    disconnect?: CanvasWhereInput | boolean
    delete?: CanvasWhereInput | boolean
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutContextualPodsInput, CanvasUpdateWithoutContextualPodsInput>, CanvasUncheckedUpdateWithoutContextualPodsInput>
  }

  export type DocumentUpdateOneWithoutActionPodsNestedInput = {
    create?: XOR<DocumentCreateWithoutActionPodsInput, DocumentUncheckedCreateWithoutActionPodsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutActionPodsInput
    upsert?: DocumentUpsertWithoutActionPodsInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutActionPodsInput, DocumentUpdateWithoutActionPodsInput>, DocumentUncheckedUpdateWithoutActionPodsInput>
  }

  export type EdgeUpdateManyWithoutSourcePodNestedInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutSourcePodInput | EdgeUpsertWithWhereUniqueWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutSourcePodInput | EdgeUpdateWithWhereUniqueWithoutSourcePodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutSourcePodInput | EdgeUpdateManyWithWhereWithoutSourcePodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type EdgeUpdateManyWithoutTargetPodNestedInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutTargetPodInput | EdgeUpsertWithWhereUniqueWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutTargetPodInput | EdgeUpdateWithWhereUniqueWithoutTargetPodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutTargetPodInput | EdgeUpdateManyWithWhereWithoutTargetPodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type ActionPodExecutionUpdateManyWithoutPodNestedInput = {
    create?: XOR<ActionPodExecutionCreateWithoutPodInput, ActionPodExecutionUncheckedCreateWithoutPodInput> | ActionPodExecutionCreateWithoutPodInput[] | ActionPodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: ActionPodExecutionCreateOrConnectWithoutPodInput | ActionPodExecutionCreateOrConnectWithoutPodInput[]
    upsert?: ActionPodExecutionUpsertWithWhereUniqueWithoutPodInput | ActionPodExecutionUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: ActionPodExecutionCreateManyPodInputEnvelope
    set?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    disconnect?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    delete?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    connect?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    update?: ActionPodExecutionUpdateWithWhereUniqueWithoutPodInput | ActionPodExecutionUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: ActionPodExecutionUpdateManyWithWhereWithoutPodInput | ActionPodExecutionUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: ActionPodExecutionScalarWhereInput | ActionPodExecutionScalarWhereInput[]
  }

  export type PodUsageLogUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutPodInput | PodUsageLogUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutPodInput | PodUsageLogUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutPodInput | PodUsageLogUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type EdgeUncheckedUpdateManyWithoutSourcePodNestedInput = {
    create?: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput> | EdgeCreateWithoutSourcePodInput[] | EdgeUncheckedCreateWithoutSourcePodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutSourcePodInput | EdgeCreateOrConnectWithoutSourcePodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutSourcePodInput | EdgeUpsertWithWhereUniqueWithoutSourcePodInput[]
    createMany?: EdgeCreateManySourcePodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutSourcePodInput | EdgeUpdateWithWhereUniqueWithoutSourcePodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutSourcePodInput | EdgeUpdateManyWithWhereWithoutSourcePodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type EdgeUncheckedUpdateManyWithoutTargetPodNestedInput = {
    create?: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput> | EdgeCreateWithoutTargetPodInput[] | EdgeUncheckedCreateWithoutTargetPodInput[]
    connectOrCreate?: EdgeCreateOrConnectWithoutTargetPodInput | EdgeCreateOrConnectWithoutTargetPodInput[]
    upsert?: EdgeUpsertWithWhereUniqueWithoutTargetPodInput | EdgeUpsertWithWhereUniqueWithoutTargetPodInput[]
    createMany?: EdgeCreateManyTargetPodInputEnvelope
    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]
    update?: EdgeUpdateWithWhereUniqueWithoutTargetPodInput | EdgeUpdateWithWhereUniqueWithoutTargetPodInput[]
    updateMany?: EdgeUpdateManyWithWhereWithoutTargetPodInput | EdgeUpdateManyWithWhereWithoutTargetPodInput[]
    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
  }

  export type ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<ActionPodExecutionCreateWithoutPodInput, ActionPodExecutionUncheckedCreateWithoutPodInput> | ActionPodExecutionCreateWithoutPodInput[] | ActionPodExecutionUncheckedCreateWithoutPodInput[]
    connectOrCreate?: ActionPodExecutionCreateOrConnectWithoutPodInput | ActionPodExecutionCreateOrConnectWithoutPodInput[]
    upsert?: ActionPodExecutionUpsertWithWhereUniqueWithoutPodInput | ActionPodExecutionUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: ActionPodExecutionCreateManyPodInputEnvelope
    set?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    disconnect?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    delete?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    connect?: ActionPodExecutionWhereUniqueInput | ActionPodExecutionWhereUniqueInput[]
    update?: ActionPodExecutionUpdateWithWhereUniqueWithoutPodInput | ActionPodExecutionUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: ActionPodExecutionUpdateManyWithWhereWithoutPodInput | ActionPodExecutionUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: ActionPodExecutionScalarWhereInput | ActionPodExecutionScalarWhereInput[]
  }

  export type PodUsageLogUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput> | PodUsageLogCreateWithoutPodInput[] | PodUsageLogUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodUsageLogCreateOrConnectWithoutPodInput | PodUsageLogCreateOrConnectWithoutPodInput[]
    upsert?: PodUsageLogUpsertWithWhereUniqueWithoutPodInput | PodUsageLogUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodUsageLogCreateManyPodInputEnvelope
    set?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    disconnect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    delete?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    connect?: PodUsageLogWhereUniqueInput | PodUsageLogWhereUniqueInput[]
    update?: PodUsageLogUpdateWithWhereUniqueWithoutPodInput | PodUsageLogUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodUsageLogUpdateManyWithWhereWithoutPodInput | PodUsageLogUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
  }

  export type CanvasCreateNestedOneWithoutEdgesInput = {
    create?: XOR<CanvasCreateWithoutEdgesInput, CanvasUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutEdgesInput
    connect?: CanvasWhereUniqueInput
  }

  export type ActionPodCreateNestedOneWithoutSourceEdgesInput = {
    create?: XOR<ActionPodCreateWithoutSourceEdgesInput, ActionPodUncheckedCreateWithoutSourceEdgesInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutSourceEdgesInput
    connect?: ActionPodWhereUniqueInput
  }

  export type ActionPodCreateNestedOneWithoutTargetEdgesInput = {
    create?: XOR<ActionPodCreateWithoutTargetEdgesInput, ActionPodUncheckedCreateWithoutTargetEdgesInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutTargetEdgesInput
    connect?: ActionPodWhereUniqueInput
  }

  export type CanvasUpdateOneRequiredWithoutEdgesNestedInput = {
    create?: XOR<CanvasCreateWithoutEdgesInput, CanvasUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutEdgesInput
    upsert?: CanvasUpsertWithoutEdgesInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutEdgesInput, CanvasUpdateWithoutEdgesInput>, CanvasUncheckedUpdateWithoutEdgesInput>
  }

  export type ActionPodUpdateOneRequiredWithoutSourceEdgesNestedInput = {
    create?: XOR<ActionPodCreateWithoutSourceEdgesInput, ActionPodUncheckedCreateWithoutSourceEdgesInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutSourceEdgesInput
    upsert?: ActionPodUpsertWithoutSourceEdgesInput
    connect?: ActionPodWhereUniqueInput
    update?: XOR<XOR<ActionPodUpdateToOneWithWhereWithoutSourceEdgesInput, ActionPodUpdateWithoutSourceEdgesInput>, ActionPodUncheckedUpdateWithoutSourceEdgesInput>
  }

  export type ActionPodUpdateOneRequiredWithoutTargetEdgesNestedInput = {
    create?: XOR<ActionPodCreateWithoutTargetEdgesInput, ActionPodUncheckedCreateWithoutTargetEdgesInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutTargetEdgesInput
    upsert?: ActionPodUpsertWithoutTargetEdgesInput
    connect?: ActionPodWhereUniqueInput
    update?: XOR<XOR<ActionPodUpdateToOneWithWhereWithoutTargetEdgesInput, ActionPodUpdateWithoutTargetEdgesInput>, ActionPodUncheckedUpdateWithoutTargetEdgesInput>
  }

  export type ActionPodCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<ActionPodCreateWithoutExecutionsInput, ActionPodUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutExecutionsInput
    connect?: ActionPodWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ActionPodUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<ActionPodCreateWithoutExecutionsInput, ActionPodUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutExecutionsInput
    upsert?: ActionPodUpsertWithoutExecutionsInput
    connect?: ActionPodWhereUniqueInput
    update?: XOR<XOR<ActionPodUpdateToOneWithWhereWithoutExecutionsInput, ActionPodUpdateWithoutExecutionsInput>, ActionPodUncheckedUpdateWithoutExecutionsInput>
  }

  export type ActionPodCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ActionPodCreateWithoutUsageLogsInput, ActionPodUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutUsageLogsInput
    connect?: ActionPodWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageLogsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ActionPodUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<ActionPodCreateWithoutUsageLogsInput, ActionPodUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ActionPodCreateOrConnectWithoutUsageLogsInput
    upsert?: ActionPodUpsertWithoutUsageLogsInput
    connect?: ActionPodWhereUniqueInput
    update?: XOR<XOR<ActionPodUpdateToOneWithWhereWithoutUsageLogsInput, ActionPodUpdateWithoutUsageLogsInput>, ActionPodUncheckedUpdateWithoutUsageLogsInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageLogsInput
    upsert?: SubscriptionUpsertWithoutUsageLogsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUsageLogsInput, SubscriptionUpdateWithoutUsageLogsInput>, SubscriptionUncheckedUpdateWithoutUsageLogsInput>
  }

  export type WorkspaceCreateNestedOneWithoutContextModulesInput = {
    create?: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutContextModulesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type CanvasCreateNestedOneWithoutContextModulesInput = {
    create?: XOR<CanvasCreateWithoutContextModulesInput, CanvasUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutContextModulesInput
    connect?: CanvasWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutContextModulesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutContextModulesInput
    upsert?: WorkspaceUpsertWithoutContextModulesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutContextModulesInput, WorkspaceUpdateWithoutContextModulesInput>, WorkspaceUncheckedUpdateWithoutContextModulesInput>
  }

  export type CanvasUpdateOneWithoutContextModulesNestedInput = {
    create?: XOR<CanvasCreateWithoutContextModulesInput, CanvasUncheckedCreateWithoutContextModulesInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutContextModulesInput
    upsert?: CanvasUpsertWithoutContextModulesInput
    disconnect?: CanvasWhereInput | boolean
    delete?: CanvasWhereInput | boolean
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutContextModulesInput, CanvasUpdateWithoutContextModulesInput>, CanvasUncheckedUpdateWithoutContextModulesInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type WorkspaceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type CanvasCollaboratorCreateNestedManyWithoutUserInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutUserInput, CanvasCollaboratorUncheckedCreateWithoutUserInput> | CanvasCollaboratorCreateWithoutUserInput[] | CanvasCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutUserInput | CanvasCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: CanvasCollaboratorCreateManyUserInputEnvelope
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type CanvasInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<CanvasInvitationCreateWithoutInviterInput, CanvasInvitationUncheckedCreateWithoutInviterInput> | CanvasInvitationCreateWithoutInviterInput[] | CanvasInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInviterInput | CanvasInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: CanvasInvitationCreateManyInviterInputEnvelope
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
  }

  export type CanvasInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<CanvasInvitationCreateWithoutInvitedUserInput, CanvasInvitationUncheckedCreateWithoutInvitedUserInput> | CanvasInvitationCreateWithoutInvitedUserInput[] | CanvasInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInvitedUserInput | CanvasInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: CanvasInvitationCreateManyInvitedUserInputEnvelope
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutUserInput, CanvasCollaboratorUncheckedCreateWithoutUserInput> | CanvasCollaboratorCreateWithoutUserInput[] | CanvasCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutUserInput | CanvasCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: CanvasCollaboratorCreateManyUserInputEnvelope
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<CanvasInvitationCreateWithoutInviterInput, CanvasInvitationUncheckedCreateWithoutInviterInput> | CanvasInvitationCreateWithoutInviterInput[] | CanvasInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInviterInput | CanvasInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: CanvasInvitationCreateManyInviterInputEnvelope
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
  }

  export type CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<CanvasInvitationCreateWithoutInvitedUserInput, CanvasInvitationUncheckedCreateWithoutInvitedUserInput> | CanvasInvitationCreateWithoutInvitedUserInput[] | CanvasInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInvitedUserInput | CanvasInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: CanvasInvitationCreateManyInvitedUserInputEnvelope
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type WorkspaceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type CanvasCollaboratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutUserInput, CanvasCollaboratorUncheckedCreateWithoutUserInput> | CanvasCollaboratorCreateWithoutUserInput[] | CanvasCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutUserInput | CanvasCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: CanvasCollaboratorUpsertWithWhereUniqueWithoutUserInput | CanvasCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CanvasCollaboratorCreateManyUserInputEnvelope
    set?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    disconnect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    delete?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    update?: CanvasCollaboratorUpdateWithWhereUniqueWithoutUserInput | CanvasCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CanvasCollaboratorUpdateManyWithWhereWithoutUserInput | CanvasCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CanvasCollaboratorScalarWhereInput | CanvasCollaboratorScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput | WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput | WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type CanvasInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<CanvasInvitationCreateWithoutInviterInput, CanvasInvitationUncheckedCreateWithoutInviterInput> | CanvasInvitationCreateWithoutInviterInput[] | CanvasInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInviterInput | CanvasInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: CanvasInvitationUpsertWithWhereUniqueWithoutInviterInput | CanvasInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: CanvasInvitationCreateManyInviterInputEnvelope
    set?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    disconnect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    delete?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    update?: CanvasInvitationUpdateWithWhereUniqueWithoutInviterInput | CanvasInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: CanvasInvitationUpdateManyWithWhereWithoutInviterInput | CanvasInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
  }

  export type CanvasInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<CanvasInvitationCreateWithoutInvitedUserInput, CanvasInvitationUncheckedCreateWithoutInvitedUserInput> | CanvasInvitationCreateWithoutInvitedUserInput[] | CanvasInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInvitedUserInput | CanvasInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: CanvasInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | CanvasInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: CanvasInvitationCreateManyInvitedUserInputEnvelope
    set?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    disconnect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    delete?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    update?: CanvasInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | CanvasInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: CanvasInvitationUpdateManyWithWhereWithoutInvitedUserInput | CanvasInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CanvasCollaboratorCreateWithoutUserInput, CanvasCollaboratorUncheckedCreateWithoutUserInput> | CanvasCollaboratorCreateWithoutUserInput[] | CanvasCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasCollaboratorCreateOrConnectWithoutUserInput | CanvasCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: CanvasCollaboratorUpsertWithWhereUniqueWithoutUserInput | CanvasCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CanvasCollaboratorCreateManyUserInputEnvelope
    set?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    disconnect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    delete?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    connect?: CanvasCollaboratorWhereUniqueInput | CanvasCollaboratorWhereUniqueInput[]
    update?: CanvasCollaboratorUpdateWithWhereUniqueWithoutUserInput | CanvasCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CanvasCollaboratorUpdateManyWithWhereWithoutUserInput | CanvasCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CanvasCollaboratorScalarWhereInput | CanvasCollaboratorScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput> | WorkspaceInvitationCreateWithoutInviterInput[] | WorkspaceInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInviterInput | WorkspaceInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: WorkspaceInvitationCreateManyInviterInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput | WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput> | WorkspaceInvitationCreateWithoutInvitedUserInput[] | WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput | WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: WorkspaceInvitationCreateManyInvitedUserInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput | WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<CanvasInvitationCreateWithoutInviterInput, CanvasInvitationUncheckedCreateWithoutInviterInput> | CanvasInvitationCreateWithoutInviterInput[] | CanvasInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInviterInput | CanvasInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: CanvasInvitationUpsertWithWhereUniqueWithoutInviterInput | CanvasInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: CanvasInvitationCreateManyInviterInputEnvelope
    set?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    disconnect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    delete?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    update?: CanvasInvitationUpdateWithWhereUniqueWithoutInviterInput | CanvasInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: CanvasInvitationUpdateManyWithWhereWithoutInviterInput | CanvasInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
  }

  export type CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<CanvasInvitationCreateWithoutInvitedUserInput, CanvasInvitationUncheckedCreateWithoutInvitedUserInput> | CanvasInvitationCreateWithoutInvitedUserInput[] | CanvasInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: CanvasInvitationCreateOrConnectWithoutInvitedUserInput | CanvasInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: CanvasInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | CanvasInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: CanvasInvitationCreateManyInvitedUserInputEnvelope
    set?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    disconnect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    delete?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    connect?: CanvasInvitationWhereUniqueInput | CanvasInvitationWhereUniqueInput[]
    update?: CanvasInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | CanvasInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: CanvasInvitationUpdateManyWithWhereWithoutInvitedUserInput | CanvasInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type WorkspaceUserCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type CanvasCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CanvasCreateWithoutWorkspaceInput, CanvasUncheckedCreateWithoutWorkspaceInput> | CanvasCreateWithoutWorkspaceInput[] | CanvasUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CanvasCreateOrConnectWithoutWorkspaceInput | CanvasCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CanvasCreateManyWorkspaceInputEnvelope
    connect?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContextModuleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type ShareLinkCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type CanvasUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CanvasCreateWithoutWorkspaceInput, CanvasUncheckedCreateWithoutWorkspaceInput> | CanvasCreateWithoutWorkspaceInput[] | CanvasUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CanvasCreateOrConnectWithoutWorkspaceInput | CanvasCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CanvasCreateManyWorkspaceInputEnvelope
    connect?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
  }

  export type ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type EnumWorkspaceTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceType
  }

  export type WorkspaceUserUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type CanvasUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CanvasCreateWithoutWorkspaceInput, CanvasUncheckedCreateWithoutWorkspaceInput> | CanvasCreateWithoutWorkspaceInput[] | CanvasUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CanvasCreateOrConnectWithoutWorkspaceInput | CanvasCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CanvasUpsertWithWhereUniqueWithoutWorkspaceInput | CanvasUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CanvasCreateManyWorkspaceInputEnvelope
    set?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    disconnect?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    delete?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    connect?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    update?: CanvasUpdateWithWhereUniqueWithoutWorkspaceInput | CanvasUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CanvasUpdateManyWithWhereWithoutWorkspaceInput | CanvasUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CanvasScalarWhereInput | CanvasScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutWorkspaceInput | DocumentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutWorkspaceInput | DocumentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutWorkspaceInput | DocumentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    upsert?: SubscriptionUpsertWithoutWorkspaceInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutWorkspaceInput, SubscriptionUpdateWithoutWorkspaceInput>, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ContextModuleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutWorkspaceInput | ContextModuleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type ShareLinkUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutWorkspaceInput | ShareLinkUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    set?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    disconnect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    delete?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    update?: ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput | ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CanvasCreateWithoutWorkspaceInput, CanvasUncheckedCreateWithoutWorkspaceInput> | CanvasCreateWithoutWorkspaceInput[] | CanvasUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CanvasCreateOrConnectWithoutWorkspaceInput | CanvasCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CanvasUpsertWithWhereUniqueWithoutWorkspaceInput | CanvasUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CanvasCreateManyWorkspaceInputEnvelope
    set?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    disconnect?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    delete?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    connect?: CanvasWhereUniqueInput | CanvasWhereUniqueInput[]
    update?: CanvasUpdateWithWhereUniqueWithoutWorkspaceInput | CanvasUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CanvasUpdateManyWithWhereWithoutWorkspaceInput | CanvasUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CanvasScalarWhereInput | CanvasScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput> | DocumentCreateWithoutWorkspaceInput[] | DocumentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkspaceInput | DocumentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutWorkspaceInput | DocumentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DocumentCreateManyWorkspaceInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutWorkspaceInput | DocumentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutWorkspaceInput | DocumentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutWorkspaceInput
    upsert?: SubscriptionUpsertWithoutWorkspaceInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutWorkspaceInput, SubscriptionUpdateWithoutWorkspaceInput>, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput> | ContextModuleCreateWithoutWorkspaceInput[] | ContextModuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ContextModuleCreateOrConnectWithoutWorkspaceInput | ContextModuleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ContextModuleCreateManyWorkspaceInputEnvelope
    set?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    disconnect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    delete?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    connect?: ContextModuleWhereUniqueInput | ContextModuleWhereUniqueInput[]
    update?: ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput | ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ContextModuleUpdateManyWithWhereWithoutWorkspaceInput | ContextModuleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
  }

  export type ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput> | ShareLinkCreateWithoutWorkspaceInput[] | ShareLinkUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutWorkspaceInput | ShareLinkCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ShareLinkCreateManyWorkspaceInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput | ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutWorkspaceInput | ShareLinkUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput> | ProviderAPIKeyCreateWithoutWorkspaceInput[] | ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput | ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProviderAPIKeyCreateManyWorkspaceInputEnvelope
    set?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    disconnect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    delete?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    connect?: ProviderAPIKeyWhereUniqueInput | ProviderAPIKeyWhereUniqueInput[]
    update?: ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput | ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput | ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumWorkspaceRoleFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceRole
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    upsert?: WorkspaceUpsertWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutMembersInput, WorkspaceUpdateWithoutMembersInput>, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentWorkspaceInvitesInput = {
    create?: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentWorkspaceInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput = {
    create?: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedWorkspaceInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    upsert?: WorkspaceUpsertWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitationsInput, WorkspaceUpdateWithoutInvitationsInput>, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentWorkspaceInvitesInput
    upsert?: UserUpsertWithoutSentWorkspaceInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentWorkspaceInvitesInput, UserUpdateWithoutSentWorkspaceInvitesInput>, UserUncheckedUpdateWithoutSentWorkspaceInvitesInput>
  }

  export type UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedWorkspaceInvitesInput
    upsert?: UserUpsertWithoutReceivedWorkspaceInvitesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedWorkspaceInvitesInput, UserUpdateWithoutReceivedWorkspaceInvitesInput>, UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput>
  }

  export type WorkspaceCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApiKeysInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumAuthTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuthType
  }

  export type WorkspaceUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApiKeysInput
    upsert?: WorkspaceUpsertWithoutApiKeysInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutApiKeysInput, WorkspaceUpdateWithoutApiKeysInput>, WorkspaceUncheckedUpdateWithoutApiKeysInput>
  }

  export type WorkspaceCreateNestedOneWithoutShareLinksInput = {
    create?: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutShareLinksInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumShareableAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShareableAssetType
  }

  export type EnumShareAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.ShareAccessLevel
  }

  export type WorkspaceUpdateOneRequiredWithoutShareLinksNestedInput = {
    create?: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutShareLinksInput
    upsert?: WorkspaceUpsertWithoutShareLinksInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutShareLinksInput, WorkspaceUpdateWithoutShareLinksInput>, WorkspaceUncheckedUpdateWithoutShareLinksInput>
  }

  export type WorkspaceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocumentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EmbeddingCreateNestedManyWithoutDocumentInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
  }

  export type ActionPodCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ActionPodCreateWithoutDocumentInput, ActionPodUncheckedCreateWithoutDocumentInput> | ActionPodCreateWithoutDocumentInput[] | ActionPodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutDocumentInput | ActionPodCreateOrConnectWithoutDocumentInput[]
    createMany?: ActionPodCreateManyDocumentInputEnvelope
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
  }

  export type EmbeddingUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
  }

  export type ActionPodUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ActionPodCreateWithoutDocumentInput, ActionPodUncheckedCreateWithoutDocumentInput> | ActionPodCreateWithoutDocumentInput[] | ActionPodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutDocumentInput | ActionPodCreateOrConnectWithoutDocumentInput[]
    createMany?: ActionPodCreateManyDocumentInputEnvelope
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocumentsInput
    upsert?: WorkspaceUpsertWithoutDocumentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDocumentsInput, WorkspaceUpdateWithoutDocumentsInput>, WorkspaceUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmbeddingUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    upsert?: EmbeddingUpsertWithWhereUniqueWithoutDocumentInput | EmbeddingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    set?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    disconnect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    delete?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    update?: EmbeddingUpdateWithWhereUniqueWithoutDocumentInput | EmbeddingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: EmbeddingUpdateManyWithWhereWithoutDocumentInput | EmbeddingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
  }

  export type ActionPodUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ActionPodCreateWithoutDocumentInput, ActionPodUncheckedCreateWithoutDocumentInput> | ActionPodCreateWithoutDocumentInput[] | ActionPodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutDocumentInput | ActionPodCreateOrConnectWithoutDocumentInput[]
    upsert?: ActionPodUpsertWithWhereUniqueWithoutDocumentInput | ActionPodUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ActionPodCreateManyDocumentInputEnvelope
    set?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    disconnect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    delete?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    update?: ActionPodUpdateWithWhereUniqueWithoutDocumentInput | ActionPodUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ActionPodUpdateManyWithWhereWithoutDocumentInput | ActionPodUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
  }

  export type EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput> | EmbeddingCreateWithoutDocumentInput[] | EmbeddingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutDocumentInput | EmbeddingCreateOrConnectWithoutDocumentInput[]
    upsert?: EmbeddingUpsertWithWhereUniqueWithoutDocumentInput | EmbeddingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: EmbeddingCreateManyDocumentInputEnvelope
    set?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    disconnect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    delete?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    update?: EmbeddingUpdateWithWhereUniqueWithoutDocumentInput | EmbeddingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: EmbeddingUpdateManyWithWhereWithoutDocumentInput | EmbeddingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
  }

  export type ActionPodUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ActionPodCreateWithoutDocumentInput, ActionPodUncheckedCreateWithoutDocumentInput> | ActionPodCreateWithoutDocumentInput[] | ActionPodUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ActionPodCreateOrConnectWithoutDocumentInput | ActionPodCreateOrConnectWithoutDocumentInput[]
    upsert?: ActionPodUpsertWithWhereUniqueWithoutDocumentInput | ActionPodUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ActionPodCreateManyDocumentInputEnvelope
    set?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    disconnect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    delete?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    connect?: ActionPodWhereUniqueInput | ActionPodWhereUniqueInput[]
    update?: ActionPodUpdateWithWhereUniqueWithoutDocumentInput | ActionPodUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ActionPodUpdateManyWithWhereWithoutDocumentInput | ActionPodUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutEmbeddingsInput = {
    create?: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutEmbeddingsInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutEmbeddingsNestedInput = {
    create?: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutEmbeddingsInput
    upsert?: DocumentUpsertWithoutEmbeddingsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutEmbeddingsInput, DocumentUpdateWithoutEmbeddingsInput>, DocumentUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type NestedEnumAdminResourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceFilter<$PrismaModel> | $Enums.AdminResource
  }

  export type NestedEnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type NestedEnumAdminResourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel>
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminResourceWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSpecificPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionFilter<$PrismaModel> | $Enums.SpecificPermission
  }

  export type NestedEnumAdminResourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableFilter<$PrismaModel> | $Enums.AdminResource | null
  }

  export type NestedEnumSpecificPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpecificPermission | EnumSpecificPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpecificPermission[] | ListEnumSpecificPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecificPermissionWithAggregatesFilter<$PrismaModel> | $Enums.SpecificPermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecificPermissionFilter<$PrismaModel>
    _max?: NestedEnumSpecificPermissionFilter<$PrismaModel>
  }

  export type NestedEnumAdminResourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminResource | EnumAdminResourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminResource[] | ListEnumAdminResourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminResourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdminResource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
    _max?: NestedEnumAdminResourceNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type NestedEnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumLLMProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderFilter<$PrismaModel> | $Enums.LLMProvider
  }

  export type NestedEnumLLMProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LLMProvider | EnumLLMProviderFieldRefInput<$PrismaModel>
    in?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.LLMProvider[] | ListEnumLLMProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumLLMProviderWithAggregatesFilter<$PrismaModel> | $Enums.LLMProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLLMProviderFilter<$PrismaModel>
    _max?: NestedEnumLLMProviderFilter<$PrismaModel>
  }

  export type NestedEnumModelCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryFilter<$PrismaModel> | $Enums.ModelCategory
  }

  export type NestedEnumModelCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelCategory | EnumModelCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelCategory[] | ListEnumModelCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumModelCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ModelCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelCategoryFilter<$PrismaModel>
    _max?: NestedEnumModelCategoryFilter<$PrismaModel>
  }

  export type NestedEnumCanvasVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasVisibility | EnumCanvasVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasVisibilityFilter<$PrismaModel> | $Enums.CanvasVisibility
  }

  export type NestedEnumCanvasVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasVisibility | EnumCanvasVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasVisibility[] | ListEnumCanvasVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.CanvasVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCanvasVisibilityFilter<$PrismaModel>
    _max?: NestedEnumCanvasVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumCanvasAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasAccessLevel | EnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasAccessLevelFilter<$PrismaModel> | $Enums.CanvasAccessLevel
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumCanvasAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasAccessLevel | EnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasAccessLevel[] | ListEnumCanvasAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.CanvasAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCanvasAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumCanvasAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumCanvasActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasActivityAction | EnumCanvasActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasActivityActionFilter<$PrismaModel> | $Enums.CanvasActivityAction
  }

  export type NestedEnumCanvasActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CanvasActivityAction | EnumCanvasActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CanvasActivityAction[] | ListEnumCanvasActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCanvasActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.CanvasActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCanvasActivityActionFilter<$PrismaModel>
    _max?: NestedEnumCanvasActivityActionFilter<$PrismaModel>
  }

  export type NestedEnumActionPodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodType | EnumActionPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodTypeFilter<$PrismaModel> | $Enums.ActionPodType
  }

  export type NestedEnumActionPodExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodExecutionStatus | EnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodExecutionStatusFilter<$PrismaModel> | $Enums.ActionPodExecutionStatus
  }

  export type NestedEnumActionPodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodType | EnumActionPodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodType[] | ListEnumActionPodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionPodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionPodTypeFilter<$PrismaModel>
    _max?: NestedEnumActionPodTypeFilter<$PrismaModel>
  }

  export type NestedEnumActionPodExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPodExecutionStatus | EnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPodExecutionStatus[] | ListEnumActionPodExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPodExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionPodExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionPodExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumActionPodExecutionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeFilter<$PrismaModel> | $Enums.WorkspaceType
  }

  export type NestedEnumWorkspaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceType | EnumWorkspaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceType[] | ListEnumWorkspaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleFilter<$PrismaModel> | $Enums.WorkspaceRole
  }

  export type NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeFilter<$PrismaModel> | $Enums.AuthType
  }

  export type NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTypeFilter<$PrismaModel>
  }

  export type NestedEnumShareableAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeFilter<$PrismaModel> | $Enums.ShareableAssetType
  }

  export type NestedEnumShareAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelFilter<$PrismaModel> | $Enums.ShareAccessLevel
  }

  export type NestedEnumShareableAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareableAssetType | EnumShareableAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareableAssetType[] | ListEnumShareableAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareableAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShareableAssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumShareableAssetTypeFilter<$PrismaModel>
  }

  export type NestedEnumShareAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareAccessLevel | EnumShareAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareAccessLevel[] | ListEnumShareAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumShareAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.ShareAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumShareAccessLevelFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type AdminSessionCreateWithoutAdminInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionUncheckedCreateWithoutAdminInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminSessionCreateOrConnectWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionCreateManyAdminInputEnvelope = {
    data: AdminSessionCreateManyAdminInput | AdminSessionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogCreateManyAdminInputEnvelope = {
    data: AdminAuditLogCreateManyAdminInput | AdminAuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminPermissionCreateWithoutAdminInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionUncheckedCreateWithoutAdminInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminPermissionCreateOrConnectWithoutAdminInput = {
    where: AdminPermissionWhereUniqueInput
    create: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput>
  }

  export type AdminPermissionCreateManyAdminInputEnvelope = {
    data: AdminPermissionCreateManyAdminInput | AdminPermissionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAPIKeyCreateWithoutAdminInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminAPIKeyCreateOrConnectWithoutAdminInput = {
    where: AdminAPIKeyWhereUniqueInput
    create: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput>
  }

  export type AdminAPIKeyCreateManyAdminInputEnvelope = {
    data: AdminAPIKeyCreateManyAdminInput | AdminAPIKeyCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminInvitationCreateOrConnectWithoutInviterInput = {
    where: AdminInvitationWhereUniqueInput
    create: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput>
  }

  export type AdminInvitationCreateManyInviterInputEnvelope = {
    data: AdminInvitationCreateManyInviterInput | AdminInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type AdminSessionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    update: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    data: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminSessionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminSessionScalarWhereInput
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminSessionScalarWhereInput = {
    AND?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    OR?: AdminSessionScalarWhereInput[]
    NOT?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    token?: StringFilter<"AdminSession"> | string
    refreshToken?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    deviceFingerprint?: StringNullableFilter<"AdminSession"> | string | null
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"AdminSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdminSession"> | Date | string | null
    revokedReason?: StringNullableFilter<"AdminSession"> | string | null
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringNullableFilter<"AdminAuditLog"> | string | null
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    resource?: EnumAdminResourceFilter<"AdminAuditLog"> | $Enums.AdminResource
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    method?: StringFilter<"AdminAuditLog"> | string
    endpoint?: StringFilter<"AdminAuditLog"> | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    changesBefore?: JsonNullableFilter<"AdminAuditLog">
    changesAfter?: JsonNullableFilter<"AdminAuditLog">
    status?: IntFilter<"AdminAuditLog"> | number
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    executionTimeMs?: IntNullableFilter<"AdminAuditLog"> | number | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminPermissionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminPermissionWhereUniqueInput
    update: XOR<AdminPermissionUpdateWithoutAdminInput, AdminPermissionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminPermissionCreateWithoutAdminInput, AdminPermissionUncheckedCreateWithoutAdminInput>
  }

  export type AdminPermissionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminPermissionWhereUniqueInput
    data: XOR<AdminPermissionUpdateWithoutAdminInput, AdminPermissionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminPermissionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminPermissionScalarWhereInput
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminPermissionScalarWhereInput = {
    AND?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
    OR?: AdminPermissionScalarWhereInput[]
    NOT?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
    id?: StringFilter<"AdminPermission"> | string
    adminId?: StringFilter<"AdminPermission"> | string
    permission?: EnumSpecificPermissionFilter<"AdminPermission"> | $Enums.SpecificPermission
    resource?: EnumAdminResourceNullableFilter<"AdminPermission"> | $Enums.AdminResource | null
    grantedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    grantedBy?: StringNullableFilter<"AdminPermission"> | string | null
    expiresAt?: DateTimeNullableFilter<"AdminPermission"> | Date | string | null
  }

  export type AdminAPIKeyUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAPIKeyWhereUniqueInput
    update: XOR<AdminAPIKeyUpdateWithoutAdminInput, AdminAPIKeyUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAPIKeyCreateWithoutAdminInput, AdminAPIKeyUncheckedCreateWithoutAdminInput>
  }

  export type AdminAPIKeyUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAPIKeyWhereUniqueInput
    data: XOR<AdminAPIKeyUpdateWithoutAdminInput, AdminAPIKeyUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAPIKeyUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAPIKeyScalarWhereInput
    data: XOR<AdminAPIKeyUpdateManyMutationInput, AdminAPIKeyUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAPIKeyScalarWhereInput = {
    AND?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
    OR?: AdminAPIKeyScalarWhereInput[]
    NOT?: AdminAPIKeyScalarWhereInput | AdminAPIKeyScalarWhereInput[]
    id?: StringFilter<"AdminAPIKey"> | string
    adminId?: StringFilter<"AdminAPIKey"> | string
    name?: StringFilter<"AdminAPIKey"> | string
    keyHash?: StringFilter<"AdminAPIKey"> | string
    keyPrefix?: StringFilter<"AdminAPIKey"> | string
    scopes?: JsonFilter<"AdminAPIKey">
    rateLimit?: IntNullableFilter<"AdminAPIKey"> | number | null
    allowedIps?: JsonNullableFilter<"AdminAPIKey">
    createdAt?: DateTimeFilter<"AdminAPIKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"AdminAPIKey"> | Date | string | null
  }

  export type AdminInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: AdminInvitationWhereUniqueInput
    update: XOR<AdminInvitationUpdateWithoutInviterInput, AdminInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<AdminInvitationCreateWithoutInviterInput, AdminInvitationUncheckedCreateWithoutInviterInput>
  }

  export type AdminInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: AdminInvitationWhereUniqueInput
    data: XOR<AdminInvitationUpdateWithoutInviterInput, AdminInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type AdminInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: AdminInvitationScalarWhereInput
    data: XOR<AdminInvitationUpdateManyMutationInput, AdminInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type AdminInvitationScalarWhereInput = {
    AND?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
    OR?: AdminInvitationScalarWhereInput[]
    NOT?: AdminInvitationScalarWhereInput | AdminInvitationScalarWhereInput[]
    id?: StringFilter<"AdminInvitation"> | string
    email?: StringFilter<"AdminInvitation"> | string
    role?: EnumAdminRoleFilter<"AdminInvitation"> | $Enums.AdminRole
    token?: StringFilter<"AdminInvitation"> | string
    invitedBy?: StringFilter<"AdminInvitation"> | string
    createdAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"AdminInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"AdminInvitation"> | Date | string | null
  }

  export type AdminCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutSessionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
  }

  export type AdminUpsertWithoutSessionsInput = {
    update: XOR<AdminUpdateWithoutSessionsInput, AdminUncheckedUpdateWithoutSessionsInput>
    create: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSessionsInput, AdminUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutAuditLogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
  }

  export type AdminUpsertWithoutAuditLogsInput = {
    update: XOR<AdminUpdateWithoutAuditLogsInput, AdminUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuditLogsInput, AdminUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutPermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutPermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutPermissionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
  }

  export type AdminUpsertWithoutPermissionsInput = {
    update: XOR<AdminUpdateWithoutPermissionsInput, AdminUncheckedUpdateWithoutPermissionsInput>
    create: XOR<AdminCreateWithoutPermissionsInput, AdminUncheckedCreateWithoutPermissionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutPermissionsInput, AdminUncheckedUpdateWithoutPermissionsInput>
  }

  export type AdminUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationCreateNestedManyWithoutInviterInput
  }

  export type AdminUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    invitations?: AdminInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type AdminCreateOrConnectWithoutApiKeysInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
  }

  export type AdminUpsertWithoutApiKeysInput = {
    update: XOR<AdminUpdateWithoutApiKeysInput, AdminUncheckedUpdateWithoutApiKeysInput>
    create: XOR<AdminCreateWithoutApiKeysInput, AdminUncheckedCreateWithoutApiKeysInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutApiKeysInput, AdminUncheckedUpdateWithoutApiKeysInput>
  }

  export type AdminUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUpdateManyWithoutInviterNestedInput
  }

  export type AdminUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    invitations?: AdminInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type AdminCreateWithoutInvitationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutInvitationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.AdminRole
    status?: $Enums.AdminStatus
    isSuperAdmin?: boolean
    requiresMfa?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: AdminAPIKeyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutInvitationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
  }

  export type AdminUpsertWithoutInvitationsInput = {
    update: XOR<AdminUpdateWithoutInvitationsInput, AdminUncheckedUpdateWithoutInvitationsInput>
    create: XOR<AdminCreateWithoutInvitationsInput, AdminUncheckedCreateWithoutInvitationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutInvitationsInput, AdminUncheckedUpdateWithoutInvitationsInput>
  }

  export type AdminUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    requiresMfa?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    mfaVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowedIpAddresses?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: AdminAPIKeyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type WorkspaceCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSubscriptionInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
  }

  export type PodUsageLogCreateWithoutSubscriptionInput = {
    id?: string
    executionId: string
    canvasId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
    pod: ActionPodCreateNestedOneWithoutUsageLogsInput
  }

  export type PodUsageLogUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    podId: string
    executionId: string
    canvasId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogCreateOrConnectWithoutSubscriptionInput = {
    where: PodUsageLogWhereUniqueInput
    create: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type PodUsageLogCreateManySubscriptionInputEnvelope = {
    data: PodUsageLogCreateManySubscriptionInput | PodUsageLogCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CreditPurchaseCreateWithoutSubscriptionInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditPurchaseCreateOrConnectWithoutSubscriptionInput = {
    where: CreditPurchaseWhereUniqueInput
    create: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditPurchaseCreateManySubscriptionInputEnvelope = {
    data: CreditPurchaseCreateManySubscriptionInput | CreditPurchaseCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CreditUsageLogCreateWithoutSubscriptionInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type CreditUsageLogCreateOrConnectWithoutSubscriptionInput = {
    where: CreditUsageLogWhereUniqueInput
    create: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditUsageLogCreateManySubscriptionInputEnvelope = {
    data: CreditUsageLogCreateManySubscriptionInput | CreditUsageLogCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutSubscriptionInput = {
    update: XOR<WorkspaceUpdateWithoutSubscriptionInput, WorkspaceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<WorkspaceCreateWithoutSubscriptionInput, WorkspaceUncheckedCreateWithoutSubscriptionInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSubscriptionInput, WorkspaceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type WorkspaceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type PodUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PodUsageLogWhereUniqueInput
    update: XOR<PodUsageLogUpdateWithoutSubscriptionInput, PodUsageLogUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PodUsageLogCreateWithoutSubscriptionInput, PodUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type PodUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PodUsageLogWhereUniqueInput
    data: XOR<PodUsageLogUpdateWithoutSubscriptionInput, PodUsageLogUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PodUsageLogUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PodUsageLogScalarWhereInput
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PodUsageLogScalarWhereInput = {
    AND?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
    OR?: PodUsageLogScalarWhereInput[]
    NOT?: PodUsageLogScalarWhereInput | PodUsageLogScalarWhereInput[]
    id?: StringFilter<"PodUsageLog"> | string
    podId?: StringFilter<"PodUsageLog"> | string
    executionId?: StringFilter<"PodUsageLog"> | string
    canvasId?: StringFilter<"PodUsageLog"> | string
    workspaceId?: StringFilter<"PodUsageLog"> | string
    subscriptionId?: StringFilter<"PodUsageLog"> | string
    provider?: EnumLLMProviderFilter<"PodUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"PodUsageLog"> | string
    modelName?: StringNullableFilter<"PodUsageLog"> | string | null
    providerMetadata?: JsonNullableFilter<"PodUsageLog">
    inputTokens?: IntFilter<"PodUsageLog"> | number
    outputTokens?: IntFilter<"PodUsageLog"> | number
    reasoningTokens?: IntFilter<"PodUsageLog"> | number
    creditsConsumed?: IntFilter<"PodUsageLog"> | number
    runtimeInMs?: IntNullableFilter<"PodUsageLog"> | number | null
    inputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFilter<"PodUsageLog"> | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFilter<"PodUsageLog"> | Date | string
  }

  export type CreditPurchaseUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditPurchaseWhereUniqueInput
    update: XOR<CreditPurchaseUpdateWithoutSubscriptionInput, CreditPurchaseUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CreditPurchaseCreateWithoutSubscriptionInput, CreditPurchaseUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditPurchaseUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditPurchaseWhereUniqueInput
    data: XOR<CreditPurchaseUpdateWithoutSubscriptionInput, CreditPurchaseUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CreditPurchaseUpdateManyWithWhereWithoutSubscriptionInput = {
    where: CreditPurchaseScalarWhereInput
    data: XOR<CreditPurchaseUpdateManyMutationInput, CreditPurchaseUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type CreditPurchaseScalarWhereInput = {
    AND?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
    OR?: CreditPurchaseScalarWhereInput[]
    NOT?: CreditPurchaseScalarWhereInput | CreditPurchaseScalarWhereInput[]
    id?: StringFilter<"CreditPurchase"> | string
    subscriptionId?: StringFilter<"CreditPurchase"> | string
    creditsPurchased?: IntFilter<"CreditPurchase"> | number
    amountPaid?: DecimalFilter<"CreditPurchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"CreditPurchase"> | string
    stripeChargeId?: StringFilter<"CreditPurchase"> | string
    status?: StringFilter<"CreditPurchase"> | string
    purchasedAt?: DateTimeFilter<"CreditPurchase"> | Date | string
  }

  export type CreditUsageLogUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditUsageLogWhereUniqueInput
    update: XOR<CreditUsageLogUpdateWithoutSubscriptionInput, CreditUsageLogUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CreditUsageLogCreateWithoutSubscriptionInput, CreditUsageLogUncheckedCreateWithoutSubscriptionInput>
  }

  export type CreditUsageLogUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: CreditUsageLogWhereUniqueInput
    data: XOR<CreditUsageLogUpdateWithoutSubscriptionInput, CreditUsageLogUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CreditUsageLogUpdateManyWithWhereWithoutSubscriptionInput = {
    where: CreditUsageLogScalarWhereInput
    data: XOR<CreditUsageLogUpdateManyMutationInput, CreditUsageLogUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type CreditUsageLogScalarWhereInput = {
    AND?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
    OR?: CreditUsageLogScalarWhereInput[]
    NOT?: CreditUsageLogScalarWhereInput | CreditUsageLogScalarWhereInput[]
    id?: StringFilter<"CreditUsageLog"> | string
    subscriptionId?: StringFilter<"CreditUsageLog"> | string
    workspaceId?: StringFilter<"CreditUsageLog"> | string
    canvasId?: StringFilter<"CreditUsageLog"> | string
    podId?: StringFilter<"CreditUsageLog"> | string
    executionId?: StringFilter<"CreditUsageLog"> | string
    creditsUsed?: IntFilter<"CreditUsageLog"> | number
    balanceBefore?: IntFilter<"CreditUsageLog"> | number
    balanceAfter?: IntFilter<"CreditUsageLog"> | number
    provider?: EnumLLMProviderFilter<"CreditUsageLog"> | $Enums.LLMProvider
    modelId?: StringFilter<"CreditUsageLog"> | string
    modelName?: StringNullableFilter<"CreditUsageLog"> | string | null
    createdAt?: DateTimeFilter<"CreditUsageLog"> | Date | string
  }

  export type SubscriptionCreateWithoutCreditPurchasesInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCreditPurchasesInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCreditPurchasesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
  }

  export type SubscriptionUpsertWithoutCreditPurchasesInput = {
    update: XOR<SubscriptionUpdateWithoutCreditPurchasesInput, SubscriptionUncheckedUpdateWithoutCreditPurchasesInput>
    create: XOR<SubscriptionCreateWithoutCreditPurchasesInput, SubscriptionUncheckedCreateWithoutCreditPurchasesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutCreditPurchasesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutCreditPurchasesInput, SubscriptionUncheckedUpdateWithoutCreditPurchasesInput>
  }

  export type SubscriptionUpdateWithoutCreditPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCreditPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateWithoutCreditUsageInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCreditUsageInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCreditUsageInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
  }

  export type SubscriptionUpsertWithoutCreditUsageInput = {
    update: XOR<SubscriptionUpdateWithoutCreditUsageInput, SubscriptionUncheckedUpdateWithoutCreditUsageInput>
    create: XOR<SubscriptionCreateWithoutCreditUsageInput, SubscriptionUncheckedCreateWithoutCreditUsageInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutCreditUsageInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutCreditUsageInput, SubscriptionUncheckedUpdateWithoutCreditUsageInput>
  }

  export type SubscriptionUpdateWithoutCreditUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCreditUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceCreateWithoutCanvasesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCanvasesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCanvasesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCanvasesInput, WorkspaceUncheckedCreateWithoutCanvasesInput>
  }

  export type ActionPodCreateWithoutCanvasInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutCanvasInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutCanvasInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutCanvasInput, ActionPodUncheckedCreateWithoutCanvasInput>
  }

  export type ActionPodCreateManyCanvasInputEnvelope = {
    data: ActionPodCreateManyCanvasInput | ActionPodCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type EdgeCreateWithoutCanvasInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    sourcePod: ActionPodCreateNestedOneWithoutSourceEdgesInput
    targetPod: ActionPodCreateNestedOneWithoutTargetEdgesInput
  }

  export type EdgeUncheckedCreateWithoutCanvasInput = {
    id?: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateOrConnectWithoutCanvasInput = {
    where: EdgeWhereUniqueInput
    create: XOR<EdgeCreateWithoutCanvasInput, EdgeUncheckedCreateWithoutCanvasInput>
  }

  export type EdgeCreateManyCanvasInputEnvelope = {
    data: EdgeCreateManyCanvasInput | EdgeCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type ActionPodCreateWithoutContextCanvasInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutContextCanvasInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutContextCanvasInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutContextCanvasInput, ActionPodUncheckedCreateWithoutContextCanvasInput>
  }

  export type ActionPodCreateManyContextCanvasInputEnvelope = {
    data: ActionPodCreateManyContextCanvasInput | ActionPodCreateManyContextCanvasInput[]
    skipDuplicates?: boolean
  }

  export type ContextModuleCreateWithoutOriginalCanvasInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutContextModulesInput
  }

  export type ContextModuleUncheckedCreateWithoutOriginalCanvasInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateOrConnectWithoutOriginalCanvasInput = {
    where: ContextModuleWhereUniqueInput
    create: XOR<ContextModuleCreateWithoutOriginalCanvasInput, ContextModuleUncheckedCreateWithoutOriginalCanvasInput>
  }

  export type ContextModuleCreateManyOriginalCanvasInputEnvelope = {
    data: ContextModuleCreateManyOriginalCanvasInput | ContextModuleCreateManyOriginalCanvasInput[]
    skipDuplicates?: boolean
  }

  export type CanvasCollaboratorCreateWithoutCanvasInput = {
    id?: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCanvasCollaborationsInput
  }

  export type CanvasCollaboratorUncheckedCreateWithoutCanvasInput = {
    id?: string
    userId: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type CanvasCollaboratorCreateOrConnectWithoutCanvasInput = {
    where: CanvasCollaboratorWhereUniqueInput
    create: XOR<CanvasCollaboratorCreateWithoutCanvasInput, CanvasCollaboratorUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasCollaboratorCreateManyCanvasInputEnvelope = {
    data: CanvasCollaboratorCreateManyCanvasInput | CanvasCollaboratorCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type CanvasInvitationCreateWithoutCanvasInput = {
    id?: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    inviter: UserCreateNestedOneWithoutSentCanvasInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedCanvasInvitesInput
  }

  export type CanvasInvitationUncheckedCreateWithoutCanvasInput = {
    id?: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationCreateOrConnectWithoutCanvasInput = {
    where: CanvasInvitationWhereUniqueInput
    create: XOR<CanvasInvitationCreateWithoutCanvasInput, CanvasInvitationUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasInvitationCreateManyCanvasInputEnvelope = {
    data: CanvasInvitationCreateManyCanvasInput | CanvasInvitationCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type CanvasSessionCreateWithoutCanvasInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type CanvasSessionUncheckedCreateWithoutCanvasInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type CanvasSessionCreateOrConnectWithoutCanvasInput = {
    where: CanvasSessionWhereUniqueInput
    create: XOR<CanvasSessionCreateWithoutCanvasInput, CanvasSessionUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasSessionCreateManyCanvasInputEnvelope = {
    data: CanvasSessionCreateManyCanvasInput | CanvasSessionCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type CanvasActivityLogCreateWithoutCanvasInput = {
    id?: string
    userId?: string | null
    action: $Enums.CanvasActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CanvasActivityLogUncheckedCreateWithoutCanvasInput = {
    id?: string
    userId?: string | null
    action: $Enums.CanvasActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CanvasActivityLogCreateOrConnectWithoutCanvasInput = {
    where: CanvasActivityLogWhereUniqueInput
    create: XOR<CanvasActivityLogCreateWithoutCanvasInput, CanvasActivityLogUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasActivityLogCreateManyCanvasInputEnvelope = {
    data: CanvasActivityLogCreateManyCanvasInput | CanvasActivityLogCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type CanvasCommentCreateWithoutCanvasInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasCommentUncheckedCreateWithoutCanvasInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasCommentCreateOrConnectWithoutCanvasInput = {
    where: CanvasCommentWhereUniqueInput
    create: XOR<CanvasCommentCreateWithoutCanvasInput, CanvasCommentUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasCommentCreateManyCanvasInputEnvelope = {
    data: CanvasCommentCreateManyCanvasInput | CanvasCommentCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutCanvasesInput = {
    update: XOR<WorkspaceUpdateWithoutCanvasesInput, WorkspaceUncheckedUpdateWithoutCanvasesInput>
    create: XOR<WorkspaceCreateWithoutCanvasesInput, WorkspaceUncheckedCreateWithoutCanvasesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutCanvasesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutCanvasesInput, WorkspaceUncheckedUpdateWithoutCanvasesInput>
  }

  export type WorkspaceUpdateWithoutCanvasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCanvasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ActionPodUpsertWithWhereUniqueWithoutCanvasInput = {
    where: ActionPodWhereUniqueInput
    update: XOR<ActionPodUpdateWithoutCanvasInput, ActionPodUncheckedUpdateWithoutCanvasInput>
    create: XOR<ActionPodCreateWithoutCanvasInput, ActionPodUncheckedCreateWithoutCanvasInput>
  }

  export type ActionPodUpdateWithWhereUniqueWithoutCanvasInput = {
    where: ActionPodWhereUniqueInput
    data: XOR<ActionPodUpdateWithoutCanvasInput, ActionPodUncheckedUpdateWithoutCanvasInput>
  }

  export type ActionPodUpdateManyWithWhereWithoutCanvasInput = {
    where: ActionPodScalarWhereInput
    data: XOR<ActionPodUpdateManyMutationInput, ActionPodUncheckedUpdateManyWithoutCanvasInput>
  }

  export type ActionPodScalarWhereInput = {
    AND?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
    OR?: ActionPodScalarWhereInput[]
    NOT?: ActionPodScalarWhereInput | ActionPodScalarWhereInput[]
    id?: StringFilter<"ActionPod"> | string
    canvasId?: StringFilter<"ActionPod"> | string
    type?: EnumActionPodTypeFilter<"ActionPod"> | $Enums.ActionPodType
    position?: JsonFilter<"ActionPod">
    executionStatus?: EnumActionPodExecutionStatusFilter<"ActionPod"> | $Enums.ActionPodExecutionStatus
    lastExecutionId?: StringNullableFilter<"ActionPod"> | string | null
    contextCanvasId?: StringNullableFilter<"ActionPod"> | string | null
    documentId?: StringNullableFilter<"ActionPod"> | string | null
    lockedBy?: StringNullableFilter<"ActionPod"> | string | null
    lockedAt?: DateTimeNullableFilter<"ActionPod"> | Date | string | null
    dynamoPartitionKey?: StringFilter<"ActionPod"> | string
    dynamoSortKey?: StringFilter<"ActionPod"> | string
    s3VectorBucket?: StringNullableFilter<"ActionPod"> | string | null
    s3VectorKey?: StringNullableFilter<"ActionPod"> | string | null
    createdAt?: DateTimeFilter<"ActionPod"> | Date | string
    updatedAt?: DateTimeFilter<"ActionPod"> | Date | string
  }

  export type EdgeUpsertWithWhereUniqueWithoutCanvasInput = {
    where: EdgeWhereUniqueInput
    update: XOR<EdgeUpdateWithoutCanvasInput, EdgeUncheckedUpdateWithoutCanvasInput>
    create: XOR<EdgeCreateWithoutCanvasInput, EdgeUncheckedCreateWithoutCanvasInput>
  }

  export type EdgeUpdateWithWhereUniqueWithoutCanvasInput = {
    where: EdgeWhereUniqueInput
    data: XOR<EdgeUpdateWithoutCanvasInput, EdgeUncheckedUpdateWithoutCanvasInput>
  }

  export type EdgeUpdateManyWithWhereWithoutCanvasInput = {
    where: EdgeScalarWhereInput
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutCanvasInput>
  }

  export type EdgeScalarWhereInput = {
    AND?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
    OR?: EdgeScalarWhereInput[]
    NOT?: EdgeScalarWhereInput | EdgeScalarWhereInput[]
    id?: StringFilter<"Edge"> | string
    canvasId?: StringFilter<"Edge"> | string
    sourcePodId?: StringFilter<"Edge"> | string
    targetPodId?: StringFilter<"Edge"> | string
    sourceHandle?: StringNullableFilter<"Edge"> | string | null
    targetHandle?: StringNullableFilter<"Edge"> | string | null
    animated?: BoolFilter<"Edge"> | boolean
    createdAt?: DateTimeFilter<"Edge"> | Date | string
  }

  export type ActionPodUpsertWithWhereUniqueWithoutContextCanvasInput = {
    where: ActionPodWhereUniqueInput
    update: XOR<ActionPodUpdateWithoutContextCanvasInput, ActionPodUncheckedUpdateWithoutContextCanvasInput>
    create: XOR<ActionPodCreateWithoutContextCanvasInput, ActionPodUncheckedCreateWithoutContextCanvasInput>
  }

  export type ActionPodUpdateWithWhereUniqueWithoutContextCanvasInput = {
    where: ActionPodWhereUniqueInput
    data: XOR<ActionPodUpdateWithoutContextCanvasInput, ActionPodUncheckedUpdateWithoutContextCanvasInput>
  }

  export type ActionPodUpdateManyWithWhereWithoutContextCanvasInput = {
    where: ActionPodScalarWhereInput
    data: XOR<ActionPodUpdateManyMutationInput, ActionPodUncheckedUpdateManyWithoutContextCanvasInput>
  }

  export type ContextModuleUpsertWithWhereUniqueWithoutOriginalCanvasInput = {
    where: ContextModuleWhereUniqueInput
    update: XOR<ContextModuleUpdateWithoutOriginalCanvasInput, ContextModuleUncheckedUpdateWithoutOriginalCanvasInput>
    create: XOR<ContextModuleCreateWithoutOriginalCanvasInput, ContextModuleUncheckedCreateWithoutOriginalCanvasInput>
  }

  export type ContextModuleUpdateWithWhereUniqueWithoutOriginalCanvasInput = {
    where: ContextModuleWhereUniqueInput
    data: XOR<ContextModuleUpdateWithoutOriginalCanvasInput, ContextModuleUncheckedUpdateWithoutOriginalCanvasInput>
  }

  export type ContextModuleUpdateManyWithWhereWithoutOriginalCanvasInput = {
    where: ContextModuleScalarWhereInput
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyWithoutOriginalCanvasInput>
  }

  export type ContextModuleScalarWhereInput = {
    AND?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
    OR?: ContextModuleScalarWhereInput[]
    NOT?: ContextModuleScalarWhereInput | ContextModuleScalarWhereInput[]
    id?: StringFilter<"ContextModule"> | string
    workspaceId?: StringFilter<"ContextModule"> | string
    name?: StringFilter<"ContextModule"> | string
    description?: StringNullableFilter<"ContextModule"> | string | null
    definitionJson?: JsonFilter<"ContextModule">
    originalCanvasId?: StringNullableFilter<"ContextModule"> | string | null
    version?: IntFilter<"ContextModule"> | number
    createdAt?: DateTimeFilter<"ContextModule"> | Date | string
    updatedAt?: DateTimeFilter<"ContextModule"> | Date | string
  }

  export type CanvasCollaboratorUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasCollaboratorWhereUniqueInput
    update: XOR<CanvasCollaboratorUpdateWithoutCanvasInput, CanvasCollaboratorUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasCollaboratorCreateWithoutCanvasInput, CanvasCollaboratorUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasCollaboratorUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasCollaboratorWhereUniqueInput
    data: XOR<CanvasCollaboratorUpdateWithoutCanvasInput, CanvasCollaboratorUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasCollaboratorUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasCollaboratorScalarWhereInput
    data: XOR<CanvasCollaboratorUpdateManyMutationInput, CanvasCollaboratorUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasCollaboratorScalarWhereInput = {
    AND?: CanvasCollaboratorScalarWhereInput | CanvasCollaboratorScalarWhereInput[]
    OR?: CanvasCollaboratorScalarWhereInput[]
    NOT?: CanvasCollaboratorScalarWhereInput | CanvasCollaboratorScalarWhereInput[]
    id?: StringFilter<"CanvasCollaborator"> | string
    canvasId?: StringFilter<"CanvasCollaborator"> | string
    userId?: StringFilter<"CanvasCollaborator"> | string
    accessLevel?: EnumCanvasAccessLevelFilter<"CanvasCollaborator"> | $Enums.CanvasAccessLevel
    canEdit?: BoolFilter<"CanvasCollaborator"> | boolean
    canExecute?: BoolFilter<"CanvasCollaborator"> | boolean
    canDelete?: BoolFilter<"CanvasCollaborator"> | boolean
    canShare?: BoolFilter<"CanvasCollaborator"> | boolean
    canInvite?: BoolFilter<"CanvasCollaborator"> | boolean
    invitedBy?: StringNullableFilter<"CanvasCollaborator"> | string | null
    invitedAt?: DateTimeFilter<"CanvasCollaborator"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"CanvasCollaborator"> | Date | string | null
  }

  export type CanvasInvitationUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasInvitationWhereUniqueInput
    update: XOR<CanvasInvitationUpdateWithoutCanvasInput, CanvasInvitationUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasInvitationCreateWithoutCanvasInput, CanvasInvitationUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasInvitationUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasInvitationWhereUniqueInput
    data: XOR<CanvasInvitationUpdateWithoutCanvasInput, CanvasInvitationUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasInvitationUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasInvitationScalarWhereInput
    data: XOR<CanvasInvitationUpdateManyMutationInput, CanvasInvitationUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasInvitationScalarWhereInput = {
    AND?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
    OR?: CanvasInvitationScalarWhereInput[]
    NOT?: CanvasInvitationScalarWhereInput | CanvasInvitationScalarWhereInput[]
    id?: StringFilter<"CanvasInvitation"> | string
    canvasId?: StringFilter<"CanvasInvitation"> | string
    email?: StringFilter<"CanvasInvitation"> | string
    accessLevel?: EnumCanvasAccessLevelFilter<"CanvasInvitation"> | $Enums.CanvasAccessLevel
    permissions?: JsonNullableFilter<"CanvasInvitation">
    invitedBy?: StringFilter<"CanvasInvitation"> | string
    invitedUserId?: StringNullableFilter<"CanvasInvitation"> | string | null
    token?: StringFilter<"CanvasInvitation"> | string
    status?: EnumInvitationStatusFilter<"CanvasInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"CanvasInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"CanvasInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CanvasInvitation"> | Date | string | null
  }

  export type CanvasSessionUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasSessionWhereUniqueInput
    update: XOR<CanvasSessionUpdateWithoutCanvasInput, CanvasSessionUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasSessionCreateWithoutCanvasInput, CanvasSessionUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasSessionUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasSessionWhereUniqueInput
    data: XOR<CanvasSessionUpdateWithoutCanvasInput, CanvasSessionUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasSessionUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasSessionScalarWhereInput
    data: XOR<CanvasSessionUpdateManyMutationInput, CanvasSessionUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasSessionScalarWhereInput = {
    AND?: CanvasSessionScalarWhereInput | CanvasSessionScalarWhereInput[]
    OR?: CanvasSessionScalarWhereInput[]
    NOT?: CanvasSessionScalarWhereInput | CanvasSessionScalarWhereInput[]
    id?: StringFilter<"CanvasSession"> | string
    canvasId?: StringFilter<"CanvasSession"> | string
    userId?: StringNullableFilter<"CanvasSession"> | string | null
    anonymousName?: StringNullableFilter<"CanvasSession"> | string | null
    sessionToken?: StringNullableFilter<"CanvasSession"> | string | null
    socketId?: StringNullableFilter<"CanvasSession"> | string | null
    cursorPosition?: JsonNullableFilter<"CanvasSession">
    selectedPodIds?: JsonNullableFilter<"CanvasSession">
    viewportState?: JsonNullableFilter<"CanvasSession">
    userColor?: StringNullableFilter<"CanvasSession"> | string | null
    userAgent?: StringNullableFilter<"CanvasSession"> | string | null
    ipAddress?: StringNullableFilter<"CanvasSession"> | string | null
    connectedAt?: DateTimeFilter<"CanvasSession"> | Date | string
    lastHeartbeatAt?: DateTimeFilter<"CanvasSession"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"CanvasSession"> | Date | string | null
  }

  export type CanvasActivityLogUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasActivityLogWhereUniqueInput
    update: XOR<CanvasActivityLogUpdateWithoutCanvasInput, CanvasActivityLogUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasActivityLogCreateWithoutCanvasInput, CanvasActivityLogUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasActivityLogUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasActivityLogWhereUniqueInput
    data: XOR<CanvasActivityLogUpdateWithoutCanvasInput, CanvasActivityLogUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasActivityLogUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasActivityLogScalarWhereInput
    data: XOR<CanvasActivityLogUpdateManyMutationInput, CanvasActivityLogUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasActivityLogScalarWhereInput = {
    AND?: CanvasActivityLogScalarWhereInput | CanvasActivityLogScalarWhereInput[]
    OR?: CanvasActivityLogScalarWhereInput[]
    NOT?: CanvasActivityLogScalarWhereInput | CanvasActivityLogScalarWhereInput[]
    id?: StringFilter<"CanvasActivityLog"> | string
    canvasId?: StringFilter<"CanvasActivityLog"> | string
    userId?: StringNullableFilter<"CanvasActivityLog"> | string | null
    action?: EnumCanvasActivityActionFilter<"CanvasActivityLog"> | $Enums.CanvasActivityAction
    entityType?: StringNullableFilter<"CanvasActivityLog"> | string | null
    entityId?: StringNullableFilter<"CanvasActivityLog"> | string | null
    changeData?: JsonNullableFilter<"CanvasActivityLog">
    createdAt?: DateTimeFilter<"CanvasActivityLog"> | Date | string
  }

  export type CanvasCommentUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasCommentWhereUniqueInput
    update: XOR<CanvasCommentUpdateWithoutCanvasInput, CanvasCommentUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasCommentCreateWithoutCanvasInput, CanvasCommentUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasCommentUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasCommentWhereUniqueInput
    data: XOR<CanvasCommentUpdateWithoutCanvasInput, CanvasCommentUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasCommentUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasCommentScalarWhereInput
    data: XOR<CanvasCommentUpdateManyMutationInput, CanvasCommentUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasCommentScalarWhereInput = {
    AND?: CanvasCommentScalarWhereInput | CanvasCommentScalarWhereInput[]
    OR?: CanvasCommentScalarWhereInput[]
    NOT?: CanvasCommentScalarWhereInput | CanvasCommentScalarWhereInput[]
    id?: StringFilter<"CanvasComment"> | string
    canvasId?: StringFilter<"CanvasComment"> | string
    userId?: StringNullableFilter<"CanvasComment"> | string | null
    content?: StringFilter<"CanvasComment"> | string
    position?: JsonNullableFilter<"CanvasComment">
    podId?: StringNullableFilter<"CanvasComment"> | string | null
    parentId?: StringNullableFilter<"CanvasComment"> | string | null
    isResolved?: BoolFilter<"CanvasComment"> | boolean
    resolvedBy?: StringNullableFilter<"CanvasComment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"CanvasComment"> | Date | string | null
    createdAt?: DateTimeFilter<"CanvasComment"> | Date | string
    updatedAt?: DateTimeFilter<"CanvasComment"> | Date | string
  }

  export type CanvasCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutInvitationsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutInvitationsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutInvitationsInput, CanvasUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentCanvasInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutSentCanvasInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutSentCanvasInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentCanvasInvitesInput, UserUncheckedCreateWithoutSentCanvasInvitesInput>
  }

  export type UserCreateWithoutReceivedCanvasInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateWithoutReceivedCanvasInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserCreateOrConnectWithoutReceivedCanvasInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedCanvasInvitesInput, UserUncheckedCreateWithoutReceivedCanvasInvitesInput>
  }

  export type CanvasUpsertWithoutInvitationsInput = {
    update: XOR<CanvasUpdateWithoutInvitationsInput, CanvasUncheckedUpdateWithoutInvitationsInput>
    create: XOR<CanvasCreateWithoutInvitationsInput, CanvasUncheckedCreateWithoutInvitationsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutInvitationsInput, CanvasUncheckedUpdateWithoutInvitationsInput>
  }

  export type CanvasUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type UserUpsertWithoutSentCanvasInvitesInput = {
    update: XOR<UserUpdateWithoutSentCanvasInvitesInput, UserUncheckedUpdateWithoutSentCanvasInvitesInput>
    create: XOR<UserCreateWithoutSentCanvasInvitesInput, UserUncheckedCreateWithoutSentCanvasInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentCanvasInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentCanvasInvitesInput, UserUncheckedUpdateWithoutSentCanvasInvitesInput>
  }

  export type UserUpdateWithoutSentCanvasInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentCanvasInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUpsertWithoutReceivedCanvasInvitesInput = {
    update: XOR<UserUpdateWithoutReceivedCanvasInvitesInput, UserUncheckedUpdateWithoutReceivedCanvasInvitesInput>
    create: XOR<UserCreateWithoutReceivedCanvasInvitesInput, UserUncheckedCreateWithoutReceivedCanvasInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedCanvasInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedCanvasInvitesInput, UserUncheckedUpdateWithoutReceivedCanvasInvitesInput>
  }

  export type UserUpdateWithoutReceivedCanvasInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedCanvasInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type CanvasCreateWithoutCollaboratorsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutCollaboratorsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutCollaboratorsInput, CanvasUncheckedCreateWithoutCollaboratorsInput>
  }

  export type UserCreateWithoutCanvasCollaborationsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutCanvasCollaborationsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutCanvasCollaborationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCanvasCollaborationsInput, UserUncheckedCreateWithoutCanvasCollaborationsInput>
  }

  export type CanvasUpsertWithoutCollaboratorsInput = {
    update: XOR<CanvasUpdateWithoutCollaboratorsInput, CanvasUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<CanvasCreateWithoutCollaboratorsInput, CanvasUncheckedCreateWithoutCollaboratorsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutCollaboratorsInput, CanvasUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type CanvasUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type UserUpsertWithoutCanvasCollaborationsInput = {
    update: XOR<UserUpdateWithoutCanvasCollaborationsInput, UserUncheckedUpdateWithoutCanvasCollaborationsInput>
    create: XOR<UserCreateWithoutCanvasCollaborationsInput, UserUncheckedCreateWithoutCanvasCollaborationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCanvasCollaborationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCanvasCollaborationsInput, UserUncheckedUpdateWithoutCanvasCollaborationsInput>
  }

  export type UserUpdateWithoutCanvasCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCanvasCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type CanvasCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutSessionsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutSessionsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutSessionsInput, CanvasUncheckedCreateWithoutSessionsInput>
  }

  export type CanvasUpsertWithoutSessionsInput = {
    update: XOR<CanvasUpdateWithoutSessionsInput, CanvasUncheckedUpdateWithoutSessionsInput>
    create: XOR<CanvasCreateWithoutSessionsInput, CanvasUncheckedCreateWithoutSessionsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutSessionsInput, CanvasUncheckedUpdateWithoutSessionsInput>
  }

  export type CanvasUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasCreateWithoutActivityLogInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutActivityLogInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutActivityLogInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutActivityLogInput, CanvasUncheckedCreateWithoutActivityLogInput>
  }

  export type CanvasUpsertWithoutActivityLogInput = {
    update: XOR<CanvasUpdateWithoutActivityLogInput, CanvasUncheckedUpdateWithoutActivityLogInput>
    create: XOR<CanvasCreateWithoutActivityLogInput, CanvasUncheckedCreateWithoutActivityLogInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutActivityLogInput, CanvasUncheckedUpdateWithoutActivityLogInput>
  }

  export type CanvasUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutCommentsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutCommentsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutCommentsInput, CanvasUncheckedCreateWithoutCommentsInput>
  }

  export type CanvasUpsertWithoutCommentsInput = {
    update: XOR<CanvasUpdateWithoutCommentsInput, CanvasUncheckedUpdateWithoutCommentsInput>
    create: XOR<CanvasCreateWithoutCommentsInput, CanvasUncheckedCreateWithoutCommentsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutCommentsInput, CanvasUncheckedUpdateWithoutCommentsInput>
  }

  export type CanvasUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasCreateWithoutActionPodsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutActionPodsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutActionPodsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutActionPodsInput, CanvasUncheckedCreateWithoutActionPodsInput>
  }

  export type CanvasCreateWithoutContextualPodsInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutContextualPodsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutContextualPodsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutContextualPodsInput, CanvasUncheckedCreateWithoutContextualPodsInput>
  }

  export type DocumentCreateWithoutActionPodsInput = {
    id?: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutActionPodsInput = {
    id?: string
    workspaceId: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutActionPodsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutActionPodsInput, DocumentUncheckedCreateWithoutActionPodsInput>
  }

  export type EdgeCreateWithoutSourcePodInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutEdgesInput
    targetPod: ActionPodCreateNestedOneWithoutTargetEdgesInput
  }

  export type EdgeUncheckedCreateWithoutSourcePodInput = {
    id?: string
    canvasId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateOrConnectWithoutSourcePodInput = {
    where: EdgeWhereUniqueInput
    create: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput>
  }

  export type EdgeCreateManySourcePodInputEnvelope = {
    data: EdgeCreateManySourcePodInput | EdgeCreateManySourcePodInput[]
    skipDuplicates?: boolean
  }

  export type EdgeCreateWithoutTargetPodInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutEdgesInput
    sourcePod: ActionPodCreateNestedOneWithoutSourceEdgesInput
  }

  export type EdgeUncheckedCreateWithoutTargetPodInput = {
    id?: string
    canvasId: string
    sourcePodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateOrConnectWithoutTargetPodInput = {
    where: EdgeWhereUniqueInput
    create: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput>
  }

  export type EdgeCreateManyTargetPodInputEnvelope = {
    data: EdgeCreateManyTargetPodInput | EdgeCreateManyTargetPodInput[]
    skipDuplicates?: boolean
  }

  export type ActionPodExecutionCreateWithoutPodInput = {
    id?: string
    canvasId: string
    workspaceId: string
    status?: $Enums.ActionPodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionUncheckedCreateWithoutPodInput = {
    id?: string
    canvasId: string
    workspaceId: string
    status?: $Enums.ActionPodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionCreateOrConnectWithoutPodInput = {
    where: ActionPodExecutionWhereUniqueInput
    create: XOR<ActionPodExecutionCreateWithoutPodInput, ActionPodExecutionUncheckedCreateWithoutPodInput>
  }

  export type ActionPodExecutionCreateManyPodInputEnvelope = {
    data: ActionPodExecutionCreateManyPodInput | ActionPodExecutionCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type PodUsageLogCreateWithoutPodInput = {
    id?: string
    executionId: string
    canvasId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutUsageLogsInput
  }

  export type PodUsageLogUncheckedCreateWithoutPodInput = {
    id?: string
    executionId: string
    canvasId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type PodUsageLogCreateOrConnectWithoutPodInput = {
    where: PodUsageLogWhereUniqueInput
    create: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput>
  }

  export type PodUsageLogCreateManyPodInputEnvelope = {
    data: PodUsageLogCreateManyPodInput | PodUsageLogCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type CanvasUpsertWithoutActionPodsInput = {
    update: XOR<CanvasUpdateWithoutActionPodsInput, CanvasUncheckedUpdateWithoutActionPodsInput>
    create: XOR<CanvasCreateWithoutActionPodsInput, CanvasUncheckedCreateWithoutActionPodsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutActionPodsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutActionPodsInput, CanvasUncheckedUpdateWithoutActionPodsInput>
  }

  export type CanvasUpdateWithoutActionPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutActionPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUpsertWithoutContextualPodsInput = {
    update: XOR<CanvasUpdateWithoutContextualPodsInput, CanvasUncheckedUpdateWithoutContextualPodsInput>
    create: XOR<CanvasCreateWithoutContextualPodsInput, CanvasUncheckedCreateWithoutContextualPodsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutContextualPodsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutContextualPodsInput, CanvasUncheckedUpdateWithoutContextualPodsInput>
  }

  export type CanvasUpdateWithoutContextualPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutContextualPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type DocumentUpsertWithoutActionPodsInput = {
    update: XOR<DocumentUpdateWithoutActionPodsInput, DocumentUncheckedUpdateWithoutActionPodsInput>
    create: XOR<DocumentCreateWithoutActionPodsInput, DocumentUncheckedCreateWithoutActionPodsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutActionPodsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutActionPodsInput, DocumentUncheckedUpdateWithoutActionPodsInput>
  }

  export type DocumentUpdateWithoutActionPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutActionPodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EdgeUpsertWithWhereUniqueWithoutSourcePodInput = {
    where: EdgeWhereUniqueInput
    update: XOR<EdgeUpdateWithoutSourcePodInput, EdgeUncheckedUpdateWithoutSourcePodInput>
    create: XOR<EdgeCreateWithoutSourcePodInput, EdgeUncheckedCreateWithoutSourcePodInput>
  }

  export type EdgeUpdateWithWhereUniqueWithoutSourcePodInput = {
    where: EdgeWhereUniqueInput
    data: XOR<EdgeUpdateWithoutSourcePodInput, EdgeUncheckedUpdateWithoutSourcePodInput>
  }

  export type EdgeUpdateManyWithWhereWithoutSourcePodInput = {
    where: EdgeScalarWhereInput
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutSourcePodInput>
  }

  export type EdgeUpsertWithWhereUniqueWithoutTargetPodInput = {
    where: EdgeWhereUniqueInput
    update: XOR<EdgeUpdateWithoutTargetPodInput, EdgeUncheckedUpdateWithoutTargetPodInput>
    create: XOR<EdgeCreateWithoutTargetPodInput, EdgeUncheckedCreateWithoutTargetPodInput>
  }

  export type EdgeUpdateWithWhereUniqueWithoutTargetPodInput = {
    where: EdgeWhereUniqueInput
    data: XOR<EdgeUpdateWithoutTargetPodInput, EdgeUncheckedUpdateWithoutTargetPodInput>
  }

  export type EdgeUpdateManyWithWhereWithoutTargetPodInput = {
    where: EdgeScalarWhereInput
    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutTargetPodInput>
  }

  export type ActionPodExecutionUpsertWithWhereUniqueWithoutPodInput = {
    where: ActionPodExecutionWhereUniqueInput
    update: XOR<ActionPodExecutionUpdateWithoutPodInput, ActionPodExecutionUncheckedUpdateWithoutPodInput>
    create: XOR<ActionPodExecutionCreateWithoutPodInput, ActionPodExecutionUncheckedCreateWithoutPodInput>
  }

  export type ActionPodExecutionUpdateWithWhereUniqueWithoutPodInput = {
    where: ActionPodExecutionWhereUniqueInput
    data: XOR<ActionPodExecutionUpdateWithoutPodInput, ActionPodExecutionUncheckedUpdateWithoutPodInput>
  }

  export type ActionPodExecutionUpdateManyWithWhereWithoutPodInput = {
    where: ActionPodExecutionScalarWhereInput
    data: XOR<ActionPodExecutionUpdateManyMutationInput, ActionPodExecutionUncheckedUpdateManyWithoutPodInput>
  }

  export type ActionPodExecutionScalarWhereInput = {
    AND?: ActionPodExecutionScalarWhereInput | ActionPodExecutionScalarWhereInput[]
    OR?: ActionPodExecutionScalarWhereInput[]
    NOT?: ActionPodExecutionScalarWhereInput | ActionPodExecutionScalarWhereInput[]
    id?: StringFilter<"ActionPodExecution"> | string
    podId?: StringFilter<"ActionPodExecution"> | string
    canvasId?: StringFilter<"ActionPodExecution"> | string
    workspaceId?: StringFilter<"ActionPodExecution"> | string
    status?: EnumActionPodExecutionStatusFilter<"ActionPodExecution"> | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFilter<"ActionPodExecution"> | Date | string
    finishedAt?: DateTimeNullableFilter<"ActionPodExecution"> | Date | string | null
    runtimeInMs?: IntNullableFilter<"ActionPodExecution"> | number | null
    provider?: EnumLLMProviderFilter<"ActionPodExecution"> | $Enums.LLMProvider
    modelId?: StringFilter<"ActionPodExecution"> | string
    modelName?: StringNullableFilter<"ActionPodExecution"> | string | null
    providerMetadata?: JsonNullableFilter<"ActionPodExecution">
    requestMetadata?: JsonNullableFilter<"ActionPodExecution">
    responseMetadata?: JsonNullableFilter<"ActionPodExecution">
    errorMessage?: StringNullableFilter<"ActionPodExecution"> | string | null
    errorCode?: StringNullableFilter<"ActionPodExecution"> | string | null
    inputTokens?: IntFilter<"ActionPodExecution"> | number
    outputTokens?: IntFilter<"ActionPodExecution"> | number
    reasoningTokens?: IntFilter<"ActionPodExecution"> | number
    creditsConsumed?: IntFilter<"ActionPodExecution"> | number
    costInUsd?: DecimalNullableFilter<"ActionPodExecution"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogUpsertWithWhereUniqueWithoutPodInput = {
    where: PodUsageLogWhereUniqueInput
    update: XOR<PodUsageLogUpdateWithoutPodInput, PodUsageLogUncheckedUpdateWithoutPodInput>
    create: XOR<PodUsageLogCreateWithoutPodInput, PodUsageLogUncheckedCreateWithoutPodInput>
  }

  export type PodUsageLogUpdateWithWhereUniqueWithoutPodInput = {
    where: PodUsageLogWhereUniqueInput
    data: XOR<PodUsageLogUpdateWithoutPodInput, PodUsageLogUncheckedUpdateWithoutPodInput>
  }

  export type PodUsageLogUpdateManyWithWhereWithoutPodInput = {
    where: PodUsageLogScalarWhereInput
    data: XOR<PodUsageLogUpdateManyMutationInput, PodUsageLogUncheckedUpdateManyWithoutPodInput>
  }

  export type CanvasCreateWithoutEdgesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutEdgesInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutEdgesInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutEdgesInput, CanvasUncheckedCreateWithoutEdgesInput>
  }

  export type ActionPodCreateWithoutSourceEdgesInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutSourceEdgesInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutSourceEdgesInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutSourceEdgesInput, ActionPodUncheckedCreateWithoutSourceEdgesInput>
  }

  export type ActionPodCreateWithoutTargetEdgesInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutTargetEdgesInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutTargetEdgesInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutTargetEdgesInput, ActionPodUncheckedCreateWithoutTargetEdgesInput>
  }

  export type CanvasUpsertWithoutEdgesInput = {
    update: XOR<CanvasUpdateWithoutEdgesInput, CanvasUncheckedUpdateWithoutEdgesInput>
    create: XOR<CanvasCreateWithoutEdgesInput, CanvasUncheckedCreateWithoutEdgesInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutEdgesInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutEdgesInput, CanvasUncheckedUpdateWithoutEdgesInput>
  }

  export type CanvasUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type ActionPodUpsertWithoutSourceEdgesInput = {
    update: XOR<ActionPodUpdateWithoutSourceEdgesInput, ActionPodUncheckedUpdateWithoutSourceEdgesInput>
    create: XOR<ActionPodCreateWithoutSourceEdgesInput, ActionPodUncheckedCreateWithoutSourceEdgesInput>
    where?: ActionPodWhereInput
  }

  export type ActionPodUpdateToOneWithWhereWithoutSourceEdgesInput = {
    where?: ActionPodWhereInput
    data: XOR<ActionPodUpdateWithoutSourceEdgesInput, ActionPodUncheckedUpdateWithoutSourceEdgesInput>
  }

  export type ActionPodUpdateWithoutSourceEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutSourceEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUpsertWithoutTargetEdgesInput = {
    update: XOR<ActionPodUpdateWithoutTargetEdgesInput, ActionPodUncheckedUpdateWithoutTargetEdgesInput>
    create: XOR<ActionPodCreateWithoutTargetEdgesInput, ActionPodUncheckedCreateWithoutTargetEdgesInput>
    where?: ActionPodWhereInput
  }

  export type ActionPodUpdateToOneWithWhereWithoutTargetEdgesInput = {
    where?: ActionPodWhereInput
    data: XOR<ActionPodUpdateWithoutTargetEdgesInput, ActionPodUncheckedUpdateWithoutTargetEdgesInput>
  }

  export type ActionPodUpdateWithoutTargetEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutTargetEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodCreateWithoutExecutionsInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutExecutionsInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutExecutionsInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutExecutionsInput, ActionPodUncheckedCreateWithoutExecutionsInput>
  }

  export type ActionPodUpsertWithoutExecutionsInput = {
    update: XOR<ActionPodUpdateWithoutExecutionsInput, ActionPodUncheckedUpdateWithoutExecutionsInput>
    create: XOR<ActionPodCreateWithoutExecutionsInput, ActionPodUncheckedCreateWithoutExecutionsInput>
    where?: ActionPodWhereInput
  }

  export type ActionPodUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: ActionPodWhereInput
    data: XOR<ActionPodUpdateWithoutExecutionsInput, ActionPodUncheckedUpdateWithoutExecutionsInput>
  }

  export type ActionPodUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodCreateWithoutUsageLogsInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    document?: DocumentCreateNestedOneWithoutActionPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutUsageLogsInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutUsageLogsInput, ActionPodUncheckedCreateWithoutUsageLogsInput>
  }

  export type SubscriptionCreateWithoutUsageLogsInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    workspaceId: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUsageLogsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
  }

  export type ActionPodUpsertWithoutUsageLogsInput = {
    update: XOR<ActionPodUpdateWithoutUsageLogsInput, ActionPodUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ActionPodCreateWithoutUsageLogsInput, ActionPodUncheckedCreateWithoutUsageLogsInput>
    where?: ActionPodWhereInput
  }

  export type ActionPodUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ActionPodWhereInput
    data: XOR<ActionPodUpdateWithoutUsageLogsInput, ActionPodUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ActionPodUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
  }

  export type SubscriptionUpsertWithoutUsageLogsInput = {
    update: XOR<SubscriptionUpdateWithoutUsageLogsInput, SubscriptionUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<SubscriptionCreateWithoutUsageLogsInput, SubscriptionUncheckedCreateWithoutUsageLogsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUsageLogsInput, SubscriptionUncheckedUpdateWithoutUsageLogsInput>
  }

  export type SubscriptionUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceCreateWithoutContextModulesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutContextModulesInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutContextModulesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
  }

  export type CanvasCreateWithoutContextModulesInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCanvasesInput
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutContextModulesInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutContextModulesInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutContextModulesInput, CanvasUncheckedCreateWithoutContextModulesInput>
  }

  export type WorkspaceUpsertWithoutContextModulesInput = {
    update: XOR<WorkspaceUpdateWithoutContextModulesInput, WorkspaceUncheckedUpdateWithoutContextModulesInput>
    create: XOR<WorkspaceCreateWithoutContextModulesInput, WorkspaceUncheckedCreateWithoutContextModulesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutContextModulesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutContextModulesInput, WorkspaceUncheckedUpdateWithoutContextModulesInput>
  }

  export type WorkspaceUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type CanvasUpsertWithoutContextModulesInput = {
    update: XOR<CanvasUpdateWithoutContextModulesInput, CanvasUncheckedUpdateWithoutContextModulesInput>
    create: XOR<CanvasCreateWithoutContextModulesInput, CanvasUncheckedCreateWithoutContextModulesInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutContextModulesInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutContextModulesInput, CanvasUncheckedUpdateWithoutContextModulesInput>
  }

  export type CanvasUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCanvasesNestedInput
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutContextModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserCreateWithoutUserInput = {
    id?: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceUserUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserCreateManyUserInputEnvelope = {
    data: WorkspaceUserCreateManyUserInput | WorkspaceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CanvasCollaboratorCreateWithoutUserInput = {
    id?: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
    canvas: CanvasCreateNestedOneWithoutCollaboratorsInput
  }

  export type CanvasCollaboratorUncheckedCreateWithoutUserInput = {
    id?: string
    canvasId: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type CanvasCollaboratorCreateOrConnectWithoutUserInput = {
    where: CanvasCollaboratorWhereUniqueInput
    create: XOR<CanvasCollaboratorCreateWithoutUserInput, CanvasCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type CanvasCollaboratorCreateManyUserInputEnvelope = {
    data: CanvasCollaboratorCreateManyUserInput | CanvasCollaboratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    invitedUser?: UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutInviterInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput>
  }

  export type WorkspaceInvitationCreateManyInviterInputEnvelope = {
    data: WorkspaceInvitationCreateManyInviterInput | WorkspaceInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutInvitedUserInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type WorkspaceInvitationCreateManyInvitedUserInputEnvelope = {
    data: WorkspaceInvitationCreateManyInvitedUserInput | WorkspaceInvitationCreateManyInvitedUserInput[]
    skipDuplicates?: boolean
  }

  export type CanvasInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    canvas: CanvasCreateNestedOneWithoutInvitationsInput
    invitedUser?: UserCreateNestedOneWithoutReceivedCanvasInvitesInput
  }

  export type CanvasInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    canvasId: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationCreateOrConnectWithoutInviterInput = {
    where: CanvasInvitationWhereUniqueInput
    create: XOR<CanvasInvitationCreateWithoutInviterInput, CanvasInvitationUncheckedCreateWithoutInviterInput>
  }

  export type CanvasInvitationCreateManyInviterInputEnvelope = {
    data: CanvasInvitationCreateManyInviterInput | CanvasInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type CanvasInvitationCreateWithoutInvitedUserInput = {
    id?: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    canvas: CanvasCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentCanvasInvitesInput
  }

  export type CanvasInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    canvasId: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: CanvasInvitationWhereUniqueInput
    create: XOR<CanvasInvitationCreateWithoutInvitedUserInput, CanvasInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type CanvasInvitationCreateManyInvitedUserInputEnvelope = {
    data: CanvasInvitationCreateManyInvitedUserInput | CanvasInvitationCreateManyInvitedUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    provider?: EnumAuthProviderFilter<"Account"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUserScalarWhereInput = {
    AND?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    OR?: WorkspaceUserScalarWhereInput[]
    NOT?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canDeleteCanvas?: BoolFilter<"WorkspaceUser"> | boolean
    canManageBilling?: BoolFilter<"WorkspaceUser"> | boolean
    canInviteMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageMembers?: BoolFilter<"WorkspaceUser"> | boolean
    canManageApiKeys?: BoolFilter<"WorkspaceUser"> | boolean
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceUser"> | string | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    deviceName?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type CanvasCollaboratorUpsertWithWhereUniqueWithoutUserInput = {
    where: CanvasCollaboratorWhereUniqueInput
    update: XOR<CanvasCollaboratorUpdateWithoutUserInput, CanvasCollaboratorUncheckedUpdateWithoutUserInput>
    create: XOR<CanvasCollaboratorCreateWithoutUserInput, CanvasCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type CanvasCollaboratorUpdateWithWhereUniqueWithoutUserInput = {
    where: CanvasCollaboratorWhereUniqueInput
    data: XOR<CanvasCollaboratorUpdateWithoutUserInput, CanvasCollaboratorUncheckedUpdateWithoutUserInput>
  }

  export type CanvasCollaboratorUpdateManyWithWhereWithoutUserInput = {
    where: CanvasCollaboratorScalarWhereInput
    data: XOR<CanvasCollaboratorUpdateManyMutationInput, CanvasCollaboratorUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutInviterInput, WorkspaceInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<WorkspaceInvitationCreateWithoutInviterInput, WorkspaceInvitationUncheckedCreateWithoutInviterInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutInviterInput, WorkspaceInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type WorkspaceInvitationScalarWhereInput = {
    AND?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    OR?: WorkspaceInvitationScalarWhereInput[]
    NOT?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    permissions?: JsonNullableFilter<"WorkspaceInvitation">
    invitedBy?: StringFilter<"WorkspaceInvitation"> | string
    invitedUserId?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    token?: StringFilter<"WorkspaceInvitation"> | string
    status?: EnumInvitationStatusFilter<"WorkspaceInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutInvitedUserInput, WorkspaceInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<WorkspaceInvitationCreateWithoutInvitedUserInput, WorkspaceInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutInvitedUserInput, WorkspaceInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserInput>
  }

  export type CanvasInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: CanvasInvitationWhereUniqueInput
    update: XOR<CanvasInvitationUpdateWithoutInviterInput, CanvasInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<CanvasInvitationCreateWithoutInviterInput, CanvasInvitationUncheckedCreateWithoutInviterInput>
  }

  export type CanvasInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: CanvasInvitationWhereUniqueInput
    data: XOR<CanvasInvitationUpdateWithoutInviterInput, CanvasInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type CanvasInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: CanvasInvitationScalarWhereInput
    data: XOR<CanvasInvitationUpdateManyMutationInput, CanvasInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type CanvasInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: CanvasInvitationWhereUniqueInput
    update: XOR<CanvasInvitationUpdateWithoutInvitedUserInput, CanvasInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<CanvasInvitationCreateWithoutInvitedUserInput, CanvasInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type CanvasInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: CanvasInvitationWhereUniqueInput
    data: XOR<CanvasInvitationUpdateWithoutInvitedUserInput, CanvasInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type CanvasInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: CanvasInvitationScalarWhereInput
    data: XOR<CanvasInvitationUpdateManyMutationInput, CanvasInvitationUncheckedUpdateManyWithoutInvitedUserInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type WorkspaceUserCreateWithoutWorkspaceInput = {
    id?: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserCreateManyWorkspaceInput | WorkspaceUserCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type CanvasCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodCreateNestedManyWithoutCanvasInput
    edges?: EdgeCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutCanvasInput
    edges?: EdgeUncheckedCreateNestedManyWithoutCanvasInput
    contextualPods?: ActionPodUncheckedCreateNestedManyWithoutContextCanvasInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutOriginalCanvasInput
    collaborators?: CanvasCollaboratorUncheckedCreateNestedManyWithoutCanvasInput
    invitations?: CanvasInvitationUncheckedCreateNestedManyWithoutCanvasInput
    sessions?: CanvasSessionUncheckedCreateNestedManyWithoutCanvasInput
    activityLog?: CanvasActivityLogUncheckedCreateNestedManyWithoutCanvasInput
    comments?: CanvasCommentUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutWorkspaceInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutWorkspaceInput, CanvasUncheckedCreateWithoutWorkspaceInput>
  }

  export type CanvasCreateManyWorkspaceInputEnvelope = {
    data: CanvasCreateManyWorkspaceInput | CanvasCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingCreateNestedManyWithoutDocumentInput
    actionPods?: ActionPodCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutDocumentInput
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutWorkspaceInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput>
  }

  export type DocumentCreateManyWorkspaceInputEnvelope = {
    data: DocumentCreateManyWorkspaceInput | DocumentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutWorkspaceInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    credits?: number
    monthlyCreditQuota?: number
    creditResetDate?: Date | string | null
    maxCanvases?: number
    maxActionPodsPerCanvas?: number
    maxDocumentSizeInMB?: number
    maxCollaboratorsPerCanvas?: number
    canInviteToWorkspace?: boolean
    canInviteToCanvas?: boolean
    canCreatePublicLinks?: boolean
    canUseAdvancedModels?: boolean
    canAccessAnalytics?: boolean
    canExportData?: boolean
    nextBillingDate?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    isByokMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
    creditPurchases?: CreditPurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
    creditUsage?: CreditUsageLogUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutWorkspaceInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
  }

  export type ContextModuleCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    originalCanvas?: CanvasCreateNestedOneWithoutContextModulesInput
  }

  export type ContextModuleUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalCanvasId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateOrConnectWithoutWorkspaceInput = {
    where: ContextModuleWhereUniqueInput
    create: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput>
  }

  export type ContextModuleCreateManyWorkspaceInputEnvelope = {
    data: ContextModuleCreateManyWorkspaceInput | ContextModuleCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ShareLinkCreateWithoutWorkspaceInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ShareLinkCreateOrConnectWithoutWorkspaceInput = {
    where: ShareLinkWhereUniqueInput
    create: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput>
  }

  export type ShareLinkCreateManyWorkspaceInputEnvelope = {
    data: ShareLinkCreateManyWorkspaceInput | ShareLinkCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ProviderAPIKeyCreateWithoutWorkspaceInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyCreateOrConnectWithoutWorkspaceInput = {
    where: ProviderAPIKeyWhereUniqueInput
    create: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyCreateManyWorkspaceInputEnvelope = {
    data: ProviderAPIKeyCreateManyWorkspaceInput | ProviderAPIKeyCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    inviter: UserCreateNestedOneWithoutSentWorkspaceInvitesInput
    invitedUser?: UserCreateNestedOneWithoutReceivedWorkspaceInvitesInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceInvitationCreateManyWorkspaceInput | WorkspaceInvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CanvasUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: CanvasWhereUniqueInput
    update: XOR<CanvasUpdateWithoutWorkspaceInput, CanvasUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<CanvasCreateWithoutWorkspaceInput, CanvasUncheckedCreateWithoutWorkspaceInput>
  }

  export type CanvasUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: CanvasWhereUniqueInput
    data: XOR<CanvasUpdateWithoutWorkspaceInput, CanvasUncheckedUpdateWithoutWorkspaceInput>
  }

  export type CanvasUpdateManyWithWhereWithoutWorkspaceInput = {
    where: CanvasScalarWhereInput
    data: XOR<CanvasUpdateManyMutationInput, CanvasUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CanvasScalarWhereInput = {
    AND?: CanvasScalarWhereInput | CanvasScalarWhereInput[]
    OR?: CanvasScalarWhereInput[]
    NOT?: CanvasScalarWhereInput | CanvasScalarWhereInput[]
    id?: StringFilter<"Canvas"> | string
    workspaceId?: StringFilter<"Canvas"> | string
    name?: StringFilter<"Canvas"> | string
    description?: StringNullableFilter<"Canvas"> | string | null
    version?: IntFilter<"Canvas"> | number
    visibility?: EnumCanvasVisibilityFilter<"Canvas"> | $Enums.CanvasVisibility
    createdBy?: StringFilter<"Canvas"> | string
    thumbnailS3Key?: StringNullableFilter<"Canvas"> | string | null
    thumbnailGeneratedAt?: DateTimeNullableFilter<"Canvas"> | Date | string | null
    createdAt?: DateTimeFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeFilter<"Canvas"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutWorkspaceInput, DocumentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<DocumentCreateWithoutWorkspaceInput, DocumentUncheckedCreateWithoutWorkspaceInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutWorkspaceInput, DocumentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type DocumentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    workspaceId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    storageKey?: StringFilter<"Document"> | string
    s3Bucket?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    sizeInBytes?: BigIntFilter<"Document"> | bigint | number
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type SubscriptionUpsertWithoutWorkspaceInput = {
    update: XOR<SubscriptionUpdateWithoutWorkspaceInput, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutWorkspaceInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutWorkspaceInput, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type SubscriptionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    monthlyCreditQuota?: IntFieldUpdateOperationsInput | number
    creditResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxCanvases?: IntFieldUpdateOperationsInput | number
    maxActionPodsPerCanvas?: IntFieldUpdateOperationsInput | number
    maxDocumentSizeInMB?: IntFieldUpdateOperationsInput | number
    maxCollaboratorsPerCanvas?: IntFieldUpdateOperationsInput | number
    canInviteToWorkspace?: BoolFieldUpdateOperationsInput | boolean
    canInviteToCanvas?: BoolFieldUpdateOperationsInput | boolean
    canCreatePublicLinks?: BoolFieldUpdateOperationsInput | boolean
    canUseAdvancedModels?: BoolFieldUpdateOperationsInput | boolean
    canAccessAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    isByokMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditPurchases?: CreditPurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
    creditUsage?: CreditUsageLogUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ContextModuleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ContextModuleWhereUniqueInput
    update: XOR<ContextModuleUpdateWithoutWorkspaceInput, ContextModuleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ContextModuleCreateWithoutWorkspaceInput, ContextModuleUncheckedCreateWithoutWorkspaceInput>
  }

  export type ContextModuleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ContextModuleWhereUniqueInput
    data: XOR<ContextModuleUpdateWithoutWorkspaceInput, ContextModuleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ContextModuleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ContextModuleScalarWhereInput
    data: XOR<ContextModuleUpdateManyMutationInput, ContextModuleUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ShareLinkUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ShareLinkWhereUniqueInput
    update: XOR<ShareLinkUpdateWithoutWorkspaceInput, ShareLinkUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ShareLinkCreateWithoutWorkspaceInput, ShareLinkUncheckedCreateWithoutWorkspaceInput>
  }

  export type ShareLinkUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ShareLinkWhereUniqueInput
    data: XOR<ShareLinkUpdateWithoutWorkspaceInput, ShareLinkUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ShareLinkUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ShareLinkScalarWhereInput
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ShareLinkScalarWhereInput = {
    AND?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
    OR?: ShareLinkScalarWhereInput[]
    NOT?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
    id?: StringFilter<"ShareLink"> | string
    publicToken?: StringFilter<"ShareLink"> | string
    assetType?: EnumShareableAssetTypeFilter<"ShareLink"> | $Enums.ShareableAssetType
    assetId?: StringFilter<"ShareLink"> | string
    workspaceId?: StringFilter<"ShareLink"> | string
    createdBy?: StringFilter<"ShareLink"> | string
    accessLevel?: EnumShareAccessLevelFilter<"ShareLink"> | $Enums.ShareAccessLevel
    password?: StringNullableFilter<"ShareLink"> | string | null
    viewCount?: IntFilter<"ShareLink"> | number
    lastViewedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
  }

  export type ProviderAPIKeyUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProviderAPIKeyWhereUniqueInput
    update: XOR<ProviderAPIKeyUpdateWithoutWorkspaceInput, ProviderAPIKeyUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProviderAPIKeyCreateWithoutWorkspaceInput, ProviderAPIKeyUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProviderAPIKeyWhereUniqueInput
    data: XOR<ProviderAPIKeyUpdateWithoutWorkspaceInput, ProviderAPIKeyUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProviderAPIKeyScalarWhereInput
    data: XOR<ProviderAPIKeyUpdateManyMutationInput, ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ProviderAPIKeyScalarWhereInput = {
    AND?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
    OR?: ProviderAPIKeyScalarWhereInput[]
    NOT?: ProviderAPIKeyScalarWhereInput | ProviderAPIKeyScalarWhereInput[]
    id?: StringFilter<"ProviderAPIKey"> | string
    workspaceId?: StringFilter<"ProviderAPIKey"> | string
    provider?: EnumLLMProviderFilter<"ProviderAPIKey"> | $Enums.LLMProvider
    displayName?: StringFilter<"ProviderAPIKey"> | string
    keyHash?: StringFilter<"ProviderAPIKey"> | string
    providerConfig?: JsonNullableFilter<"ProviderAPIKey">
    endpoint?: StringNullableFilter<"ProviderAPIKey"> | string | null
    authType?: EnumAuthTypeFilter<"ProviderAPIKey"> | $Enums.AuthType
    isActive?: BoolFilter<"ProviderAPIKey"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ProviderAPIKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProviderAPIKey"> | Date | string | null
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateWithoutMembersInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutMembersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type WorkspaceUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutInvitationsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    receivedWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutSentWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutSentWorkspaceInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
  }

  export type UserCreateWithoutReceivedWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationCreateNestedManyWithoutInviterInput
    sentCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationCreateNestedManyWithoutInvitedUserInput
  }

  export type UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    hash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    canvasCollaborations?: CanvasCollaboratorUncheckedCreateNestedManyWithoutUserInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedCreateNestedManyWithoutInviterInput
    sentCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedCanvasInvites?: CanvasInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
  }

  export type UserCreateOrConnectWithoutReceivedWorkspaceInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
  }

  export type WorkspaceUpsertWithoutInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type WorkspaceUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutSentWorkspaceInvitesInput = {
    update: XOR<UserUpdateWithoutSentWorkspaceInvitesInput, UserUncheckedUpdateWithoutSentWorkspaceInvitesInput>
    create: XOR<UserCreateWithoutSentWorkspaceInvitesInput, UserUncheckedCreateWithoutSentWorkspaceInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentWorkspaceInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentWorkspaceInvitesInput, UserUncheckedUpdateWithoutSentWorkspaceInvitesInput>
  }

  export type UserUpdateWithoutSentWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    receivedWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUpsertWithoutReceivedWorkspaceInvitesInput = {
    update: XOR<UserUpdateWithoutReceivedWorkspaceInvitesInput, UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput>
    create: XOR<UserCreateWithoutReceivedWorkspaceInvitesInput, UserUncheckedCreateWithoutReceivedWorkspaceInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedWorkspaceInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedWorkspaceInvitesInput, UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput>
  }

  export type UserUpdateWithoutReceivedWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUpdateManyWithoutInviterNestedInput
    sentCanvasInvites?: CanvasInvitationUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUpdateManyWithoutInvitedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedWorkspaceInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    canvasCollaborations?: CanvasCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    sentWorkspaceInvites?: WorkspaceInvitationUncheckedUpdateManyWithoutInviterNestedInput
    sentCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedCanvasInvites?: CanvasInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
  }

  export type WorkspaceCreateWithoutApiKeysInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutApiKeysInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
  }

  export type WorkspaceUpsertWithoutApiKeysInput = {
    update: XOR<WorkspaceUpdateWithoutApiKeysInput, WorkspaceUncheckedUpdateWithoutApiKeysInput>
    create: XOR<WorkspaceCreateWithoutApiKeysInput, WorkspaceUncheckedCreateWithoutApiKeysInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutApiKeysInput, WorkspaceUncheckedUpdateWithoutApiKeysInput>
  }

  export type WorkspaceUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutShareLinksInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutShareLinksInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutShareLinksInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
  }

  export type WorkspaceUpsertWithoutShareLinksInput = {
    update: XOR<WorkspaceUpdateWithoutShareLinksInput, WorkspaceUncheckedUpdateWithoutShareLinksInput>
    create: XOR<WorkspaceCreateWithoutShareLinksInput, WorkspaceUncheckedCreateWithoutShareLinksInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutShareLinksInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutShareLinksInput, WorkspaceUncheckedUpdateWithoutShareLinksInput>
  }

  export type WorkspaceUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutDocumentsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    type?: $Enums.WorkspaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    canvases?: CanvasUncheckedCreateNestedManyWithoutWorkspaceInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutWorkspaceInput
    contextModules?: ContextModuleUncheckedCreateNestedManyWithoutWorkspaceInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutWorkspaceInput
    apiKeys?: ProviderAPIKeyUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDocumentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
  }

  export type EmbeddingCreateWithoutDocumentInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingUncheckedCreateWithoutDocumentInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmbeddingCreateOrConnectWithoutDocumentInput = {
    where: EmbeddingWhereUniqueInput
    create: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput>
  }

  export type EmbeddingCreateManyDocumentInputEnvelope = {
    data: EmbeddingCreateManyDocumentInput | EmbeddingCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type ActionPodCreateWithoutDocumentInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutActionPodsInput
    contextCanvas?: CanvasCreateNestedOneWithoutContextualPodsInput
    sourceEdges?: EdgeCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogCreateNestedManyWithoutPodInput
  }

  export type ActionPodUncheckedCreateWithoutDocumentInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourcePodInput
    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetPodInput
    executions?: ActionPodExecutionUncheckedCreateNestedManyWithoutPodInput
    usageLogs?: PodUsageLogUncheckedCreateNestedManyWithoutPodInput
  }

  export type ActionPodCreateOrConnectWithoutDocumentInput = {
    where: ActionPodWhereUniqueInput
    create: XOR<ActionPodCreateWithoutDocumentInput, ActionPodUncheckedCreateWithoutDocumentInput>
  }

  export type ActionPodCreateManyDocumentInputEnvelope = {
    data: ActionPodCreateManyDocumentInput | ActionPodCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutDocumentsInput = {
    update: XOR<WorkspaceUpdateWithoutDocumentsInput, WorkspaceUncheckedUpdateWithoutDocumentsInput>
    create: XOR<WorkspaceCreateWithoutDocumentsInput, WorkspaceUncheckedCreateWithoutDocumentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDocumentsInput, WorkspaceUncheckedUpdateWithoutDocumentsInput>
  }

  export type WorkspaceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkspaceTypeFieldUpdateOperationsInput | $Enums.WorkspaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    canvases?: CanvasUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutWorkspaceNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutWorkspaceNestedInput
    apiKeys?: ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type EmbeddingUpsertWithWhereUniqueWithoutDocumentInput = {
    where: EmbeddingWhereUniqueInput
    update: XOR<EmbeddingUpdateWithoutDocumentInput, EmbeddingUncheckedUpdateWithoutDocumentInput>
    create: XOR<EmbeddingCreateWithoutDocumentInput, EmbeddingUncheckedCreateWithoutDocumentInput>
  }

  export type EmbeddingUpdateWithWhereUniqueWithoutDocumentInput = {
    where: EmbeddingWhereUniqueInput
    data: XOR<EmbeddingUpdateWithoutDocumentInput, EmbeddingUncheckedUpdateWithoutDocumentInput>
  }

  export type EmbeddingUpdateManyWithWhereWithoutDocumentInput = {
    where: EmbeddingScalarWhereInput
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyWithoutDocumentInput>
  }

  export type EmbeddingScalarWhereInput = {
    AND?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
    OR?: EmbeddingScalarWhereInput[]
    NOT?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
    id?: StringFilter<"Embedding"> | string
    documentId?: StringFilter<"Embedding"> | string
    model?: StringFilter<"Embedding"> | string
    chunkIndex?: IntFilter<"Embedding"> | number
    chunkText?: StringFilter<"Embedding"> | string
    s3VectorBucket?: StringFilter<"Embedding"> | string
    s3VectorKey?: StringFilter<"Embedding"> | string
    vectorDimension?: IntFilter<"Embedding"> | number
    metadata?: JsonNullableFilter<"Embedding">
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
  }

  export type ActionPodUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ActionPodWhereUniqueInput
    update: XOR<ActionPodUpdateWithoutDocumentInput, ActionPodUncheckedUpdateWithoutDocumentInput>
    create: XOR<ActionPodCreateWithoutDocumentInput, ActionPodUncheckedCreateWithoutDocumentInput>
  }

  export type ActionPodUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ActionPodWhereUniqueInput
    data: XOR<ActionPodUpdateWithoutDocumentInput, ActionPodUncheckedUpdateWithoutDocumentInput>
  }

  export type ActionPodUpdateManyWithWhereWithoutDocumentInput = {
    where: ActionPodScalarWhereInput
    data: XOR<ActionPodUpdateManyMutationInput, ActionPodUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutEmbeddingsInput = {
    id?: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocumentsInput
    actionPods?: ActionPodCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutEmbeddingsInput = {
    id?: string
    workspaceId: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPods?: ActionPodUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutEmbeddingsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
  }

  export type DocumentUpsertWithoutEmbeddingsInput = {
    update: XOR<DocumentUpdateWithoutEmbeddingsInput, DocumentUncheckedUpdateWithoutEmbeddingsInput>
    create: XOR<DocumentCreateWithoutEmbeddingsInput, DocumentUncheckedCreateWithoutEmbeddingsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutEmbeddingsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutEmbeddingsInput, DocumentUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type DocumentUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocumentsNestedInput
    actionPods?: ActionPodUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type AdminSessionCreateManyAdminInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: string | null
  }

  export type AdminAuditLogCreateManyAdminInput = {
    id?: string
    action: $Enums.AdminAction
    resource: $Enums.AdminResource
    resourceId?: string | null
    method: string
    endpoint: string
    ipAddress: string
    userAgent?: string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status: number
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: number | null
    createdAt?: Date | string
  }

  export type AdminPermissionCreateManyAdminInput = {
    id?: string
    permission: $Enums.SpecificPermission
    resource?: $Enums.AdminResource | null
    grantedAt?: Date | string
    grantedBy?: string | null
    expiresAt?: Date | string | null
  }

  export type AdminAPIKeyCreateManyAdminInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    scopes: JsonNullValueInput | InputJsonValue
    rateLimit?: number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
  }

  export type AdminInvitationCreateManyInviterInput = {
    id?: string
    email: string
    role: $Enums.AdminRole
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AdminSessionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    resource?: EnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changesBefore?: NullableJsonNullValueInput | InputJsonValue
    changesAfter?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminPermissionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSpecificPermissionFieldUpdateOperationsInput | $Enums.SpecificPermission
    resource?: NullableEnumAdminResourceFieldUpdateOperationsInput | $Enums.AdminResource | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAPIKeyUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    scopes?: JsonNullValueInput | InputJsonValue
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    allowedIps?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PodUsageLogCreateManySubscriptionInput = {
    id?: string
    podId: string
    executionId: string
    canvasId: string
    workspaceId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type CreditPurchaseCreateManySubscriptionInput = {
    id?: string
    creditsPurchased: number
    amountPaid: Decimal | DecimalJsLike | number | string
    currency?: string
    stripeChargeId: string
    status?: string
    purchasedAt?: Date | string
  }

  export type CreditUsageLogCreateManySubscriptionInput = {
    id?: string
    workspaceId: string
    canvasId: string
    podId: string
    executionId: string
    creditsUsed?: number
    balanceBefore: number
    balanceAfter: number
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type PodUsageLogUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: ActionPodUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type PodUsageLogUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPurchaseUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsPurchased?: IntFieldUpdateOperationsInput | number
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeChargeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUsageLogUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    podId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodCreateManyCanvasInput = {
    id?: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EdgeCreateManyCanvasInput = {
    id?: string
    sourcePodId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type ActionPodCreateManyContextCanvasInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    documentId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateManyOriginalCanvasInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasCollaboratorCreateManyCanvasInput = {
    id?: string
    userId: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type CanvasInvitationCreateManyCanvasInput = {
    id?: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasSessionCreateManyCanvasInput = {
    id?: string
    userId?: string | null
    anonymousName?: string | null
    sessionToken?: string | null
    socketId?: string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    connectedAt?: Date | string
    lastHeartbeatAt?: Date | string
    disconnectedAt?: Date | string | null
  }

  export type CanvasActivityLogCreateManyCanvasInput = {
    id?: string
    userId?: string | null
    action: $Enums.CanvasActivityAction
    entityType?: string | null
    entityId?: string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CanvasCommentCreateManyCanvasInput = {
    id?: string
    userId?: string | null
    content: string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: string | null
    parentId?: string | null
    isResolved?: boolean
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionPodUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourcePod?: ActionPodUpdateOneRequiredWithoutSourceEdgesNestedInput
    targetPod?: ActionPodUpdateOneRequiredWithoutTargetEdgesNestedInput
  }

  export type EdgeUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodUpdateWithoutContextCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    document?: DocumentUpdateOneWithoutActionPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutContextCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateManyWithoutContextCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUpdateWithoutOriginalCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutContextModulesNestedInput
  }

  export type ContextModuleUncheckedUpdateWithoutOriginalCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUncheckedUpdateManyWithoutOriginalCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCollaboratorUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCanvasCollaborationsNestedInput
  }

  export type CanvasCollaboratorUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasCollaboratorUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviter?: UserUpdateOneRequiredWithoutSentCanvasInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedCanvasInvitesNestedInput
  }

  export type CanvasInvitationUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasSessionUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasSessionUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasSessionUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousName?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    cursorPosition?: NullableJsonNullValueInput | InputJsonValue
    selectedPodIds?: NullableJsonNullValueInput | InputJsonValue
    viewportState?: NullableJsonNullValueInput | InputJsonValue
    userColor?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastHeartbeatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasActivityLogUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasActivityLogUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasActivityLogUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumCanvasActivityActionFieldUpdateOperationsInput | $Enums.CanvasActivityAction
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCommentUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCommentUncheckedUpdateWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCommentUncheckedUpdateManyWithoutCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    position?: NullableJsonNullValueInput | InputJsonValue
    podId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeCreateManySourcePodInput = {
    id?: string
    canvasId: string
    targetPodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type EdgeCreateManyTargetPodInput = {
    id?: string
    canvasId: string
    sourcePodId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    animated?: boolean
    createdAt?: Date | string
  }

  export type ActionPodExecutionCreateManyPodInput = {
    id?: string
    canvasId: string
    workspaceId: string
    status?: $Enums.ActionPodExecutionStatus
    startedAt?: Date | string
    finishedAt?: Date | string | null
    runtimeInMs?: number | null
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    costInUsd?: Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogCreateManyPodInput = {
    id?: string
    executionId: string
    canvasId: string
    workspaceId: string
    subscriptionId: string
    provider: $Enums.LLMProvider
    modelId: string
    modelName?: string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: number
    outputTokens?: number
    reasoningTokens?: number
    creditsConsumed?: number
    runtimeInMs?: number | null
    inputTokenCost: Decimal | DecimalJsLike | number | string
    outputTokenCost: Decimal | DecimalJsLike | number | string
    reasoningTokenCost: Decimal | DecimalJsLike | number | string
    totalCostInUsd: Decimal | DecimalJsLike | number | string
    executedAt?: Date | string
  }

  export type EdgeUpdateWithoutSourcePodInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutEdgesNestedInput
    targetPod?: ActionPodUpdateOneRequiredWithoutTargetEdgesNestedInput
  }

  export type EdgeUncheckedUpdateWithoutSourcePodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyWithoutSourcePodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    targetPodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUpdateWithoutTargetPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutEdgesNestedInput
    sourcePod?: ActionPodUpdateOneRequiredWithoutSourceEdgesNestedInput
  }

  export type EdgeUncheckedUpdateWithoutTargetPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeUncheckedUpdateManyWithoutTargetPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    sourcePodId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodExecutionUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionUncheckedUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ActionPodExecutionUncheckedUpdateManyWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    requestMetadata?: NullableJsonNullValueInput | InputJsonValue
    responseMetadata?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    costInUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PodUsageLogUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type PodUsageLogUncheckedUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUsageLogUncheckedUpdateManyWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    modelId?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    providerMetadata?: NullableJsonNullValueInput | InputJsonValue
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    reasoningTokens?: IntFieldUpdateOperationsInput | number
    creditsConsumed?: IntFieldUpdateOperationsInput | number
    runtimeInMs?: NullableIntFieldUpdateOperationsInput | number | null
    inputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoningTokenCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCostInUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WorkspaceUserCreateManyUserInput = {
    id?: string
    workspaceId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    deviceName: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasCollaboratorCreateManyUserInput = {
    id?: string
    canvasId: string
    accessLevel?: $Enums.CanvasAccessLevel
    canEdit?: boolean
    canExecute?: boolean
    canDelete?: boolean
    canShare?: boolean
    canInvite?: boolean
    invitedBy?: string | null
    invitedAt?: Date | string
    lastViewedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyInviterInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyInvitedUserInput = {
    id?: string
    workspaceId: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationCreateManyInviterInput = {
    id?: string
    canvasId: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type CanvasInvitationCreateManyInvitedUserInput = {
    id?: string
    canvasId: string
    email: string
    accessLevel?: $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCollaboratorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canvas?: CanvasUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type CanvasCollaboratorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasCollaboratorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    canShare?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canvas?: CanvasUpdateOneRequiredWithoutInvitationsNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedCanvasInvitesNestedInput
  }

  export type CanvasInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canvas?: CanvasUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentCanvasInvitesNestedInput
  }

  export type CanvasInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CanvasInvitationUncheckedUpdateManyWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumCanvasAccessLevelFieldUpdateOperationsInput | $Enums.CanvasAccessLevel
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role?: $Enums.WorkspaceRole
    canCreateCanvas?: boolean
    canDeleteCanvas?: boolean
    canManageBilling?: boolean
    canInviteMembers?: boolean
    canManageMembers?: boolean
    canManageApiKeys?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type CanvasCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    version?: number
    visibility?: $Enums.CanvasVisibility
    createdBy: string
    thumbnailS3Key?: string | null
    thumbnailGeneratedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyWorkspaceInput = {
    id?: string
    name: string
    storageKey: string
    s3Bucket: string
    fileType: string
    mimeType?: string | null
    sizeInBytes: bigint | number
    status?: $Enums.DocumentStatus
    uploadedBy?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextModuleCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    definitionJson: JsonNullValueInput | InputJsonValue
    originalCanvasId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareLinkCreateManyWorkspaceInput = {
    id?: string
    publicToken?: string
    assetType: $Enums.ShareableAssetType
    assetId: string
    createdBy: string
    accessLevel?: $Enums.ShareAccessLevel
    password?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProviderAPIKeyCreateManyWorkspaceInput = {
    id?: string
    provider: $Enums.LLMProvider
    displayName: string
    keyHash: string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: string | null
    authType?: $Enums.AuthType
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyWorkspaceInput = {
    id?: string
    email: string
    role?: $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy: string
    invitedUserId?: string | null
    token: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceUserUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    canCreateCanvas?: BoolFieldUpdateOperationsInput | boolean
    canDeleteCanvas?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    canInviteMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageMembers?: BoolFieldUpdateOperationsInput | boolean
    canManageApiKeys?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CanvasUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPods?: ActionPodUncheckedUpdateManyWithoutCanvasNestedInput
    edges?: EdgeUncheckedUpdateManyWithoutCanvasNestedInput
    contextualPods?: ActionPodUncheckedUpdateManyWithoutContextCanvasNestedInput
    contextModules?: ContextModuleUncheckedUpdateManyWithoutOriginalCanvasNestedInput
    collaborators?: CanvasCollaboratorUncheckedUpdateManyWithoutCanvasNestedInput
    invitations?: CanvasInvitationUncheckedUpdateManyWithoutCanvasNestedInput
    sessions?: CanvasSessionUncheckedUpdateManyWithoutCanvasNestedInput
    activityLog?: CanvasActivityLogUncheckedUpdateManyWithoutCanvasNestedInput
    comments?: CanvasCommentUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    visibility?: EnumCanvasVisibilityFieldUpdateOperationsInput | $Enums.CanvasVisibility
    createdBy?: StringFieldUpdateOperationsInput | string
    thumbnailS3Key?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUpdateManyWithoutDocumentNestedInput
    actionPods?: ActionPodUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: EmbeddingUncheckedUpdateManyWithoutDocumentNestedInput
    actionPods?: ActionPodUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeInBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCanvas?: CanvasUpdateOneWithoutContextModulesNestedInput
  }

  export type ContextModuleUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextModuleUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definitionJson?: JsonNullValueInput | InputJsonValue
    originalCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareLinkUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicToken?: StringFieldUpdateOperationsInput | string
    assetType?: EnumShareableAssetTypeFieldUpdateOperationsInput | $Enums.ShareableAssetType
    assetId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumShareAccessLevelFieldUpdateOperationsInput | $Enums.ShareAccessLevel
    password?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAPIKeyUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumLLMProviderFieldUpdateOperationsInput | $Enums.LLMProvider
    displayName?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    providerConfig?: NullableJsonNullValueInput | InputJsonValue
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    authType?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviter?: UserUpdateOneRequiredWithoutSentWorkspaceInvitesNestedInput
    invitedUser?: UserUpdateOneWithoutReceivedWorkspaceInvitesNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmbeddingCreateManyDocumentInput = {
    id?: string
    model: string
    chunkIndex: number
    chunkText: string
    s3VectorBucket: string
    s3VectorKey: string
    vectorDimension?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActionPodCreateManyDocumentInput = {
    id?: string
    canvasId: string
    type: $Enums.ActionPodType
    position: JsonNullValueInput | InputJsonValue
    executionStatus?: $Enums.ActionPodExecutionStatus
    lastExecutionId?: string | null
    contextCanvasId?: string | null
    lockedBy?: string | null
    lockedAt?: Date | string | null
    dynamoPartitionKey: string
    dynamoSortKey: string
    s3VectorBucket?: string | null
    s3VectorKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmbeddingUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkText?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: StringFieldUpdateOperationsInput | string
    s3VectorKey?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionPodUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutActionPodsNestedInput
    contextCanvas?: CanvasUpdateOneWithoutContextualPodsNestedInput
    sourceEdges?: EdgeUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourcePodNestedInput
    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetPodNestedInput
    executions?: ActionPodExecutionUncheckedUpdateManyWithoutPodNestedInput
    usageLogs?: PodUsageLogUncheckedUpdateManyWithoutPodNestedInput
  }

  export type ActionPodUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvasId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionPodTypeFieldUpdateOperationsInput | $Enums.ActionPodType
    position?: JsonNullValueInput | InputJsonValue
    executionStatus?: EnumActionPodExecutionStatusFieldUpdateOperationsInput | $Enums.ActionPodExecutionStatus
    lastExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    contextCanvasId?: NullableStringFieldUpdateOperationsInput | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dynamoPartitionKey?: StringFieldUpdateOperationsInput | string
    dynamoSortKey?: StringFieldUpdateOperationsInput | string
    s3VectorBucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3VectorKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}